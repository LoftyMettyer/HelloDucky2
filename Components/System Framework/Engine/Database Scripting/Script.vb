Option Strict On
Option Explicit On

Imports System.Runtime.InteropServices
Imports System.Text
Imports System.Text.RegularExpressions
Imports System.Xml.Serialization
Imports SystemFramework.Enums
Imports SystemFramework.Enums.Errors
Imports SystemFramework.Structures

Namespace ScriptDB

  <ClassInterface(ClassInterfaceType.None)>
  Public Class Script
    Implements ICommitDB

#Region "General"

    Private Shared Function SqlDropUdf(ByVal schema As String, ByVal name As String) As String

      Return String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " &
                           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & vbNewLine &
                           "WHERE o.[name] = '{1}' AND [type] IN ('FN', 'TF') AND u.[name] = '{0}')" & vbNewLine &
                           "DROP FUNCTION [{0}].[{1}]", schema, name)

    End Function

    Private Shared Function SqlDropProcedure(ByVal schema As String, ByVal name As String) As String

      Return String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & vbNewLine &
                           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & vbNewLine &
                           "WHERE o.[name] = '{1}' AND [type] = 'P' AND u.[name] = '{0}')" & vbNewLine &
                           "DROP PROCEDURE [{0}].[{1}]", schema, name)

    End Function

#End Region

    Public Shared Function DropUdf(schema As String, name As String) As Boolean

      Dim sql As String = SqlDropUdf(schema, name)

      Try
        CommitDb.ScriptStatement(sql, True, False)

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, name, Severity.Error, ex.Message, sql)
        Return False
      End Try

      Return True

    End Function

#Region "Table Scripting"

    Private Sub DropView(ByVal role As String, ByVal viewName As String)

      Dim sSql As String

      Try

        sSql = String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " &
           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " &
           "WHERE o.[name] = '{1}' AND [type] = 'V' AND u.[name] = '{0}')" & vbNewLine &
          " DROP VIEW [{0}].[{1}]", [role], viewName)

        ' Commit
        CommitDb.ScriptStatement(sSql, True, False)

      Catch ex As Exception
        MsgBox(ex.Message, MsgBoxStyle.Critical)
        Stop

      End Try

    End Sub

    Public Function DropViews() As Boolean Implements ICommitDB.DropViews

      Dim bOk As Boolean = True

      Try
        For Each objTable As Table In Tables

          For Each objView As View In objTable.Views
            DropView(objTable.SchemaName, objView.Name)
          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, "DropViews", Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function DropTableViews() As Boolean Implements ICommitDB.DropTableViews

      Dim objTable As New Table
      Dim bOk As Boolean = True

      Try
        For Each objTable In Tables
          DropView("dbo", objTable.Name)
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, objTable.Name, Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateTables() As Boolean Implements ICommitDB.ScriptTables

      Dim bOk As Boolean = True
      Dim sSql As String = vbNullString

      Try
        For Each objTable As Table In Tables

          Select Case objTable.State

            Case DataRowState.Deleted
              sSql = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1) " & vbNewLine &
                                   "DROP TABLE [dbo].[{0}];", objTable.PhysicalName)
              CommitDb.ScriptStatement(sSql, True, False)

            Case DataRowState.Modified
              'If Not objTable.PhysicalName = objTable.NameInDB Then
              '  sSQL = String.Format("sp_rename @objname = [{0}], @newname = [{1}]" _
              '        , objTable.NameInDB, objTable.PhysicalName)
              '  Globals.CommitDB.ScriptStatement(sSQL)
              '  'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)
              'End If

            Case Else ' DataRowState.Added
              sSql = String.Format("IF NOT EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine &
                "CREATE TABLE [dbo].[{0}] (" &
                " [id] integer PRIMARY KEY CLUSTERED IDENTITY(1,1)" &
                " , [guid] uniqueidentifier DEFAULT (newsequentialid())" & vbNewLine &
                " , [updflag] integer" & vbNewLine &
                " , [deleteddate] datetime" & vbNewLine &
                " , [recorddescription] nvarchar(255)" & vbNewLine &
                " , [timestamp] rowversion" & vbNewLine &
                " , [lastsavedby] varbinary(85)" & vbNewLine &
                " , [lastsavedatetime] datetime);" _
                , objTable.PhysicalName)
              CommitDb.ScriptStatement(sSql, True, False)

          End Select


          ' Add any relations
          For Each objRelation As Relation In objTable.Relations

            If objRelation.RelationshipType = RelationshipType.Parent Then
              sSql = String.Format("IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='ID_{1}')" & vbNewLine &
                  "ALTER TABLE [dbo].[{0}] ADD [ID_{1}] integer NOT NULL", objTable.PhysicalName, objRelation.ParentId)
              CommitDb.ScriptStatement(sSql, True, False)

              sSql = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID_{1}')" & vbNewLine &
                  "CREATE NONCLUSTERED INDEX [IDX_ID_{1}] ON [dbo].[{0}] ([ID_{1}] ASC)", objTable.PhysicalName, objRelation.ParentId)
              CommitDb.ScriptStatement(sSql, False, False)

            End If

          Next

          ' Now add the columns
          For Each objColumn As Column In objTable.Columns

            If objColumn.State = DataRowState.Deleted Then
              sSql = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine &
                  "ALTER TABLE [dbo].[{0}] DROP COLUMN [{1}]", objTable.PhysicalName, objColumn.Name)
              CommitDb.ScriptStatement(sSql, True, False)

            ElseIf objColumn.State = DataRowState.Modified Or Options.RefreshObjects Then
              sSql = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine &
                  "ALTER TABLE [dbo].[{0}] ALTER COLUMN [{1}] {2} ELSE ALTER TABLE [dbo].[{0}] ADD [{1}] {2}", objTable.PhysicalName, objColumn.Name, objColumn.DataTypeSyntax)
              CommitDb.ScriptStatement(sSql, True, False)
            End If
          Next

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.TableAndColumns, "Views", Severity.Error, ex.Message, sSql)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateTableViews() As Boolean Implements ICommitDB.ScriptTableViews

      Dim bOk As Boolean = True
      Dim sDefinitionSql As String = String.Empty
      Dim sViewName As String = String.Empty
      Dim sActualTableName As String
      Dim sOptions As String = String.Empty

      Dim objTable As Table
      Dim objColumn As Column
      Dim objRelation As Relation

      Try

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          sViewName = objTable.Name
          sActualTableName = String.Format("{0}{1}", Consts.UserTable, objTable.Name)

          sDefinitionSql = "AS SELECT [id], [timestamp]" & vbNewLine

          ' Add relations
          For Each objRelation In objTable.Relations
            If objRelation.RelationshipType = RelationshipType.Parent Then
              sDefinitionSql = sDefinitionSql & String.Format(", [ID_{0}]", objRelation.ParentId) & vbNewLine
            End If
          Next


          ' Add columns
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated And objColumn.IsReadOnly And objTable.TableType = TableType.Parent Then
              sDefinitionSql = sDefinitionSql & String.Format(", {0} AS [{1}]", objColumn.Calculation.Udf.CallingCode.Replace("@prm_", "base."), objColumn.Name & vbNewLine)
            Else
              sDefinitionSql = sDefinitionSql & (String.Format(", base.[{0}] AS [{0}]", objColumn.Name) & vbNewLine)
            End If
          Next

          ' Add the base table
          sDefinitionSql = sDefinitionSql & vbNewLine & String.Format("FROM [dbo].[{0}] base", sActualTableName)

          DropView(objTable.SchemaName, sViewName)

          sDefinitionSql = String.Format("CREATE VIEW [{0}].[{1}] {2} {3}", objTable.SchemaName, sViewName, sOptions, sDefinitionSql)
          CommitDb.ScriptStatement(sDefinitionSql, True, False)

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, sViewName, Severity.Error, ex.Message, sDefinitionSql)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateViews() As Boolean Implements ICommitDB.ScriptViews

      Dim objTable As Table
      Dim objView As View
      Dim objColumn As Column

      Dim sDefinition As New StringBuilder
      Dim bOk As Boolean = True

      Try

        For Each objTable In Tables
          For Each objView In objTable.Views

            sDefinition = New StringBuilder
            sDefinition.AppendLine(String.Format("CREATE VIEW [{0}].[{1}]", objTable.SchemaName, objView.Name))
            sDefinition.AppendLine("AS SELECT [id], [timestamp]")

            For Each objColumn In objView.Columns
              If objColumn.IsCalculated And objColumn.IsReadOnly Then
                sDefinition.AppendLine(String.Format(", {0} AS [{1}]", objColumn.Calculation.Udf.CallingCode.Replace("@prm_", "base."), objColumn.Name))
              Else
                sDefinition.AppendLine(String.Format(", base.[{0}] AS [{0}]", objColumn.Name))
              End If
            Next

            sDefinition.AppendLine(String.Format("FROM [{0}].[{1}] base", objTable.SchemaName, objTable.Name))

            ' Generate this view
            DropView(objTable.SchemaName, objView.Name)
            CommitDb.ScriptStatement(sDefinition.ToString, True, False)

          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, "Views", Severity.Error, ex.Message, sDefinition.ToString)
        bOk = False
      End Try

      Return bOk

    End Function

#End Region

#Region "Trigger Scripting"

    Public Function CreateTriggers() As Boolean Implements ICommitDB.ScriptTriggers

      Dim bOk As Boolean = True
      Dim objTable As Table
      Dim objRelatedTable As Table
      Dim objColumn As Column
      Dim objRelation As Relation
      Dim objIndex As Index

      Dim sSql As String = String.Empty
      Dim sCalculationCode As String
      Dim sColumnName As String
      Dim sAuditDataBase As String
      Dim sAuditDataDelete As String
      Dim sAuditDataInsert As String

      Dim objAuditIndex As Index

      Dim sSqlCodeAuditInsert As String
      Dim sSqlCodeAuditUpdate As String
      Dim sSqlCodeAuditDelete As String
      Dim sSqlCodeAudit As String

      Dim sSqlPostUpdateTriggerCode As String
      Dim ssqlPostInsertTriggerCode As String

      Dim sSqlCodeBypass As String

      Dim sValidation As String

      Dim sqlWriteableColumns As String
      Dim sqlInsteadOfInsertColumns As String
      Dim sqlAfterInsertColumns As String

      Dim sSqlCalculatedColumns As String
      Dim sSqlPostAuditCalcs As String
      Dim sSqlPostAuditCalcsAlsoAudited As String
      Dim sSqlParentColumns As String
      Dim sSqlParentColumnsDelete As String
      Dim sSqlChildColumns As String

      Dim sSqlSpecialUpdate As String
      Dim sSqlCategoryUpdate As String
      Dim sSqlFusionCode As String

      Dim sSqlHeadcountCheck As String = ""

      Dim aryCalculatedColumns As ArrayList
      Dim aryPostAuditCalcs As ArrayList

      Dim aryBaseTableColumns As ArrayList
      Dim aryParentsToUpdate As ArrayList
      Dim aryChildrenToUpdate As ArrayList
      Dim aryParentsToUpdateDelete As ArrayList

      Dim aryColumnsWithDefaultValues As ArrayList
      Dim aryAllWriteableColumns As ArrayList
      Dim aryAllWriteableFormatted As ArrayList

      Dim aryColumns As ArrayList

      Dim colAuditColumns As List(Of AuditColumnCode)

      Try

        'Build list of existing system UDF
        Dim existingTriggers = (From f In DatabaseMetadata.GetTriggers()
                                         ).ToDictionary(Function(f) f.Name, StringComparer.InvariantCultureIgnoreCase)

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          aryColumnsWithDefaultValues = New ArrayList
          aryAllWriteableColumns = New ArrayList
          aryAllWriteableFormatted = New ArrayList
          colAuditColumns = New List(Of AuditColumnCode)

          aryParentsToUpdate = New ArrayList
          aryChildrenToUpdate = New ArrayList
          aryParentsToUpdateDelete = New ArrayList
          aryBaseTableColumns = New ArrayList
          aryCalculatedColumns = New ArrayList
          aryPostAuditCalcs = New ArrayList

          sSqlCalculatedColumns = String.Empty
          sSqlParentColumns = String.Empty
          sSqlParentColumnsDelete = String.Empty
          sSqlChildColumns = String.Empty

          sSqlCodeAuditInsert = String.Empty
          sSqlCodeAuditUpdate = String.Empty
          sSqlCodeAuditDelete = String.Empty
          sSqlCodeAudit = String.Empty
          sSqlPostAuditCalcs = String.Empty

          ' Build in indexes
          objAuditIndex = New Index
          objTable.Indexes.Add(objAuditIndex)

          ' Add the system generated columns
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            aryCalculatedColumns.Add(String.Format("[_description] = {0}", objTable.RecordDescription.Udf.CallingCode))
          End If

          objAuditIndex.IsClustered = False
          objAuditIndex.IsTableIndex = True
          objAuditIndex.IncludePrimaryKey = True
          objAuditIndex.Name = "IDX_AuditFields"


          ' Build fusion messages
          sSqlFusionCode = SpecialTrigger_Fusion(objTable)

          ' Add any relationship columns
          For Each objRelation In objTable.Relations

            aryColumns = New ArrayList
            If objRelation.RelationshipType = RelationshipType.Parent Then
              aryBaseTableColumns.Add(String.Format("[ID_{0}] = base.[ID_{0}]", objRelation.ParentId))
              aryAllWriteableColumns.Add(String.Format("[ID_{0}]", objRelation.ParentId))
              aryAllWriteableFormatted.Add(String.Format("[ID_{0}]", objRelation.ParentId))

              objRelatedTable = Tables.GetById(objRelation.ParentId)
              For Each objColumn In objTable.DependsOnParentColumns
                If objColumn.Table Is objRelatedTable Then
                  aryColumns.Add(String.Format("base.{0} = {0}", objColumn.Name))
                End If
              Next

              If aryColumns.Count > 0 Then
                aryParentsToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [tablefromid] FROM {2} WHERE [tablefromid] = {1})" & vbNewLine &
                    "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM inserted)" & vbNewLine _
                    , objRelation.PhysicalName, objRelation.ParentId, Consts.SysTriggerTransaction))

                aryParentsToUpdateDelete.Add(String.Format("    IF NOT EXISTS(SELECT [tablefromid] FROM {2} WHERE [tablefromid] = {1})" & vbNewLine &
                    "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM deleted)" & vbNewLine _
                    , objRelation.PhysicalName, objRelation.ParentId, Consts.SysTriggerTransaction))

              End If

            Else

              objRelatedTable = Tables.GetById(objRelation.ChildId)
              objIndex = New Index
              objIndex.Name = String.Format("IDX_relation_{0}", objRelatedTable.Name)
              objIndex.IsTableIndex = True
              objIndex.IsClustered = False
              objIndex.Enabled = False

              For Each objColumn In objRelatedTable.DependsOnChildColumns
                If objColumn.Table Is objTable Then
                  aryColumns.Add(String.Format("NOT ISNULL(i.{0}, {1}) = ISNULL(d.{0}, {1})", objColumn.Name, objColumn.NullCheckValue))
                  objIndex.IncludedColumns.AddIfNew(objColumn)
                End If
              Next

              If aryColumns.Count > 0 Then
                aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [tablefromid] FROM {5} WHERE [tablefromid] = {3})" & vbNewLine &
                    "            AND EXISTS(SELECT i.ID FROM dbo.[{2}] i" & vbNewLine &
                    "                INNER JOIN deleted d ON d.ID = i.ID " & vbNewLine &
                    "                WHERE {4})" & vbNewLine &
                    "        UPDATE dbo.[{0}] SET [updflag] = 1 WHERE ID_{1} IN (SELECT i.ID FROM inserted i);" _
                    , objRelatedTable.PhysicalName, objTable.Id, objTable.PhysicalName, objRelatedTable.Id _
                    , String.Join(" OR ", aryColumns.ToArray()), Consts.SysTriggerTransaction))
                objTable.Indexes.Add(objIndex)
              End If
            End If
          Next

          For Each objColumn In objTable.Columns

            If Not objColumn.State = DataRowState.Deleted Then

              ' Create an index on any unique check columns
              If objColumn.UniqueType = UniqueCheckScope.All Then
                objIndex = New Index
                objIndex.Name = String.Format("IDX_uniquecheck_{0}", objColumn.Name)
                objIndex.IncludePrimaryKey = False
                objIndex.IsTableIndex = True
                objIndex.IsClustered = False
                objIndex.Enabled = True
                objIndex.IsUnique = True
                objIndex.Columns.Add(objColumn)
                objTable.Indexes.Add(objIndex)
              End If

              If objColumn.IsCalculated Then
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.ExpressionType = ExpressionType.ColumnCalculation
                '  objColumn.Calculation.GenerateCodeForColumn()

                If objColumn.Calculation.IsValid Then
                  If objColumn.Calculation.IsComplex Then
                    sCalculationCode = objColumn.Calculation.Udf.CallingCode
                  Else
                    sCalculationCode = objColumn.Calculation.Udf.InlineCode
                  End If

                  If objColumn.CalculateIfEmpty Then
                    If objColumn.SafeReturnType = "NULL" Then
                      sColumnName = String.Format("[{0}] = ISNULL([{0}], {1})", objColumn.Name, sCalculationCode)
                    Else
                      sColumnName = String.Format("[{0}] = ISNULL(NULLIF([{0}], {2}), {1})", objColumn.Name, sCalculationCode, objColumn.SafeReturnType)
                    End If
                  Else
                    sColumnName = String.Format("[{0}] = {1}", objColumn.Name, sCalculationCode)
                  End If

                  If objColumn.Calculation.CalculatePostAudit Then
                    aryPostAuditCalcs.Add(sColumnName & vbNewLine)
                  Else
                    aryCalculatedColumns.Add(sColumnName)
                  End If
                End If

              End If


              ' Build list of default values
              If objColumn.DefaultCalcId > 0 And Not objColumn.DefaultCalculation Is Nothing Then
                objColumn.DefaultCalculation.AssociatedColumn = objColumn
                objColumn.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
                objColumn.DefaultCalculation.GenerateCodeForColumn()

                sCalculationCode = objColumn.DefaultCalculation.Udf.CallingCode
                aryColumnsWithDefaultValues.Add(String.Format("[{0}] = ISNULL(base.[{0}], {1})", objColumn.Name, sCalculationCode))

              End If


              If Not objColumn.IsReadOnly Then
                Select Case objColumn.DataType

                  Case ColumnTypes.Date
                    aryBaseTableColumns.Add(String.Format("[{0}] = DATEADD(dd, 0, DATEDIFF(dd, 0, base.[{0}]))", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format(" DATEADD(dd, 0, DATEDIFF(dd, 0, [{0}]))", objColumn.Name))

                  Case Else
                    aryBaseTableColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.ApplyFormatting("base")))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format("[{0}]", objColumn.Name))

                End Select

              End If

              ' Concatenate audited columns
              If objColumn.Audit Then
                Select Case objColumn.DataType
                  Case ColumnTypes.Date
                    sAuditDataInsert = String.Format(" CONVERT(varchar(11), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(11), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(11), base.[{0}], 105)", objColumn.Name)

                  Case ColumnTypes.Logic
                    sAuditDataInsert = String.Format(" CASE i.[{0}] WHEN 1 THEN 'Yes' WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataDelete = String.Format(" CASE d.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataBase = String.Format(" CASE base.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)

                  Case Else
                    sAuditDataInsert = String.Format(" CONVERT(varchar(255), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(255), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(255), base.[{0}], 105)", objColumn.Name)
                End Select

                colAuditColumns.Add(New AuditColumnCode With {.Column = objColumn _
                    , .TriggerType = TriggerType.AfterInsert _
                    , .Code = String.Format("        SELECT @username, @dChangeDate, base.ID, '* New Record *', {0}, {4}, '{3}', '{5}', {1}, base.[_description]" & vbNewLine &
                    "            FROM inserted i" & vbNewLine &
                    "            INNER JOIN dbo.[{2}] base ON i.[id] = base.[id] AND NOT ISNULL({0},'') = ''" _
                    , sAuditDataInsert, objColumn.Id, objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.Id), objColumn.Name)
                    })

                colAuditColumns.Add(New AuditColumnCode With {.Column = objColumn _
                    , .TriggerType = TriggerType.AfterUpdate _
                    , .Code = String.Format("        SELECT @username, @dChangeDate, d.ID, {6}, {0}, {4}, '{3}', '{5}', {1}, base.[_description]" & vbNewLine &
                    "            FROM deleted d" & vbNewLine &
                    "            INNER JOIN dbo.[{2}] base ON d.[id] = base.[id] AND NOT ISNULL({0},'') = ISNULL({6},'')" _
                    , sAuditDataBase, objColumn.Id, objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.Id), objColumn.Name, sAuditDataDelete)
                    })

                colAuditColumns.Add(New AuditColumnCode With {.Column = objColumn _
                    , .TriggerType = TriggerType.AfterDelete _
                    , .Code = String.Format("        SELECT @username, @dChangeDate, d.ID, {0}, ' * Deleted Record *', {3}, '{2}', '{4}', {1}, d.[_description]" & vbNewLine &
                    "            FROM deleted d WHERE {0} IS NOT NULL" _
                    , sAuditDataDelete, objColumn.Id, objColumn.Table.Name, objColumn.Table.Id, objColumn.Name)
                    })



                objAuditIndex.IncludedColumns.AddIfNew(objColumn)
              End If
            End If

          Next

          ' Update any parents
          If aryParentsToUpdate.ToArray.Length > 0 Then
            sSqlParentColumns = "    /* Refresh parent records */" & vbNewLine &
                        "    IF @isovernight = 0" & vbNewLine & "    BEGIN" & vbNewLine &
                        String.Join(vbNewLine, aryParentsToUpdate.ToArray()) &
                        "     END"
            sSqlParentColumnsDelete = "    /* Refresh parents records  */" & vbNewLine &
                        String.Join(vbNewLine, aryParentsToUpdateDelete.ToArray())

          End If

          ' Validation
          sValidation = String.Format("    /* Validation */" & vbNewLine &
              "    IF @isovernight = 0 AND (SELECT TOP 1 [tablefromid] FROM {2} ORDER BY [nestlevel] ASC) = {0}" & vbNewLine &
              "    BEGIN" & vbNewLine &
              "        DELETE FROM fusion.ValidationWarnings" & vbNewLine &
              "            WHERE RecordID IN (SELECT ID FROM inserted) AND tableid = {0}" & vbNewLine & vbNewLine &
              "        SET @sValidation = '';" & vbNewLine &
              "        SELECT @sValidation = @sValidation + dbo.[udfvalid_{1}](ID, [_description]) FROM inserted" & vbNewLine &
              "        IF LEN(@sValidation) > 0 AND @bIsFusionMessage = 0" & vbNewLine &
              "        BEGIN" & vbNewLine &
              "            RAISERROR(@sValidation, 16, 1);" & vbNewLine &
              "            ROLLBACK;" & vbNewLine &
              "        END" & vbNewLine _
              , objTable.Id, objTable.Name, Consts.SysTriggerTransaction)

          If objTable.FusionMessages.Count > 0 Then
            sValidation = sValidation & vbNewLine & String.Format("        IF LEN(@sValidation) > 0 AND @bIsFusionMessage = 1" & vbNewLine &
                "        BEGIN" & vbNewLine &
                "            INSERT fusion.ValidationWarnings (TableID, RecordID, MessageName, ValidationMessage, CreatedDateTime)" & vbNewLine &
                "            SELECT '1',ID,@fusionMessageName,@sValidation,GETDATE()" & vbNewLine &
                "                FROM inserted" & vbNewLine &
                "        END" & vbNewLine)
          End If

          sValidation = sValidation & "    END" & vbNewLine

          ' Update child records
          If aryChildrenToUpdate.ToArray.Length > 0 Then
            sSqlChildColumns = "    /* Update children */" & vbNewLine &
                 "    IF @isovernight = 0 AND @startingtrigger = 2" & vbNewLine & "    BEGIN" & vbNewLine &
                 String.Join(vbNewLine & vbNewLine, aryChildrenToUpdate.ToArray()) & vbNewLine &
                "     END"
          End If

          ' Update statement of all the non read only columns (free entry columns)
          If aryBaseTableColumns.ToArray.Length > 0 Then
            sqlWriteableColumns = String.Format("    /* Update any columns specified in the update clause */" & vbNewLine &
                "    UPDATE [dbo].[{0}]" & vbNewLine &
                "        SET [updflag] = base.[updflag], [_deleted] = base.[_deleted], [_deleteddate] = base.[_deleteddate]," & vbNewLine &
                "        {1}" & vbNewLine &
                "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
                , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryBaseTableColumns.ToArray()))
          Else
            sqlWriteableColumns = String.Format("    /* Update any columns specified in the update clause */" & vbNewLine &
                "    UPDATE [dbo].[{0}]" & vbNewLine &
                "        SET [updflag] = base.[updflag], [_deleted] = base.[_deleted], [_deleteddate] = base.[_deleteddate]" & vbNewLine &
                "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
                , objTable.PhysicalName)
          End If


          ' Update the default values
          If aryColumnsWithDefaultValues.ToArray.Length > 0 Then
            'aryColumnsWithDefaultValues.AddRange(aryBaseTableColumns)
            sqlAfterInsertColumns = String.Format("    /* Update any columns specified in the update clause */" & vbNewLine &
                "    UPDATE [dbo].[{0}]" & vbNewLine &
                "        SET [updflag] = base.[updflag]," & vbNewLine &
                "        {1}" & vbNewLine &
                "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
                , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryColumnsWithDefaultValues.ToArray()))
          Else
            sqlAfterInsertColumns = String.Format("    /* Update any columns specified in the update clause */" & vbNewLine &
                "    UPDATE [dbo].[{0}]" & vbNewLine &
                "        SET [updflag] = base.[updflag]" & vbNewLine &
                "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
                , objTable.PhysicalName)
          End If

          ' Instead of writeable columns
          If aryAllWriteableColumns.ToArray.Length > 0 Then
            sqlInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine &
                 "    INSERT [dbo].[{0}]  ({1})" & vbNewLine &
                 "        OUTPUT inserted.ID INTO @insertedRow" & vbNewLine &
                 "        SELECT {2} FROM inserted base;" & vbNewLine & vbNewLine _
                 , objTable.PhysicalName, String.Join(",", aryAllWriteableColumns.ToArray()), String.Join("," & vbNewLine, aryAllWriteableFormatted.ToArray()))
          Else
            sqlInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine &
                 "    INSERT [dbo].[{0}] ([updflag]) VALUES (1);" & vbNewLine & vbNewLine _
                 , objTable.PhysicalName)
          End If

          ' Build audit strings
          If colAuditColumns.ToArray.Length > 0 Then

            Dim blah = String.Join(", ", colAuditColumns _
                .Where(Function(a) a.TriggerType = TriggerType.AfterInsert) _
                .Select(Function(a) a.Code) _
                .ToList())

            sSqlCodeAuditInsert = String.Format("    INSERT @audit (username, changedate, id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & " {0};" _
                            , String.Join(vbNewLine & "        UNION" & vbNewLine, colAuditColumns _
                            .Where(Function(a) a.TriggerType = TriggerType.AfterInsert) _
                            .Select(Function(a) a.Code) _
                            .ToList()))

            sSqlCodeAuditUpdate = String.Format("    INSERT @audit (username, changedate, id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & " {0};" _
                            , String.Join(vbNewLine & "        UNION" & vbNewLine, colAuditColumns _
                            .Where(Function(a) a.TriggerType = TriggerType.AfterUpdate) _
                            .Select(Function(a) a.Code) _
                            .ToList()))

            sSqlCodeAuditDelete = String.Format("    INSERT @audit (username, changedate, id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & " {0};" _
                            , String.Join(vbNewLine & "        UNION" & vbNewLine, colAuditColumns _
                            .Where(Function(a) a.TriggerType = TriggerType.AfterDelete) _
                            .Select(Function(a) a.Code) _
                            .ToList()))

            sSqlCodeAudit = vbNewLine & "    INSERT dbo.[ASRSysAuditTrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], [deleted], [recorddesc])" & vbNewLine &
                     "		     SELECT [username], [changedate], [id], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], 1, [recorddesc] FROM @audit;" & vbNewLine & vbNewLine
          End If

          ' Table level audits
          If objTable.AuditInsert Then
            sSqlCodeAuditInsert += vbNewLine & String.Format("    INSERT @audit (username, changedate, id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine &
                 "        SELECT @username, @dChangeDate, i.[id], '', ' * New Record *', {0}, '{1}', '', base.[_description] FROM inserted i" & vbNewLine &
                 "            INNER JOIN dbo.{2} base ON i.[id] = base.[id]" _
                 , objTable.Id, objTable.Name, objTable.PhysicalName)
          End If

          If objTable.AuditDelete Then
            sSqlCodeAuditDelete += vbNewLine & String.Format("    INSERT @audit (username, changedate, id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine &
                 "        SELECT @username, @dChangeDate, d.[id], '', ' * Deleted Record *', {0}, '{1}', '', d.[_description] FROM deleted d" & vbNewLine _
                 , objTable.Id, objTable.Name)
          End If

          ' Update statement of all the calculated columns
          If aryCalculatedColumns.ToArray.Length > 0 Then
            sSqlCalculatedColumns = String.Format("    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine &
              "    /* Update calculated columns */" & vbNewLine &
              "    ;WITH base AS (" & vbNewLine &
              "        SELECT *" & vbNewLine &
              "            FROM [dbo].[{0}]" & vbNewLine &
              "            WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine &
              "    UPDATE base SET " & vbNewLine &
              "        {1};" & vbNewLine & vbNewLine &
              "    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine _
              , objTable.PhysicalName, String.Join(vbNewLine & vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))
          End If

          ' Any calculations that require to be saved after the audit
          If aryPostAuditCalcs.ToArray.Length > 0 Then
            sSqlPostAuditCalcs = String.Format(vbNewLine & "    /* Update columns that rely on audit log data */" & vbNewLine &
                "    ;WITH base AS (" & vbNewLine &
                "        SELECT *" & vbNewLine &
                "        FROM [dbo].[{0}]" & vbNewLine &
                "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine &
                "    UPDATE base" & vbNewLine &
                "    SET {1};" & vbNewLine _
                , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryPostAuditCalcs.ToArray()))
          End If

          sSqlPostAuditCalcsAlsoAudited = String.Format("{0}", String.Join(vbNewLine & " UNION " & vbNewLine, colAuditColumns _
                              .Where(Function(a) a.TriggerType = TriggerType.AfterUpdate AndAlso a.Column.Audit AndAlso a.Column.Calculation IsNot Nothing AndAlso a.Column.Calculation.CalculatePostAudit) _
                              .Select(Function(a) a.Code) _
                              .ToList()))

          If Len(sSqlPostAuditCalcsAlsoAudited) > 0 Then
            sSqlPostAuditCalcsAlsoAudited = vbNewLine & "    INSERT dbo.[ASRSysAuditTrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], [recorddesc])" & vbNewLine &
            sSqlPostAuditCalcsAlsoAudited
          End If


          ' Special bypass trigger code
          sSqlCodeBypass = SpecialTrigger_SSP(objTable)

          ' Add trigger code based on module setup
          sSqlSpecialUpdate = SpecialTrigger_BankHolidays(objTable)
          sSqlSpecialUpdate = sSqlSpecialUpdate & SpecialTrigger_Personnel(objTable)
          sSqlCategoryUpdate = SpecialTrigger_Categories(objTable)
          sSqlHeadcountCheck = SpecialTrigger_Personnel_HeadcountCheck(objTable)

          ssqlPostInsertTriggerCode = SpecialTrigger_TriggerCode(objTable, TriggerCodePosition.AfterI02Insert)
          sSqlPostUpdateTriggerCode = SpecialTrigger_TriggerCode(objTable, TriggerCodePosition.AfterU02Update)

          ' INSTEAD OF INSERT
          sSql = sSqlHeadcountCheck & vbNewLine & vbNewLine & String.Format("    DECLARE @sValidation nvarchar(MAX) = '';" & vbNewLine & vbNewLine &
              "    INSERT {1} ([tablefromid], [actiontype], [nestlevel])" & vbNewLine &
              "       VALUES ({0}, 1, @@NESTLEVEL);" & vbNewLine & vbNewLine &
              sqlInsteadOfInsertColumns & vbNewLine & vbNewLine &
              "    SELECT @localID = ID FROM @insertedRow;" & vbNewLine &
              "    SET CONTEXT_INFO @localID;" & vbNewLine _
              , objTable.Id, Consts.SysTriggerTransaction)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfInsert, sSql, existingTriggers, objTable.InsertTriggerDisabled)

          ' AFTER INSERT
          sSql = String.Format("    DECLARE @audit TABLE ([username] varchar(255), [changedate] datetime, [id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tableid] integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine &
              "    DECLARE @sValidation nvarchar(MAX) = '';" & vbNewLine & vbNewLine &
              sqlAfterInsertColumns & vbNewLine &
              "    /* Audit Trail */" & vbNewLine &
              "{2}" & vbNewLine & vbNewLine &
              sSqlCodeAudit &
              sSqlPostAuditCalcs &
              sValidation & vbNewLine &
              "    DELETE {5} WHERE [tablefromid] = {3};" & vbNewLine & vbNewLine &
              "{4}" & vbNewLine & vbNewLine &
              "{1}" & vbNewLine & vbNewLine _
              , objTable.Name, ssqlPostInsertTriggerCode, sSqlCodeAuditInsert, objTable.Id, objTable.SysMgrInsertTrigger, Consts.SysTriggerTransaction)
          ScriptTrigger("dbo", objTable, TriggerType.AfterInsert, sSql, existingTriggers, False)

          ' INSTEAD OF UPDATE
          sSql = String.Format("    DECLARE @sValidation nvarchar(MAX) = '';" & vbNewLine & vbNewLine &
            sSqlCodeBypass &
            "    INSERT [dbo].[{2}] ([tablefromid], [actiontype], [nestlevel]) VALUES ({3}, 2, @@NESTLEVEL);" & vbNewLine & vbNewLine &
            "{1}" & vbNewLine & vbNewLine &
            sValidation & vbNewLine & vbNewLine &
            "    DELETE [dbo].[{2}] WHERE [tablefromid] = {0};" & vbNewLine _
            , objTable.Id _
            , sqlWriteableColumns _
            , Consts.SysTriggerTransaction, objTable.Id)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfUpdate, sSql, existingTriggers, objTable.UpdateTriggerDisabled)

          ' AFTER UPDATE
          sSql = String.Format("    DECLARE @audit TABLE ([username] varchar(255), [changedate] datetime, [id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), tableid integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine &
              "    DECLARE @sValidation nvarchar(MAX) = '';" & vbNewLine & vbNewLine &
              "    SELECT TOP 1 @startingtrigger = ISNULL([actiontype],2) FROM {1} WHERE [tablefromid] = {0} ORDER BY [nestlevel] ASC;" & vbNewLine &
              "    SELECT TOP 1 @startingtriggertable = ISNULL([tablefromid],0) FROM {1} ORDER BY [nestlevel] ASC;" & vbNewLine & vbNewLine &
              sSqlCalculatedColumns & vbNewLine & vbNewLine &
              sSqlParentColumns & vbNewLine &
              sSqlChildColumns & vbNewLine & vbNewLine &
              "{3}" & vbNewLine &
              sSqlCodeAudit &
              sSqlSpecialUpdate &
              "{4}" & vbNewLine & vbNewLine &
              "{7}" & vbNewLine & vbNewLine &
              "{5}" & vbNewLine & vbNewLine &
              "{6}" & vbNewLine & vbNewLine &
              "{2}" & vbNewLine & vbNewLine _
              , objTable.Id, Consts.SysTriggerTransaction _
              , sSqlPostUpdateTriggerCode _
              , sSqlCodeAuditUpdate, sSqlPostAuditCalcs, objTable.SysMgrUpdateTrigger, sSqlFusionCode, sSqlPostAuditCalcsAlsoAudited) & vbNewLine & vbNewLine
          ScriptTrigger("dbo", objTable, TriggerType.AfterUpdate, sSql, existingTriggers, objTable.UpdateTriggerDisabled)

          ' INSTEAD OF DELETE
          sSql = String.Format("	   DECLARE @audit TABLE ([username] varchar(255), [changedate] datetime, [id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tablename] varchar(255), [tableid] integer, [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & vbNewLine &
              "    INSERT [dbo].[{3}] ([tablefromid], [actiontype], [nestlevel]) VALUES ({4}, 3, @@NESTLEVEL);" & vbNewLine & vbNewLine &
           "     /* Purge if already deleted */" & vbNewLine &
              "    WITH base AS (SELECT * FROM dbo.[{0}]" & vbNewLine &
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM deleted WHERE [_deleted] = 1))" & vbNewLine &
              "        DELETE FROM base;" & vbNewLine & vbNewLine &
              "    /* Mark records as deleted. */" & vbNewLine &
              "    WITH base AS (SELECT [_deleted], [_deleteddate] FROM dbo.[{0}]" & vbNewLine &
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM deleted))" & vbNewLine &
              "        UPDATE base SET [_deleted] = 1, [_deleteddate] = GETDATE();" & vbNewLine & vbNewLine &
              "    /* Audit Trail */" & vbNewLine &
              "{1}" & vbNewLine & vbNewLine &
              sSqlCodeAudit &
              sSqlSpecialUpdate &
              "{2}" & vbNewLine & vbNewLine &
              "{5}" & vbNewLine & vbNewLine &
              "{6}" &
              "    /* Clear the temporary trigger status table */" & vbNewLine &
              "    DELETE [dbo].[{3}] WHERE [tablefromid] = {4};" & vbNewLine & vbNewLine _
              , objTable.PhysicalName, sSqlCodeAuditDelete, sSqlParentColumnsDelete _
              , Consts.SysTriggerTransaction, objTable.Id, objTable.SysMgrDeleteTrigger, sSqlCategoryUpdate)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfDelete, sSql, existingTriggers, objTable.DeleteTriggerDisabled)

          ' AFTER DELETE
          DropTrigger(objTable, TriggerType.AfterDelete, existingTriggers)

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Error generating trigger", Severity.Error, ex.Message, sSql)
        bOk = False

      Finally

      End Try

      Return bOk

    End Function

    Private Sub DropTrigger(table As Table, triggerType As TriggerType, existingTriggers As IDictionary(Of String, ScriptedMetadata))

      Dim sSql As String
      Dim sTriggerName As String = String.Empty

      Try

        Select Case [triggerType]
          Case TriggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", Consts.Trigger, table.Name)

          Case TriggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", Consts.Trigger, table.Name)

          Case TriggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", Consts.Trigger, table.Name)

          Case TriggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", Consts.Trigger, table.Name)

          Case TriggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", Consts.Trigger, table.Name)

          Case TriggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", Consts.Trigger, table.Name)

        End Select

        Dim existingTrigger As ScriptedMetadata = Nothing
        existingTriggers.TryGetValue(sTriggerName, existingTrigger)

        If existingTrigger IsNot Nothing Then
          sSql = String.Format("DROP TRIGGER {0}", sTriggerName)
          CommitDb.ScriptStatement(sSql, True, False)
        End If

      Catch ex As Exception

      End Try


    End Sub


    Private Sub ScriptTrigger(role As String, table As Table, triggerType As TriggerType, bodyCode As String _
                                   , existingTriggers As IDictionary(Of String, ScriptedMetadata), dropOnly As Boolean)

      Dim sSql As String = String.Empty
      Dim sTriggerType As String = String.Empty
      Dim sTriggerName As String = String.Empty
      Dim sTriggerFireType As String = String.Empty

      Try

        Select Case [triggerType]
          Case TriggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF INSERT"
            sTriggerFireType = "INSERT"

          Case TriggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER INSERT"
            sTriggerFireType = "INSERT"

          Case TriggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF UPDATE"
            sTriggerFireType = "UPDATE"

          Case TriggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER UPDATE"
            sTriggerFireType = "UPDATE"

          Case TriggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF DELETE"
            sTriggerFireType = "DELETE"

          Case TriggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER DELETE"
            sTriggerFireType = "DELETE"

        End Select

        ' Create new trigger code
        sSql = String.Format("CREATE TRIGGER [{1}].[{0}] ON [{1}].[{2}]" & vbNewLine &
          "    {3}" & vbNewLine & "AS" & vbNewLine &
          "BEGIN" & vbNewLine &
          "    SET NOCOUNT ON;" & vbNewLine &
          "    DECLARE @insertedRow TABLE (id integer);" & vbNewLine &
          "    DECLARE @iCount                integer," & vbNewLine &
          "            @dChangeDate           datetime = GETDATE()," & vbNewLine &
          "            @localID               integer = 0," & vbNewLine &
          "            @isovernight           bit," & vbNewLine &
          "            @startingtrigger       tinyint," & vbNewLine &
          "            @startingtriggertable  integer," & vbNewLine &
          "            @fusionMessageName     varchar(128)," & vbNewLine &
          "            @bIsFusionMessage      bit," & vbNewLine &
          "            @username              varchar(255);" & vbNewLine & vbNewLine &
          "    SELECT @isovernight = dbo.[udfsys_isovernightprocess]();" & vbNewLine &
          "    SELECT @fusionMessageName = RTRIM(LTRIM(ISNULL(SUBSTRING(CAST(CONTEXT_INFO() AS varchar(128)),0,128),'')));" & vbNewLine &
          "    SELECT @bIsFusionMessage = CASE SUBSTRING(@fusionMessageName,1,6) WHEN 'Fusion' THEN 1 ELSE 0 END;" & vbNewLine &
          "    SELECT @username =	CASE WHEN UPPER(LEFT(APP_NAME(), 15)) = 'OPENHR WORKFLOW' THEN 'OpenHR Workflow'" & vbNewLine &
          "          ELSE CASE WHEN @isovernight = 1 THEN 'OpenHR Overnight Process' ELSE RTRIM(SYSTEM_USER) END END" & vbNewLine & vbNewLine &
          "    IF OBJECT_ID('tempdb..#intransactiontrigger') IS NULL" & vbNewLine &
          "        CREATE TABLE {5}([tablefromid] [int] NOT NULL, [nestlevel] [int] NOT NULL, [actiontype] [tinyint] NOT NULL);" & vbNewLine &
          "{4}" & vbNewLine & vbNewLine &
          "END" _
          , sTriggerName, [role], table.PhysicalName, sTriggerType, [bodyCode], Consts.SysTriggerTransaction)

        Dim existingTrigger As ScriptedMetadata = Nothing
        existingTriggers.TryGetValue(sTriggerName, existingTrigger)

        If dropOnly Then
          DropTrigger(table, triggerType, existingTriggers)

        ElseIf existingTrigger IsNot Nothing AndAlso existingTrigger.Definition = sSql Then
          'trigger exists and is the same, do nothing
        Else
          If existingTrigger Is Nothing Then
            'create trigger
            CommitDb.ScriptStatement(sSql, True, False)
          Else
            'update trigger
            sSql = sSql.Replace("CREATE TRIGGER", "ALTER TRIGGER")
            CommitDb.ScriptStatement(sSql, True, False)
          End If

          'wether creating or altering we need to set the trigger alter
          If triggerType = TriggerType.AfterDelete Or triggerType = TriggerType.AfterUpdate Or triggerType = TriggerType.AfterInsert Then
            sSql = String.Format("EXEC sp_settriggerorder @triggername=N'[{0}].[{1}]', @order=N'First', @stmttype=N'{2}'", [role], sTriggerName, sTriggerFireType)
            CommitDb.ScriptStatement(sSql, False, False)
          End If
        End If

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, sTriggerName, Severity.Error, ex.Message, sSql)

      End Try

    End Sub

#End Region

#Region "Calculation Scripting"

    Public Function CreateFunctions() As Boolean Implements ICommitDB.ScriptFunctions

      Dim bOk As Boolean

      Try
        bOk = ConvertCurrency()

        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Date)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Numeric)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Logic)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.String)

      Catch ex As Exception
        bOk = False

      End Try

      Return bOk

    End Function

    Private Function IsSameWithoutComments(sql1 As String, sql2 As String) As Boolean

      If sql1 = sql2 Then Return True

      Const removeComments As String = "^--.*$"

      sql1 = Regex.Replace(sql1, removeComments, "", RegexOptions.Multiline).Trim

      sql2 = Regex.Replace(sql2, removeComments, "", RegexOptions.Multiline).Trim

      Return sql1 = sql2
    End Function

    Public Function CreateObjects() As Boolean Implements ICommitDB.ScriptObjects

      Try
        'Build list of existing system UDF
        Dim existingFunctions = (From f In DatabaseMetadata.GetFunctions() Where
                           f.Name.StartsWith(Consts.RecordDescriptionUdf) OrElse
                           f.Name.StartsWith(Consts.MaskUdf) OrElse
                           f.Name.StartsWith(Consts.CalculationUdf) OrElse
                           f.Name.StartsWith(Consts.DefaultValueUdf) OrElse
                           f.Name.StartsWith(Consts.TableOrderFilterUdf)
                           ).ToDictionary(Function(f) f.Name, StringComparer.InvariantCultureIgnoreCase)

        Dim functions As New List(Of GeneratedUdf)

        ' If complete refresh drop existing objects
        If Options.VersionUpgraded Then
          For Each func In existingFunctions.Values
            CommitDb.ScriptStatement(SqlDropUdf("dbo", func.Name), False, True)
          Next
          existingFunctions.Clear()
        End If

        ' Now create the objects
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          ' Record Descriptions
          If table.RecordDescription IsNot Nothing Then
            With table.RecordDescription
              .GenerateRecordDescription()
              functions.Add(.Udf)
            End With
          End If

          ' Indexes for views
          Dim index As New Index
          index.Name = String.Format("IDX_Views_{0}", table.Name)
          index.IncludePrimaryKey = True
          index.IsTableIndex = True

          For Each view In table.Views

            If Not view.Filter Is Nothing Then
              view.Filter.ExpressionType = ExpressionType.Mask
              view.Filter.AssociatedColumn = table.Columns(0)
              view.Filter.GenerateCodeForColumn()

              For Each column In view.Filter.Dependencies.Columns
                index.Columns.AddIfNew(column)
              Next
            End If

          Next
          table.Indexes.Add(index)

          ' Calculations
          For Each column In table.Columns

            If column.State <> DataRowState.Deleted Then

              If column.IsCalculated Then

                column.Calculation = table.Expressions.GetById(column.CalcId).Clone
                column.Calculation.SetRootNode(column.Calculation)

                If Not column.Calculation Is Nothing Then
                  column.Calculation.ExpressionType = ExpressionType.ColumnCalculation

                  column.Calculation.AssociatedColumn = column
                  column.Calculation.ConvertToExpression()
                  column.Calculation.GenerateCodeForColumn()

                  If column.Calculation.ReturnType <> column.ComponentReturnType Then
                    ErrorLog.Add(Section.UdFs, column.Name, Severity.Error _
                      , String.Format("Incorrect return type on {0}", column.Name) _
                      , String.Format("The calculation selected on {0}.{1} is not the same type as its column. Please reselect the correct calculation for this column" & vbNewLine &
                                "This could result in further errors in the save process or conversion failure error messages when saving records on this table or associated tables" _
                                , column.Table.Name, column.Name))
                  End If

                  ' Trap for error 1753 (some system may have duff metadata that's built up over the years
                  If column.Calculation.Components.Count = 0 Then
                    ErrorLog.Add(Section.UdFs, column.Name, Severity.Warning _
                      , String.Format("Invalid expression on {0}", column.Name) _
                      , String.Format("The calculation on {0}.{1} has no components and is invalid. You will need to redefine this calculation.", column.Table.Name, column.Name))
                    column.Calculation.IsValid = False
                  End If

                End If

              End If

              ' Build default value code
              If column.DefaultCalcId > 0 Then
                column.DefaultCalculation = table.Expressions.GetById(column.DefaultCalcId)

                If column.DefaultCalculation Is Nothing Then
                  ErrorLog.Add(Section.UdFs, "", Severity.Warning _
                  , String.Format("Default calculation for {0}.{1} not found.", column.Table.Name, column.Name) _
                    , "This is likely to be caused by copying a table and a calculation reference is still attached to the original column. In the associated calculation try re-selecting any calculations.")
                Else
                  column.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
                  column.DefaultCalculation.AssociatedColumn = column
                  column.DefaultCalculation.GenerateCodeForColumn()
                End If
              End If

            End If


          Next

          '  Validation Masks
          For Each expression In table.Masks
            With expression
              .GenerateMaskCode()
              functions.Add(.Udf)
            End With
          Next
        Next

        ' Generate any table UDFs
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each tableOrderFilter In table.TableOrderFilters
            With tableOrderFilter
              .GenerateCode()
              functions.Add(.Udf)
            End With
          Next
        Next

        ' Script the column calculations
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each column In table.Columns

            If column.State <> DataRowState.Deleted Then

              If column.IsCalculated Then

                With column.Calculation
                  .ExpressionType = ExpressionType.ColumnCalculation
                  .AssociatedColumn = column
                  .GenerateCodeForColumn()

                  TuningLog.Expressions.Add(column)

                  If .IsValid And .IsComplex Then
                    functions.Add(.Udf)
                  End If
                End With
              End If

              If column.DefaultCalcId > 0 And Not column.DefaultCalculation Is Nothing Then

                With column.DefaultCalculation
                  .ExpressionType = ExpressionType.ColumnDefault
                  .AssociatedColumn = column
                  .GenerateCodeForColumn()
                  TuningLog.Expressions.Add(column)

                  If .IsValid Then
                    functions.Add(.Udf)
                  Else
                    Dim newUdf = .Udf
                    newUdf.Code = newUdf.CodeStub
                    functions.Add(newUdf)
                  End If
                End With
              End If

            End If

          Next
        Next


        'Update the database for all the functions
        For Each func In functions.Distinct

          If existingFunctions.ContainsKey(func.BaseName) Then

            If Not IsSameWithoutComments(func.Code, existingFunctions(func.BaseName).Definition) Then
              'function needs to be updated
              CommitDb.ScriptStatement(func.SqlAlter, False, True)
            End If

          Else

            'create the function it doesnt exist
            CommitDb.ScriptStatement(func.SqlCreate, False, True)

          End If
          existingFunctions.Remove(func.BaseName)
        Next

        'Drop from the database function no longer needed
        For Each func In existingFunctions.Values
          CommitDb.ScriptStatement(SqlDropUdf("dbo", func.Name), False, True)
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, String.Empty, Severity.Error, ex.Message, vbNullString)
        Return False

      End Try

      Return True

    End Function

#End Region

#Region "Security Scripting"

    Public Function ApplySecurity() As Boolean Implements ICommitDB.ApplySecurity
      Return True
    End Function

#End Region

    Public Function ScriptIndexes() As Boolean Implements ICommitDB.ScriptIndexes

      Dim objTable As Table
      Dim objRelation As Relation
      Dim objColumn As Column
      Dim objIndex As Index
      Dim bOk As Boolean = True
      Dim sSql As String
      Dim aryColumns As ArrayList
      Dim aryIncludeColumns As ArrayList
      Dim sObjectName As String
      Dim sIncludeColumns As String
      Dim bCreateIndex As Boolean

      Try

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each objIndex In objTable.Indexes

            bCreateIndex = False

            ' Drop existing index
            sObjectName = If(objIndex.IsTableIndex, objTable.PhysicalName, objTable.Name)
            sSql = String.Format("IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'{1}')" &
                  "DROP INDEX [{1}] ON [dbo].[{0}]" _
                  , sObjectName, objIndex.Name)
            CommitDb.ScriptStatement(sSql, True, False)

            ' Generate index contents
            aryColumns = New ArrayList
            aryColumns.Clear()
            If objIndex.IncludePrimaryKey Then aryColumns.Add("[ID] ASC")
            For Each objColumn In objIndex.Columns
              If objColumn.Table Is objTable And Not objColumn.Multiline Then
                aryColumns.Add(objColumn.Name & " ASC")
                bCreateIndex = True
              End If
            Next

            aryIncludeColumns = New ArrayList
            For Each objColumn In objIndex.IncludedColumns
              If Not objIndex.Columns.Contains(objColumn) Then
                If objColumn.Table Is objTable Then
                  aryIncludeColumns.Add(objColumn.Name)
                  bCreateIndex = True
                End If
              End If
            Next

            ' If there's too many column in this index don't create because it'll be less efficient
            If aryColumns.ToArray.Length > 10 Then
              aryColumns.Clear()
              bCreateIndex = False
            End If

            For Each objRelation In objIndex.Relations
              Select Case objRelation.RelationshipType
                Case RelationshipType.Child
                  aryColumns.Add(String.Format("[ID_{0}] ASC", objRelation.ParentId))
                Case RelationshipType.Parent
                  aryColumns.Add(String.Format("[ID_{0}] ASC", objRelation.ChildId))
              End Select
              bCreateIndex = True
            Next

            ' Create index
            sIncludeColumns = If(aryIncludeColumns.Count > 0, " INCLUDE (" & String.Join(", ", aryIncludeColumns.ToArray) & ")", "")
            sSql = String.Format("CREATE NONCLUSTERED INDEX [{0}] ON [dbo].[{1}] " &
                "({2})" &
                "{3}" _
                , objIndex.Name, sObjectName, String.Join(", ", aryColumns.ToArray), sIncludeColumns)

            If objIndex.Enabled And bCreateIndex Then
              CommitDb.ScriptStatement(sSql, False, False)
            End If

          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, "Index", Severity.Error, ex.Message, vbNullString)
        bOk = False
      End Try

      Return bOk

    End Function

    Private Function SpecialTrigger_Categories(table As Table) As String

      Dim sSql As String = ""

      If table Is ModuleSetup.Setting("MODULE_CATEGORY", "Param_CategoryTable").Table Then

        sSql = vbTab & "/* Remove this category from reports and utilities. */" & vbNewLine &
          vbTab & "DELETE cats" & vbNewLine &
          vbTab & vbTab & "FROM dbo.tbsys_objectcategories cats, deleted" & vbNewLine &
          vbTab & vbTab & "WHERE cats.CategoryID = deleted.ID;" & vbNewLine & vbNewLine

      End If

      Return sSql

    End Function

    Private Function SpecialTrigger_TriggerCode(table As Table, position As TriggerCodePosition) As String

      Dim sSql As String = ""

      For Each objTrigger In table.CodeTriggers.Where(Function(m) m.CodePosition = position)
        sSql &= String.Format("	   -- {0}{1}{2}{1}{1}", objTrigger.Name, vbNewLine, objTrigger.Content)
      Next

      Return sSql

    End Function

    Private Function SpecialTrigger_Fusion(table As Table) As String

      Const sCursorDec As String = vbNullString
      Const sFetchNext As String = vbNullString
      Const sExecFusion As String = vbNullString

      Return String.Format("    /* Message Bus Integration */" & vbNewLine &
          vbTab & "DECLARE MessageCursor CURSOR LOCAL FAST_FORWARD FOR SELECT [ID] {1} FROM inserted;	" & vbNewLine &
          vbTab & "OPEN MessageCursor;" & vbNewLine &
          vbTab & "FETCH NEXT FROM MessageCursor INTO @localID {2};" & vbNewLine &
          vbTab & "WHILE @@FETCH_STATUS = 0 " & vbNewLine &
          vbTab & "BEGIN " & vbNewLine &
          vbTab & "    IF ISNULL(@localID,0) > 0" & vbNewLine &
          vbTab & "    BEGIN" & vbNewLine &
          vbTab & "        EXEC fusion.[spSendFusionMessage] @TableID={0}, @RecordID=@localID {3}" & vbNewLine &
          vbTab & "    END" & vbNewLine &
          vbTab & "    FETCH NEXT FROM MessageCursor INTO @localID {2};" & vbNewLine &
          vbTab & "END" & vbNewLine &
          vbTab & "CLOSE MessageCursor;" & vbNewLine &
          vbTab & "DEALLOCATE MessageCursor;" _
            , table.Id, sCursorDec, sFetchNext, sExecFusion)

    End Function

    Private Function SpecialTrigger_BankHolidays(table As Table) As String

      Dim aryTriggerCode As ArrayList
      Dim objColumn As Column
      Dim sCode As String = ""
      Dim objTriggeredUpdate As TriggeredUpdate

      Try

        ' Special bank holiday update
        If table Is ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableBHol").Table Then
          aryTriggerCode = New ArrayList

          objColumn = ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldBHolDate").Column

          For Each objTriggeredUpdate In OnBankHolidayUpdate
            aryTriggerCode.Add(String.Format("    ;WITH base AS (" & vbNewLine &
                "        SELECT {0} FROM dbo.[{1}]" & vbNewLine &
                "        INNER JOIN @dates bankholidays ON bankholidays.{2} {3})" & vbNewLine &
                "    UPDATE base SET [{0}] = [{0}];" _
                , objTriggeredUpdate.Column.Name, objTriggeredUpdate.Column.Table.PhysicalName, objColumn.Name, objTriggeredUpdate.Where))
          Next

          If aryTriggerCode.Count > 0 Then
            sCode = vbNewLine & vbNewLine & String.Format(vbNewLine & "/* Bank Holiday update */" & vbNewLine &
                  "DECLARE @dates TABLE ([{0}] datetime);" & vbNewLine &
                  "INSERT @dates" & vbNewLine &
                 "    SELECT [{0}] FROM inserted" & vbNewLine &
                 "    UNION" & vbNewLine &
                 "    SELECT [{0}] FROM deleted;" & vbNewLine & vbNewLine &
                  "{1}", objColumn.Name, String.Join(vbNewLine & vbNewLine, aryTriggerCode.ToArray())) & vbNewLine
          End If
        End If

      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Error generating trigger (SpecialTrigger_BankHolidays)", Severity.Error, ex.Message, sCode)

      End Try

      Return sCode

    End Function

    Private Function SpecialTrigger_Personnel(table As Table) As String

      Dim sCode As String = ""
      Dim objAbsenceTable As Table

      Try

        If table Is ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table Then
          objAbsenceTable = ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table
          If Not objAbsenceTable Is Nothing Then

            sCode = String.Format("    -- Statutory Sick Pay" & vbNewLine _
                    & "    IF EXISTS(SELECT [tablefromid] FROM {1} WHERE [tablefromid] = {0})" & vbNewLine _
                    & "        AND EXISTS(SELECT Name FROM sysobjects WHERE id = object_id('spsys_absencessp') AND sysstat & 0xf = 4)" & vbNewLine _
                    & "    BEGIN" & vbNewLine _
                    & "        SET @iCount = 0;" & vbNewLine _
                    & "        WHILE @iCount IS NOT NULL" & vbNewLine _
                    & "        BEGIN" & vbNewLine _
                    & "            EXEC dbo.[spsys_absencessp] @iCount;" & vbNewLine _
                    & "            SELECT @iCount=(SELECT MIN([ID]) FROM inserted WHERE [ID] > @iCount);" & vbNewLine _
                    & "        END" & vbNewLine _
                    & "    END;", objAbsenceTable.Id, Consts.SysTriggerTransaction)
          End If

          Dim selfServiceColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsLoginName").Column
          Dim workEmailColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsWorkEmail").Column
          Dim leavingDateColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsLeavingDate").Column
          Dim knownAsColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsSSIWelcome").Column
          Dim startDateColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsStartDate").Column
          Dim securityGroupColumn = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_FieldsSecurityGroup").Column

          If selfServiceColumn IsNot Nothing And securityGroupColumn IsNot Nothing Then

            sCode &= String.Format(vbNewLine & vbNewLine & "    -- Maintain logins from self service column" & vbNewLine _
                  & "    IF UPDATE([{0}])" & vbNewLine _
                  & "    BEGIN" & vbNewLine _
                  & "        DECLARE @logins AS SelfServiceType;" & vbNewLine _
                  & "        INSERT @logins" & vbNewLine _
                  & "        SELECT i.[{0}], i.[{1}], i.[{2}], i.[{3}], i.[{4}], i.[{5}] FROM inserted i" & vbNewLine _
                  & "            INNER JOIN deleted d ON d.id = i.id" & vbNewLine _
                  & "            WHERE ISNULL(i.[{0}], '') <> ISNULL(d.[{0}], '');" & vbNewLine _
                  & "        EXECUTE dbo.spASRGenerateSelfServiceLogins @logins;" & vbNewLine _
                  & "    END", selfServiceColumn.Name, workEmailColumn.Name, startDateColumn.Name, leavingDateColumn.Name, knownAsColumn.Name, securityGroupColumn.Name)

          End If

        End If

      Catch ex As Exception

      End Try

      Return sCode

		End Function

		Private Function SpecialTrigger_Personnel_HeadcountCheck(table As Table) As String

			Dim sCode As String = ""

			If table Is ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table Then

				sCode = "    DECLARE @prEnable bit = 0," & vbNewLine & _
								"            @headcountMessage varchar(MAX);" & vbNewLine & vbNewLine & _
								"    SELECT @prEnable = ISNULL([SettingValue],0)" & vbNewLine & _
								"        FROM ASRSysSystemSettings" & vbNewLine & _
								"        WHERE section = 'overnight' AND SettingKey = 'PREnable';" & vbNewLine & vbNewLine & _
								"    IF @prEnable = 0" & vbNewLine & _
								"    BEGIN" & vbNewLine & _
								"        SET @headcountMessage = 'You have reached or exceeded your headcount limit set within the terms of your licence agreement.' + char(13) + char(13)" & vbNewLine & _
								"            + 'You are no longer able to add new employee records, but you may access the system for all other purposes.' + char(13) + char(13)" & vbNewLine & _
								"            + 'Please contact OpenHR Customer Services on 08451 609 999 as soon as possible to increase the licence headcount number.'" & vbNewLine & _
								"       RAISERROR(@headcountMessage , 16, 1);" & vbNewLine & _
								"       RETURN;" & vbNewLine & _
								"    END" & vbNewLine & vbNewLine
			End If

			Return sCode

		End Function


		Private Function SpecialTrigger_SSP(table As Table) As String

			Dim sCode As String = ""
			Dim objPersonnelTable As Table
			Dim objColumn1 As Column
			Dim objColumn2 As Column
			Dim objColumn3 As Column
			Dim objColumn4 As Column

      Try

        If table Is ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table Then

          objPersonnelTable = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table

          objColumn1 = ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldSSPApplies").Column
          objColumn2 = ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldQualifyingDays").Column
          objColumn3 = ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldWaitingDays").Column
          objColumn4 = ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldPaidDays").Column

          If Not (objColumn1 Is Nothing Or objColumn2 Is Nothing Or objColumn3 Is Nothing Or objColumn4 Is Nothing Or objPersonnelTable Is Nothing) Then

            sCode = vbNewLine & String.Format("    /* SSP bypass */" & vbNewLine _
                    & "    IF EXISTS (SELECT ID_{0} FROM inserted INNER JOIN dbo.[ASRSysSSPRunning] ON [PersonnelRecordID] = ID_{0} AND sspRunning = 1)" & vbNewLine _
                    & "    BEGIN" & vbNewLine _
                    & "        UPDATE dbo.[{1}]" & vbNewLine _
                    & "           SET [{2}] = inserted.[{2}]," & vbNewLine _
                    & "               [{3}] = inserted.[{3}]," & vbNewLine _
                    & "               [{4}] = inserted.[{4}]," & vbNewLine _
                    & "               [{5}] = inserted.[{5}]" & vbNewLine _
                    & "        FROM [inserted] WHERE [inserted].[id] = [dbo].[{1}].[id]" & vbNewLine _
                    & "        RETURN;" & vbNewLine _
                    & "    END;" & vbNewLine & vbNewLine _
                    , objPersonnelTable.Id, table.PhysicalName _
                    , objColumn1.Name, objColumn2.Name, objColumn3.Name, objColumn4.Name)

          End If
        End If

      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Error generating trigger (SpecialTrigger_SSP)", Severity.Error, ex.Message, sCode)

      End Try

      Return sCode

		End Function

    Public Function ScriptOvernightStep2() As Boolean Implements ICommitDB.ScriptOvernightStep2

      Dim bOk As Boolean
      Dim objTable As Table
      Dim objColumn As Column
      Dim aryColumns As ArrayList
      Dim sSqlOvernightJob As String = vbNullString
      Dim sUpdate As String
      Const sObjectName As String = "spASRSysOvernightStep2"
      Dim objPayrollArchive As Setting
      Dim lngPayrollPeriod As Long
      Dim lngPayrollPeriodType As AccordPurgeType
      Dim bRefreshAll As Boolean

      Try

        bRefreshAll = CBool(SystemSettings.Setting("overnight", "refreshalltables").Value)

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          aryColumns = New ArrayList
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated And objColumn.State <> DataRowState.Deleted Then
              If objColumn.Calculation.IsTimeDependant Then
                sUpdate = String.Format("[{0}] = {1}", objColumn.Name, objColumn.Calculation.Udf.CallingCode)
                aryColumns.Add(sUpdate)
              End If
            End If

          Next

          If aryColumns.ToArray.Length > 0 Or bRefreshAll Then

            ' Each table with somethine time dependant
            sSqlOvernightJob = sSqlOvernightJob & String.Format("    EXEC dbo.[spASRSysOvernightTableUpdate] '{0}', 'updflag', 1000;" & vbNewLine _
              , objTable.PhysicalName)

          End If

        Next

        ' Add the payroll archive code
        objPayrollArchive = ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOption")
        If objPayrollArchive.Value = "1" Then

          lngPayrollPeriod = CLng(ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOptionPeriod").Value)
          lngPayrollPeriodType = CType(CInt(ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOptionPeriodType").Value), AccordPurgeType)

          sSqlOvernightJob = sSqlOvernightJob & vbNewLine & "    /* Archive payroll */" & vbNewLine

          Dim datePart As String = Nothing

          Select Case lngPayrollPeriodType
            Case AccordPurgeType.Days
              datePart = "dd"
            Case AccordPurgeType.Weeks
              datePart = "wk"
            Case AccordPurgeType.Months
              datePart = "mm"
            Case AccordPurgeType.Years
              datePart = "yy"
          End Select

          If Not datePart Is Nothing Then
            sSqlOvernightJob += "    DECLARE @date datetime" & vbNewLine &
                                "    SET @date = DATEADD(" & datePart & ", -" & lngPayrollPeriod & ", GETDATE())" & vbNewLine & vbNewLine &
                                "    UPDATE dbo.[ASRSysAccordTransactions] SET [archived] = 1 " & vbNewLine &
                                "    WHERE [CreatedDateTime] < @date AND [archived] = 0" & vbNewLine
          End If
        End If

        ' Generate the stored procedure
        sSqlOvernightJob = "/* ------------------------------------------------------------------------------- */" & vbNewLine & _
            "/* OpenHR system stored procedure.                  */" & vbNewLine & _
            "/* Automatically generated by the .NET Framework.   */" & vbNewLine & _
            "/* ------------------------------------------------------------------------------- */" & vbNewLine & _
            "CREATE PROCEDURE [dbo].[" & sObjectName & "] AS" & vbNewLine & _
            "BEGIN" & vbNewLine & vbNewLine & _
            "    SET NOCOUNT ON;" & vbNewLine & _
            "    DECLARE @iCount integer;" & vbNewLine & vbNewLine & _
            "    /* Tables with date dependent calculations */" & vbNewLine & _
            sSqlOvernightJob & vbNewLine & _
            "END"

        CommitDb.ScriptStatement(SqlDropProcedure("dbo", sObjectName), True, False)
        bOk = CommitDb.ScriptStatement(sSqlOvernightJob, True, False)


      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Overnight Job", Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

  End Class

End Namespace

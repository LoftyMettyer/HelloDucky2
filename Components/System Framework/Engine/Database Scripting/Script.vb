Imports System.Runtime.InteropServices
Imports System.Text
Imports SystemFramework.Things
Imports System.Text.RegularExpressions
Imports SystemFramework.Enums
Imports SystemFramework.Enums.Errors
Imports SystemFramework.Structures

Namespace ScriptDB

  <ClassInterface(ClassInterfaceType.None)>
  Public Class Script
    Implements ICommitDB

#Region "General"

    Public Shared Function SqlDropUdf(ByVal schema As String, ByVal name As String) As String

      Return String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " &
                           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & vbNewLine &
                           "WHERE o.[name] = '{1}' AND [type] IN ('FN', 'TF') AND u.[name] = '{0}')" & vbNewLine &
                           "DROP FUNCTION [{0}].[{1}]", schema, name)

    End Function

    Public Shared Function SqlDropProcedure(ByVal schema As String, ByVal name As String) As String

      Return String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & vbNewLine &
                           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & vbNewLine &
                           "WHERE o.[name] = '{1}' AND [type] = 'P' AND u.[name] = '{0}')" & vbNewLine &
                           "DROP PROCEDURE [{0}].[{1}]", schema, name)

    End Function

#End Region

    Public Shared Function DropUdf(ByVal schema As String, ByVal name As String) As Boolean

      Dim sql As String = SqlDropUdf(schema, name)

      Try
        CommitDb.ScriptStatement(sql, True)

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, name, Severity.Error, ex.Message, sql)
        Return False
      End Try

      Return True

    End Function

#Region "Table Scripting"

    Private Sub DropView(ByVal role As String, ByVal viewName As String)

      Dim sSql As String

      Try

        sSql = String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & _
           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & _
           "WHERE o.[name] = '{1}' AND [type] = 'V' AND u.[name] = '{0}')" & vbNewLine & _
          " DROP VIEW [{0}].[{1}]", [role], viewName)

        ' Commit
        CommitDb.ScriptStatement(sSql, True)

      Catch ex As Exception
        MsgBox(ex.Message, MsgBoxStyle.Critical)
        Stop

      End Try

    End Sub

    Public Function DropViews() As Boolean Implements ICommitDB.DropViews

      Dim bOk As Boolean = True

      Try
        For Each objTable As Table In Tables

          For Each objView As View In objTable.Views
            DropView(objTable.SchemaName, objView.Name)
          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, "DropViews", Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function DropTableViews() As Boolean Implements ICommitDB.DropTableViews

      Dim objTable As New Table
      Dim bOk As Boolean = True

      Try
        For Each objTable In Tables
          DropView("dbo", objTable.Name)
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, objTable.Name, Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateTables() As Boolean Implements ICommitDB.ScriptTables

      Dim bOk As Boolean = True
      Dim sSql As String = vbNullString

      Try
        For Each objTable As Table In Tables

          Select Case objTable.State

            Case DataRowState.Deleted
              sSql = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1) " & vbNewLine & _
                                   "DROP TABLE [dbo].[{0}];", objTable.PhysicalName)
              CommitDb.ScriptStatement(sSql, True)

            Case DataRowState.Modified
              'If Not objTable.PhysicalName = objTable.NameInDB Then
              '  sSQL = String.Format("sp_rename @objname = [{0}], @newname = [{1}]" _
              '        , objTable.NameInDB, objTable.PhysicalName)
              '  Globals.CommitDB.ScriptStatement(sSQL)
              '  'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)
              'End If

            Case Else ' DataRowState.Added
              sSql = String.Format("IF NOT EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "CREATE TABLE [dbo].[{0}] (" & _
                " [id] integer PRIMARY KEY CLUSTERED IDENTITY(1,1)" & _
                " , [guid] uniqueidentifier DEFAULT (newsequentialid())" & vbNewLine & _
                " , [updflag] integer" & vbNewLine & _
                " , [deleteddate] datetime" & vbNewLine & _
                " , [recorddescription] nvarchar(255)" & vbNewLine & _
                " , [timestamp] rowversion" & vbNewLine & _
                " , [lastsavedby] varbinary(85)" & vbNewLine & _
                " , [lastsavedatetime] datetime);" _
                , objTable.PhysicalName)
              CommitDb.ScriptStatement(sSql, True)

          End Select


          ' Add any relations
          For Each objRelation As Relation In objTable.Relations

            If objRelation.RelationshipType = RelationshipType.Parent Then
              sSql = String.Format("IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='ID_{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ADD [ID_{1}] integer NOT NULL", objTable.PhysicalName, objRelation.ParentId)
              CommitDb.ScriptStatement(sSql, True)

              sSql = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID_{1}')" & vbNewLine & _
                  "CREATE NONCLUSTERED INDEX [IDX_ID_{1}] ON [dbo].[{0}] ([ID_{1}] ASC)", objTable.PhysicalName, objRelation.ParentId)
              CommitDb.ScriptStatement(sSql, False)

            End If

          Next

          ' Now add the columns
          For Each objColumn As Column In objTable.Columns

            If objColumn.State = DataRowState.Deleted Then
              sSql = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] DROP COLUMN [{1}]", objTable.PhysicalName, objColumn.Name)
              CommitDb.ScriptStatement(sSql, True)

            ElseIf objColumn.State = DataRowState.Modified Or Options.RefreshObjects Then
              sSql = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ALTER COLUMN [{1}] {2} ELSE ALTER TABLE [dbo].[{0}] ADD [{1}] {2}", objTable.PhysicalName, objColumn.Name, objColumn.DataTypeSyntax)
              CommitDb.ScriptStatement(sSql, True)
            End If
          Next

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.TableAndColumns, "Views", Severity.Error, ex.Message, sSql)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateTableViews() As Boolean Implements ICommitDB.ScriptTableViews

      Dim bOk As Boolean = True
      Dim sDefinitionSql As String = String.Empty
      Dim sViewName As String = String.Empty
      Dim sActualTableName As String
      Dim sOptions As String = String.Empty

      Dim objTable As Table
      Dim objColumn As Column
      Dim objRelation As Relation

      Try

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          sViewName = objTable.Name
          sActualTableName = String.Format("{0}{1}", Consts.UserTable, objTable.Name)

          sDefinitionSql = "AS SELECT [id], [timestamp]" & vbNewLine

          ' Add relations
          For Each objRelation In objTable.Relations
            If objRelation.RelationshipType = RelationshipType.Parent Then
              sDefinitionSql = sDefinitionSql & String.Format(", [ID_{0}]", objRelation.ParentId) & vbNewLine
            End If
          Next


          ' Add columns
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated And objColumn.IsReadOnly And objTable.TableType = TableType.Parent Then
              sDefinitionSql = sDefinitionSql & String.Format(", {0} AS [{1}]", objColumn.Calculation.Udf.CallingCode.Replace("@prm_", "base."), objColumn.Name & vbNewLine)
            Else
              sDefinitionSql = sDefinitionSql & (String.Format(", base.[{0}] AS [{0}]", objColumn.Name) & vbNewLine)
            End If
          Next

          ' Add the base table
          sDefinitionSql = sDefinitionSql & vbNewLine & String.Format("FROM [dbo].[{0}] base", sActualTableName)

          DropView(objTable.SchemaName, sViewName)

          sDefinitionSql = String.Format("CREATE VIEW [{0}].[{1}] {2} {3}", objTable.SchemaName, sViewName, sOptions, sDefinitionSql)
          CommitDb.ScriptStatement(sDefinitionSql, True)

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, sViewName, Severity.Error, ex.Message, sDefinitionSql)
        bOk = False

      End Try

      Return bOk

    End Function

    Public Function CreateViews() As Boolean Implements ICommitDB.ScriptViews

      Dim objTable As Table
      Dim objView As View
      Dim objColumn As Column

      Dim sDefinition As New StringBuilder
      Dim bOk As Boolean = True

      Try

        For Each objTable In Tables
          For Each objView In objTable.Views

            sDefinition = New StringBuilder
            sDefinition.AppendLine(String.Format("CREATE VIEW [{0}].[{1}]", objTable.SchemaName, objView.Name))
            sDefinition.AppendLine("--WITH SCHEMABINDING")
            sDefinition.AppendLine("AS SELECT [id], [timestamp]")

            For Each objColumn In objView.Columns
              If objColumn.IsCalculated And objColumn.IsReadOnly Then
                sDefinition.AppendLine(String.Format(", {0} AS [{1}]", objColumn.Calculation.Udf.CallingCode.Replace("@prm_", "base."), objColumn.Name))
              Else
                sDefinition.AppendLine(String.Format(", base.[{0}] AS [{0}]", objColumn.Name))
              End If
            Next

            sDefinition.AppendLine(String.Format("FROM [{0}].[{1}] base", objTable.SchemaName, objTable.Name))

            ' Generate this view
            DropView(objTable.SchemaName, objView.Name)
            CommitDb.ScriptStatement(sDefinition.ToString, True)

          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Views, "Views", Severity.Error, ex.Message, sDefinition.ToString)
        bOk = False
      End Try

      Return bOk

    End Function

#End Region

#Region "Trigger Scripting"

    Public Function CreateTriggers() As Boolean Implements ICommitDB.ScriptTriggers

      Dim bOk As Boolean = True
      Dim objTable As Table
      Dim objRelatedTable As Table
      Dim objColumn As Column
      Dim objRelation As Relation
      Dim objIndex As Index

      Dim sSql As String = String.Empty
      Dim sCalculationCode As String
      Dim sColumnName As String
      Dim sAuditDataBase As String
      Dim sAuditDataDelete As String
      Dim sAuditDataInsert As String

      Dim objAuditIndex As Index

      Dim sSqlCodeAuditInsert As String
      Dim sSqlCodeAuditUpdate As String
      Dim sSqlCodeAuditDelete As String
      Dim sSqlCodeAudit As String

      Dim sSqlCodeBypass As String

      Dim sValidation As String

      Dim sSqlWriteableColumns As String
      Dim sQlInsteadOfInsertColumns As String
      Dim sqlAfterInsertColumns As String

      Dim sSqlCalculatedColumns As String
      Dim sSqlPostAuditCalcs As String
      Dim sSqlParentColumns As String
      Dim sSqlParentColumnsDelete As String
      Dim sSqlChildColumns As String

      Dim sSqlSpecialUpdate As String
      Dim sSqlCategoryUpdate As String
      Dim sSqlFusionCode As String

      Dim aryCalculatedColumns As ArrayList
      Dim aryPostAuditCalcs As ArrayList
      Dim aryBaseTableColumns As ArrayList
      Dim aryParentsToUpdate As ArrayList
      Dim aryChildrenToUpdate As ArrayList
      Dim aryParentsToUpdateDelete As ArrayList

      Dim aryColumnsWithDefaultValues As ArrayList
      Dim aryAllWriteableColumns As ArrayList
      Dim aryAllWriteableFormatted As ArrayList

      Dim aryColumns As ArrayList

      Dim aryAuditUpdates As ArrayList
      Dim aryAuditInserts As ArrayList
      Dim aryAuditDeletes As ArrayList

      Try

        'Build list of existing system UDF
        Dim existingTriggers = (From f In DatabaseMetadata.GetTriggers()
                         ).ToDictionary(Function(f) f.Name, StringComparer.InvariantCultureIgnoreCase)

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          aryColumnsWithDefaultValues = New ArrayList
          aryAllWriteableColumns = New ArrayList
          aryAllWriteableFormatted = New ArrayList
          aryAuditUpdates = New ArrayList
          aryAuditInserts = New ArrayList
          aryAuditDeletes = New ArrayList

          aryParentsToUpdate = New ArrayList
          aryChildrenToUpdate = New ArrayList
          aryParentsToUpdateDelete = New ArrayList
          aryBaseTableColumns = New ArrayList
          aryCalculatedColumns = New ArrayList
          aryPostAuditCalcs = New ArrayList

          sSqlCalculatedColumns = String.Empty
          sSqlParentColumns = String.Empty
          sSqlParentColumnsDelete = String.Empty
          sSqlChildColumns = String.Empty

          sSqlCodeAuditInsert = String.Empty
          sSqlCodeAuditUpdate = String.Empty
          sSqlCodeAuditDelete = String.Empty
          sSqlCodeAudit = String.Empty
          sSqlPostAuditCalcs = String.Empty

          ' Build in indexes
          objAuditIndex = New Index
          objTable.Indexes.Add(objAuditIndex)

          ' Add the system generated columns
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            aryCalculatedColumns.Add(String.Format("[_description] = {0}", objTable.RecordDescription.Udf.CallingCode))
          End If

          objAuditIndex.IsClustered = False
          objAuditIndex.IsTableIndex = True
          objAuditIndex.IncludePrimaryKey = True
          objAuditIndex.Name = "IDX_AuditFields"


          ' Build fusion messages
          sSqlFusionCode = SpecialTrigger_Fusion(objTable)

          ' Add any relationship columns
          For Each objRelation In objTable.Relations

            aryColumns = New ArrayList
            If objRelation.RelationshipType = RelationshipType.Parent Then
              aryBaseTableColumns.Add(String.Format("[ID_{0}] = base.[ID_{0}]", objRelation.ParentId))
              aryAllWriteableColumns.Add(String.Format("[ID_{0}]", objRelation.ParentId))
              aryAllWriteableFormatted.Add(String.Format("[ID_{0}]", objRelation.ParentId))

              objRelatedTable = Tables.GetById(objRelation.ParentId)
              For Each objColumn In objTable.DependsOnParentColumns
                If objColumn.Table Is objRelatedTable Then
                  aryColumns.Add(String.Format("base.{0} = {0}", objColumn.Name))
                End If
              Next

              If aryColumns.Count > 0 Then
                aryParentsToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                  "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM inserted)" & vbNewLine _
                  , objRelation.PhysicalName, objRelation.ParentId))

                aryParentsToUpdateDelete.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                  "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM deleted)" & vbNewLine _
                  , objRelation.PhysicalName, objRelation.ParentId))

              End If

            Else

              objRelatedTable = Tables.GetById(objRelation.ChildId)
              objIndex = New Index
              objIndex.Name = String.Format("IDX_relation_{0}", objRelatedTable.Name)
              objIndex.IsTableIndex = True
              objIndex.IsClustered = False
              objIndex.Enabled = False

              For Each objColumn In objRelatedTable.DependsOnChildColumns
                If objColumn.Table Is objTable Then
                  aryColumns.Add(String.Format("NOT i.{0} = d.{0}", objColumn.Name))
                  objIndex.IncludedColumns.AddIfNew(objColumn)
                End If
              Next

              If aryColumns.Count > 0 Then
                aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3})" & vbNewLine & _
                  "            AND EXISTS(SELECT i.ID FROM dbo.[{2}] i" & vbNewLine & _
                  "                INNER JOIN deleted d ON d.ID = i.ID " & vbNewLine & _
                  "                WHERE {4})" & vbNewLine & _
                  "        UPDATE dbo.[{0}] SET [updflag] = 1 WHERE ID_{1} IN (SELECT i.ID FROM inserted i);" _
                  , objRelatedTable.PhysicalName, objTable.Id, objTable.PhysicalName, objRelatedTable.Id _
                  , String.Join(" OR ", aryColumns.ToArray())))
                objTable.Indexes.Add(objIndex)
              End If
            End If
          Next

          For Each objColumn In objTable.Columns

            If Not objColumn.State = DataRowState.Deleted Then

              ' Create an index on any unique check columns
              If objColumn.UniqueType = UniqueCheckScope.All Then
                objIndex = New Index
                objIndex.Name = String.Format("IDX_uniquecheck_{0}", objColumn.Name)
                objIndex.IncludePrimaryKey = False
                objIndex.IsTableIndex = True
                objIndex.IsClustered = False
                objIndex.Enabled = True
                objIndex.IsUnique = True
                objIndex.Columns.Add(objColumn)
                objTable.Indexes.Add(objIndex)
              End If

              If objColumn.IsCalculated Then
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.ExpressionType = ExpressionType.ColumnCalculation
                '                objColumn.Calculation.GenerateCodeForColumn()

                If objColumn.Calculation.IsValid Then
                  If objColumn.Calculation.IsComplex Then
                    sCalculationCode = objColumn.Calculation.Udf.CallingCode
                  Else
                    sCalculationCode = objColumn.Calculation.Udf.InlineCode
                  End If

                  If objColumn.CalculateIfEmpty Then
                    If objColumn.SafeReturnType = "NULL" Then
                      sColumnName = String.Format("[{0}] = ISNULL([{0}], {1})", objColumn.Name, sCalculationCode)
                    Else
                      sColumnName = String.Format("[{0}] = ISNULL(NULLIF([{0}], {2}), {1})", objColumn.Name, sCalculationCode, objColumn.SafeReturnType)
                    End If
                  Else
                    sColumnName = String.Format("[{0}] = {1}", objColumn.Name, sCalculationCode)
                  End If

                  If objColumn.Calculation.CalculatePostAudit Then
                    aryPostAuditCalcs.Add(sColumnName & vbNewLine)
                  Else
                    aryCalculatedColumns.Add(sColumnName)
                  End If
                End If

              End If

              ' Build list of default values
              If objColumn.DefaultCalcId > 0 And Not objColumn.DefaultCalculation Is Nothing Then
                objColumn.DefaultCalculation.AssociatedColumn = objColumn
                objColumn.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
                objColumn.DefaultCalculation.GenerateCodeForColumn()

                sCalculationCode = objColumn.DefaultCalculation.Udf.CallingCode
                aryColumnsWithDefaultValues.Add(String.Format("[{0}] = ISNULL(base.[{0}], {1})", objColumn.Name, sCalculationCode))

              End If


              If Not objColumn.IsReadOnly Then
                Select Case objColumn.DataType

                  Case ColumnTypes.Date
                    aryBaseTableColumns.Add(String.Format("[{0}] = DATEADD(dd, 0, DATEDIFF(dd, 0, base.[{0}]))", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format(" DATEADD(dd, 0, DATEDIFF(dd, 0, [{0}]))", objColumn.Name))

                  Case Else
                    aryBaseTableColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.ApplyFormatting("base")))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format("[{0}]", objColumn.Name))

                End Select

              End If

              ' Concatenate audited columns
              If objColumn.Audit Then
                Select Case objColumn.DataType
                  Case ColumnTypes.Date
                    sAuditDataInsert = String.Format(" CONVERT(varchar(11), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(11), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(11), base.[{0}], 105)", objColumn.Name)

                  Case ColumnTypes.Logic
                    sAuditDataInsert = String.Format(" CASE i.[{0}] WHEN 1 THEN 'Yes' WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataDelete = String.Format(" CASE d.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataBase = String.Format(" CASE base.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)

                  Case Else
                    sAuditDataInsert = String.Format(" CONVERT(varchar(255), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(255), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(255), base.[{0}], 105)", objColumn.Name)
                End Select

                aryAuditInserts.Add(String.Format("        SELECT base.ID, '* New Record *', {0}, {4}, '{3}', '{5}', {1}, base.[_description]" & vbNewLine & _
                  "            FROM inserted i" & vbNewLine & _
                  "            INNER JOIN dbo.[{2}] base ON i.[id] = base.[id] AND NOT ISNULL({0},'') = ''" _
                  , sAuditDataInsert, objColumn.Id, objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.Id), objColumn.Name))

                aryAuditUpdates.Add(String.Format("        SELECT d.ID, {6}, {0}, {4}, '{3}', '{5}', {1}, base.[_description]" & vbNewLine & _
                  "            FROM deleted d" & vbNewLine & _
                  "            INNER JOIN dbo.[{2}] base ON d.[id] = base.[id] AND NOT ISNULL({0},'') = ISNULL({6},'')" _
                  , sAuditDataBase, objColumn.Id, objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.Id), objColumn.Name, sAuditDataDelete))

                aryAuditDeletes.Add(String.Format("        SELECT d.ID, {0}, ' * Deleted Record *', {3}, '{2}', '{4}', {1}, d.[_description]" & vbNewLine & _
                  "            FROM deleted d WHERE {0} IS NOT NULL" _
                  , sAuditDataDelete, objColumn.Id, objColumn.Table.Name, objColumn.Table.Id, objColumn.Name))

                objAuditIndex.IncludedColumns.AddIfNew(objColumn)
              End If
            End If

          Next

          ' Update any parents
          If aryParentsToUpdate.ToArray.Length > 0 Then
            sSqlParentColumns = "    -- Refresh parent records" & vbNewLine & _
                  "    IF @isovernight = 0" & vbNewLine & "    BEGIN" & vbNewLine & _
                  String.Join(vbNewLine, aryParentsToUpdate.ToArray()) & _
                  "     END"
            sSqlParentColumnsDelete = "    -- Refresh parents records" & vbNewLine & _
                  String.Join(vbNewLine, aryParentsToUpdateDelete.ToArray())

          End If

          ' Validation
          sValidation = String.Format("    -- Validation" & vbNewLine & _
            "    IF @isovernight = 0 AND (SELECT TOP 1 [tablefromid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid ORDER BY [nestlevel] ASC) = {0}" & vbNewLine & _
            "    BEGIN" & vbNewLine & _
            "        DELETE FROM fusion.ValidationWarnings" & vbNewLine & _
            "            WHERE RecordID IN (SELECT ID FROM inserted) AND tableid = {0}" & vbNewLine & vbNewLine & _
            "        SET @sValidation = '';" & vbNewLine & _
            "        SELECT @sValidation = @sValidation + dbo.[udfvalid_{1}](ID, [_description]) FROM inserted" & vbNewLine & _
            "        IF LEN(@sValidation) > 0 AND @bIsFusionMessage = 0" & vbNewLine & _
            "        BEGIN" & vbNewLine & _
            "            RAISERROR(@sValidation, 16, 1);" & vbNewLine & _
            "            ROLLBACK;" & vbNewLine & _
            "        END" & vbNewLine _
            , objTable.Id, objTable.Name)

          If objTable.FusionMessages.Count > 0 Then
            sValidation = sValidation & vbNewLine & String.Format("        IF LEN(@sValidation) > 0 AND @bIsFusionMessage = 1" & vbNewLine & _
              "        BEGIN" & vbNewLine & _
              "            INSERT fusion.ValidationWarnings (TableID, RecordID, MessageName, ValidationMessage, CreatedDateTime)" & vbNewLine & _
              "            SELECT '1',ID,@fusionMessageName,@sValidation,GETDATE()" & vbNewLine & _
              "                FROM inserted" & vbNewLine & _
              "        END" & vbNewLine)
          End If

          sValidation = sValidation & "    END" & vbNewLine

          ' Update child records
          If aryChildrenToUpdate.ToArray.Length > 0 Then
            sSqlChildColumns = "    --Update children" & vbNewLine & _
               "    IF @isovernight = 0 AND @startingtrigger = 2" & vbNewLine & "    BEGIN" & vbNewLine & _
               String.Join(vbNewLine & vbNewLine, aryChildrenToUpdate.ToArray()) & vbNewLine & _
              "     END"
          End If

          ' Update statement of all the non read only columns (free entry columns)
          If aryBaseTableColumns.ToArray.Length > 0 Then
            sSqlWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag], [_deleted] = base.[_deleted], [_deleteddate] = base.[_deleteddate]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryBaseTableColumns.ToArray()))
          Else
            sSqlWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag], [_deleted] = base.[_deleted], [_deleteddate] = base.[_deleteddate]" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName)
          End If


          ' Update the default values
          If aryColumnsWithDefaultValues.ToArray.Length > 0 Then
            'aryColumnsWithDefaultValues.AddRange(aryBaseTableColumns)
            sqlAfterInsertColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryColumnsWithDefaultValues.ToArray()))
          Else
            sqlAfterInsertColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName)
          End If

          ' Instead of writeable columns
          If aryAllWriteableColumns.ToArray.Length > 0 Then
            sQlInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine & _
               "    INSERT [dbo].[{0}] ({1})" & vbNewLine & _
               "        SELECT {2} FROM inserted base;" & vbNewLine & vbNewLine _
               , objTable.PhysicalName, String.Join(",", aryAllWriteableColumns.ToArray()), String.Join("," & vbNewLine, aryAllWriteableFormatted.ToArray()))
          Else
            sQlInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine & _
               "    INSERT [dbo].[{0}] ([updflag]) VALUES (1);" & vbNewLine & vbNewLine _
               , objTable.PhysicalName)
          End If

          ' Build audit strings
          If aryAuditUpdates.ToArray.Length > 0 Then
            sSqlCodeAuditInsert = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                    "{0};" _
                   , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditInserts.ToArray()))
            sSqlCodeAuditUpdate = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                    "{0};" _
                   , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditUpdates.ToArray()))
            sSqlCodeAuditDelete = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                    "{0};" _
                   , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditDeletes.ToArray()))
            sSqlCodeAudit = vbNewLine & "    INSERT dbo.[ASRSysAuditTrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], [deleted], [recorddesc])" & vbNewLine & _
                 "		     SELECT @username, @dChangeDate, [id], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], 1, [recorddesc] FROM @audit;" & vbNewLine & vbNewLine
          End If

          ' Table level audits
          If objTable.AuditInsert Then
            sSqlCodeAuditInsert += vbNewLine & String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine & _
               "        SELECT i.[id], '', ' * New Record *', {0}, '{1}', '', base.[_description] FROM inserted i" & vbNewLine & _
               "            INNER JOIN dbo.{2} base ON i.[id] = base.[id]" _
               , objTable.Id, objTable.Name, objTable.PhysicalName)
          End If

          If objTable.AuditDelete Then
            sSqlCodeAuditDelete += vbNewLine & String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine & _
               "        SELECT d.[id], '', ' * Deleted Record *', {0}, '{1}', '', d.[_description] FROM deleted d" & vbNewLine _
               , objTable.Id, objTable.Name)
          End If

          ' Update statement of all the calculated columns
          If aryCalculatedColumns.ToArray.Length > 0 Then
            sSqlCalculatedColumns = String.Format("    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine & _
              "    -- Update calculated columns" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *" & vbNewLine & _
              "            FROM [dbo].[{0}]" & vbNewLine & _
              "            WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base SET " & vbNewLine & _
              "        {1};" & vbNewLine & vbNewLine & _
              "    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine _
              , objTable.PhysicalName, String.Join(vbNewLine & vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))
          End If

          ' Any calculations that require to be saved after the audit
          If aryPostAuditCalcs.ToArray.Length > 0 Then
            sSqlPostAuditCalcs = String.Format("    -- Update columns that rely on audit log data" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *" & vbNewLine & _
              "        FROM [dbo].[{0}]" & vbNewLine & _
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base" & vbNewLine & _
              "    SET {1};" & vbNewLine _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryPostAuditCalcs.ToArray()))
          End If


          ' Special bypass trigger code
          sSqlCodeBypass = SpecialTrigger_SSP(objTable)

          ' Add trigger code based on module setup
          sSqlSpecialUpdate = SpecialTrigger_BankHolidays(objTable)
          sSqlSpecialUpdate = sSqlSpecialUpdate & SpecialTrigger_Personnel(objTable)
          sSqlCategoryUpdate = SpecialTrigger_Categories(objTable)

          ' -------------------
          ' INSTEAD OF INSERT
          ' -------------------
          sSql = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
            "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
            "    SET @sValidation = '';" & vbNewLine & _
            "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
            "    INSERT [dbo].[tbsys_intransactiontrigger] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {2}, 1, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
            sQlInsteadOfInsertColumns _
            , objTable.Name, "" _
            , objTable.Id _
            , String.Join(",", aryAllWriteableColumns.ToArray()), String.Join("," & vbNewLine, aryAllWriteableFormatted.ToArray()))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfInsert, sSql, existingTriggers)

          ' -------------------
          ' AFTER INSERT
          ' -------------------
          sSql = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tableid] integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
            "    DECLARE @dChangeDate datetime," & vbNewLine & _
            "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
            "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
            sqlAfterInsertColumns & vbNewLine & _
            "    -- Audit Trail" & vbNewLine & _
            "{2}" & vbNewLine & vbNewLine & _
            sSqlCodeAudit & _
            sValidation & vbNewLine & _
            "    DELETE [dbo].[tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3};" & vbNewLine & vbNewLine & _
            "{4}" & vbNewLine & vbNewLine _
            , objTable.Name, "", sSqlCodeAuditInsert, objTable.Id, objTable.SysMgrInsertTrigger)
          ScriptTrigger("dbo", objTable, TriggerType.AfterInsert, sSql, existingTriggers)

          ' -------------------
          ' INSTEAD OF UPDATE
          ' -------------------
          sSql = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
            "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
            "    SET @sValidation = '';" & vbNewLine & _
            "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
            sSqlCodeBypass & _
            "    INSERT [dbo].[{4}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {5}, 2, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
            "{3}" & vbNewLine & vbNewLine & _
            sValidation & vbNewLine & vbNewLine & _
            "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {2};" & vbNewLine _
            , objTable.Name, "" _
            , objTable.Id _
            , sSqlWriteableColumns _
            , Consts.SysTriggerTransaction, objTable.Id)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfUpdate, sSql, existingTriggers)

          ' -------------------
          ' AFTER UPDATE
          ' -------------------
          sSql = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), tableid integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
            "    DECLARE @dChangeDate datetime," & vbNewLine & _
            "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
            "    SELECT TOP 1 @startingtrigger = ISNULL([actiontype],2) FROM dbo.[tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3} ORDER BY [nestlevel] ASC;" & vbNewLine & _
            "    SELECT TOP 1 @startingtriggertable = ISNULL([tablefromid],0) FROM dbo.[tbsys_intransactiontrigger] WHERE [spid] = @@spid ORDER BY [nestlevel] ASC;" & vbNewLine & _
            "    SET @sValidation = '';" & vbNewLine & _
            "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
            sSqlCalculatedColumns & vbNewLine & vbNewLine & _
            sSqlParentColumns & vbNewLine & _
            sSqlChildColumns & vbNewLine & vbNewLine & _
            "{6}" & vbNewLine & _
            sSqlCodeAudit & _
            sSqlSpecialUpdate & _
            "{7}" & vbNewLine & vbNewLine & _
            "{8}" & vbNewLine & vbNewLine & _
            "{9}" & vbNewLine & vbNewLine _
            , objTable.Name, "" _
            , "", objTable.Id, Consts.SysTriggerTransaction _
            , "" _
            , sSqlCodeAuditUpdate, sSqlPostAuditCalcs, objTable.SysMgrUpdateTrigger, sSqlFusionCode) & vbNewLine & vbNewLine
          ScriptTrigger("dbo", objTable, TriggerType.AfterUpdate, sSql, existingTriggers)

          ' -------------------
          ' INSTEAD OF DELETE
          ' -------------------
          sSql = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tablename] varchar(255), [tableid] integer, [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
            "    DECLARE @dChangeDate datetime;" & vbNewLine & _
            "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
            "    INSERT [dbo].[{3}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {4}, 3, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
           "    -- Purge if already deleted" & vbNewLine & _
            "    WITH base AS (SELECT * FROM dbo.[{0}]" & vbNewLine & _
            "        WHERE [id] IN (SELECT DISTINCT [id] FROM deleted WHERE [_deleted] = 1))" & vbNewLine & _
            "        DELETE FROM base;" & vbNewLine & vbNewLine & _
            "    -- Mark records as deleted." & vbNewLine & _
            "    WITH base AS (SELECT [_deleted], [_deleteddate] FROM dbo.[{0}]" & vbNewLine & _
            "        WHERE [id] IN (SELECT DISTINCT [id] FROM deleted))" & vbNewLine & _
            "        UPDATE base SET [_deleted] = 1, [_deleteddate] = GETDATE();" & vbNewLine & vbNewLine & _
            "    -- Audit Trail" & vbNewLine & _
            "{1}" & vbNewLine & vbNewLine & _
            sSqlCodeAudit & _
            sSqlSpecialUpdate & _
            "{2}" & vbNewLine & vbNewLine & _
            "{5}" & vbNewLine & vbNewLine & _
            "{6}" & _
            "    -- Clear the temporary trigger status table" & vbNewLine & _
            "    DELETE [dbo].[{3}] WHERE [spid] = @@spid AND [tablefromid] = {4};" & vbNewLine & vbNewLine _
            , objTable.PhysicalName, sSqlCodeAuditDelete, sSqlParentColumnsDelete _
            , Consts.SysTriggerTransaction, objTable.Id, objTable.SysMgrDeleteTrigger, sSqlCategoryUpdate)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfDelete, sSql, existingTriggers)

          ' -------------------
          ' AFTER DELETE
          ' -------------------
          DropTrigger(objTable, TriggerType.AfterDelete, existingTriggers)

        Next

      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Error generating trigger", Severity.Error, ex.Message, sSql)
        bOk = False

      Finally

      End Try

      Return bOk

    End Function

    Private Sub DropTrigger(ByVal table As Table, ByVal triggerType As TriggerType, ByVal existingTriggers As IDictionary(Of String, ScriptedMetadata))

      Dim sSql As String 
      Dim sTriggerName As String = String.Empty

      Try

        Select Case [triggerType]
          Case triggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", Consts.Trigger, table.Name)

          Case triggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", Consts.Trigger, table.Name)

          Case triggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", Consts.Trigger, table.Name)

          Case triggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", Consts.Trigger, table.Name)

          Case triggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", Consts.Trigger, table.Name)

          Case triggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", Consts.Trigger, table.Name)

        End Select

        Dim existingTrigger As ScriptedMetadata = Nothing
        existingTriggers.TryGetValue(sTriggerName, existingTrigger)

        If existingTrigger IsNot Nothing Then
          sSql = String.Format("DROP TRIGGER {0}", sTriggerName)
          CommitDb.ScriptStatement(sSql, True)
        End If

      Catch ex As Exception

      End Try


    End Sub



    Private Sub ScriptTrigger(ByVal role As String, ByVal table As Table, ByVal triggerType As TriggerType, ByVal bodyCode As String _
                                   , ByVal existingTriggers As IDictionary(Of String, ScriptedMetadata))

      Dim sSql As String = String.Empty
      Dim sTriggerType As String = String.Empty
      Dim sTriggerName As String = String.Empty
      Dim sTriggerFireType As String = String.Empty

      Try

        Select Case [triggerType]
          Case triggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF INSERT"
            sTriggerFireType = "INSERT"

          Case triggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER INSERT"
            sTriggerFireType = "INSERT"

          Case triggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF UPDATE"
            sTriggerFireType = "UPDATE"

          Case triggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER UPDATE"
            sTriggerFireType = "UPDATE"

          Case triggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", Consts.Trigger, table.Name)
            sTriggerType = "INSTEAD OF DELETE"
            sTriggerFireType = "DELETE"

          Case triggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", Consts.Trigger, table.Name)
            sTriggerType = "AFTER DELETE"
            sTriggerFireType = "DELETE"

        End Select

        ' Create new trigger code
        sSql = String.Format("CREATE TRIGGER [{1}].[{0}] ON [{1}].[{2}]" & vbNewLine & _
          "    {3}" & vbNewLine & "AS" & vbNewLine & _
          "BEGIN" & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Start ([{2}].[{0}]';" & vbNewLine & _
          "    SET NOCOUNT ON;" & vbNewLine & _
          "    DECLARE @iCount                integer," & vbNewLine & _
          "            @localID               integer," & vbNewLine & _
          "            @isovernight           bit," & vbNewLine & _
          "            @startingtrigger       tinyint," & vbNewLine & _
          "            @startingtriggertable  integer," & vbNewLine & _
          "            @fusionMessageName     varchar(128)," & vbNewLine & _
          "            @bIsFusionMessage      bit," & vbNewLine & _
          "            @username              varchar(255);" & vbNewLine & vbNewLine & _
          "    SELECT @isovernight = dbo.[udfsys_isovernightprocess]();" & vbNewLine & _
          "    SELECT @fusionMessageName = RTRIM(LTRIM(ISNULL(SUBSTRING(CAST(CONTEXT_INFO() AS varchar(128)),0,128),'')));" & vbNewLine & _
          "    SELECT @bIsFusionMessage = CASE SUBSTRING(@fusionMessageName,1,6) WHEN 'Fusion' THEN 1 ELSE 0 END;" & vbNewLine & _
          "    SELECT @username =	CASE WHEN UPPER(LEFT(APP_NAME(), 15)) = 'OPENHR WORKFLOW' THEN 'OpenHR Workflow'" & vbNewLine & _
          "          ELSE CASE WHEN @isovernight = 1 THEN 'OpenHR Overnight Process' ELSE RTRIM(SYSTEM_USER) END END" & vbNewLine & vbNewLine & _
          "{4}" & vbNewLine & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Exit ([{2}].[{0}]'; " & vbNewLine & _
          "END" _
          , sTriggerName, [role], table.PhysicalName, sTriggerType, [bodyCode] _
          , If(Options.DevelopmentMode, "", "--"))

        Dim existingTrigger As ScriptedMetadata = Nothing
        existingTriggers.TryGetValue(sTriggerName, existingTrigger)

        If existingTrigger IsNot Nothing AndAlso existingTrigger.Definition = sSql Then
          'trigger exists and is the same, do nothing
        Else
          If existingTrigger Is Nothing Then
            'create trigger
            CommitDb.ScriptStatement(sSql, True)
          Else
            'update trigger
            sSql = sSql.Replace("CREATE TRIGGER", "ALTER TRIGGER")
            CommitDb.ScriptStatement(sSql, True)
          End If

          'wether creating or altering we need to set the trigger alter
          If triggerType = triggerType.AfterDelete Or triggerType = triggerType.AfterUpdate Or triggerType = triggerType.AfterInsert Then
            sSql = String.Format("EXEC sp_settriggerorder @triggername=N'[{0}].[{1}]', @order=N'First', @stmttype=N'{2}'", [role], sTriggerName, sTriggerFireType)
            CommitDb.ScriptStatement(sSql, False)
          End If
        End If

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, sTriggerName, Severity.Error, ex.Message, sSql)

      End Try

    End Sub

#End Region

#Region "Calculation Scripting"

    Public Function CreateFunctions() As Boolean Implements ICommitDB.ScriptFunctions

      Dim bOk As Boolean

      Try
        bOk = ConvertCurrency()

        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Date)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Numeric)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.Logic)
        bOk = bOk And GetFieldFromDatabases(ComponentValueTypes.String)

      Catch ex As Exception
        bOk = False

      End Try

      Return bOk

    End Function

    Private Function IsSameWithoutComments(ByVal sql1 As String, ByVal sql2 As String) As Boolean

      If sql1 = sql2 Then Return True

      Const removeComments As String = "^--.*$"

      sql1 = Regex.Replace(sql1, removeComments, "", RegexOptions.Multiline).Trim

      sql2 = Regex.Replace(sql2, removeComments, "", RegexOptions.Multiline).Trim

      Return sql1 = sql2
    End Function

    Public Function CreateObjects() As Boolean Implements ICommitDB.ScriptObjects

      Try
        'Build list of existing system UDF
        Dim existingFunctions = (From f In DatabaseMetadata.GetFunctions() Where
                         f.Name.StartsWith(Consts.RecordDescriptionUdf) OrElse
                         f.Name.StartsWith(Consts.MaskUdf) OrElse
                         f.Name.StartsWith(Consts.CalculationUdf) OrElse
                         f.Name.StartsWith(Consts.DefaultValueUdf) OrElse
                         f.Name.StartsWith(Consts.TableOrderFilterUdf)
                         ).ToDictionary(Function(f) f.Name, StringComparer.InvariantCultureIgnoreCase)

        Dim functions As New List(Of GeneratedUdf)

        ' Now create the objects
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)

          ' Record Descriptions
          If table.RecordDescription IsNot Nothing Then
            With table.RecordDescription
              .GenerateRecordDescription()
              functions.Add(.Udf)
            End With
          End If

          ' Indexes for views
          Dim index As New Index
          index.Name = String.Format("IDX_Views_{0}", table.Name)
          index.IncludePrimaryKey = True
          index.IsTableIndex = True

          For Each view In table.Views

            If Not view.Filter Is Nothing Then
              view.Filter.ExpressionType = ExpressionType.Mask
              view.Filter.AssociatedColumn = table.Columns(0)
              view.Filter.GenerateCodeForColumn()

              For Each column In view.Filter.Dependencies.Columns
                index.Columns.AddIfNew(column)
              Next
            End If

          Next
          table.Indexes.Add(index)

          ' Calculations
          For Each column In table.Columns

            If column.State <> DataRowState.Deleted Then

              If column.IsCalculated Then

                column.Calculation = table.Expressions.GetById(column.CalcId).Clone
                column.Calculation.SetRootNode(column.Calculation)

                If Not column.Calculation Is Nothing Then
                  column.Calculation.ExpressionType = ExpressionType.ColumnCalculation

                  column.Calculation.AssociatedColumn = column
                  column.Calculation.ConvertToExpression()
                  column.Calculation.GenerateCodeForColumn()

                  If column.Calculation.ReturnType <> column.ComponentReturnType Then
                    ErrorLog.Add(Section.UdFs, column.Name, Severity.Error _
                      , String.Format("Incorrect return type on {0}", column.Name) _
                      , String.Format("The calculation selected on {0}.{1} is not the same type as its column. Please reselect the correct calculation for this column" & vbNewLine & _
                                "This could result in further errors in the save process or conversion failure error messages when saving records on this table or associated tables" _
                                , column.Table.Name, column.Name))
                  End If

                  ' Trap for error 1753 (some system may have duff metadata that's built up over the years
                  If column.Calculation.Components.Count = 0 Then
                    ErrorLog.Add(Section.UdFs, column.Name, Severity.Warning _
                      , String.Format("Invalid expression on {0}", column.Name) _
                      , String.Format("The calculation on {0}.{1} has no components and is invalid. You will need to redefine this calculation.", column.Table.Name, column.Name))
                    column.Calculation.IsValid = False
                  End If

                End If

              End If

              ' Build default value code
              If column.DefaultCalcId > 0 Then
                column.DefaultCalculation = table.Expressions.GetById(column.DefaultCalcId)

                If column.DefaultCalculation Is Nothing Then
                  ErrorLog.Add(Section.UdFs, "", Severity.Warning _
                  , String.Format("Default calculation for {0}.{1} not found.", column.Table.Name, column.Name) _
                    , "This is likely to be caused by copying a table and a calculation reference is still attached to the original column. In the associated calculation try re-selecting any calculations.")
                Else
                  column.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
                  column.DefaultCalculation.AssociatedColumn = column
                  column.DefaultCalculation.GenerateCodeForColumn()
                End If
              End If

            End If


          Next

          '  Validation Masks
          For Each expression In table.Masks
            With expression
              .GenerateMaskCode()
              functions.Add(.Udf)
            End With
          Next
        Next

        ' Generate any table UDFs
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each tableOrderFilter In table.TableOrderFilters
            With tableOrderFilter
              .GenerateCode()
              functions.Add(.Udf)
            End With
          Next
        Next

        ' Script the column calculations
        For Each table In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each column In table.Columns

            If column.State <> DataRowState.Deleted Then

              If column.IsCalculated Then

                With column.Calculation
                  .ExpressionType = ExpressionType.ColumnCalculation
                  .AssociatedColumn = column
                  .GenerateCodeForColumn()

                  TuningLog.Expressions.Add(column)

                  If .IsValid And .IsComplex Then
                    functions.Add(.Udf)
                  End If
                End With
              End If

              If column.DefaultCalcId > 0 And Not column.DefaultCalculation Is Nothing Then

                With column.DefaultCalculation
                  .ExpressionType = ExpressionType.ColumnDefault
                  .AssociatedColumn = column
                  .GenerateCodeForColumn()
                  TuningLog.Expressions.Add(column)

                  If .IsValid Then
                    functions.Add(.Udf)
                  Else
                    Dim newUdf = .Udf
                    newUdf.Code = newUdf.CodeStub
                    functions.Add(newUdf)
                  End If
                End With
              End If

            End If

          Next
        Next

        'Update the database for all the functions
        For Each func In functions.Distinct

          If existingFunctions.ContainsKey(func.BaseName) Then

            If Not IsSameWithoutComments(func.Code, existingFunctions(func.BaseName).Definition) Then
              'function needs to be updated
              CommitDb.ScriptStatement(func.SqlAlter, False)
            End If

          Else

            'create the function it doesnt exist
            CommitDb.ScriptStatement(func.SqlCreate, False)

          End If
          existingFunctions.Remove(func.BaseName)
        Next

        'Drop from the database function no longer needed
        For Each func In existingFunctions.Values
          CommitDb.ScriptStatement(SqlDropUdf("dbo", func.Name), False)
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, String.Empty, Severity.Error, ex.Message, vbNullString)
        Return False

      End Try

      Return True

    End Function

#End Region

#Region "Security Scripting"

    Public Function ApplySecurity() As Boolean Implements ICommitDB.ApplySecurity
      Return True
    End Function

#End Region

    Public Function ScriptIndexes() As Boolean Implements ICommitDB.ScriptIndexes

      Dim objTable As Table
      Dim objRelation As Relation
      Dim objColumn As Column
      Dim objIndex As Index
      Dim bOk As Boolean = True
      Dim sSql As String
      Dim aryColumns As ArrayList
      Dim aryIncludeColumns As ArrayList
      Dim sObjectName As String
      Dim sIncludeColumns As String
      Dim bCreateIndex As Boolean

      Try

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          For Each objIndex In objTable.Indexes

            bCreateIndex = False

            ' Drop existing index
            sObjectName = If(objIndex.IsTableIndex, objTable.PhysicalName, objTable.Name)
            sSql = String.Format("IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'{1}')" & _
                  "DROP INDEX [{1}] ON [dbo].[{0}]" _
                  , sObjectName, objIndex.Name)
            CommitDb.ScriptStatement(sSql, True)

            ' Generate index contents
            aryColumns = New ArrayList
            aryColumns.Clear()
            If objIndex.IncludePrimaryKey Then aryColumns.Add("[ID] ASC")
            For Each objColumn In objIndex.Columns
              If objColumn.Table Is objTable And Not objColumn.Multiline Then
                aryColumns.Add(objColumn.Name & " ASC")
                bCreateIndex = True
              End If
            Next

            aryIncludeColumns = New ArrayList
            For Each objColumn In objIndex.IncludedColumns
              If Not objIndex.Columns.Contains(objColumn) Then
                If objColumn.Table Is objTable Then
                  aryIncludeColumns.Add(objColumn.Name)
                  bCreateIndex = True
                End If
              End If
            Next

            ' If there's too many column in this index don't create because it'll be less efficient
            If aryColumns.ToArray.Length > 10 Then
              aryColumns.Clear()
              bCreateIndex = False
            End If

            For Each objRelation In objIndex.Relations
              Select Case objRelation.RelationshipType
                Case RelationshipType.Child
                  aryColumns.Add(String.Format("[ID_{0}] ASC", objRelation.ParentId))
                Case RelationshipType.Parent
                  aryColumns.Add(String.Format("[ID_{0}] ASC", objRelation.ChildId))
              End Select
              bCreateIndex = True
            Next

            ' Create index
            sIncludeColumns = If(aryIncludeColumns.Count > 0, " INCLUDE (" & String.Join(", ", aryIncludeColumns.ToArray) & ")", "")
            sSql = String.Format("CREATE NONCLUSTERED INDEX [{0}] ON [dbo].[{1}] " & _
                "({2})" & _
                "{3}" _
                , objIndex.Name, sObjectName, String.Join(", ", aryColumns.ToArray), sIncludeColumns)

            If objIndex.Enabled And bCreateIndex Then
              CommitDb.ScriptStatement(sSql, False)
            End If

          Next
        Next

      Catch ex As Exception
        ErrorLog.Add(Section.UdFs, "Index", Severity.Error, ex.Message, vbNullString)
        bOk = False
      End Try

      Return bOk

    End Function

    Private Function SpecialTrigger_Categories(ByVal table As Table) As String

      Dim sSql As String = ""

      If table Is ModuleSetup.Setting("MODULE_CATEGORY", "Param_CategoryTable").Table Then

        sSql = vbTab & "-- Remove this category from reports and utilities." & vbNewLine & _
          vbTab & "DELETE cats" & vbNewLine & _
          vbTab & vbTab & "FROM dbo.tbsys_objectcategories cats, deleted" & vbNewLine & _
          vbTab & vbTab & "WHERE cats.CategoryID = deleted.ID;" & vbNewLine & vbNewLine

      End If

      Return sSql

    End Function

    Private Function SpecialTrigger_Fusion(ByVal table As Table) As String

      Const sCursorDec As String = vbNullString
      Const sFetchNext As String = vbNullString
      Const sExecFusion As String = vbNullString

      Return String.Format("    -- Message Bus Integration" & vbNewLine & _
          vbTab & "DECLARE MessageCursor CURSOR LOCAL FAST_FORWARD FOR SELECT [ID] {1} FROM inserted;	" & vbNewLine & _
          vbTab & "OPEN MessageCursor;" & vbNewLine & _
          vbTab & "FETCH NEXT FROM MessageCursor INTO @localID {2};" & vbNewLine & _
          vbTab & "WHILE @@FETCH_STATUS = 0 " & vbNewLine & _
          vbTab & "BEGIN " & vbNewLine & _
          vbTab & "    IF ISNULL(@localID,0) > 0" & vbNewLine & _
          vbTab & "    BEGIN" & vbNewLine & _
          vbTab & "        EXEC fusion.[spSendFusionMessage] @TableID={0}, @RecordID=@localID {3}" & vbNewLine & _
          vbTab & "    END" & vbNewLine & _
          vbTab & "    FETCH NEXT FROM MessageCursor INTO @localID {2};" & vbNewLine & _
          vbTab & "END" & vbNewLine & _
          vbTab & "CLOSE MessageCursor;" & vbNewLine & _
          vbTab & "DEALLOCATE MessageCursor;" _
            , table.Id, sCursorDec, sFetchNext, sExecFusion)

    End Function

    Private Function SpecialTrigger_BankHolidays(ByVal table As Table) As String

      Dim aryTriggerCode As ArrayList
      Dim lngColumnId As Integer
      Dim objColumn As Column
      Dim sCode As String = ""
      Dim objTriggeredUpdate As TriggeredUpdate

      ' Special bank holiday update
      If table Is ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableBHol").Table Then
        aryTriggerCode = New ArrayList

        lngColumnId = CInt(ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldBHolDate").Value)
        objColumn = table.Columns.GetById(lngColumnId)

        For Each objTriggeredUpdate In OnBankHolidayUpdate
          aryTriggerCode.Add(String.Format("    WITH base AS (" & vbNewLine &
              "        SELECT {0} FROM dbo.[{1}]" & vbNewLine & _
              "        INNER JOIN @dates bankholidays ON bankholidays.{2} {3})" & vbNewLine & _
              "    UPDATE base SET [{0}] = [{0}];" _
              , objTriggeredUpdate.Column.Name, objTriggeredUpdate.Column.Table.PhysicalName, objColumn.Name, objTriggeredUpdate.Where))
        Next

        If aryTriggerCode.Count > 0 Then
          sCode = vbNewLine & vbNewLine & String.Format(vbNewLine & "-- Bank Holiday update" & vbNewLine & _
                "DECLARE @dates TABLE ([{0}] datetime);" & vbNewLine &
                "INSERT @dates" & vbNewLine &
               "    SELECT [{0}] FROM inserted" & vbNewLine &
               "    UNION" & vbNewLine &
               "    SELECT [{0}] FROM deleted;" & vbNewLine & vbNewLine &
                "{1}", objColumn.Name, String.Join(vbNewLine & vbNewLine, aryTriggerCode.ToArray())) & vbNewLine
        End If
      End If

      Return sCode

    End Function

    Private Function SpecialTrigger_Personnel(ByVal table As Table) As String

      Dim sCode As String = ""
      Dim objAbsenceTable As Table

      If table Is ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table Then
        objAbsenceTable = ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table
        If Not objAbsenceTable Is Nothing Then

          sCode = String.Format("    -- Statutory Sick Pay" & vbNewLine _
                  & "    IF EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {0})" & vbNewLine _
                  & "        AND EXISTS(SELECT Name FROM sysobjects WHERE id = object_id('spsys_absencessp') AND sysstat & 0xf = 4)" & vbNewLine _
                  & "    BEGIN" & vbNewLine _
                  & "        SET @iCount = 0;" & vbNewLine _
                  & "        WHILE @iCount IS NOT NULL" & vbNewLine _
                  & "        BEGIN" & vbNewLine _
                  & "            EXEC dbo.[spsys_absencessp] @iCount;" & vbNewLine _
                  & "            SELECT @iCount=(SELECT MIN([ID]) FROM inserted WHERE [ID] > @iCount);" & vbNewLine _
                  & "        END" & vbNewLine _
                  & "    END;", objAbsenceTable.Id)
        End If
      End If

      Return sCode

    End Function

    Private Function SpecialTrigger_SSP(ByVal table As Table) As String

      Dim sCode As String = ""
      Dim objPersonnelTable As Table
      Dim objColumn1 As Column
      Dim objColumn2 As Column
      Dim objColumn3 As Column
      Dim objColumn4 As Column
      Dim lngColumnId As Integer

      If table Is ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table Then

        objPersonnelTable = ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table

        lngColumnId = CInt(ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldSSPApplies").Value)
        objColumn1 = table.Columns.GetById(lngColumnId)

        lngColumnId = CInt(ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldQualifyingDays").Value)
        objColumn2 = table.Columns.GetById(lngColumnId)

        lngColumnId = CInt(ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldWaitingDays").Value)
        objColumn3 = table.Columns.GetById(lngColumnId)

        lngColumnId = CInt(ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldPaidDays").Value)
        objColumn4 = table.Columns.GetById(lngColumnId)

        If Not (objColumn1 Is Nothing Or objColumn2 Is Nothing Or objColumn3 Is Nothing Or objColumn4 Is Nothing Or objPersonnelTable Is Nothing) Then

          sCode = vbNewLine & String.Format("    -- SSP bypass" & vbNewLine _
                  & "    IF EXISTS (SELECT ID_{0} FROM inserted INNER JOIN dbo.[ASRSysSSPRunning] ON [PersonnelRecordID] = ID_{0} AND sspRunning = 1)" & vbNewLine _
                  & "    BEGIN" & vbNewLine _
                  & "        UPDATE dbo.[{1}]" & vbNewLine _
                  & "           SET [{2}] = inserted.[{2}]," & vbNewLine _
                  & "               [{3}] = inserted.[{3}]," & vbNewLine _
                  & "               [{4}] = inserted.[{4}]," & vbNewLine _
                  & "               [{5}] = inserted.[{5}]" & vbNewLine _
                  & "        FROM [inserted] WHERE [inserted].[id] = [dbo].[{1}].[id]" & vbNewLine _
                  & "        RETURN;" & vbNewLine _
                  & "    END;" & vbNewLine & vbNewLine _
                  , objPersonnelTable.Id, table.PhysicalName _
                  , objColumn1.Name, objColumn2.Name, objColumn3.Name, objColumn4.Name)

        End If
      End If

      Return sCode

    End Function

    Public Function ScriptOvernightStep2() As Boolean Implements ICommitDB.ScriptOvernightStep2

      Dim bOk As Boolean
      Dim objTable As Table
      Dim objColumn As Column
      Dim aryColumns As ArrayList
      Dim sSqlOvernightJob As String = vbNullString
      Dim sUpdate As String
      Const sObjectName As String = "spASRSysOvernightStep2"
      Dim objPayrollArchive As Setting
      Dim lngPayrollPeriod As Long
      Dim lngPayrollPeriodType As AccordPurgeType
      Dim bRefreshAll As Boolean

      Try

        bRefreshAll = CBool(SystemSettings.Setting("overnight", "refreshalltables").Value)

        For Each objTable In Tables.Where(Function(f) f.State <> DataRowState.Deleted)
          aryColumns = New ArrayList
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated And objColumn.State <> DataRowState.Deleted Then
              If objColumn.Calculation.IsTimeDependant Then
                sUpdate = String.Format("[{0}] = {1}", objColumn.Name, objColumn.Calculation.Udf.CallingCode)
                aryColumns.Add(sUpdate)
              End If
            End If

          Next

          If aryColumns.ToArray.Length > 0 Or bRefreshAll Then

            ' Each table with somethine time dependant
            sSqlOvernightJob = sSqlOvernightJob & String.Format("    EXEC dbo.[spASRSysOvernightTableUpdate] '{0}', 'updflag', 1000;" & vbNewLine _
              , objTable.PhysicalName)

          End If

        Next

        ' Add the payroll archive code
        objPayrollArchive = ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOption")
        If objPayrollArchive.Value = "1" Then

          lngPayrollPeriod = CLng(ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOptionPeriod").Value)
          lngPayrollPeriodType = CType(CInt(ModuleSetup.Setting("MODULE_ACCORD", "Param_PurgeOptionPeriodType").Value), AccordPurgeType)

          sSqlOvernightJob = sSqlOvernightJob & vbNewLine & "    -- Archive payroll" & vbNewLine

          Dim datePart As String = Nothing

          Select Case lngPayrollPeriodType
            Case AccordPurgeType.Days
              datePart = "dd"
            Case AccordPurgeType.Weeks
              datePart = "wk"
            Case AccordPurgeType.Months
              datePart = "mm"
            Case AccordPurgeType.Years
              datePart = "yy"
          End Select

          If Not datePart Is Nothing Then
            sSqlOvernightJob += "    DECLARE @date datetime" & vbNewLine &
                                "    SET @date = DATEADD(" & datePart & ", -" & lngPayrollPeriod & ", GETDATE())" & vbNewLine & vbNewLine &
                                "    UPDATE dbo.[ASRSysAccordTransactions] SET [archived] = 1 " & vbNewLine &
                                "    WHERE [CreatedDateTime] < @date AND [archived] = 0" & vbNewLine
          End If
        End If

        ' Generate the stored procedure
        sSqlOvernightJob = "/* ------------------------------------------------------------------------------- */" & vbNewLine & _
            "/* OpenHR system stored procedure.                  */" & vbNewLine & _
            "/* Automatically generated by the .NET Framework.   */" & vbNewLine & _
            "/* ------------------------------------------------------------------------------- */" & vbNewLine & _
            "CREATE PROCEDURE [dbo].[" & sObjectName & "] AS" & vbNewLine & _
            "BEGIN" & vbNewLine & vbNewLine & _
            "    SET NOCOUNT ON;" & vbNewLine & _
            "    DECLARE @iCount integer;" & vbNewLine & vbNewLine & _
            "    -- Tables with date dependent calculations" & vbNewLine & _
            sSqlOvernightJob & vbNewLine & _
            "END"

        CommitDb.ScriptStatement(SqlDropProcedure("dbo", sObjectName), True)
        bOk = CommitDb.ScriptStatement(sSqlOvernightJob, True)


      Catch ex As Exception
        ErrorLog.Add(Section.Triggers, "Overnight Job", Severity.Error, ex.Message, vbNullString)
        bOk = False

      End Try

      Return bOk

    End Function

  End Class

End Namespace

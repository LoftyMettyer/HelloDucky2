Option Explicit On

Imports System.Runtime.InteropServices
Imports System.Text

Namespace ScriptDB

  <ClassInterface(ClassInterfaceType.None)> _
  Public Class Script
    Implements Interfaces.iCommitDB

#Region "Table Scripting"

    Private Sub DropView(ByRef [Role] As String, ByRef [ViewName] As String)

      Dim sSQL As String

      Try

        sSQL = String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & _
           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & _
           "WHERE o.[name] = '{1}' AND [type] = 'V' AND u.[name] = '{0}')" & vbNewLine & _
          " DROP VIEW [{0}].[{1}]", [Role], ViewName)

        ' Commit
        CommitDB.ScriptStatement(sSQL)

      Catch ex As Exception
        MsgBox(ex.Message, MsgBoxStyle.Critical)
        Stop

      End Try

    End Sub

    Public Function DropViews() As Boolean Implements iCommitDB.DropViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things

          For Each objView In objTable.Objects(Things.Type.View)
            DropView(objTable.SchemaName, objView.Name)
          Next
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, "DropViews", HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      End Try

      Return bOK

    End Function


    Public Function DropTableViews() As Boolean Implements iCommitDB.DropTableViews

      Dim objTable As Things.Table
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things
          DropView("dbo", objTable.Name)
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, objTable.Name, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)

      End Try

      Return bOK

    End Function

    Public Function CreateTables() As Boolean Implements iCommitDB.ScriptTables

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim sSQL As String

      Try

        For Each objTable In Globals.Things

          Select Case objTable.State

            Case DataRowState.Deleted
              sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "DROP TABLE [dbo].[{0}];", objTable.NameInDB)
              Globals.CommitDB.ScriptStatement(sSQL)

            Case DataRowState.Modified
              'If Not objTable.PhysicalName = objTable.NameInDB Then
              '  sSQL = String.Format("sp_rename @objname = [{0}], @newname = [{1}]" _
              '        , objTable.NameInDB, objTable.PhysicalName)
              '  Globals.CommitDB.ScriptStatement(sSQL)
              '  'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)
              'End If

            Case Else ' DataRowState.Added
              sSQL = String.Format("IF NOT EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "CREATE TABLE [dbo].[{0}] (" & _
                " [id] integer PRIMARY KEY CLUSTERED IDENTITY(1,1)" & _
                " , [guid] uniqueidentifier DEFAULT (newsequentialid())" & vbNewLine & _
                " , [updflag] integer" & vbNewLine & _
                " , [deleteddate] datetime" & vbNewLine & _
                " , [recorddescription] nvarchar(255)" & vbNewLine & _
                " , [timestamp] rowversion" & vbNewLine & _
                " , [lastsavedby] varbinary(85)" & vbNewLine & _
                " , [lastsavedatetime] datetime);" _
                , objTable.PhysicalName)
              Globals.CommitDB.ScriptStatement(sSQL)
              'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)

          End Select


          ' Add any relations
          For Each objRelation In objTable.Objects(Things.Type.Relation)

            If objRelation.RelationshipType = ScriptDB.RelationshipType.Parent Then
              sSQL = String.Format("IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='ID_{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ADD [ID_{1}] integer NOT NULL", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

              sSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID_{1}')" & vbNewLine & _
                  "CREATE NONCLUSTERED INDEX [IDX_ID_{1}] ON [dbo].[{0}] ([ID_{1}] ASC)", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next



          ' Now add the columns
          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.State = DataRowState.Deleted Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] DROP COLUMN [{1}]", objTable.PhysicalName, objColumn.Name)
              Globals.CommitDB.ScriptStatement(sSQL)

            ElseIf System.Data.DataRowState.Modified Or Globals.Options.RefreshObjects Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ALTER COLUMN [{1}] {2} ELSE ALTER TABLE [dbo].[{0}] ADD [{1}] {2}", objTable.PhysicalName, objColumn.Name, objColumn.DataTypeSyntax)
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.TableAndColumns, "Views", HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateTableViews() As Boolean Implements iCommitDB.ScriptTableViews

      Dim bOK As Boolean = True
      Dim sDefinitionSQL As String = String.Empty
      Dim sViewName As String = String.Empty
      Dim sActualTableName As String = String.Empty
      Dim sOptions As String = String.Empty

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim objExpression As Things.Expression

      Try

        '     sSchemaName = "dbo"
        sOptions = vbNewLine & "WITH SCHEMABINDING" & vbNewLine

        '        ProgressInfo.TotalSteps2 = Globals.Things.Count
        For Each objTable In Globals.Things

          sViewName = objTable.Name
          sActualTableName = String.Format("{0}{1}", Consts.UserTable, objTable.Name)

          sDefinitionSQL = "AS SELECT [id], [guid], [timestamp], [updflag]" & vbNewLine

          ' Add relations
          For Each objRelation In objTable.Objects(Things.Type.Relation)
            If objRelation.RelationshipType = RelationshipType.Parent Then
              sDefinitionSQL = sDefinitionSQL & String.Format(", [ID_{0}]", CInt(objRelation.ParentID)) & vbNewLine
            End If
          Next


          ' Is it a physical HR Pro table or a connection to a remote table/database
          If objTable.IsRemoteView Then

            ' Create dummy place holder for view
            For Each objColumn In objTable.Objects(Things.Type.Column)
              sDefinitionSQL = sDefinitionSQL & String.Format("{0} AS [{1}]", objColumn.BlankDefintion, objColumn.Name) & vbNewLine
            Next

          Else

            'aryJoinCode = New ArrayList

            ' Add columns
            For Each objColumn In objTable.Objects(Things.Type.Column)

              If Not objColumn.State = System.Data.DataRowState.Deleted Then

                If objColumn.IsCalculated And 1 = 2 Then  'tempry 1=2 because I want to test just having it in the trigger
                  objExpression = New Things.Expression
                  objExpression = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)
                  If Not objExpression Is Nothing Then
                    '    objExpression.ExpressionType = ScriptDB.ExpressionType.ViewCode
                    objExpression.AssociatedColumn = objColumn
                    '    sColumnCalculation = objExpression.Code
                    '    If objExpression.IsSimpleCalc Then  'And objExpression.IsValid Then
                    '      sSQL = sSQL & String.Format(", {0} AS [{1}]", sColumnCalculation, objColumn.Name) & vbNewLine
                    '    Else
                    '      sSQL = sSQL & String.Format(", [{0}]", objColumn.Name) & vbNewLine
                    '    End If

                    '    '    aryJoinCode.

                    '    '    aryJoinCode.Add(objExpression.Joins)
                    sDefinitionSQL = sDefinitionSQL & String.Format(", {0} AS [{1}]", objExpression.UDF.CallingCode, objColumn.Name) & vbNewLine


                  End If
                  'If objColumn.DataType = ColumnTypes.Binary Then

                Else
                  sDefinitionSQL = sDefinitionSQL & String.Format(", base.[{0}]", objColumn.Name) & vbNewLine
                  'End If
                  'Else

                End If
              End If
            Next

            ' Add the base table
            sDefinitionSQL = sDefinitionSQL & vbNewLine & String.Format("FROM [dbo].[{0}] base", sActualTableName)
          End If


          DropView(objTable.SchemaName, sViewName)

          sDefinitionSQL = String.Format("CREATE VIEW [{0}].[{1}] {2} {3}", objTable.SchemaName, sViewName, sOptions, sDefinitionSQL)
          CommitDB.ScriptStatement(sDefinitionSQL)

          sDefinitionSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID')" & vbNewLine & _
              "CREATE UNIQUE CLUSTERED INDEX [IDX_ID] ON [dbo].[{0}] ([ID] ASC)", objTable.Name)
          CommitDB.ScriptStatement(sDefinitionSQL)


        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, sViewName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sDefinitionSQL)
        bOK = False

      End Try

      Return bOK

    End Function

    ' Script each of the user defined views for this table
    Public Function CreateViews() As Boolean Implements iCommitDB.ScriptViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim objColumn As Things.Column

      Dim sDefinition As New StringBuilder
      Dim bOK As Boolean = True

      Try

        For Each objTable In Globals.Things
          For Each objView In objTable.Objects(Things.Type.View)

            sDefinition = New StringBuilder
            sDefinition.AppendLine(String.Format("CREATE VIEW [{0}].[{1}]", objTable.SchemaName, objView.Name))
            sDefinition.AppendLine("WITH SCHEMABINDING")
            sDefinition.AppendLine("AS SELECT [id], [timestamp]")

            For Each objColumn In objView.Objects(Things.Type.Column)
              sDefinition.AppendLine(String.Format(", base.[{0}] AS [{0}]", objColumn.Name))
            Next

            sDefinition.AppendLine(String.Format("FROM [{0}].[{1}] base", objTable.SchemaName, objTable.Name))

            ' Add the filter
            'If Not objView.Filter Is Nothing Then
            '  sDefinition.AppendLine("WHERE " & objView.Filter.UDF.SelectCode)
            'End If

            ' Generate this view
            DropView(objTable.SchemaName, objView.Name)
            CommitDB.ScriptStatement(sDefinition.ToString)

            '' Add an index
            'sDefinitionSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID')" & vbNewLine & _
            '    "CREATE UNIQUE CLUSTERED INDEX [IDX_ID] ON [dbo].[{0}] ([ID] ASC)", objTable.Name)
            'CommitDB.ScriptStatement(sDefinitionSQL)

          Next
        Next



      Catch ex As Exception
        Globals.ErrorLog.Add(ErrorHandler.Section.Views, "Views", ErrorHandler.Severity.Error, ex.Message, sDefinition.ToString)
        bOK = False
      End Try

      Return bOK

    End Function


#End Region

#Region "Trigger Scripting"

    Public Function CreateTriggers() As Boolean Implements iCommitDB.ScriptTriggers

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim sSQL As String = String.Empty
      Dim sValidation As String = String.Empty
      Dim sTriggerName As String = String.Empty

      Dim sSQLCode_AuditInsert As String = String.Empty
      Dim sSQLCode_AuditUpdate As String = String.Empty
      Dim sSQLCode_AuditDelete As String = String.Empty

      Dim sSQLCode_RecordDescription As New StringBuilder

      Dim sSQLCode_DiaryLinks As String = String.Empty
      Dim sSQLWriteableColumns As String
      Dim sSQLCalculatedColumns As String
      Dim sSQLPostAuditCalcs As String
      Dim sSQLParentColumns As String
      Dim sSQLParentColumns_Delete As String
      Dim sSQLChildColumns As String

      Dim aryCalculatedColumns As ArrayList
      Dim aryPostAuditCalcs As ArrayList
      Dim aryDebugColumns As ArrayList
      Dim aryBaseTableColumns As ArrayList
      Dim aryParentsToUpdate As ArrayList
      Dim aryChildrenToUpdate As ArrayList
      Dim aryParentsToUpdate_Delete As ArrayList
      Dim aryAfterInsertColumns As ArrayList
      Dim aryAllWriteableColumns As ArrayList

      Dim aryAuditUpdates As ArrayList
      Dim aryAuditInserts As ArrayList
      Dim aryAuditDeletes As ArrayList

      '      Dim aryInsertStatements As ArrayList
      'Dim aryUpdateStatements As ArrayList
      '  Dim aryDeleteStatements As ArrayList

      Dim aryValidationStatements As ArrayList

      Dim aryUpdateUniqueCodes As ArrayList

      ' Now strut our funky stuff
      Try

        '   ProgressInfo.TotalSteps2 = Globals.Things.Count
        For Each objTable In Globals.Things

          '       ProgressInfo.NextStep2()

          aryAllWriteableColumns = New ArrayList
          '   aryInsertStatements = New ArrayList
          '   aryDeleteStatements = New ArrayList

          aryAuditUpdates = New ArrayList
          aryAuditInserts = New ArrayList
          aryAuditDeletes = New ArrayList

          aryValidationStatements = New ArrayList
          'For Each objValidation In objTable.Validations

          '  Select Case objValidation.ValidationType

          '    Case Things.ValidationType.Mandatory
          '      sValidation = String.Format("    INSERT @Failed" & vbNewLine & _
          '          "       SELECT [id],'{0}' AS [Message], {2} AS [Severity]" & vbNewLine & _
          '          "       FROM inserted" & vbNewLine & _
          '          "       WHERE [{1}] IS NULL OR [{1}] = {3};" & vbNewLine & vbNewLine _
          '          , objValidation.Message, objValidation.Column.Name, CInt(objValidation.Severity), objValidation.Column.SafeReturnType)

          '    Case Things.ValidationType.UniqueInTable
          '      sValidation = String.Format("    INSERT @Failed" & vbNewLine & _
          '          "        SELECT [id],'{0}' AS [Message], {1} AS [Severity] " & vbNewLine & _
          '          "        FROM inserted base" & vbNewLine & _
          '          "        WHERE [{2}] IN (SELECT [{2}] FROM inserted" & vbNewLine & _
          '          "        GROUP BY [{2}]" & vbNewLine & _
          '          "        HAVING COUNT([{2}]) > 1)" _
          '          , objValidation.Message, CInt(objValidation.Severity), objValidation.Column.Name)

          '      If objValidation.Column.IsCalculated Then
          '        sValidation = sValidation & vbNewLine & String.Format("        OR [dbo].[{0}]() > 0" & vbNewLine _
          '          , objValidation.Column.Calculation.UDF.CallingCode)
          '      End If


          '  End Select

          '  aryValidationStatements.Add(sValidation)

          'Next

          aryAfterInsertColumns = New ArrayList
          aryUpdateUniqueCodes = New ArrayList
          aryParentsToUpdate = New ArrayList
          aryChildrenToUpdate = New ArrayList
          aryParentsToUpdate_Delete = New ArrayList

          ' Diary links code
          'sSQLCode_DiaryLinks = String.Format("       SET @nvarCommand = '';" & vbNewLine & _
          '                    "        SELECT @nvarCommand = @nvarCommand + 'EXEC dbo.spASRDiary_{0} ' + CONVERT(nvarchar(10),ID) + ';' FROM inserted;" & vbNewLine & _
          '                    "        EXECUTE sp_executeSQL @nvarCommand" _
          '                   , CInt(objTable.ID))


          ' Build list of columns in this table
          aryBaseTableColumns = New ArrayList
          aryCalculatedColumns = New ArrayList
          aryPostAuditCalcs = New ArrayList
          aryDebugColumns = New ArrayList

          sSQLCode_AuditInsert = String.Empty
          sSQLCode_AuditUpdate = String.Empty
          sSQLCode_AuditDelete = String.Empty

          ' Add the system generated columns
          If Not objTable.RecordDescription Is Nothing Then
            'objTable.RecordDescription.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
            objTable.RecordDescription.GenerateCode()
            aryCalculatedColumns.Add(String.Format("[_description] = {0}", objTable.RecordDescription.UDF.CallingCode))
          End If


          For Each objColumn In objTable.Columns

            If Not objColumn.State = System.Data.DataRowState.Deleted Then

              If objColumn.IsCalculated Then
                objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.GenerateCode()

                If objColumn.Calculation.CalculatePostAudit Then
                  aryPostAuditCalcs.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.Calculation.UDF.CallingCode) & vbNewLine)
                Else
                  aryCalculatedColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.Calculation.UDF.CallingCode) & vbNewLine)
                End If

              End If

              If Not objColumn.IsReadOnly Then
                Select Case objColumn.DataType

                  Case ScriptDB.ColumnTypes.Binary
                    aryBaseTableColumns.Add(String.Format("[{0}] = [inserted].[{0}]", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                  Case ScriptDB.ColumnTypes.Date
                    aryBaseTableColumns.Add(String.Format("[{0}] = DATEADD(dd, 0, DATEDIFF(dd, 0, [inserted].[{0}]))", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                  Case Else
                    aryBaseTableColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.ApplyFormatting("inserted")))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                End Select

              End If


              ' Concatenate all the audited columns
              If objColumn.Audit Then
                If objColumn.IsCalculated Then

                  aryAuditInserts.Add(String.Format("        SELECT base.ID, NULL, convert(nvarchar({4}),[{0}]), {1}, {5}, base.[_description]" & vbNewLine & _
                                      "            FROM dbo.[{3}] base" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.Calculation.UDF.CallingCode, objColumn.Table.PhysicalName, objColumn.DataTypeSize, CInt(objTable.ID)))
                  aryAuditUpdates.Add(String.Format("        SELECT d.ID, convert(nvarchar({4}),d.[{0}]), convert(nvarchar({4}), base.[{0}]), {1}, {5}, base.[_description]" & vbNewLine & _
                                      "            FROM deleted d" & vbNewLine & _
                                      "            INNER JOIN dbo.[{3}] base ON d.[id] = base.[id] AND NOT d.[{0}] = base.[{0}]" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.Calculation.UDF.CallingCode, objColumn.Table.PhysicalName, objColumn.DataTypeSize, CInt(objTable.ID)))
                  aryAuditDeletes.Add(String.Format("        SELECT base.ID, convert(nvarchar({4}),{2}), NULL, {1}, {5}, base.[_description]" & vbNewLine & _
                                      "            FROM deleted base" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.Calculation.UDF.CallingCode, "", objColumn.DataTypeSize, CInt(objTable.ID)))
                Else
                  aryAuditInserts.Add(String.Format("        SELECT ID, NULL, convert(nvarchar({2}),[{0}]), {1}, {3}, [_description]" & vbNewLine & _
                                      "            FROM inserted WHERE [{0}] IS NOT NULL" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.DataTypeSize, CInt(objTable.ID)))
                  aryAuditUpdates.Add(String.Format("        SELECT i.ID, convert(nvarchar({2}),d.[{0}]), convert(nvarchar({2}),i.[{0}]), {1}, {3}, i.[_description]" & vbNewLine & _
                                      "            FROM inserted i" & vbNewLine & _
                                      "            INNER JOIN deleted d ON i.[id] = d.[id] AND NOT d.[{0}] = i.[{0}] AND UPDATE([{0}])" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.DataTypeSize, CInt(objTable.ID)))
                  aryAuditDeletes.Add(String.Format("        SELECT ID, convert(nvarchar({2}),[{0}]), NULL, {1}, {3}, [_description]" & vbNewLine & _
                                      "            FROM deleted WHERE [{0}] IS NOT NULL" _
                                      , objColumn.Name, CInt(objColumn.ID), objColumn.DataTypeSize, CInt(objTable.ID)))
                End If
              End If
            End If
          Next


          ' Add any relationship columns
          For Each objRelation In objTable.Objects(Things.Type.Relation)
            If objRelation.RelationshipType = RelationshipType.Parent Then
              aryBaseTableColumns.Add(String.Format("[ID_{0}] = [inserted].[ID_{0}]", CInt(objRelation.ParentID)))
              aryAllWriteableColumns.Add(String.Format("[ID_{0}]", CInt(objRelation.ParentID)))

              aryParentsToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                  "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM inserted)" & vbNewLine _
                  , objRelation.PhysicalName, CInt(objRelation.ParentID)))

              aryParentsToUpdate_Delete.Add(String.Format("    UPDATE [dbo].[{1}] SET [updflag] = 1 WHERE [dbo].[{1}].[id] IN (SELECT DISTINCT [id_{2}] FROM deleted)" & vbNewLine & vbNewLine _
                , CInt(objTable.ID), objRelation.PhysicalName, CInt(objRelation.ParentID)))
            Else

              aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3})" & vbNewLine & _
                      "        UPDATE base SET [updflag] = 1 FROM dbo.[{1}] base WHERE [ID_{2}] IN (SELECT DISTINCT [id] FROM inserted);" & vbNewLine _
                      , CInt(objTable.ID), objRelation.PhysicalName, CInt(objRelation.ParentID), CInt(objRelation.ChildID)))

            End If
          Next

          ' Update any parents
          If aryParentsToUpdate.ToArray.Length > 0 Then
            sSQLParentColumns = String.Format("    -- Refresh any parents" & vbNewLine & String.Join(vbNewLine, aryParentsToUpdate.ToArray()))
            sSQLParentColumns_Delete = String.Format("    -- Refresh any parents" & vbNewLine & String.Join(vbNewLine, aryParentsToUpdate_Delete.ToArray()))
          Else
            sSQLParentColumns = "    -- No parents to refresh" & vbNewLine & vbNewLine
            sSQLParentColumns_Delete = "    -- No parents to refresh" & vbNewLine & vbNewLine
          End If


          ' Update child records
          If aryChildrenToUpdate.ToArray.Length > 0 Then
            sSQLChildColumns = String.Format("    -- Refresh children" & vbNewLine & String.Join(vbNewLine, aryChildrenToUpdate.ToArray()))
          Else
            sSQLChildColumns = "    -- No children to refresh" & vbNewLine & vbNewLine
          End If

          ' Update statement of all the non read only columns (free entry columns)
          If aryBaseTableColumns.ToArray.Length > 0 Then
            sSQLWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = [inserted].[updflag]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] WHERE [inserted].[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryBaseTableColumns.ToArray()))
          Else
            sSQLWriteableColumns = String.Empty
          End If


          ' Build Audit strings
          If aryAuditUpdates.ToArray.Length > 0 Then
            sSQLCode_AuditInsert = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditInserts.ToArray()))
            sSQLCode_AuditUpdate = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditUpdates.ToArray()))
            sSQLCode_AuditDelete = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditDeletes.ToArray()))
          End If


          ' Update statement of all the calculated columns
          If aryCalculatedColumns.ToArray.Length > 0 Then
            'sSQLCalculatedColumns = String.Format("    -- Update any calculated columns" & vbNewLine & _
            '  "    UPDATE base" & vbNewLine & _
            '  "        SET {1}" & vbNewLine & _
            '  "        FROM [dbo].[{0}] base" & vbNewLine & _
            '  "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted);" & vbNewLine & vbNewLine _
            '  , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))

            sSQLCalculatedColumns = String.Format("    -- Update any calculated columns" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "        FROM [dbo].[{0}]" & vbNewLine & _
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base" & vbNewLine & _
              "        SET {1}" _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))

          Else
            sSQLCalculatedColumns = "    -- No calculated columns" & vbNewLine & vbNewLine
          End If

          ' Any calculations that require to be saved after the audit
          If aryPostAuditCalcs.ToArray.Length > 0 Then
            sSQLPostAuditCalcs = String.Format("    -- Update columns that rely on audit log data" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "        FROM [dbo].[{0}]" & vbNewLine & _
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base" & vbNewLine & _
              "        SET {1}" _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryPostAuditCalcs.ToArray()))
          Else
            sSQLPostAuditCalcs = vbNullString
          End If


          ' -------------------
          ' INSTEAD OF INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    -- Commit valid data." & vbNewLine & _
              "    ---------------------------" & vbNewLine & vbNewLine & _
              "    --DECLARE @UpdateBypass TABLE ([id] integer PRIMARY KEY CLUSTERED);" & vbNewLine & _
              "    --INSERT @UpdateBypass SELECT DISTINCT [id] FROM @Failed WHERE [Severity] = 2;" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[{0}] ({4})" & vbNewLine & _
              "        SELECT {4} FROM inserted;" & vbNewLine _
              , objTable.Name, sTriggerName _
              , "" _
              , "" _
              , String.Join(",", aryAllWriteableColumns.ToArray()))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfInsert, sSQL)


          ' -------------------
          ' AFTER INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime;" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLWriteableColumns & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] (username, datetimestamp, recordid, oldvalue, newvalue, tableid, columnid, deleted, recorddesc)" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, id, oldvalue, newvalue, tableid, columnid, 0, recorddesc FROM @audit" & vbNewLine & vbNewLine & _
              sSQLCode_DiaryLinks & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditInsert)
          ScriptTrigger("dbo", objTable, TriggerType.AfterInsert, sSQL)


          ' -------------------
          ' INSTEAD OF UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @nvarCommand nvarchar(MAX)," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    -- Has the trigger been called from an update on another table?" & vbNewLine & _
              "    IF NOT UPDATE([updflag]) INSERT [dbo].[{5}] ([spid], [tablefromid]) VALUES (@@spid,{6});" & vbNewLine & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "        ---------------------------" & vbNewLine & _
              "        -- Commit writeable columns" & vbNewLine & _
              "        ---------------------------" & vbNewLine & vbNewLine & _
              "{3}" & vbNewLine & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "{4}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] (username, datetimestamp, recordid, oldvalue, newvalue, tableid, columnid, deleted, recorddesc)" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, id, oldvalue, newvalue, tableid, columnid, 0, recorddesc FROM @audit;" & vbNewLine & vbNewLine & _
              "{7}" & vbNewLine & vbNewLine & _
              "    -- Clear the temporary trigger status table" & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{5}] WHERE [spid] = @@spid AND [tablefromid] = {6};" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName _
              , String.Join(vbNewLine, aryValidationStatements.ToArray()) _
              , sSQLWriteableColumns _
              , sSQLCode_AuditUpdate _
              , Tables.sysTriggerTransaction, CInt(objTable.ID), sSQLPostAuditCalcs)
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfUpdate, sSQL)


          ' -------------------
          ' AFTER UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLCalculatedColumns & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[{4}] ([spid], [tablefromid]) VALUES (@@spid,{3});" & vbNewLine & vbNewLine & _
              sSQLParentColumns & vbNewLine & _
              sSQLChildColumns & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {3};" & vbNewLine & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    -- Validation" & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    IF NOT UPDATE([updflag])" & vbNewLine & _
              "    BEGIN" & vbNewLine & _
              "        SELECT @sValidation = dbo.[udfvalid_{0}](ID) FROM inserted WHERE LEN(dbo.[udfvalid_{0}](ID)) > 0" & vbNewLine & _
              "        IF LEN(@sValidation) > 0" & vbNewLine & _
              "        BEGIN" & vbNewLine & _
              "            RAISERROR(@sValidation, 16, 1);" & vbNewLine & _
              "            ROLLBACK;" & vbNewLine & _
              "        END" & vbNewLine & _
              "     END" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName _
              , "", CInt(objTable.ID), Tables.sysTriggerTransaction _
              , String.Join(vbNewLine, aryUpdateUniqueCodes.ToArray()))
          ScriptTrigger("dbo", objTable, TriggerType.AfterUpdate, sSQL)


          ' -------------------
          ' AFTER DELETE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime;" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    -- Has the trigger been called from an update on another table?" & vbNewLine & _
              "    IF NOT UPDATE([updflag]) INSERT [dbo].[{4}] ([spid], [tablefromid]) VALUES (@@spid,{5});" & vbNewLine & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "    ---------------------------" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [columnid], [deleted], [recorddesc])" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, [id], [oldvalue], [newvalue], [tableid], [columnid], 1, [recorddesc] FROM @audit" & vbNewLine & vbNewLine & _
              "{3}" & vbNewLine & vbNewLine & _
              "    -- Clear the temporary trigger status table" & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {5};" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditDelete, sSQLParentColumns_Delete _
              , Tables.sysTriggerTransaction, CInt(objTable.ID))
          ScriptTrigger("dbo", objTable, TriggerType.AfterDelete, sSQL)


        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Triggers, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      Finally

      End Try

      Return bOK

    End Function

    Private Function ScriptTrigger(ByVal [Role] As String, ByVal [Table] As Things.Table, ByVal [TriggerType] As TriggerType, ByRef [BodyCode] As String) As Boolean

      Dim sSQL As String = String.Empty
      Dim sTriggerType As String = String.Empty
      Dim sTriggerName As String = String.Empty

      Try

        Select Case [TriggerType]
          Case Enums.TriggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF INSERT"

          Case Enums.TriggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER INSERT"

          Case Enums.TriggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF UPDATE"

          Case Enums.TriggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER UPDATE"

          Case Enums.TriggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF DELETE"

          Case Enums.TriggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER DELETE"

        End Select

        ' Drop existing trigger
        sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE [type] = 'TR' AND [name] = '{0}')  DROP TRIGGER [{0}]", sTriggerName)
        CommitDB.ScriptStatement(sSQL)

        ' Create new trigger code
        sSQL = String.Format("CREATE TRIGGER [{1}].[{0}] ON [{1}].[{2}]" & vbNewLine & _
          "    {3}" & vbNewLine & "AS" & vbNewLine & _
          "BEGIN" & vbNewLine & _
          "    PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Start ([{2}].[{0}]';" & vbNewLine & _
          "    SET NOCOUNT ON;" & vbNewLine & _
          "    DECLARE @iCount integer;" & vbNewLine & vbNewLine & _
         "    -- Only top level call (in case database property activating recursion is enabled)" & vbNewLine & _
         "    --print TRIGGER_NESTLEVEL()" & vbNewLine & _
         "    --IF TRIGGER_NESTLEVEL() > 15 RETURN" & vbNewLine & vbNewLine & _
          "{4}" & vbNewLine & vbNewLine & _
          "    PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Exit ([{2}].[{0}]'; " & vbNewLine & _
          "END" _
          , sTriggerName, [Role], Table.PhysicalName, sTriggerType, [BodyCode])
        CommitDB.ScriptStatement(sSQL)

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        Return False

      End Try

      Return True

    End Function

    ' Generate the diary links part of the trigger
    Private Function SQLTrigger_Diary(ByRef objTable As Things.Table) As String

      'Dim objDiaryLink As Things.DiaryLink
      'Dim objRelation As Things.Relation
      'Dim aryDiaryStatements1 As New ArrayList
      'Dim aryDiaryStatements2 As New ArrayList
      'Dim aryDiaryStatements3 As New ArrayList
      'Dim aryRelations As New ArrayList
      'Dim iCount As Integer = 0

      'Dim sRecordDescriptionCode = ""
      Dim sTriggerCode As String = ""

      '' objTable.RecordDescription.Parameters

      '' BOTHC - DON;T WORK ON JOINED (i.e OpenPay view) tablkes
      'If 1 = 1 Or objTable.Objects(Things.Type.DiaryLink).Count = 0 Then
      '  sTriggerCode = "---------------------------" & vbNewLine & "-- No Diary Links" & vbNewLine & "---------------------------" & vbNewLine
      'Else

      '  objTable.RecordDescription.GenerateCode()
      '  sRecordDescriptionCode = objTable.RecordDescription.UDF.CallingCode
      '  '   "dbo.[udfrecdesc_Personnel_Records](base.Surname, base.Forenames)"

      '  ' eefective date could be something like this?
      '  '	, CASE WHEN [Start_Date] < GETDATE() THEN DATEADD(DD, 20, DATEADD(D, 0, DATEDIFF(D, 0, [Start_Date]))) ELSE NULL END AS [17]

      '  For Each objDiaryLink In objTable.Objects(Things.Type.DiaryLink)
      '    objDiaryLink.Generate()
      '    aryDiaryStatements1.Add(String.Format("{0}INSERT @links([id], [linkid], [description], [alarm], [columnid]) VALUES ({1}, {2}, '{3}', {4}, {5});" _
      '        , vbTab, CInt(iCount), CInt(objDiaryLink.ID), objDiaryLink.Comment, IIf(objDiaryLink.Reminder, 1, 0), CInt(objDiaryLink.Column.ID)))
      '    aryDiaryStatements2.Add(String.Format("{0} AS [{1}]", objDiaryLink.UDF.CallingCode, iCount))
      '    aryDiaryStatements3.Add(String.Format("[{0}]", iCount))
      '    iCount += 1
      '  Next


      '  ' Build any parent relations
      '  For Each objRelation In objTable.Objects(Things.Type.Relation)
      '    If objRelation.RelationshipType = RelationshipType.Parent Then
      '      aryRelations.Add(String.Format("INNER JOIN dbo.[{0}] ON dbo.[{0}].[ID] = dbo.[{1}].[ID_{2}]", objRelation.PhysicalName, objTable.Name, CInt(objTable.ID)))
      '    End If
      '  Next


      '  ' Put it all together
      '  sTriggerCode = "---------------------------" & vbNewLine & "-- Diary Links" & vbNewLine & "---------------------------" & vbNewLine & _
      '    vbTab & "DECLARE @links TABLE([id] integer, [linkid] nvarchar(2), [description] nvarchar(255), [alarm] bit, [columnid] integer);" & vbNewLine & _
      '    String.Join(vbNewLine, aryDiaryStatements1.ToArray()) & vbNewLine & vbNewLine &
      '    vbTab & "INSERT dbo.[ASRSysDiaryEvents] ([tableid], [columnid], [rowid], [eventdate], [eventtime], [alarm], [access], [copiedfromid], [eventnotes], [eventtitle], [username], [columnvalue], [linkid])" & vbNewLine & _
      '    vbTab & String.Format("SELECT {0}, d.columnid, tblpivot.ID, tblPivot.eventdate, NULL, d.alarm, 'RO', NULL, NULL" & vbNewLine & _
      '    "		, {1} + ': ' + d.[description]" & vbNewLine & _
      '    "		, SYSTEM_USER, NULL, d.[linkid]" & vbNewLine & _
      '    "    FROM (SELECT [ID]," & vbNewLine & _
      '    "      {2}" & vbNewLine & _
      '    "      FROM dbo.[{3}]) obj" & vbNewLine & _
      '    "    UNPIVOT (eventdate For property IN ({4})) AS tblPivot" & vbNewLine & _
      '    "      INNER JOIN @links d ON d.id = tblPivot.Property" & vbNewLine & _
      '    "      INNER JOIN dbo.[{3}] ON dbo.[{3}].ID = tblPivot.ID" & vbNewLine & _
      '    "      INNER JOIN inserted ON inserted.ID = dbo.[{3}].ID" & _
      '    "{5};" _
      '    , CInt(objTable.ID), sRecordDescriptionCode, String.Join(vbNewLine & vbTab & vbTab & ", ", aryDiaryStatements2.ToArray()) _
      '    , objTable.Name, String.Join(",", aryDiaryStatements3.ToArray()) _
      '    , String.Join(vbNewLine, aryRelations.ToArray()))

      '  ' Comment it all over - development mode!!! (take out later)
      '  sTriggerCode = vbNewLine & sTriggerCode & vbNewLine

      'End If

      ''SELECT 0 AS [tableID], d.columnid, tblpivot.ID AS [RowID]
      ''		, tblPivot.EventDate, NULL AS [EventTime], d.alarm, 'RO' AS [Access], NULL AS [CopiedFrom], NULL AS [EventNotes]
      ''		, dbo.[udfrecdesc_Personnel_Records](base.Surname, base.Forenames) + ': ' + d.[description]  AS [EventTitle]
      ''		, SYSTEM_USER AS [UserName], NULL AS [ColumnValue], tblPivot.Property AS [LinkID]
      ''	FROM (SELECT id,
      ''		[date_of_birth] AS [1],
      ''		[leaving_date] AS [2],
      ''		[Start_Date] AS [3],		
      ''		[Start_Date]+1 AS [4],
      ''		dbo.udf_function_randomdate() AS [5]
      ''		FROM Personnel_records) Person
      ''		UNPIVOT (EventDate For Property IN ([1],[2],[3],[4],[5])) AS tblPivot
      ''	INNER JOIN @diarylinks d ON d.linkid = tblPivot.Property
      ''	INNER JOIN Personnel_Records base ON base.ID = tblPivot.ID


      Return sTriggerCode


    End Function

#End Region

#Region "Calculation Scripting"


    Public Sub ScriptDiaryLinkFilters(ByRef ProgressInfo As HCMProgressBar)

      Dim objTable As Things.Table
      Dim objDiaryLink As Things.DiaryLink
      Dim sObjectName As String

      For Each objTable In Globals.Things
        For Each objDiaryLink In objTable.Objects(Things.Type.DiaryLink)
          If Not objDiaryLink.Filter Is Nothing Then
            objDiaryLink.Filter.GenerateCode()
            If objDiaryLink.Filter.IsComplex Then

              sObjectName = String.Format("udfdiarylinkfilter_{0}.{1}", objTable.Name, objDiaryLink.Name)
              ScriptDB.DropUDF("dbo", sObjectName)

            End If
          End If
        Next
      Next

    End Sub

    Public Sub ScriptColumnCalculations(ByRef ProgressInfo As HCMProgressBar)

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim sObjectName As String = String.Empty
      Dim sReturnType As String

      Dim sUDFWithOptions As String
      Dim sUDFSQL As String = String.Empty
      Dim sSafeDummyUDF As String
      Dim sCalcSQL As String
      Dim sParameters As String

      '      Dim aryDependantTables As Array

      Try

        ' Put this on later, after development and after some tweaking in the system manager
        'sUDFWithOptions = "WITH SCHEMABINDING"
        sUDFWithOptions = String.Empty

        ProgressInfo.TotalSteps2 = Globals.Things.Count
        For Each objTable In Globals.Things

          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.IsCalculated Then

              sObjectName = String.Format("udfcalc_{0}.{1}", objTable.Name, objColumn.Name)
              '    sReturnType = objColumn.DataTypeSyntax

              objColumn.Calculation.ExpressionType = ExpressionType.ColumnCalculation
              sParameters = String.Format("@pID as integer, @pOriginalValue {0}", sReturnType)

              '    sParameters = objColumn.Calculation.Parameters
              sCalcSQL = objColumn.Calculation.UDF.Code

              ' If we're dependant on any fields other than our base table wrap within the cache code
              'If objColumn.Calculation.DependsOnTables.Length > 0 Then

              '  sUDFSQL = String.Format("({0})" & vbNewLine & _
              '             "RETURNS {1}" & vbNewLine & _
              '             sUDFWithOptions & vbNewLine & _
              '             "AS" & vbNewLine & "BEGIN" & vbNewLine & _
              '             "    DECLARE @Result as {1} = @pOriginalValue;" & vbNewLine & vbNewLine & _
              '             "    IF EXISTS (SELECT [actiontype] FROM [dbo].[{4}] WHERE [tablefromid] IN ({2}) AND [spid] = @@SPID)" & vbNewLine & _
              '             "    BEGIN" & vbNewLine & vbNewLine & _
              '             "         -- Execute calculation code" & vbNewLine & _
              '             "{3}" & vbNewLine & vbNewLine & _
              '             "    END" & vbNewLine &
              '             "    RETURN ISNULL(@Result, 0);" & vbNewLine & _
              '             "END" _
              '            , sParameters, sReturnType, objColumn.Calculation.DependsOnTables _
              '            , sCalcSQL, Tables.sysTriggerTransaction)

              'Else

              sUDFSQL = String.Format("({0})" & vbNewLine & _
                         "RETURNS {1}" & vbNewLine & _
                         sUDFWithOptions & vbNewLine & _
                         "AS" & vbNewLine & "BEGIN" & vbNewLine & _
                         "    DECLARE @Result as {1} = @pOriginalValue;" & vbNewLine & vbNewLine & _
                         "    -- Execute calculation code" & vbNewLine & _
                         "{2}" & vbNewLine & vbNewLine & _
                         "    RETURN ISNULL(@Result, 0);" & vbNewLine & _
                         "END" _
                        , sParameters, objColumn.DataTypeSyntax, sCalcSQL)
              '  End If

              sSafeDummyUDF = String.Format("({0})" & vbNewLine & _
                           "RETURNS {1}" & vbNewLine & _
                           "AS" & vbNewLine & "BEGIN" & vbNewLine & _
                           "    DECLARE @Result as {1};" & vbNewLine & vbNewLine & _
                           "    -- Execute calculation code" & vbNewLine & _
                           "/*" & vbNewLine & "{2}" & vbNewLine & vbNewLine & _
                           "*/" & vbNewLine & "    RETURN ISNULL(@Result, 0);" & vbNewLine & "END" _
                          , sParameters, objColumn.DataTypeSyntax, sCalcSQL)

              ' Try and create the UDF, if not put dummy code in place and record the error. To be updated once project go-ahead has been given (in other words I don't
              ' won't to spend ages debugging the whole damn thing in case this never sees the light of day!!!!
              If Not ScriptDB.CreateUDF("dbo", sObjectName, sUDFSQL, sSafeDummyUDF) Then
                objColumn.Calculation.IsScriptSafe = False
              End If

            End If

          Next

          ProgressInfo.NextStep2()
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sObjectName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sUDFSQL)

      Finally
        ProgressInfo.NextStep1()

      End Try

    End Sub

    ' Generates and stores the code for all the calculations
    '    Public Sub GenerateSQLCodeForObjects(ByRef ProgressInfo As HCMProgressBar)
    Public Sub OLD_CreateObjects()

      Dim objTable As Things.Table
      ' Dim objExpression As Things.Expression
      Dim objColumn As Things.Column
      Dim sObjectName As String = String.Empty
      'Dim sReturnType As String

      Dim sUDFWithOptions As String
      'Dim sUDFSQL As String
      'Dim sSafeDummyUDF As String
      'Dim sCalcSQL As String

      'Dim aryDependantTables As Array

      Try

        ' Put this on later, after development and after some tweaking in the system manager
        'sUDFWithOptions = "WITH SCHEMABINDING"
        sUDFWithOptions = String.Empty

        '  ProgressInfo.TotalSteps2 = Globals.Things.Count
        For Each objTable In Globals.Things

          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.IsCalculated Then

              sObjectName = String.Format("udfcalc_{0}.{1}", objTable.Name, objColumn.Name)

              ScriptDB.DropUDF("dbo", sObjectName)

              objColumn.Calculation = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)

              If Not objColumn.Calculation Is Nothing Then
                objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                objColumn.Calculation.AssociatedColumn = objColumn

                objColumn.Calculation.GenerateCode()

                ' Validate the expression
                'sTestSQLCode = objColumn.Calculation.Code
                'If Not CommitDB.ScriptStatement(sTestSQLCode) Then
                '  objColumn.Calculation.IsValid = False
                'End If


                '                objColumn.DirectInView = objColumn.Calculation.IsSimpleCalc      ' This is calculated in the .code function - reorder some of the functions to make better code-reading.

                '  aryDependantTables = objColumn.Calculation.DependsOnTables()

                '  sReturnType = GetSQLColumnSyntax(objColumn)


                '  ' If we're dependant on any fields other than our base table wrap within the cache code
                '  If aryDependantTables.Length > 0 Then

                '    sUDFSQL = String.Format("(@pID as integer, @pOriginalValue {0})" & vbNewLine & _
                '               "RETURNS {0}" & vbNewLine & _
                '               sUDFWithOptions & vbNewLine & _
                '               "AS" & vbNewLine & "BEGIN" & vbNewLine & _
                '               "    DECLARE @Result as {0} = @pOriginalValue;" & vbNewLine & vbNewLine & _
                '               "    IF EXISTS (SELECT [actiontype] FROM [dbo].[{3}] WHERE [tablefromid] IN ({1}) AND [spid] = @@SPID)" & vbNewLine & _
                '               "    BEGIN" & vbNewLine & vbNewLine & _
                '               "         -- Execute calculation code" & vbNewLine & _
                '               "{2}" & vbNewLine & vbNewLine & _
                '               "    END" & vbNewLine & "--    ELSE" & vbNewLine & "--    BEGIN" & vbNewLine & vbNewLine & _
                '               "    --    -- No need to update - read from table" & vbNewLine & _
                '               "    --    SET @Result = @pOriginalValue" & vbNewLine & vbNewLine & _
                '               "    --END" & vbNewLine & _
                '               "    RETURN ISNULL(@Result, 0);" & vbNewLine & _
                '               "END" _
                '              , sReturnType, String.Join(",", aryDependantTables), sCalcSQL, Tables.sysTriggerTransaction)

                '  Else

                '    sUDFSQL = String.Format("(@pID as integer, @pOriginalValue {0})" & vbNewLine & _
                '               "RETURNS {0}" & vbNewLine & _
                '               sUDFWithOptions & vbNewLine & _
                '               "AS" & vbNewLine & "BEGIN" & vbNewLine & _
                '               "    DECLARE @Result as {0};" & vbNewLine & vbNewLine & _
                '               "    -- Execute calculation code" & vbNewLine & _
                '               "{1}" & vbNewLine & vbNewLine & _
                '               "    RETURN ISNULL(@Result, 0);" & vbNewLine & _
                '               "END" _
                '              , sReturnType, sCalcSQL)
                '  End If

                '  sSafeDummyUDF = String.Format("(@pID as integer, @pOriginalValue {0})" & vbNewLine & _
                '               "RETURNS {0}" & vbNewLine & _
                '               "AS" & vbNewLine & "BEGIN" & vbNewLine & _
                '               "    DECLARE @Result as {0};" & vbNewLine & vbNewLine & _
                '               "    -- Execute calculation code" & vbNewLine & _
                '               "/*" & vbNewLine & _
                '               "{1}" & vbNewLine & vbNewLine & _
                '               "*/" & vbNewLine & _
                '               "    RETURN ISNULL(@Result, 0);" & vbNewLine & _
                '               "END" _
                '              , sReturnType, sCalcSQL)

                'ScriptUDF("dbo", sObjectName, sUDFSQL, sSafeDummyUDF)
              End If

            End If

          Next

          '      ProgressInfo.NextStep2()
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.LoadingData, sObjectName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)

      Finally
        '     ProgressInfo.NextStep1()

      End Try


    End Sub

    Public Function CreateFunctions() As Boolean Implements iCommitDB.ScriptFunctions

      Dim bOK As Boolean = True

      Try

        bOK = ScriptFunctions.ConvertCurrency
        bOK = bOK And ScriptFunctions.UniqueCodeView

      Catch ex As Exception
        bOK = False

      End Try

      Return bOK

    End Function


    Public Function CreateObjects() As Boolean Implements iCommitDB.ScriptObjects

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objExpression As Things.Expression

      Dim bOK As Boolean = True
      Dim sObjectName As String = String.Empty
      Dim sUDFWithOptions As String = String.Empty

      Try

        ' Put this on later, after development and after some tweaking in the system manager
        'sUDFWithOptions = "WITH SCHEMABINDING"
        'sUDFWithOptions = String.Empty

        '  ProgressInfo.TotalSteps2 = Globals.Things.Count
        For Each objTable In Globals.Things

          ' Views
          'For Each objView In objTable.Views
          '  If Not objView.Filter Is Nothing Then
          '    objView.Filter.ExpressionType = ExpressionType.ViewCode
          '    '              objView.Filter.BaseTable
          '    objView.Filter.GenerateCode()
          '  End If
          'Next

          ' Record Descriptions
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            sObjectName = String.Format("{0}{1}", Consts.RecordDescriptionUDF, objTable.Name)
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.CodeStub)
            End If
          End If

          '  Validation Masks
          For Each objExpression In objTable.Objects(Things.Type.Mask)
            objExpression.GenerateCode()
            sObjectName = String.Format("{0}{1}", Consts.MaskUDF, CInt(objExpression.ID))
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objExpression.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objExpression.UDF.CodeStub)
            End If

            Debug.Print(objExpression.Name)

          Next


          ' Calculations
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated Then

              objColumn.Calculation = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)
              If Not objColumn.Calculation.State = System.Data.DataRowState.Unchanged Or Globals.Options.RefreshObjects Then

                sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)

                '   Debug.Assert(sObjectName <> "udfcalc_Table1.ChildFieldLastChangeDate")

                ScriptDB.DropUDF("dbo", sObjectName)

                If Not objColumn.Calculation Is Nothing Then
                  objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                  objColumn.Calculation.AssociatedColumn = objColumn
                  objColumn.Calculation.GenerateCode()

                  ' Script the expression (generate a code stub if error)
                  If Not Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.Code) Then
                    Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.CodeStub)
                  End If

                End If

              End If
            End If
          Next

          '      ProgressInfo.NextStep2()
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sObjectName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      Finally
        '     ProgressInfo.NextStep1()

      End Try

      Return bOK

    End Function

    Public Sub ScriptRecordDescriptions(ByRef ProgressInfo As HCMProgressBar)

      Dim objTable As Things.Table
      'Dim sObjectName As String = ""
      'Dim sSQLRecordDescription As String

      'Try

      '  ProgressInfo.TotalSteps2 = Globals.Things.Count
      '  For Each objTable In Globals.Things
      '    If Not objTable.RecordDescription Is Nothing Then
      '      objTable.RecordDescription.GenerateCode()


      '      sObjectName = String.Format("udfrecdesc_{0}", objTable.Name)
      '      sSQLRecordDescription = String.Format("({0})" & vbNewLine & _
      '       "RETURNS nvarchar(MAX)" & vbNewLine & _
      '       "AS" & vbNewLine & "BEGIN" & vbNewLine & _
      '       "    DECLARE @Result as nvarchar(MAX);" & vbNewLine & vbNewLine & _
      '       "    -- Execute calculation code" & vbNewLine & _
      '       "{1}" & vbNewLine & vbNewLine & _
      '       "    RETURN ISNULL(@Result, '');" & vbNewLine & _
      '       "END" _
      '      , objTable.RecordDescription.Parameters, objTable.RecordDescription.UDF.Code)

      '      ScriptUDF("dbo", sObjectName, sSQLRecordDescription, "")
      '    End If

      '  Next

      'Catch ex As Exception
      '  Globals.ErrorLog.Add(Phoenix.ErrorHandler.Section.UDFs, "", Phoenix.ErrorHandler.Severity.Error, ex.Message, "")

      'Finally
      '  ProgressInfo.NextStep1()

      'End Try



    End Sub

#End Region

#Region "Security Scripting"

    Public Function ApplySecurity() As Boolean Implements iCommitDB.ApplySecurity
      Return True
    End Function

#End Region

  End Class

End Namespace

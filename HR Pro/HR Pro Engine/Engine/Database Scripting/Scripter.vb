Option Explicit On

Imports System.Runtime.InteropServices
Imports System.Text

Namespace ScriptDB

  <ClassInterface(ClassInterfaceType.None)> _
  Public Class Script
    Implements Interfaces.iCommitDB

#Region "Table Scripting"

    Private Sub DropView(ByRef [Role] As String, ByRef [ViewName] As String)

      Dim sSQL As String

      Try

        sSQL = String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & _
           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & _
           "WHERE o.[name] = '{1}' AND [type] = 'V' AND u.[name] = '{0}')" & vbNewLine & _
          " DROP VIEW [{0}].[{1}]", [Role], ViewName)

        ' Commit
        CommitDB.ScriptStatement(sSQL)

      Catch ex As Exception
        MsgBox(ex.Message, MsgBoxStyle.Critical)
        Stop

      End Try

    End Sub

    Public Function DropViews() As Boolean Implements iCommitDB.DropViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things

          For Each objView In objTable.Objects(Things.Type.View)
            DropView(objTable.SchemaName, objView.Name)
          Next
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, "DropViews", HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function DropTableViews() As Boolean Implements iCommitDB.DropTableViews

      Dim objTable As Things.Table
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things
          DropView("dbo", objTable.Name)
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, objTable.Name, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)

      End Try

      Return bOK

    End Function

    Public Function CreateTables() As Boolean Implements iCommitDB.ScriptTables

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim sSQL As String

      Try

        For Each objTable In Globals.Things

          Select Case objTable.State

            Case DataRowState.Deleted
              sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "DROP TABLE [dbo].[{0}];", objTable.NameInDB)
              Globals.CommitDB.ScriptStatement(sSQL)

            Case DataRowState.Modified
              'If Not objTable.PhysicalName = objTable.NameInDB Then
              '  sSQL = String.Format("sp_rename @objname = [{0}], @newname = [{1}]" _
              '        , objTable.NameInDB, objTable.PhysicalName)
              '  Globals.CommitDB.ScriptStatement(sSQL)
              '  'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)
              'End If

            Case Else ' DataRowState.Added
              sSQL = String.Format("IF NOT EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "CREATE TABLE [dbo].[{0}] (" & _
                " [id] integer PRIMARY KEY CLUSTERED IDENTITY(1,1)" & _
                " , [guid] uniqueidentifier DEFAULT (newsequentialid())" & vbNewLine & _
                " , [updflag] integer" & vbNewLine & _
                " , [deleteddate] datetime" & vbNewLine & _
                " , [recorddescription] nvarchar(255)" & vbNewLine & _
                " , [timestamp] rowversion" & vbNewLine & _
                " , [lastsavedby] varbinary(85)" & vbNewLine & _
                " , [lastsavedatetime] datetime);" _
                , objTable.PhysicalName)
              Globals.CommitDB.ScriptStatement(sSQL)
              'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)

          End Select


          ' Add any relations
          For Each objRelation In objTable.Objects(Things.Type.Relation)

            If objRelation.RelationshipType = ScriptDB.RelationshipType.Parent Then
              sSQL = String.Format("IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='ID_{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ADD [ID_{1}] integer NOT NULL", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

              sSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID_{1}')" & vbNewLine & _
                  "CREATE NONCLUSTERED INDEX [IDX_ID_{1}] ON [dbo].[{0}] ([ID_{1}] ASC)", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next



          ' Now add the columns
          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.State = DataRowState.Deleted Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] DROP COLUMN [{1}]", objTable.PhysicalName, objColumn.Name)
              Globals.CommitDB.ScriptStatement(sSQL)

            ElseIf System.Data.DataRowState.Modified Or Globals.Options.RefreshObjects Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ALTER COLUMN [{1}] {2} ELSE ALTER TABLE [dbo].[{0}] ADD [{1}] {2}", objTable.PhysicalName, objColumn.Name, objColumn.DataTypeSyntax)
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.TableAndColumns, "Views", HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateTableViews() As Boolean Implements iCommitDB.ScriptTableViews

      'Dim bOK As Boolean = True
      'Dim sDefinitionSQL As String = String.Empty
      'Dim sViewName As String = String.Empty
      'Dim sActualTableName As String = String.Empty
      'Dim sOptions As String = String.Empty

      'Dim objTable As Things.Table
      'Dim objColumn As Things.Column
      'Dim objRelation As Things.Relation
      'Dim objExpression As Things.Expression

      'Try

      '  '     sSchemaName = "dbo"
      '  sOptions = vbNewLine & "WITH SCHEMABINDING" & vbNewLine

      '  '        ProgressInfo.TotalSteps2 = Globals.Things.Count
      '  For Each objTable In Globals.Things

      '    sViewName = objTable.Name
      '    sActualTableName = String.Format("{0}{1}", Consts.UserTable, objTable.Name)

      '    sDefinitionSQL = "AS SELECT [id], [guid], [timestamp], [updflag]" & vbNewLine

      '    ' Add relations
      '    For Each objRelation In objTable.Objects(Things.Type.Relation)
      '      If objRelation.RelationshipType = RelationshipType.Parent Then
      '        sDefinitionSQL = sDefinitionSQL & String.Format(", [ID_{0}]", CInt(objRelation.ParentID)) & vbNewLine
      '      End If
      '    Next


      '    ' Is it a physical HR Pro table or a connection to a remote table/database
      '    If objTable.IsRemoteView Then

      '      ' Create dummy place holder for view
      '      For Each objColumn In objTable.Objects(Things.Type.Column)
      '        sDefinitionSQL = sDefinitionSQL & String.Format("{0} AS [{1}]", objColumn.BlankDefintion, objColumn.Name) & vbNewLine
      '      Next

      '    Else

      '      'aryJoinCode = New ArrayList

      '      ' Add columns
      '      For Each objColumn In objTable.Objects(Things.Type.Column)

      '        If Not objColumn.State = System.Data.DataRowState.Deleted Then

      '          If objColumn.IsCalculated And 1 = 2 Then  'tempry 1=2 because I want to test just having it in the trigger
      '            objExpression = New Things.Expression
      '            objExpression = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)
      '            If Not objExpression Is Nothing Then
      '              '    objExpression.ExpressionType = ScriptDB.ExpressionType.ViewCode
      '              objExpression.AssociatedColumn = objColumn
      '              '    sColumnCalculation = objExpression.Code
      '              '    If objExpression.IsSimpleCalc Then  'And objExpression.IsValid Then
      '              '      sSQL = sSQL & String.Format(", {0} AS [{1}]", sColumnCalculation, objColumn.Name) & vbNewLine
      '              '    Else
      '              '      sSQL = sSQL & String.Format(", [{0}]", objColumn.Name) & vbNewLine
      '              '    End If

      '              '    '    aryJoinCode.

      '              '    '    aryJoinCode.Add(objExpression.Joins)
      '              sDefinitionSQL = sDefinitionSQL & String.Format(", {0} AS [{1}]", objExpression.UDF.CallingCode, objColumn.Name) & vbNewLine


      '            End If
      '            'If objColumn.DataType = ColumnTypes.Binary Then

      '          Else
      '            sDefinitionSQL = sDefinitionSQL & String.Format(", base.[{0}]", objColumn.Name) & vbNewLine
      '            'End If
      '            'Else

      '          End If
      '        End If
      '      Next

      '      ' Add the base table
      '      sDefinitionSQL = sDefinitionSQL & vbNewLine & String.Format("FROM [dbo].[{0}] base", sActualTableName)
      '    End If


      '    DropView(objTable.SchemaName, sViewName)

      '    sDefinitionSQL = String.Format("CREATE VIEW [{0}].[{1}] {2} {3}", objTable.SchemaName, sViewName, sOptions, sDefinitionSQL)
      '    CommitDB.ScriptStatement(sDefinitionSQL)

      '    sDefinitionSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID')" & vbNewLine & _
      '        "CREATE UNIQUE CLUSTERED INDEX [IDX_ID] ON [dbo].[{0}] ([ID] ASC)", objTable.Name)
      '    CommitDB.ScriptStatement(sDefinitionSQL)


      '  Next

      'Catch ex As Exception
      '  Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, sViewName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sDefinitionSQL)
      '  bOK = False

      'End Try

      'Return bOK

    End Function

    Public Function CreateViews() As Boolean Implements iCommitDB.ScriptViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim objColumn As Things.Column

      Dim sDefinition As New StringBuilder
      Dim bOK As Boolean = True

      Try

        For Each objTable In Globals.Things
          For Each objView In objTable.Objects(Things.Type.View)

            sDefinition = New StringBuilder
            sDefinition.AppendLine(String.Format("CREATE VIEW [{0}].[{1}]", objTable.SchemaName, objView.Name))
            sDefinition.AppendLine("WITH SCHEMABINDING")
            sDefinition.AppendLine("AS SELECT [id], [timestamp]")

            For Each objColumn In objView.Objects(Things.Type.Column)
              sDefinition.AppendLine(String.Format(", base.[{0}] AS [{0}]", objColumn.Name))
            Next

            sDefinition.AppendLine(String.Format("FROM [{0}].[{1}] base", objTable.SchemaName, objTable.Name))

            ' Add the filter
            'If Not objView.Filter Is Nothing Then
            '  sDefinition.AppendLine("WHERE " & objView.Filter.UDF.SelectCode)
            'End If

            ' Generate this view
            DropView(objTable.SchemaName, objView.Name)
            CommitDB.ScriptStatement(sDefinition.ToString)

            '' Add an index
            'sDefinitionSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID')" & vbNewLine & _
            '    "CREATE UNIQUE CLUSTERED INDEX [IDX_ID] ON [dbo].[{0}] ([ID] ASC)", objTable.Name)
            'CommitDB.ScriptStatement(sDefinitionSQL)

          Next
        Next



      Catch ex As Exception
        Globals.ErrorLog.Add(ErrorHandler.Section.Views, "Views", ErrorHandler.Severity.Error, ex.Message, sDefinition.ToString)
        bOK = False
      End Try

      Return bOK

    End Function

#End Region

#Region "Trigger Scripting"

    Public Function CreateTriggers() As Boolean Implements iCommitDB.ScriptTriggers

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objRelatedTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim sSQL As String = String.Empty
      Dim sValidation As String = String.Empty
      Dim sTriggerName As String = String.Empty
      Dim sColumnName As String = String.Empty

      Dim sSQLCode_AuditInsert As String = String.Empty
      Dim sSQLCode_AuditUpdate As String = String.Empty
      Dim sSQLCode_AuditDelete As String = String.Empty

      'Dim sSQLCode_RecordDescription As New StringBuilder
      'Dim sSQLCode_DiaryLinks As String = String.Empty

      Dim sSQLWriteableColumns As String
      Dim sSQLCalculatedColumns As String
      Dim sSQLPostAuditCalcs As String
      Dim sSQLParentColumns As String
      Dim sSQLParentColumns_Delete As String
      Dim sSQLChildColumns As String

      Dim aryCalculatedColumns As ArrayList
      Dim aryPerformanceTuneColumns As ArrayList
      Dim aryPostAuditCalcs As ArrayList
      Dim aryDebugColumns As ArrayList
      Dim aryBaseTableColumns As ArrayList
      Dim aryParentsToUpdate As ArrayList
      Dim aryChildrenToUpdate As ArrayList
      Dim aryParentsToUpdate_Delete As ArrayList
      Dim aryAfterInsertColumns As ArrayList
      Dim aryAllWriteableColumns As ArrayList

      Dim aryColumns As New ArrayList

      'Dim colRelatedTables As New Things.Collection

      Dim aryAuditUpdates As ArrayList
      Dim aryAuditInserts As ArrayList
      Dim aryAuditDeletes As ArrayList

      Dim sDebugCode As String
      Dim aryUpdateUniqueCodes As ArrayList

      Try

        For Each objTable In Globals.Things

          aryPerformanceTuneColumns = New ArrayList
          aryAllWriteableColumns = New ArrayList
          aryAuditUpdates = New ArrayList
          aryAuditInserts = New ArrayList
          aryAuditDeletes = New ArrayList
          'aryValidationStatements = New ArrayList
          aryAfterInsertColumns = New ArrayList
          aryUpdateUniqueCodes = New ArrayList
          aryParentsToUpdate = New ArrayList
          aryChildrenToUpdate = New ArrayList
          aryParentsToUpdate_Delete = New ArrayList
          aryBaseTableColumns = New ArrayList
          aryCalculatedColumns = New ArrayList
          aryPostAuditCalcs = New ArrayList
          aryDebugColumns = New ArrayList




          sDebugCode = String.Empty

          sSQLCode_AuditInsert = String.Empty
          sSQLCode_AuditUpdate = String.Empty
          sSQLCode_AuditDelete = String.Empty

          ' Add the system generated columns
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            aryCalculatedColumns.Add(String.Format("[_description] = {0}", objTable.RecordDescription.UDF.CallingCode))
          End If

          ' Add any relationship columns
          For Each objRelation In objTable.Objects(Things.Type.Relation)

            aryColumns = New ArrayList
            If objRelation.RelationshipType = RelationshipType.Parent Then
              aryBaseTableColumns.Add(String.Format("[ID_{0}] = [inserted].[ID_{0}]", CInt(objRelation.ParentID)))
              aryAllWriteableColumns.Add(String.Format("[ID_{0}]", CInt(objRelation.ParentID)))

              aryParentsToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                  "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM inserted)" & vbNewLine _
                  , objRelation.PhysicalName, CInt(objRelation.ParentID)))

              aryParentsToUpdate_Delete.Add(String.Format("    UPDATE [dbo].[{1}] SET [updflag] = 1 WHERE [dbo].[{1}].[id] IN (SELECT DISTINCT [id_{2}] FROM deleted)" & vbNewLine & vbNewLine _
                , CInt(objTable.ID), objRelation.PhysicalName, CInt(objRelation.ParentID)))

            Else

              objRelatedTable = Globals.Things.GetObject(Things.Type.Table, objRelation.ChildID)
              For Each objColumn In objRelatedTable.DependsOnColumns
                If objColumn.Table Is objTable Then
                  aryColumns.Add(String.Format("NOT i.{0} = d.{0}", objColumn.Name))
                End If
              Next

              If aryColumns.Count > 0 Then
                aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3})" & vbNewLine & _
                      "        UPDATE dbo.[{0}] SET [updflag] = 1 WHERE ID_{1} IN (SELECT i.ID FROM inserted i" & vbNewLine & _
                      "        INNER JOIN dbo.[{2}] d ON d.ID = i.ID " & vbNewLine & _
                      "        WHERE {4});" _
                      , objRelatedTable.PhysicalName, CInt(objTable.ID), objTable.PhysicalName, CInt(objRelatedTable.ID) _
                      , String.Join(" OR ", aryColumns.ToArray())))
              End If
            End If
          Next


          For Each objColumn In objTable.Columns

            If Not objColumn.State = System.Data.DataRowState.Deleted Then

              If objColumn.IsCalculated Then
                objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.GenerateCode()

                If objColumn.CalculateIfEmpty Then
                  sColumnName = String.Format("[{0}] = ISNULL([{0}], {1})", objColumn.Name, objColumn.Calculation.UDF.CallingCode)
                Else
                  sColumnName = String.Format("[{0}] = {1}", objColumn.Name, objColumn.Calculation.UDF.CallingCode)
                End If

                If objColumn.Calculation.CalculatePostAudit Then
                  aryPostAuditCalcs.Add(sColumnName & vbNewLine)
                Else
                  aryCalculatedColumns.Add(sColumnName & vbNewLine)
                End If

                aryPerformanceTuneColumns.Add(String.Format("SELECT {0} FROM {1} base --WHERE id" _
                             , objColumn.Calculation.UDF.CallingCode, objTable.Name))

              End If

              If Not objColumn.IsReadOnly Then
                Select Case objColumn.DataType

                  Case ScriptDB.ColumnTypes.Binary
                    aryBaseTableColumns.Add(String.Format("[{0}] = [inserted].[{0}]", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                  Case ScriptDB.ColumnTypes.Date
                    aryBaseTableColumns.Add(String.Format("[{0}] = DATEADD(dd, 0, DATEDIFF(dd, 0, [inserted].[{0}]))", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                  Case Else
                    aryBaseTableColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.ApplyFormatting("inserted")))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))

                End Select

              End If

              ' Concatenate audited columns
              If objColumn.Audit Then

                aryAuditInserts.Add(String.Format("        SELECT base.ID, NULL, convert(nvarchar(255),base.[{0}]), {1}, {3}, base.[_description]" & vbNewLine & _
                    "            FROM inserted i" & vbNewLine & _
                    "            INNER JOIN dbo.[{2}] base ON i.[id] = base.[id]" _
                    , objColumn.Name, CInt(objColumn.ID), objColumn.Table.PhysicalName, CInt(objTable.ID)))

                aryAuditUpdates.Add(String.Format("        SELECT d.ID, convert(nvarchar(255),d.[{0}]), convert(nvarchar(255), base.[{0}]), {1}, {3}, base.[_description]" & vbNewLine & _
                    "            FROM deleted d" & vbNewLine & _
                    "            INNER JOIN dbo.[{2}] base ON d.[id] = base.[id] AND NOT d.[{0}] = base.[{0}]" _
                    , objColumn.Name, CInt(objColumn.ID), objColumn.Table.PhysicalName, CInt(objTable.ID)))

                aryAuditDeletes.Add(String.Format("        SELECT ID, convert(nvarchar(255),[{0}]), NULL, {1}, {2}, [_description]" & vbNewLine & _
                    "            FROM deleted WHERE [{0}] IS NOT NULL", objColumn.Name, CInt(objColumn.ID), CInt(objTable.ID)))

              End If
            End If

            'For Each objChildTable In objColumn.ReferencedBy

            '  '   colRelatedTables(objChildTable).id = 1


            '  If colRelatedTables.Contains(objChildTable) Then
            '    colRelatedTables.Table(objChildTable.ID).UpdateStatements.Add(String.Format("--NOT i.[{0}] = d.[{0}]", objColumn.Name, objChildTable.PhysicalName))
            '  End If
            'Next

            ' Add any relationship columns
            '   For Each objRelation In objTable.Objects(Things.Type.Relation)




            '           UPDATE base SET [updflag] = 1 FROM dbo.[tbuser_chiltable1] base WHERE [ID_1] 
            'IN (SELECT i.[id] FROM inserted i
            'INNER JOIN dbo.tbuser_table1 d ON d.id = i.id
            'WHERE NOT i.[address_combined] = d.[address_combined] OR NOT i.[address_combined] = d.[address_combined]);


            '
          Next


          '     For Each objColumn In objTable.DependantChildTableColumns

          'aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3})" & vbNewLine & _
          '        "        UPDATE base SET [updflag] = 1 FROM dbo.[{1}] base WHERE [ID_{2}] IN (SELECT DISTINCT [id] FROM inserted);" & vbNewLine _
          '        , CInt(objTable.ID), objRelation.PhysicalName, CInt(objRelation.ParentID), CInt(objRelation.ChildID)))


          'Next



          ' Update any parents
          If aryParentsToUpdate.ToArray.Length > 0 Then
            sSQLParentColumns = String.Format("    -- Refresh any parents" & vbNewLine & String.Join(vbNewLine, aryParentsToUpdate.ToArray()))
            sSQLParentColumns_Delete = String.Format("    -- Refresh any parents" & vbNewLine & String.Join(vbNewLine, aryParentsToUpdate_Delete.ToArray()))
          Else
            sSQLParentColumns = "    -- No parents to refresh" & vbNewLine & vbNewLine
            sSQLParentColumns_Delete = "    -- No parents to refresh" & vbNewLine & vbNewLine
          End If


          ' Update child records
          If aryChildrenToUpdate.ToArray.Length > 0 Then
            sSQLChildColumns = String.Format("    -- Update children" & vbNewLine & String.Join(vbNewLine & vbNewLine, aryChildrenToUpdate.ToArray()))
          Else
            sSQLChildColumns = "    -- No children to refresh" & vbNewLine & vbNewLine
          End If

          ' Update statement of all the non read only columns (free entry columns)
          If aryBaseTableColumns.ToArray.Length > 0 Then
            sSQLWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = [inserted].[updflag]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] WHERE [inserted].[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryBaseTableColumns.ToArray()))
          Else
            sSQLWriteableColumns = String.Empty
          End If


          ' Build Audit strings
          If aryAuditUpdates.ToArray.Length > 0 Then
            sSQLCode_AuditInsert = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditInserts.ToArray()))
            sSQLCode_AuditUpdate = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditUpdates.ToArray()))
            sSQLCode_AuditDelete = String.Format("    INSERT @audit (id, oldvalue, newvalue, columnid, tableid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditDeletes.ToArray()))
          End If


          ' Update statement of all the calculated columns
          If aryCalculatedColumns.ToArray.Length > 0 Then

            sSQLCalculatedColumns = String.Format("    -- Update calculated columns" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "        FROM [dbo].[{0}]" & vbNewLine & _
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base SET " & vbNewLine & _
              "        {1}" _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))

            sDebugCode = String.Format("{0}", String.Join(vbNewLine, aryPerformanceTuneColumns.ToArray()))


          Else
            sSQLCalculatedColumns = "    -- No calculated columns" & vbNewLine & vbNewLine
          End If

          ' Any calculations that require to be saved after the audit
          If aryPostAuditCalcs.ToArray.Length > 0 Then
            sSQLPostAuditCalcs = String.Format("    -- Update columns that rely on audit log data" & vbNewLine & _
              "    IF EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {2} AND [nestlevel] = 1)" & vbNewLine & _
              "    BEGIN" & vbNewLine & _
              "        WITH base AS (" & vbNewLine & _
              "            SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "            FROM [dbo].[{0}]" & vbNewLine & _
              "            WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "        UPDATE base" & vbNewLine & _
              "        SET {1}" & vbNewLine & _
              "    END" _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryPostAuditCalcs.ToArray()), CInt(objTable.ID))
          Else
            sSQLPostAuditCalcs = vbNullString
          End If

          ' -------------------
          ' INSTEAD OF INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[tbsys_intransactiontrigger] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {2}, 1, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              "    -- Commit writeable columns" & vbNewLine & _
              "    INSERT [dbo].[{0}] ({3})" & vbNewLine & _
              "        SELECT {3} FROM inserted;" & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {2};" & vbNewLine _
              , objTable.Name, sTriggerName _
              , CInt(objTable.ID) _
              , String.Join(",", aryAllWriteableColumns.ToArray()))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfInsert, sSQL)


          ' -------------------
          ' AFTER INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime;" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLWriteableColumns & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] (username, datetimestamp, recordid, oldvalue, newvalue, tableid, columnid, deleted, recorddesc)" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, id, oldvalue, newvalue, tableid, columnid, 0, recorddesc FROM @audit" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditInsert)
          ScriptTrigger("dbo", objTable, TriggerType.AfterInsert, sSQL)

          ' -------------------
          ' INSTEAD OF UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[{4}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {5}, 2, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              "{3}" & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {2};" & vbNewLine _
              , objTable.Name, sTriggerName _
              , CInt(objTable.ID) _
              , sSQLWriteableColumns _
              , Tables.sysTriggerTransaction, CInt(objTable.ID))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfUpdate, sSQL)

          ' -------------------
          ' AFTER UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLCalculatedColumns & vbNewLine & vbNewLine & _
              "    --INSERT [dbo].[{4}] ([spid], [tablefromid]) VALUES (@@spid,{3});" & vbNewLine & vbNewLine & _
              sSQLParentColumns & vbNewLine & _
              sSQLChildColumns & vbNewLine & vbNewLine & _
              "    -- Validation" & vbNewLine & _
              "    IF EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3} AND [nestlevel] = 1)" & vbNewLine & _
              "    BEGIN" & vbNewLine & _
              "        SET @sValidation = '';" & vbNewLine & _
              "        SELECT @sValidation = @sValidation + dbo.[udfvalid_{0}](ID, [_description]) FROM inserted" & vbNewLine & _
              "        IF LEN(@sValidation) > 0" & vbNewLine & _
              "        BEGIN" & vbNewLine & _
              "            RAISERROR(@sValidation, 16, 1);" & vbNewLine & _
              "            ROLLBACK;" & vbNewLine & _
              "        END" & vbNewLine & _
              "    END" & vbNewLine & vbNewLine & _
              "{6}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] (username, datetimestamp, recordid, oldvalue, newvalue, tableid, columnid, deleted, recorddesc)" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, id, oldvalue, newvalue, tableid, columnid, 0, recorddesc FROM @audit;" & vbNewLine & vbNewLine & _
              "{7}" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName _
              , "", CInt(objTable.ID), Tables.sysTriggerTransaction _
              , String.Join(vbNewLine, aryUpdateUniqueCodes.ToArray()) _
              , sSQLCode_AuditUpdate, sSQLPostAuditCalcs) & "/* " & sDebugCode & "*/" & vbNewLine & vbNewLine
          ScriptTrigger("dbo", objTable, TriggerType.AfterUpdate, sSQL)


          ' -------------------
          ' AFTER DELETE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] nvarchar(MAX), [newvalue] nvarchar(MAX), [tableid] integer, [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime;" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[{4}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {5}, 3, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              "    INSERT dbo.[tbsys_audittrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [columnid], [deleted], [recorddesc])" & vbNewLine & _
              "		     SELECT SYSTEM_USER, @dChangeDate, [id], [oldvalue], [newvalue], [tableid], [columnid], 1, [recorddesc] FROM @audit" & vbNewLine & vbNewLine & _
              "{3}" & vbNewLine & vbNewLine & _
              "    -- Clear the temporary trigger status table" & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {5};" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditDelete, sSQLParentColumns_Delete _
              , Tables.sysTriggerTransaction, CInt(objTable.ID))
          ScriptTrigger("dbo", objTable, TriggerType.AfterDelete, sSQL)

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Triggers, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      Finally

      End Try

      Return bOK

    End Function

    Private Function ScriptTrigger(ByVal [Role] As String, ByVal [Table] As Things.Table, ByVal [TriggerType] As TriggerType, ByRef [BodyCode] As String) As Boolean

      Dim sSQL As String = String.Empty
      Dim sTriggerType As String = String.Empty
      Dim sTriggerName As String = String.Empty
      Dim sTriggerFireType As String = String.Empty

      Try

        Select Case [TriggerType]
          Case Enums.TriggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF INSERT"
            sTriggerFireType = "INSERT"

          Case Enums.TriggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER INSERT"
            sTriggerFireType = "INSERT"

          Case Enums.TriggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF UPDATE"
            sTriggerFireType = "UPDATE"

          Case Enums.TriggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER UPDATE"
            sTriggerFireType = "UPDATE"

          Case Enums.TriggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF DELETE"
            sTriggerFireType = "DELETE"

          Case Enums.TriggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER DELETE"
            sTriggerFireType = "DELETE"

        End Select

        ' Drop existing trigger
        sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE [type] = 'TR' AND [name] = '{0}')  DROP TRIGGER [{0}]", sTriggerName)
        CommitDB.ScriptStatement(sSQL)

        ' Create new trigger code
        sSQL = String.Format("CREATE TRIGGER [{1}].[{0}] ON [{1}].[{2}]" & vbNewLine & _
          "    {3}" & vbNewLine & "AS" & vbNewLine & _
          "BEGIN" & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Start ([{2}].[{0}]';" & vbNewLine & _
          "    SET NOCOUNT ON;" & vbNewLine & _
          "    DECLARE @iCount integer;" & vbNewLine & vbNewLine & _
          "{4}" & vbNewLine & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Exit ([{2}].[{0}]'; " & vbNewLine & _
          "END" _
          , sTriggerName, [Role], Table.PhysicalName, sTriggerType, [BodyCode] _
          , IIf(Globals.Options.DevelopmentMode, "", "--"))
        CommitDB.ScriptStatement(sSQL)

        ' Put the correct firing order on the trigger
        If TriggerType = Enums.TriggerType.AfterDelete Or TriggerType = Enums.TriggerType.AfterUpdate Or TriggerType = Enums.TriggerType.AfterInsert Then
          sSQL = String.Format("EXEC sp_settriggerorder @triggername=N'[{0}].[{1}]', @order=N'First', @stmttype=N'{2}'" _
              , [Role], sTriggerName, sTriggerFireType)
          CommitDB.ScriptStatement(sSQL)
        End If

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        Return False

      End Try

      Return True

    End Function

#End Region

#Region "Calculation Scripting"

    Public Function CreateFunctions() As Boolean Implements iCommitDB.ScriptFunctions

      Dim bOK As Boolean = True

      Try

        bOK = ScriptFunctions.ConvertCurrency
        bOK = bOK And ScriptFunctions.UniqueCodeViews
        bOK = bOK And ScriptFunctions.GetFieldFromDatabases
        bOK = bOK And ScriptFunctions.GeneratePerformanceIndexes

      Catch ex As Exception
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateObjects() As Boolean Implements iCommitDB.ScriptObjects

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objExpression As Things.Expression

      Dim bOK As Boolean = True
      Dim sObjectName As String = String.Empty

      Try

        ' Drop objects first (for schemabinding purposes)
        For Each objTable In Globals.Things

          For Each objColumn In objTable.Columns
            sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)
            ScriptDB.DropUDF("dbo", sObjectName)
          Next

        Next


        ' Now create the objects
        For Each objTable In Globals.Things

          ' Record Descriptions
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            sObjectName = String.Format("{0}{1}", Consts.RecordDescriptionUDF, objTable.Name)
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.CodeStub)
            End If
          End If

          '  Validation Masks
          For Each objExpression In objTable.Objects(Things.Type.Mask)
            sObjectName = String.Format("{0}{1}", Consts.MaskUDF, CInt(objExpression.ID))
            objExpression.GenerateCode()
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objExpression.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objExpression.UDF.CodeStub)
            End If

          Next

          ' Calculations
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated Then

              objColumn.Calculation = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)
              If Not objColumn.Calculation.State = System.Data.DataRowState.Unchanged Or Globals.Options.RefreshObjects Then

                sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)

                Debug.Assert(sObjectName <> "udfcalc_Table1.divby0_triggerval")

                If Not objColumn.Calculation Is Nothing Then
                  objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                  objColumn.Calculation.AssociatedColumn = objColumn
                  objColumn.Calculation.GenerateCode()

                  ' Script the expression (generate a code stub if error)
                  If Not Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.Code) Then
                    Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.CodeStub)
                  End If

                End If

              End If
            End If
          Next

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sObjectName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      End Try

      Return bOK

    End Function

#End Region

#Region "Security Scripting"

    Public Function ApplySecurity() As Boolean Implements iCommitDB.ApplySecurity
      Return True
    End Function

#End Region

  End Class

End Namespace

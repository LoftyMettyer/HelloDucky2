Option Explicit On

Imports System.Runtime.InteropServices
Imports System.Text

Namespace ScriptDB

  <ClassInterface(ClassInterfaceType.None)> _
  Public Class Script
    Implements COMInterfaces.iCommitDB

#Region "Table Scripting"

    Private Sub DropView(ByRef [Role] As String, ByRef [ViewName] As String)

      Dim sSQL As String

      Try

        sSQL = String.Format("IF EXISTS(SELECT o.[name] FROM sys.sysobjects o " & _
           "INNER JOIN sys.sysusers u ON o.[uid] = u.[uid] " & _
           "WHERE o.[name] = '{1}' AND [type] = 'V' AND u.[name] = '{0}')" & vbNewLine & _
          " DROP VIEW [{0}].[{1}]", [Role], ViewName)

        ' Commit
        CommitDB.ScriptStatement(sSQL)

      Catch ex As Exception
        MsgBox(ex.Message, MsgBoxStyle.Critical)
        Stop

      End Try

    End Sub

    Public Function DropViews() As Boolean Implements COMInterfaces.iCommitDB.DropViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things

          For Each objView In objTable.Objects(Things.Type.View)
            DropView(objTable.SchemaName, objView.Name)
          Next
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, "DropViews", HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function DropTableViews() As Boolean Implements iCommitDB.DropTableViews

      Dim objTable As Things.Table
      Dim bOK As Boolean = True

      Try
        For Each objTable In Globals.Things
          DropView("dbo", objTable.Name)
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, objTable.Name, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)

      End Try

      Return bOK

    End Function

    Public Function CreateTables() As Boolean Implements iCommitDB.ScriptTables

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim sSQL As String

      Try

        For Each objTable In Globals.Things

          Select Case objTable.State

            Case DataRowState.Deleted
              sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "DROP TABLE [dbo].[{0}];", objTable.NameInDB)
              Globals.CommitDB.ScriptStatement(sSQL)

            Case DataRowState.Modified
              'If Not objTable.PhysicalName = objTable.NameInDB Then
              '  sSQL = String.Format("sp_rename @objname = [{0}], @newname = [{1}]" _
              '        , objTable.NameInDB, objTable.PhysicalName)
              '  Globals.CommitDB.ScriptStatement(sSQL)
              '  'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)
              'End If

            Case Else ' DataRowState.Added
              sSQL = String.Format("IF NOT EXISTS(SELECT [name] FROM sys.sysobjects WHERE id = OBJECT_ID(N'[dbo].[{0}]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)" & vbNewLine & _
                "CREATE TABLE [dbo].[{0}] (" & _
                " [id] integer PRIMARY KEY CLUSTERED IDENTITY(1,1)" & _
                " , [guid] uniqueidentifier DEFAULT (newsequentialid())" & vbNewLine & _
                " , [updflag] integer" & vbNewLine & _
                " , [deleteddate] datetime" & vbNewLine & _
                " , [recorddescription] nvarchar(255)" & vbNewLine & _
                " , [timestamp] rowversion" & vbNewLine & _
                " , [lastsavedby] varbinary(85)" & vbNewLine & _
                " , [lastsavedatetime] datetime);" _
                , objTable.PhysicalName)
              Globals.CommitDB.ScriptStatement(sSQL)
              'ScriptExtendedProperty(ObjectTypes.Table, "dbo", sTableName, ExtendedProperties.AutoGenerated, 1)

          End Select


          ' Add any relations
          For Each objRelation In objTable.Objects(Things.Type.Relation)

            If objRelation.RelationshipType = ScriptDB.RelationshipType.Parent Then
              sSQL = String.Format("IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='ID_{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ADD [ID_{1}] integer NOT NULL", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

              sSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID_{1}')" & vbNewLine & _
                  "CREATE NONCLUSTERED INDEX [IDX_ID_{1}] ON [dbo].[{0}] ([ID_{1}] ASC)", objTable.PhysicalName, CInt(objRelation.ParentID))
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next



          ' Now add the columns
          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.State = DataRowState.Deleted Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] DROP COLUMN [{1}]", objTable.PhysicalName, objColumn.Name)
              Globals.CommitDB.ScriptStatement(sSQL)

            ElseIf System.Data.DataRowState.Modified Or Globals.Options.RefreshObjects Then
              sSQL = String.Format("IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME]='{0}' AND [COLUMN_NAME] ='{1}')" & vbNewLine & _
                  "ALTER TABLE [dbo].[{0}] ALTER COLUMN [{1}] {2} ELSE ALTER TABLE [dbo].[{0}] ADD [{1}] {2}", objTable.PhysicalName, objColumn.Name, objColumn.DataTypeSyntax)
              Globals.CommitDB.ScriptStatement(sSQL)

            End If

          Next

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.TableAndColumns, "Views", HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateTableViews() As Boolean Implements iCommitDB.ScriptTableViews

      Dim bOK As Boolean = True
      Dim sDefinitionSQL As String = String.Empty
      Dim sViewName As String = String.Empty
      Dim sActualTableName As String = String.Empty
      Dim sOptions As String = String.Empty

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim objExpression As Things.Expression

      Try

        For Each objTable In Globals.Things

          sViewName = objTable.Name
          sActualTableName = String.Format("{0}{1}", Consts.UserTable, objTable.Name)

          sDefinitionSQL = "AS SELECT [id], [timestamp]" & vbNewLine

          ' Add relations
          For Each objRelation In objTable.Objects(Things.Type.Relation)
            If objRelation.RelationshipType = RelationshipType.Parent Then
              sDefinitionSQL = sDefinitionSQL & String.Format(", [ID_{0}]", CInt(objRelation.ParentID)) & vbNewLine
            End If
          Next


          ' Add columns
          For Each objColumn In objTable.Objects(Things.Type.Column)

            If objColumn.IsCalculated And objColumn.IsReadOnly And objTable.TableType = Things.TableType.Parent Then
              '              If Not objColumn.Calculation.RequiresRowNumber Then

              sDefinitionSQL = sDefinitionSQL & String.Format(", {0} AS [{1}]", objColumn.Calculation.UDF.CallingCode.Replace("@prm_", "base."), objColumn.Name & vbNewLine)
              '              End If
            Else
              sDefinitionSQL = sDefinitionSQL & (String.Format(", base.[{0}] AS [{0}]", objColumn.Name) & vbNewLine)
            End If
          Next

          ' Add the base table
          sDefinitionSQL = sDefinitionSQL & vbNewLine & String.Format("FROM [dbo].[{0}] base", sActualTableName)


          DropView(objTable.SchemaName, sViewName)

          sDefinitionSQL = String.Format("CREATE VIEW [{0}].[{1}] {2} {3}", objTable.SchemaName, sViewName, sOptions, sDefinitionSQL)
          CommitDB.ScriptStatement(sDefinitionSQL)




        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Views, sViewName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sDefinitionSQL)
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateViews() As Boolean Implements iCommitDB.ScriptViews

      Dim objTable As Things.Table
      Dim objView As Things.View
      Dim objColumn As Things.Column

      Dim sDefinition As New StringBuilder
      Dim bOK As Boolean = True

      Try

        For Each objTable In Globals.Things
          For Each objView In objTable.Objects(Things.Type.View)

            sDefinition = New StringBuilder
            sDefinition.AppendLine(String.Format("CREATE VIEW [{0}].[{1}]", objTable.SchemaName, objView.Name))
            sDefinition.AppendLine("--WITH SCHEMABINDING")
            sDefinition.AppendLine("AS SELECT [id], [timestamp]")

            For Each objColumn In objView.Objects(Things.Type.Column)
              If objColumn.IsCalculated And objColumn.IsReadOnly Then
                sDefinition.AppendLine(String.Format(", {0} AS [{1}]", objColumn.Calculation.UDF.CallingCode.Replace("@prm_", "base."), objColumn.Name))
              Else
                sDefinition.AppendLine(String.Format(", base.[{0}] AS [{0}]", objColumn.Name))
              End If
            Next

            sDefinition.AppendLine(String.Format("FROM [{0}].[{1}] base", objTable.SchemaName, objTable.Name))

            ' Add the filter
            'If Not objView.Filter Is Nothing Then
            '  sDefinition.AppendLine("WHERE " & objView.Filter.UDF.SelectCode)
            'End If

            ' Generate this view
            DropView(objTable.SchemaName, objView.Name)
            CommitDB.ScriptStatement(sDefinition.ToString)

            '' Add an index
            'sDefinitionSQL = String.Format("IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'IDX_ID')" & vbNewLine & _
            '    "CREATE UNIQUE CLUSTERED INDEX [IDX_ID] ON [dbo].[{0}] ([ID] ASC)", objTable.Name)
            'CommitDB.ScriptStatement(sDefinitionSQL)

          Next
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(ErrorHandler.Section.Views, "Views", ErrorHandler.Severity.Error, ex.Message, sDefinition.ToString)
        bOK = False
      End Try

      Return bOK

    End Function

#End Region

#Region "Trigger Scripting"

    Public Function CreateTriggers() As Boolean Implements iCommitDB.ScriptTriggers

      Dim bOK As Boolean = True
      Dim objTable As Things.Table
      Dim objRelatedTable As Things.Table
      Dim objColumn As Things.Column
      Dim objRelation As Things.Relation
      Dim objIndex As Things.Index

      Dim sSQL As String = String.Empty
      Dim sCalculationCode As String
      Dim sTriggerName As String = String.Empty
      Dim sColumnName As String = String.Empty
      Dim sAuditDataBase As String = String.Empty
      Dim sAuditDataDelete As String = String.Empty
      Dim sAuditDataInsert As String = String.Empty

      Dim objAuditIndex As Things.Index

      Dim sSQLCode_AuditInsert As String = String.Empty
      Dim sSQLCode_AuditUpdate As String = String.Empty
      Dim sSQLCode_AuditDelete As String = String.Empty
      Dim sSQLCode_Audit As String = String.Empty

      Dim sSQLCode_Bypass As String = String.Empty

      Dim sValidation As String

      Dim sSQLWriteableColumns As String
      Dim sQLInsteadOfInsertColumns As String
      Dim SQLAfterInsertColumns As String

      Dim sSQLCalculatedColumns As String
      Dim sSQLPostAuditCalcs As String
      '      Dim sSQLUniqueCalcs As String
      '   Dim sWritebackColumns As String
      Dim sSQLParentColumns As String
      Dim sSQLParentColumns_Delete As String
      Dim sSQLChildColumns As String

      Dim sSQLSpecialUpdate As String

      Dim aryCalculatedColumns As ArrayList
      Dim aryPostAuditCalcs As ArrayList
      '      Dim aryWritebackColumns As ArrayList
      '      Dim aryUpdateUniqueCodes As ArrayList

      Dim aryBaseTableColumns As ArrayList
      Dim aryParentsToUpdate As ArrayList
      Dim aryChildrenToUpdate As ArrayList
      Dim aryParentsToUpdate_Delete As ArrayList

      Dim aryColumnsWithDefaultValues As ArrayList
      Dim aryAllWriteableColumns As ArrayList
      Dim aryAllWriteableFormatted As ArrayList

      Dim aryColumns As New ArrayList

      Dim aryAuditUpdates As ArrayList
      Dim aryAuditInserts As ArrayList
      Dim aryAuditDeletes As ArrayList

      Try

        For Each objTable In Globals.Things

          aryColumnsWithDefaultValues = New ArrayList
          aryAllWriteableColumns = New ArrayList
          aryAllWriteableFormatted = New ArrayList
          aryAuditUpdates = New ArrayList
          aryAuditInserts = New ArrayList
          aryAuditDeletes = New ArrayList
          '          aryUpdateUniqueCodes = New ArrayList
          aryParentsToUpdate = New ArrayList
          aryChildrenToUpdate = New ArrayList
          aryParentsToUpdate_Delete = New ArrayList
          aryBaseTableColumns = New ArrayList
          aryCalculatedColumns = New ArrayList
          aryPostAuditCalcs = New ArrayList
          '     aryWritebackColumns = New ArrayList

          sSQLCalculatedColumns = String.Empty
          sSQLParentColumns = String.Empty
          sSQLParentColumns_Delete = String.Empty
          sSQLChildColumns = String.Empty
          sValidation = String.Empty

          sSQLCode_AuditInsert = String.Empty
          sSQLCode_AuditUpdate = String.Empty
          sSQLCode_AuditDelete = String.Empty
          sSQLCode_Audit = String.Empty
          sSQLPostAuditCalcs = String.Empty
          '       sWritebackColumns = String.Empty
          sSQLSpecialUpdate = String.Empty
          sQLInsteadOfInsertColumns = String.Empty

          ' Build in indexes
          objAuditIndex = New Things.Index
          objTable.Objects.Add(objAuditIndex)

          ' Add the system generated columns
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            aryCalculatedColumns.Add(String.Format("[_description] = {0}", objTable.RecordDescription.UDF.CallingCode))
          End If

          objAuditIndex.IsClustered = False
          objAuditIndex.IsTableIndex = True
          objAuditIndex.IncludePrimaryKey = True
          objAuditIndex.Name = "IDX_AuditFields"


          ' Add any relationship columns
          For Each objRelation In objTable.Objects(Things.Type.Relation)

            aryColumns = New ArrayList
            If objRelation.RelationshipType = RelationshipType.Parent Then
              aryBaseTableColumns.Add(String.Format("[ID_{0}] = base.[ID_{0}]", CInt(objRelation.ParentID)))
              aryAllWriteableColumns.Add(String.Format("[ID_{0}]", CInt(objRelation.ParentID)))
              aryAllWriteableFormatted.Add(String.Format("[ID_{0}]", CInt(objRelation.ParentID)))

              objRelatedTable = Globals.Things.GetObject(Things.Type.Table, objRelation.ParentID)
              For Each objColumn In objTable.DependsOnParentColumns
                If objColumn.Table Is objRelatedTable Then
                  aryColumns.Add(String.Format("base.{0} = {0}", objColumn.Name))
                End If
              Next

              If aryColumns.Count > 0 Then
                aryParentsToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                    "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM inserted)" & vbNewLine _
                    , objRelation.PhysicalName, CInt(objRelation.ParentID)))

                aryParentsToUpdate_Delete.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {1})" & vbNewLine & _
                    "        UPDATE [dbo].[{0}] SET [updflag] = 1 WHERE [dbo].[{0}].[id] IN (SELECT DISTINCT [id_{1}] FROM deleted)" & vbNewLine _
                    , objRelation.PhysicalName, CInt(objRelation.ParentID)))

              End If

            Else

              objRelatedTable = Globals.Things.GetObject(Things.Type.Table, objRelation.ChildID)
              objIndex = New Things.Index
              objIndex.Name = String.Format("IDX_relation_{0}", objRelatedTable.Name)
              objIndex.IsTableIndex = True
              objIndex.IsClustered = False
              objIndex.Enabled = False

              For Each objColumn In objRelatedTable.DependsOnChildColumns
                If objColumn.Table Is objTable Then
                  aryColumns.Add(String.Format("NOT i.{0} = d.{0}", objColumn.Name))
                  objIndex.IncludedColumns.AddIfNew(objColumn)
                End If
              Next

              If aryColumns.Count > 0 Then
                aryChildrenToUpdate.Add(String.Format("    IF NOT EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3})" & vbNewLine & _
                      "            AND EXISTS(SELECT i.ID FROM dbo.[{2}] i" & vbNewLine & _
                      "                INNER JOIN deleted d ON d.ID = i.ID " & vbNewLine & _
                      "                WHERE {4})" & vbNewLine & _
                      "        UPDATE dbo.[{0}] SET [updflag] = 1 WHERE ID_{1} IN (SELECT i.ID FROM inserted i);" _
                      , objRelatedTable.PhysicalName, CInt(objTable.ID), objTable.PhysicalName, CInt(objRelatedTable.ID) _
                      , String.Join(" OR ", aryColumns.ToArray())))
                objTable.Objects.Add(objIndex)
              End If
            End If
          Next

          For Each objColumn In objTable.Columns

            If Not objColumn.State = System.Data.DataRowState.Deleted Then

              If objColumn.IsCalculated Then
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.ExpressionType = ExpressionType.ColumnCalculation
                objColumn.Calculation.GenerateCode()

                If objColumn.Calculation.IsComplex Then
                  sCalculationCode = objColumn.Calculation.UDF.CallingCode
                Else
                  sCalculationCode = objColumn.Calculation.UDF.InlineCode
                End If

                If objColumn.CalculateIfEmpty Then
                  sColumnName = String.Format("[{0}] = ISNULL([{0}], {1})", objColumn.Name, sCalculationCode)
                Else
                  sColumnName = String.Format("[{0}] = {1}", objColumn.Name, sCalculationCode)
                End If

                'If objColumn.Calculation.RequiresWriteback Then
                '  aryWritebackColumns.Add(sColumnName & vbNewLine)
                'Else
                If objColumn.Calculation.CalculatePostAudit Then
                  aryPostAuditCalcs.Add(sColumnName & vbNewLine)
                Else
                  aryCalculatedColumns.Add(sColumnName)
                End If
                '              End If

              End If

              ' Build list of default values
              If CInt(objColumn.DefaultCalcID) > 0 Then
                objColumn.DefaultCalculation.AssociatedColumn = objColumn
                objColumn.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
                objColumn.DefaultCalculation.GenerateCode()

                sCalculationCode = objColumn.DefaultCalculation.UDF.CallingCode
                aryColumnsWithDefaultValues.Add(String.Format("[{0}] = {1}", objColumn.Name, sCalculationCode))
              End If


              If Not objColumn.IsReadOnly Then
                Select Case objColumn.DataType

                  Case ScriptDB.ColumnTypes.Date
                    aryBaseTableColumns.Add(String.Format("[{0}] = DATEADD(dd, 0, DATEDIFF(dd, 0, base.[{0}]))", objColumn.Name))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format(" DATEADD(dd, 0, DATEDIFF(dd, 0, [{0}]))", objColumn.Name))

                  Case Else
                    aryBaseTableColumns.Add(String.Format("[{0}] = {1}", objColumn.Name, objColumn.ApplyFormatting("base")))
                    aryAllWriteableColumns.Add(String.Format("[{0}]", objColumn.Name))
                    aryAllWriteableFormatted.Add(String.Format("[{0}]", objColumn.Name))

                End Select

              End If

              ' Concatenate audited columns
              If objColumn.Audit Then
                Select Case objColumn.DataType
                  Case ColumnTypes.Date
                    sAuditDataInsert = String.Format(" CONVERT(varchar(11), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(11), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(11), base.[{0}], 105)", objColumn.Name)

                  Case ColumnTypes.Logic
                    sAuditDataInsert = String.Format(" CASE i.[{0}] WHEN 1 THEN 'Yes' WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataDelete = String.Format(" CASE d.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)
                    sAuditDataBase = String.Format(" CASE base.[{0}] WHEN 1 THEN 'Yes'  WHEN NULL THEN 'No' ELSE 'No' END", objColumn.Name)

                  Case Else
                    sAuditDataInsert = String.Format(" CONVERT(varchar(255), i.[{0}], 105)", objColumn.Name)
                    sAuditDataDelete = String.Format(" CONVERT(varchar(255), d.[{0}], 105)", objColumn.Name)
                    sAuditDataBase = String.Format(" CONVERT(varchar(255), base.[{0}], 105)", objColumn.Name)
                End Select

                aryAuditInserts.Add(String.Format("        SELECT base.ID, '* New Record *', {0}, {4}, '{3}', '{6}', {1}, base.[_description]" & vbNewLine & _
                    "            FROM inserted i" & vbNewLine & _
                    "            INNER JOIN dbo.[{2}] base ON i.[id] = base.[id] AND NOT ISNULL({0},'') = ''" _
                    , sAuditDataInsert, CInt(objColumn.ID), objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.ID), objColumn.SafeReturnType, objColumn.Name))

                aryAuditUpdates.Add(String.Format("        SELECT d.ID, {7}, {0}, {4}, '{3}', '{6}', {1}, base.[_description]" & vbNewLine & _
                    "            FROM deleted d" & vbNewLine & _
                    "            INNER JOIN dbo.[{2}] base ON d.[id] = base.[id] AND NOT ISNULL({0},'') = ISNULL({7},'')" _
                    , sAuditDataBase, CInt(objColumn.ID), objColumn.Table.PhysicalName, objColumn.Table.Name, CInt(objColumn.Table.ID), objColumn.SafeReturnType, objColumn.Name, sAuditDataDelete))

                aryAuditDeletes.Add(String.Format("        SELECT d.ID, {0}, ' * Deleted Record *', {3}, '{2}', '{4}', {1}, d.[_description]" & vbNewLine & _
                    "            FROM deleted d WHERE {0} IS NOT NULL" _
                    , sAuditDataDelete, CInt(objColumn.ID), objColumn.Table.Name, CInt(objColumn.Table.ID), objColumn.Name))

                objAuditIndex.IncludedColumns.Add(objColumn)
              End If
            End If

          Next

          ' Update any parents
          If aryParentsToUpdate.ToArray.Length > 0 Then
            sSQLParentColumns = "    -- Refresh parent records" & vbNewLine & _
                                "    IF @isovernight = 0" & vbNewLine & "    BEGIN" & vbNewLine & _
                                String.Join(vbNewLine, aryParentsToUpdate.ToArray()) & _
                                "     END"
            sSQLParentColumns_Delete = "    -- Refresh parents records" & vbNewLine & _
                                String.Join(vbNewLine, aryParentsToUpdate_Delete.ToArray())

          End If

          ' Validation
          sValidation = String.Format("    -- Validation" & vbNewLine & _
              "    IF @isovernight = 0 AND (SELECT TOP 1 [tablefromid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid ORDER BY [nestlevel] ASC) = {0}" & vbNewLine & _
              "    BEGIN" & vbNewLine & _
              "        SET @sValidation = '';" & vbNewLine & _
              "        SELECT @sValidation = @sValidation + dbo.[udfvalid_{1}](ID, [_description]) FROM inserted" & vbNewLine & _
              "        IF LEN(@sValidation) > 0" & vbNewLine & _
              "        BEGIN" & vbNewLine & _
              "            RAISERROR(@sValidation, 16, 1);" & vbNewLine & _
              "            ROLLBACK;" & vbNewLine & _
              "        END" & vbNewLine & _
              "    END" & vbNewLine, CInt(objTable.ID), objTable.Name)

          ' Update child records
          If aryChildrenToUpdate.ToArray.Length > 0 Then
            sSQLChildColumns = "    --Update children" & vbNewLine & _
                    "    IF @isovernight = 0 AND @startingtrigger = 2" & vbNewLine & "    BEGIN" & vbNewLine & _
                    String.Join(vbNewLine & vbNewLine, aryChildrenToUpdate.ToArray()) & vbNewLine & _
                   "     END"
          End If

          ' Update statement of all the non read only columns (free entry columns)
          If aryBaseTableColumns.ToArray.Length > 0 Then
            sSQLWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryBaseTableColumns.ToArray()))
          Else
            sSQLWriteableColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName)
          End If


          ' Update the default values
          If aryColumnsWithDefaultValues.ToArray.Length > 0 Then
            'aryColumnsWithDefaultValues.AddRange(aryBaseTableColumns)
            SQLAfterInsertColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]," & vbNewLine & _
              "        {1}" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName, String.Join(", " & vbNewLine & vbTab & vbTab & vbTab, aryColumnsWithDefaultValues.ToArray()))
          Else
            SQLAfterInsertColumns = String.Format("    -- Update any columns specified in the update clause" & vbNewLine & _
              "    UPDATE [dbo].[{0}]" & vbNewLine & _
              "        SET [updflag] = base.[updflag]" & vbNewLine & _
              "        FROM [inserted] base WHERE base.[id] = [dbo].[{0}].[id]" & vbNewLine _
              , objTable.PhysicalName)
          End If

          ' Instead of writeable columns
          If aryAllWriteableColumns.ToArray.Length > 0 Then
            sQLInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine & _
                      "    INSERT [dbo].[{0}] ({1})" & vbNewLine & _
                      "        SELECT {2} FROM inserted base;" & vbNewLine & vbNewLine _
                      , objTable.PhysicalName, String.Join(",", aryAllWriteableColumns.ToArray()), String.Join("," & vbNewLine, aryAllWriteableFormatted.ToArray()))
          Else
            sQLInsteadOfInsertColumns = String.Format("    -- Commit writeable columns" & vbNewLine & _
                      "    INSERT [dbo].[{0}] ([updflag]) VALUES (1);" & vbNewLine & vbNewLine _
                      , objTable.PhysicalName)
          End If

          ' Build audit strings
          If aryAuditUpdates.ToArray.Length > 0 Then
            sSQLCode_AuditInsert = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditInserts.ToArray()))
            sSQLCode_AuditUpdate = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditUpdates.ToArray()))
            sSQLCode_AuditDelete = String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, columnid, recorddesc)" & vbNewLine & _
                                           "{0};" _
                                          , String.Join(vbNewLine & "        UNION" & vbNewLine, aryAuditDeletes.ToArray()))
            sSQLCode_Audit = vbNewLine & "    INSERT dbo.[ASRSysAuditTrail] ([username], [datetimestamp], [recordid], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], [deleted], [recorddesc])" & vbNewLine & _
                             "		     SELECT @username, @dChangeDate, [id], [oldvalue], [newvalue], [tableid], [tablename], [columnname], [columnid], 1, [recorddesc] FROM @audit;" & vbNewLine & vbNewLine
          End If

          ' Table level audits
          If objTable.AuditInsert Then
            sSQLCode_AuditInsert += vbNewLine & String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine & _
                    "        SELECT i.[id], '', ' * New Record *', {0}, '{1}', '', base.[_description] FROM inserted i" & vbNewLine & _
                    "            INNER JOIN dbo.{2} base ON i.[id] = base.[id]" _
                    , CInt(objTable.ID), objTable.Name, objTable.PhysicalName)
          End If

          If objTable.AuditDelete Then
            sSQLCode_AuditDelete += vbNewLine & String.Format("    INSERT @audit (id, oldvalue, newvalue, tableid, tablename, columnname, recorddesc)" & vbNewLine & _
                    "        SELECT d.[id], '', ' * Deleted Record *', {0}, '{1}', '', d.[_description] FROM deleted d" & vbNewLine _
                    , CInt(objTable.ID), objTable.Name)
          End If

          ' Update statement of all the calculated columns
          If aryCalculatedColumns.ToArray.Length > 0 Then
            sSQLCalculatedColumns = String.Format("    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine & _
              "    -- Update calculated columns" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "            FROM [dbo].[{0}]" & vbNewLine & _
              "            WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base SET " & vbNewLine & _
              "        {1};" & vbNewLine & vbNewLine & _
              "    EXECUTE sp_executeSQL N'dbo.[spstat_flushuniquecode]';" & vbNewLine & vbNewLine _
              , objTable.PhysicalName, String.Join(vbNewLine & vbTab & vbTab & vbTab & ", ", aryCalculatedColumns.ToArray()))
          End If

          ' Any calculations that require to be saved after the audit
          If aryPostAuditCalcs.ToArray.Length > 0 Then
            sSQLPostAuditCalcs = String.Format("    -- Update columns that rely on audit log data" & vbNewLine & _
              "    WITH base AS (" & vbNewLine & _
              "        SELECT *, ROW_NUMBER() OVER(ORDER BY [ID]) AS [rownumber]" & vbNewLine & _
              "        FROM [dbo].[{0}]" & vbNewLine & _
              "        WHERE [id] IN (SELECT DISTINCT [id] FROM inserted))" & vbNewLine & _
              "    UPDATE base" & vbNewLine & _
              "    SET {1};" & vbNewLine _
              , objTable.PhysicalName, String.Join(vbTab & vbTab & vbTab & ", ", aryPostAuditCalcs.ToArray()), CInt(objTable.ID))
          End If


          ' Special bypass trigger code
          sSQLCode_Bypass = SpecialTrigger_SSP(objTable)

          ' Add trigger code based on module setup
          sSQLSpecialUpdate = SpecialTrigger_BankHolidays(objTable)
          sSQLSpecialUpdate = sSQLSpecialUpdate & SpecialTrigger_Personnel(objTable)

          ' -------------------
          ' INSTEAD OF INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[tbsys_intransactiontrigger] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {2}, 1, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              sQLInsteadOfInsertColumns _
              , objTable.Name, sTriggerName _
              , CInt(objTable.ID) _
              , String.Join(",", aryAllWriteableColumns.ToArray()), String.Join("," & vbNewLine, aryAllWriteableFormatted.ToArray()))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfInsert, sSQL)

          ' -------------------
          ' AFTER INSERT
          ' -------------------
          sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tableid] integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              SQLAfterInsertColumns & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              sSQLCode_Audit & _
              sValidation & vbNewLine & _
              "    DELETE [dbo].[tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3};" & vbNewLine & vbNewLine & _
              "{4}" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditInsert, CInt(objTable.ID), objTable.SysMgrInsertTrigger)
          ScriptTrigger("dbo", objTable, TriggerType.AfterInsert, sSQL)

          ' -------------------
          ' INSTEAD OF UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLCode_Bypass & _
              "    INSERT [dbo].[{4}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {5}, 2, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              "{3}" & vbNewLine & vbNewLine & _
              sValidation & vbNewLine & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {2};" & vbNewLine _
              , objTable.Name, sTriggerName _
              , CInt(objTable.ID) _
              , sSQLWriteableColumns _
              , Tables.sysTriggerTransaction, CInt(objTable.ID))
          ScriptTrigger("dbo", objTable, TriggerType.InsteadOfUpdate, sSQL)

          ' -------------------
          ' AFTER UPDATE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("    DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), tableid integer, [tablename] varchar(255), [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime," & vbNewLine & _
              "            @sValidation nvarchar(MAX);" & vbNewLine & vbNewLine & _
              "    SELECT @forcerefresh = dbo.[udfsys_triggerrequiresrefresh]();" & vbNewLine & _
              "    SELECT TOP 1 @startingtrigger = ISNULL([actiontype],2) FROM dbo.[tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {3} ORDER BY [nestlevel] ASC;" & vbNewLine & _
              "    SELECT TOP 1 @startingtriggertable = ISNULL([tablefromid],0) FROM dbo.[tbsys_intransactiontrigger] WHERE [spid] = @@spid ORDER BY [nestlevel] ASC;" & vbNewLine & _
              "    SET @sValidation = '';" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              sSQLCalculatedColumns & vbNewLine & vbNewLine & _
              sSQLParentColumns & vbNewLine & _
              sSQLChildColumns & vbNewLine & vbNewLine & _
              "{6}" & vbNewLine & _
              sSQLCode_Audit & _
              sSQLSpecialUpdate & _
              "{7}" & vbNewLine & vbNewLine & _
              "{8}" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName _
              , "", CInt(objTable.ID), Tables.sysTriggerTransaction _
              , "" _
              , sSQLCode_AuditUpdate, sSQLPostAuditCalcs, objTable.SysMgrUpdateTrigger) & vbNewLine & vbNewLine
          ScriptTrigger("dbo", objTable, TriggerType.AfterUpdate, sSQL)

          ' -------------------
          ' AFTER DELETE
          ' -------------------
          sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, objTable.Name)
          sSQL = String.Format("	   DECLARE @audit TABLE ([id] integer, [oldvalue] varchar(255), [newvalue] varchar(255), [tablename] varchar(255), [tableid] integer, [columnname] varchar(255), [columnid] integer, [recorddesc] nvarchar(255));" & vbNewLine & _
              "    DECLARE @dChangeDate datetime;" & vbNewLine & _
              "    SET @dChangeDate = GETDATE();" & vbNewLine & vbNewLine & _
              "    INSERT [dbo].[{4}] ([spid], [tablefromid], [actiontype], [nestlevel]) VALUES (@@spid, {5}, 3, @@NESTLEVEL);" & vbNewLine & vbNewLine & _
              "    -- Audit Trail" & vbNewLine & _
              "{2}" & vbNewLine & vbNewLine & _
              sSQLCode_Audit & _
              sSQLSpecialUpdate & _
              "{3}" & vbNewLine & vbNewLine & _
              "{6}" & vbNewLine & vbNewLine & _
              "    -- Clear the temporary trigger status table" & vbNewLine & _
              "    DELETE [dbo].[{4}] WHERE [spid] = @@spid AND [tablefromid] = {5};" & vbNewLine & vbNewLine _
              , objTable.Name, sTriggerName, sSQLCode_AuditDelete, sSQLParentColumns_Delete _
              , Tables.sysTriggerTransaction, CInt(objTable.ID), objTable.SysMgrDeleteTrigger)
          ScriptTrigger("dbo", objTable, TriggerType.AfterDelete, sSQL)

        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.Triggers, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        bOK = False

      Finally

      End Try

      Return bOK

    End Function

    Private Function ScriptTrigger(ByVal [Role] As String, ByVal [Table] As Things.Table, ByVal [TriggerType] As TriggerType, ByRef [BodyCode] As String) As Boolean

      Dim sSQL As String = String.Empty
      Dim sTriggerType As String = String.Empty
      Dim sTriggerName As String = String.Empty
      Dim sTriggerFireType As String = String.Empty

      Try

        Select Case [TriggerType]
          Case Enums.TriggerType.InsteadOfInsert
            sTriggerName = String.Format("{0}{1}_i01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF INSERT"
            sTriggerFireType = "INSERT"

          Case Enums.TriggerType.AfterInsert
            sTriggerName = String.Format("{0}{1}_i02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER INSERT"
            sTriggerFireType = "INSERT"

          Case Enums.TriggerType.InsteadOfUpdate
            sTriggerName = String.Format("{0}{1}_u01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF UPDATE"
            sTriggerFireType = "UPDATE"

          Case Enums.TriggerType.AfterUpdate
            sTriggerName = String.Format("{0}{1}_u02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER UPDATE"
            sTriggerFireType = "UPDATE"

          Case Enums.TriggerType.InsteadOfDelete
            sTriggerName = String.Format("{0}{1}_d01", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "INSTEAD OF DELETE"
            sTriggerFireType = "DELETE"

          Case Enums.TriggerType.AfterDelete
            sTriggerName = String.Format("{0}{1}_d02", ScriptDB.Consts.Trigger, Table.Name)
            sTriggerType = "AFTER DELETE"
            sTriggerFireType = "DELETE"

        End Select

        ' Drop existing trigger
        sSQL = String.Format("IF EXISTS(SELECT [name] FROM sys.sysobjects WHERE [type] = 'TR' AND [name] = '{0}')  DROP TRIGGER [{0}]", sTriggerName)
        CommitDB.ScriptStatement(sSQL)

        ' Create new trigger code
        sSQL = String.Format("CREATE TRIGGER [{1}].[{0}] ON [{1}].[{2}]" & vbNewLine & _
          "    {3}" & vbNewLine & "AS" & vbNewLine & _
          "BEGIN" & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Start ([{2}].[{0}]';" & vbNewLine & _
          "    SET NOCOUNT ON;" & vbNewLine & _
          "    DECLARE @iCount                integer," & vbNewLine & _
          "            @isovernight           bit," & vbNewLine & _
          "            @startingtrigger       tinyint," & vbNewLine & _
          "            @startingtriggertable  integer," & vbNewLine & _
          "            @forcerefresh          bit," & vbNewLine & _
          "            @username              varchar(255);" & vbNewLine & vbNewLine & _
          "    SELECT @isovernight = dbo.[udfsys_isovernightprocess]();" & vbNewLine & _
          "    SELECT @username =	CASE WHEN UPPER(LEFT(APP_NAME(), 15)) = 'HR PRO WORKFLOW' THEN 'HR Pro Workflow'" & vbNewLine & _
          "          ELSE CASE WHEN @isovernight = 1 THEN 'HR Pro Overnight Process' ELSE RTRIM(SYSTEM_USER) END END" & vbNewLine & vbNewLine & _
          "{4}" & vbNewLine & vbNewLine & _
          "    {5}PRINT CONVERT(nvarchar(28), GETDATE(),121) + ' Exit ([{2}].[{0}]'; " & vbNewLine & _
          "END" _
          , sTriggerName, [Role], Table.PhysicalName, sTriggerType, [BodyCode] _
          , IIf(Globals.Options.DevelopmentMode, "", "--"))

        ' Compile the trigger and put the apply correct firing order
        If CommitDB.ScriptStatement(sSQL) Then

          If TriggerType = Enums.TriggerType.AfterDelete Or TriggerType = Enums.TriggerType.AfterUpdate Or TriggerType = Enums.TriggerType.AfterInsert Then
            sSQL = String.Format("EXEC sp_settriggerorder @triggername=N'[{0}].[{1}]', @order=N'First', @stmttype=N'{2}'" _
                , [Role], sTriggerName, sTriggerFireType)
            CommitDB.ScriptStatement(sSQL)
          End If
        End If

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sTriggerName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, sSQL)
        Return False

      End Try

      Return True

    End Function

#End Region

#Region "Calculation Scripting"

    Public Function CreateFunctions() As Boolean Implements iCommitDB.ScriptFunctions

      Dim bOK As Boolean = True

      Try
        bOK = ScriptFunctions.ConvertCurrency
        bOK = bOK And ScriptFunctions.UniqueCodeViews
        bOK = bOK And ScriptFunctions.GetFieldFromDatabases
        'bOK = bOK And ScriptFunctions.BankHolidayUpdate
        ' bOK = bOK And ScriptFunctions.GeneratePerformanceIndexes

      Catch ex As Exception
        bOK = False

      End Try

      Return bOK

    End Function

    Public Function CreateObjects() As Boolean Implements iCommitDB.ScriptObjects

      Dim objTable As Things.Table
      Dim objColumn As Things.Column
      Dim objExpression As Things.Expression
      Dim objIndex As Things.Index
      Dim objView As Things.View

      Dim bOK As Boolean = True
      Dim sObjectName As String = String.Empty
      Dim objTableOrderFilter As Things.TableOrderFilter

      Try

        ' Drop objects first (for schemabinding purposes)
        For Each objTable In Globals.Things
          For Each objColumn In objTable.Columns
            sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)
            ScriptDB.DropUDF("dbo", sObjectName)
          Next
        Next


        ' Now create the objects
        For Each objTable In Globals.Things

          ' Record Descriptions
          If Not objTable.RecordDescription Is Nothing Then
            objTable.RecordDescription.GenerateCode()
            sObjectName = String.Format("{0}{1}", Consts.RecordDescriptionUDF, objTable.Name)
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objTable.RecordDescription.UDF.CodeStub)
            End If
          End If

          '  Validation Masks
          For Each objExpression In objTable.Objects(Things.Type.Mask)
            sObjectName = String.Format("{0}{1}", Consts.MaskUDF, CInt(objExpression.ID))
            objExpression.GenerateCode()
            ScriptDB.DropUDF("dbo", sObjectName)
          Next

          ' Indexes for views
          objIndex = New Things.Index
          objIndex.Name = String.Format("IDX_Views_{0}", objTable.Name)
          objIndex.IncludePrimaryKey = True
          objIndex.IsTableIndex = True
          For Each objView In objTable.Objects(Things.Type.View)

            If Not objView.Filter Is Nothing Then
              objView.Filter.ExpressionType = ExpressionType.Mask
              objView.Filter.AssociatedColumn = objTable.Objects(Things.Type.Column)(0)
              objView.Filter.GenerateCode()

              For Each objColumn In objView.Filter.Dependencies.Objects(Things.Type.Column)
                If objColumn.Type = Things.Type.Column Then
                  objIndex.Columns.AddIfNew(objColumn)
                End If
              Next
            End If

          Next
          objTable.Objects.Add(objIndex)


          ' Calculations
          For Each objColumn In objTable.Columns

            If objColumn.IsCalculated Then

              objColumn.Calculation = objTable.Objects.GetObject(Things.Type.Expression, objColumn.CalcID)
              '              If Not objColumn.Calculation.State = System.Data.DataRowState.Unchanged Or Globals.Options.RefreshObjects Then

              '              sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)
              Debug.Assert(objColumn.Name <> "recur1")

              If Not objColumn.Calculation Is Nothing Then
                objColumn.Calculation.ExpressionType = ScriptDB.ExpressionType.ColumnCalculation
                objColumn.Calculation.AssociatedColumn = objColumn
                objColumn.Calculation.GenerateCode()
              End If

              '            End If
            End If

            ' Build default value code
            If CInt(objColumn.DefaultCalcID) > 0 Then
              objColumn.DefaultCalculation = objTable.Objects.GetObject(Things.Type.Expression, objColumn.DefaultCalcID)

              If Not objColumn.DefaultCalculation Is Nothing Then
                objColumn.DefaultCalculation.ExpressionType = ScriptDB.ExpressionType.ColumnDefault
                objColumn.DefaultCalculation.AssociatedColumn = objColumn
                objColumn.DefaultCalculation.GenerateCode()
              End If

            End If

          Next

          '  Validation Masks
          For Each objExpression In objTable.Objects(Things.Type.Mask)
            sObjectName = String.Format("{0}{1}", Consts.MaskUDF, CInt(objExpression.ID))
            objExpression.GenerateCode()
            ScriptDB.DropUDF("dbo", sObjectName)

            If Not Globals.CommitDB.ScriptStatement(objExpression.UDF.Code) Then
              Globals.CommitDB.ScriptStatement(objExpression.UDF.CodeStub)
            End If

          Next

        Next




        ' Generate any table UDFs
        For Each objTable In Globals.Things
          For Each objTableOrderFilter In objTable.Objects(Things.Type.TableOrderFilter)

            '     Debug.Assert(objTableOrderFilter.Name <> "udftab_Post_Allocations_Post_Start_Date_Primary_Post_1_First")

            objTableOrderFilter.GenerateCode()
            ScriptDB.DropUDF("dbo", objTableOrderFilter.Name)
            Globals.CommitDB.ScriptStatement(objTableOrderFilter.UDF.Code)
          Next
        Next





        ' Script the column calculations
        For Each objTable In Globals.Things
          For Each objColumn In objTable.Columns

            '   Debug.Print(objColumn.Name)
            If objColumn.IsCalculated Then
              '     If objColumn.Calculation.IsComplex Then
              '  Debug.Assert(objColumn.Name <> "Current_Salary_Size_2")

              objColumn.Calculation.AssociatedColumn = objColumn
              objColumn.Calculation.StartOfPartNumbers = 0
              objColumn.Calculation.StatementObjects.Clear()

              objColumn.Calculation.ExpressionType = ExpressionType.ColumnCalculation
              objColumn.Calculation.GenerateCode()
              Globals.TuningLog.Expressions.Add(objColumn)

              sObjectName = String.Format("{0}{1}.{2}", Consts.CalculationUDF, objTable.Name, objColumn.Name)

              ScriptDB.DropUDF("dbo", sObjectName)

              If objColumn.Calculation.IsValid Then
                If Not Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.Code) Then
                  Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.CodeStub)
                End If
              Else
                Globals.CommitDB.ScriptStatement(objColumn.Calculation.UDF.CodeStub)
              End If
              'End If
            End If

            If CInt(objColumn.DefaultCalcID) > 0 Then

              objColumn.DefaultCalculation.AssociatedColumn = objColumn
              objColumn.DefaultCalculation.StartOfPartNumbers = 0
              objColumn.DefaultCalculation.StatementObjects.Clear()

              objColumn.DefaultCalculation.ExpressionType = ExpressionType.ColumnDefault
              objColumn.DefaultCalculation.GenerateCode()
              Globals.TuningLog.Expressions.Add(objColumn)

              sObjectName = String.Format("{0}{1}.{2}", Consts.DefaultValueUDF, objTable.Name, objColumn.Name)

              ScriptDB.DropUDF("dbo", sObjectName)

              If objColumn.DefaultCalculation.IsValid Then
                If Not Globals.CommitDB.ScriptStatement(objColumn.DefaultCalculation.UDF.Code) Then
                  Globals.CommitDB.ScriptStatement(objColumn.DefaultCalculation.UDF.CodeStub)
                End If
              Else
                Globals.CommitDB.ScriptStatement(objColumn.DefaultCalculation.UDF.CodeStub)
              End If
              'End If
            End If



          Next
        Next



      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, sObjectName, HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False

      End Try

      Return bOK

    End Function

#End Region

#Region "Security Scripting"

    Public Function ApplySecurity() As Boolean Implements iCommitDB.ApplySecurity
      Return True
    End Function

#End Region

    Public Function ScriptIndexes() As Boolean Implements COMInterfaces.iCommitDB.ScriptIndexes

      Dim objTable As Things.Table
      Dim objRelation As Things.Relation
      Dim objColumn As Things.Column
      Dim objIndex As Things.Index
      Dim bOK As Boolean = True
      Dim sSQL As String
      Dim aryColumns As ArrayList
      Dim aryIncludeColumns As ArrayList
      Dim sObjectName As String
      Dim sIncludeColumns As String
      Dim bCreateIndex As Boolean

      Try

        For Each objTable In Globals.Things
          For Each objIndex In objTable.Indexes

            bCreateIndex = False

            ' Drop existing index
            sObjectName = IIf(objIndex.IsTableIndex, objTable.PhysicalName, objTable.Name)
            sSQL = String.Format("IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND name = N'{1}')" & _
                    "DROP INDEX [{1}] ON [dbo].[{0}]" _
                    , sObjectName, objIndex.Name)
            Globals.CommitDB.ScriptStatement(sSQL)

            ' Generate index contents
            aryColumns = New ArrayList
            If objIndex.IncludePrimaryKey Then aryColumns.Add("[ID] ASC")
            For Each objColumn In objIndex.Columns
              If objColumn.Table Is objTable Then
                aryColumns.Add(objColumn.Name & " ASC")
                bCreateIndex = True
              End If
            Next

            aryIncludeColumns = New ArrayList
            For Each objColumn In objIndex.IncludedColumns
              If Not objIndex.Columns.Contains(objColumn) Then
                If objColumn.Table Is objTable Then
                  aryIncludeColumns.Add(objColumn.Name)
                  bCreateIndex = True
                End If
              End If
            Next

            For Each objRelation In objIndex.Relations
              Select Case objRelation.RelationshipType
                Case RelationshipType.Child
                  aryColumns.Add(String.Format("[ID_{0}] ASC", CInt(objRelation.ParentID)))
                Case RelationshipType.Parent
                  aryColumns.Add(String.Format("[ID_{0}] ASC", CInt(objRelation.ChildID)))
              End Select
              bCreateIndex = True
            Next

            ' Create index
            sIncludeColumns = IIf(aryIncludeColumns.Count > 0, " INCLUDE (" & String.Join(", ", aryIncludeColumns.ToArray) & ")", "")
            sSQL = String.Format("CREATE NONCLUSTERED INDEX [{0}] ON [dbo].[{1}] " & _
                  "({2})" & _
                  "{3}" _
                  , objIndex.Name, sObjectName, String.Join(", ", aryColumns.ToArray), sIncludeColumns)

            If objIndex.Enabled And bCreateIndex Then
              Globals.CommitDB.ScriptStatement(sSQL)
            End If

          Next
        Next

      Catch ex As Exception
        Globals.ErrorLog.Add(HRProEngine.ErrorHandler.Section.UDFs, "Index", HRProEngine.ErrorHandler.Severity.Error, ex.Message, vbNullString)
        bOK = False
      End Try

      Return bOK

    End Function

    Private Function SpecialTrigger_BankHolidays(ByRef Table As Things.Table) As String

      Dim aryTriggerCode As ArrayList
      Dim lngColumnID As HCMGuid
      Dim objColumn As Things.Column
      Dim sCode As String = ""
      Dim objTriggeredUpdate As ScriptDB.TriggeredUpdate

      ' Special bank holiday update
      If Table Is Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableBHol").Table Then
        aryTriggerCode = New ArrayList

        lngColumnID = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldBHolDate").Value
        objColumn = Table.Column(lngColumnID)

        For Each objTriggeredUpdate In Globals.OnBankHolidayUpdate
          aryTriggerCode.Add(String.Format("    WITH base AS (" & vbNewLine &
              "        SELECT {0} FROM dbo.[{1}]" & vbNewLine & _
              "        INNER JOIN @dates bankholidays ON bankholidays.{2} {3})" & vbNewLine & _
              "    UPDATE base SET [{0}] = [{0}];" _
              , objTriggeredUpdate.Column.Name, objTriggeredUpdate.Column.Table.PhysicalName, objColumn.Name, objTriggeredUpdate.Where))
        Next

        If aryTriggerCode.Count > 0 Then
          sCode = vbNewLine & vbNewLine & String.Format(vbNewLine & "-- Bank Holiday update" & vbNewLine & _
                "DECLARE @dates TABLE ([{0}] datetime);" & vbNewLine &
                "INSERT @dates" & vbNewLine &
               "    SELECT [{0}] FROM inserted" & vbNewLine &
               "    UNION" & vbNewLine &
               "    SELECT [{0}] FROM deleted;" & vbNewLine & vbNewLine &
                "{1}", objColumn.Name, String.Join(vbNewLine & vbNewLine, aryTriggerCode.ToArray())) & vbNewLine
        End If
      End If

      Return sCode

    End Function

    Private Function SpecialTrigger_Personnel(ByRef Table As Things.Table) As String

      Dim sCode As String = ""
      Dim objAbsenceTable As Things.Table

      If Table Is Globals.ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table Then
        objAbsenceTable = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table
        If Not objAbsenceTable Is Nothing Then

          sCode = String.Format("    -- Statutory Sick Pay" & vbNewLine _
                  & "    IF EXISTS(SELECT [spid] FROM [tbsys_intransactiontrigger] WHERE [spid] = @@spid AND [tablefromid] = {0})" & vbNewLine _
                  & "        AND EXISTS(SELECT Name FROM sysobjects WHERE id = object_id('spsys_absencessp') AND sysstat & 0xf = 4)" & vbNewLine _
                  & "    BEGIN" & vbNewLine _
                  & "        SET @iCount = 0;" & vbNewLine _
                  & "        WHILE @iCount IS NOT NULL" & vbNewLine _
                  & "        BEGIN" & vbNewLine _
                  & "            EXEC dbo.[spsys_absencessp] @iCount;" & vbNewLine _
                  & "            SELECT @iCount=(SELECT MIN([ID]) FROM inserted WHERE [ID] > @iCount);" & vbNewLine _
                  & "        END" & vbNewLine _
                  & "    END;", CInt(objAbsenceTable.ID))
        End If
      End If

      Return sCode

    End Function


    Private Function SpecialTrigger_SSP(ByRef Table As Things.Table) As String

      Dim sCode As String = ""
      Dim objPersonnelTable As Things.Table
      Dim objColumn1 As Things.Column
      Dim objColumn2 As Things.Column
      Dim objColumn3 As Things.Column
      Dim objColumn4 As Things.Column
      Dim lngColumnID As HCMGuid


      If Table Is Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_TableAbsence").Table Then

        objPersonnelTable = Globals.ModuleSetup.Setting("MODULE_PERSONNEL", "Param_TablePersonnel").Table

        lngColumnID = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldSSPApplies").Value
        objColumn1 = Table.Column(lngColumnID)

        lngColumnID = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldQualifyingDays").Value
        objColumn2 = Table.Column(lngColumnID)

        lngColumnID = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldWaitingDays").Value
        objColumn3 = Table.Column(lngColumnID)

        lngColumnID = Globals.ModuleSetup.Setting("MODULE_ABSENCE", "Param_FieldPaidDays").Value
        objColumn4 = Table.Column(lngColumnID)

        If Not (objColumn1 Is Nothing Or objColumn2 Is Nothing Or objColumn3 Is Nothing Or objColumn4 Is Nothing Or objPersonnelTable Is Nothing) Then

          sCode = vbNewLine & String.Format("    -- SSP bypass" & vbNewLine _
                  & "    IF EXISTS (SELECT ID_{0} FROM inserted INNER JOIN dbo.[ASRSysSSPRunning] ON [PersonnelRecordID] = ID_{0} AND sspRunning = 1)" & vbNewLine _
                  & "    BEGIN" & vbNewLine _
                  & "        UPDATE dbo.[{1}]" & vbNewLine _
                  & "           SET [{2}] = inserted.[{2}]," & vbNewLine _
                  & "               [{3}] = inserted.[{3}]," & vbNewLine _
                  & "               [{4}] = inserted.[{4}]," & vbNewLine _
                  & "               [{5}] = inserted.[{5}]" & vbNewLine _
                  & "        FROM [inserted] WHERE [inserted].[id] = [dbo].[{1}].[id]" & vbNewLine _
                  & "        RETURN;" & vbNewLine _
                  & "    END;" & vbNewLine & vbNewLine _
                  , CInt(objPersonnelTable.ID), Table.PhysicalName _
                  , objColumn1.Name, objColumn2.Name, objColumn3.Name, objColumn4.Name)

        End If
      End If

      Return sCode

    End Function

  End Class

End Namespace

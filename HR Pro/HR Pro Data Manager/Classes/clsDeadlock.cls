VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsDeadlock"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

Private mblnFatalError As Boolean
Private mstrErrorString As String
Private Const iRETRIES = 5

Public Property Get ErrorString() As String
  ErrorString = mstrErrorString
End Property

Public Property Let ErrorString(ByVal sNewValue As String)
  mstrErrorString = sNewValue
End Property

Public Property Get FatalError() As Boolean
  FatalError = mblnFatalError
End Property

Public Property Let FatalError(ByVal bNewValue As Boolean)
  mblnFatalError = bNewValue
End Property

Public Function InsertTableRecord(psInsertSQL As String, _
  plngTableID As Long, _
  plngNewRecordID As Long) As Boolean
  ' Insert the given record in the given table.
  On Error GoTo ErrorTrap
  
  Dim fInsertedOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sSQL As String
  Dim sErrorMsg As String
  Dim rsInfo As Recordset
  Dim cmADO As ADODB.Command
  Dim pmADO As ADODB.Parameter
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
  
  ' Clear the properties each time we run the function
  ClearProperties
  
  iOldCursorLocation = gADOCon.CursorLocation
  fInsertedOK = True
  iRetryCount = 0
  
  ' Check that the required update stored procedure exists.
  sSQL = "SELECT COUNT(*) as recCount" & _
    " FROM sysobjects" & _
    " WHERE type = 'P'" & _
    " AND name = 'sp_ASRInsertNewRecord_" & Trim(Str(plngTableID)) & "'"
  Set rsInfo = datGeneral.GetRecords(sSQL)
  fInsertedOK = (rsInfo!recCount > 0)
  rsInfo.Close
  Set rsInfo = Nothing
          
  If Not fInsertedOK Then
    mblnFatalError = True
    mstrErrorString = "The new record(s) could not be created." & vbCrLf & vbCrLf & _
      "The required stored procedure 'sp_ASRInsertNewRecord_" & Trim(Str(plngTableID)) & "' does not exist."
  Else
    Set cmADO = New ADODB.Command
    With cmADO
      .CommandText = "dbo.sp_ASRInsertNewRecord_" & Trim(Str(plngTableID))
      .CommandType = adCmdStoredProc
      .CommandTimeout = 0
      Set .ActiveConnection = gADOCon
              
      Set pmADO = .CreateParameter("newID", adInteger, adParamOutput)
      .Parameters.Append pmADO
    
      Set pmADO = .CreateParameter("insertString", adLongVarChar, adParamInput, -1)
      .Parameters.Append pmADO
      pmADO.Value = psInsertSQL
              
      Set pmADO = Nothing
  
      fDeadlock = True
      Do While fDeadlock
        fDeadlock = False
                
        ' Change the cursor location to 'client' as the errors that might be raised
        ' during the update cannot be read for 'server' cursors.
        gADOCon.Errors.Clear
        gADOCon.CursorLocation = adUseClient
              
        On Error GoTo InsertErrorTrap
InsertDeadlockRecoveryPoint:
        cmADO.Execute
        On Error GoTo ErrorTrap
    
        ' Restore the original cursor location to the ADO connection object.
        gADOCon.CursorLocation = iOldCursorLocation
              
        ' Check if the update prodcued any errors.
        If gADOCon.Errors.Count > 0 Then
          sErrorMsg = ""
                  
          For Each ADOErr In gADOCon.Errors
            ' If any 'deadlocks' occur, try to save changes again.
            ' Do this a few times and if errors still occur then display a more friendly
            ' error message than the ' deadlock victim' one generated by ODBC.
            If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
              (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
                (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
              ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
                (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    
              ' The error is for a deadlock.
              ' Sorry about having to use the err.description to trap the error but the err.number
              ' is not specific and MSDN suggests using the err.description.
              If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
                iRetryCount = iRetryCount + 1
                fDeadlock = True
              Else
                sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                  "Another user is deadlocking the database."
                fInsertedOK = False
              End If
            Else
              sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                ADOErr.Description
              fInsertedOK = False
            End If
          Next ADOErr
    
          gADOCon.Errors.Clear

          If Not fInsertedOK Then
            mstrErrorString = "The new record could not be created." & vbCrLf & vbCrLf & _
              sErrorMsg
          End If
        Else
          plngNewRecordID = IIf(IsNull(.Parameters(0).Value), 0, .Parameters(0).Value)
        End If
      Loop
    End With
    Set cmADO = Nothing
  End If
  
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  InsertTableRecord = fInsertedOK
  Exit Function

ErrorTrap:
  fInsertedOK = False
  COAMsgBox ODBC.FormatError(Err.Description), vbExclamation + vbOKOnly, Application.Name
  Resume TidyUpAndExit

InsertErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      Resume InsertDeadlockRecoveryPoint
    Else
      fInsertedOK = False
      mstrErrorString = "The new record could not be created." & vbCrLf & vbCrLf & _
        "Another user is deadlocking the database."
      Resume TidyUpAndExit
    End If
  Else
    fInsertedOK = False
    mstrErrorString = ODBC.FormatError(Err.Description)
    Resume TidyUpAndExit
  End If
  
End Function


Public Function InsertTableRecordJustDoIt(psInsertSQL As String) As Boolean
  ' Insert the given record in the given table.
  On Error GoTo ErrorTrap
  
  Dim fInsertedOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sSQL As String
  Dim sErrorMsg As String
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
  
  ' Clear the properties each time we run the function
  ClearProperties
  
  iOldCursorLocation = gADOCon.CursorLocation
  fInsertedOK = True
  iRetryCount = 0
  
  fDeadlock = True
  Do While fDeadlock
    fDeadlock = False
            
    ' Change the cursor location to 'client' as the errors that might be raised
    ' during the update cannot be read for 'server' cursors.
    gADOCon.Errors.Clear
    gADOCon.CursorLocation = adUseClient
          
    On Error GoTo InsertErrorTrap
InsertDeadlockRecoveryPoint:
    gADOCon.Execute psInsertSQL
    On Error GoTo ErrorTrap
    
    ' Restore the original cursor location to the ADO connection object.
    gADOCon.CursorLocation = iOldCursorLocation
          
    ' Check if the update prodcued any errors.
    If gADOCon.Errors.Count > 0 Then
      sErrorMsg = ""
              
      For Each ADOErr In gADOCon.Errors
        ' If any 'deadlocks' occur, try to save changes again.
        ' Do this a few times and if errors still occur then display a more friendly
        ' error message than the ' deadlock victim' one generated by ODBC.
        If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
          (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
            (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
          ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
            (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    
          ' The error is for a deadlock.
          ' Sorry about having to use the err.description to trap the error but the err.number
          ' is not specific and MSDN suggests using the err.description.
          If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
            iRetryCount = iRetryCount + 1
            fDeadlock = True
          Else
            sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
              "Another user is deadlocking the database."
            fInsertedOK = False
          End If
        Else
          sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
            ADOErr.Description
          fInsertedOK = False
        End If
      Next ADOErr
    
      gADOCon.Errors.Clear
  
      If Not fInsertedOK Then
        mstrErrorString = "The new record could not be created." & vbCrLf & vbCrLf & _
          sErrorMsg
      End If
    End If
  Loop
  
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  InsertTableRecordJustDoIt = fInsertedOK
  Exit Function

ErrorTrap:
  fInsertedOK = False
  COAMsgBox ODBC.FormatError(Err.Description), vbExclamation + vbOKOnly, Application.Name
  Resume TidyUpAndExit

InsertErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      Resume InsertDeadlockRecoveryPoint
    Else
      fInsertedOK = False
      mstrErrorString = "The new record could not be created." & vbCrLf & vbCrLf & _
        "Another user is deadlocking the database."
      Resume TidyUpAndExit
    End If
  Else
    fInsertedOK = False
    mstrErrorString = ODBC.FormatError(Err.Description)
    Resume TidyUpAndExit
  End If
  
End Function



Public Function DeleteTableRecord(plngTableID As Long, _
  psRealSource As String, _
  plngRecordID As Long) As Boolean
  ' Insert the given record in the given table.
  On Error GoTo ErrorTrap
  
  Dim fDeletedOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sSQL As String
  Dim sErrorMsg As String
  Dim rsInfo As Recordset
  Dim cmADO As ADODB.Command
  Dim pmADO As ADODB.Parameter
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
  
  ' Clear the properties each time we run the function
  ClearProperties
  
  iOldCursorLocation = gADOCon.CursorLocation
  fDeletedOK = True
  iRetryCount = 0
  
  ' Check that the required update stored procedure exists.
  sSQL = "SELECT COUNT(*) as recCount" & _
    " FROM sysobjects" & _
    " WHERE type = 'P'" & _
    " AND name = 'sp_ASRDeleteRecord_" & Trim(Str(plngTableID)) & "'"
  Set rsInfo = datGeneral.GetRecords(sSQL)
  fDeletedOK = (rsInfo!recCount > 0)
  rsInfo.Close
  Set rsInfo = Nothing
          
  If Not fDeletedOK Then
    mstrErrorString = "The record could not be deleted." & vbCrLf & vbCrLf & _
      "The required stored procedure 'sp_ASRDeleteRecord_" & Trim(Str(plngTableID)) & "' does not exist."
    mblnFatalError = True
  Else
    Set cmADO = New ADODB.Command
    With cmADO
      .CommandText = "sp_ASRDeleteRecord_" & Trim(Str(plngTableID))
      .CommandType = adCmdStoredProc
      .CommandTimeout = 0
      Set .ActiveConnection = gADOCon
              
      Set pmADO = .CreateParameter("resultCode", adInteger, adParamOutput)
      .Parameters.Append pmADO
    
      Set pmADO = .CreateParameter("realSource", adVarChar, adParamInput, 255)
      .Parameters.Append pmADO
      pmADO.Value = psRealSource
      
      Set pmADO = .CreateParameter("id", adInteger, adParamInput)
      .Parameters.Append pmADO
      pmADO.Value = plngRecordID
              
      Set pmADO = Nothing
  
      fDeadlock = True
      Do While fDeadlock
        fDeadlock = False
                
        ' Change the cursor location to 'client' as the errors that might be raised
        ' during the update cannot be read for 'server' cursors.
        gADOCon.Errors.Clear
        gADOCon.CursorLocation = adUseClient
              
        On Error GoTo DeleteErrorTrap
DeleteDeadlockRecoveryPoint:
        cmADO.Execute
        On Error GoTo ErrorTrap
    
        ' Restore the original cursor location to the ADO connection object.
        gADOCon.CursorLocation = iOldCursorLocation
              
        ' Check if the update prodcued any errors.
        If gADOCon.Errors.Count > 0 Then
          sErrorMsg = ""
                  
          For Each ADOErr In gADOCon.Errors
            ' If any 'deadlocks' occur, try to save changes again.
            ' Do this a few times and if errors still occur then display a more friendly
            ' error message than the ' deadlock victim' one generated by ODBC.
            If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
              (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
                (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
              ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
                (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    
              ' The error is for a deadlock.
              ' Sorry about having to use the err.description to trap the error but the err.number
              ' is not specific and MSDN suggests using the err.description.
              If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
                iRetryCount = iRetryCount + 1
                fDeadlock = True
              Else
                sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                  "Another user is deadlocking the database."
                fDeletedOK = False
              End If
            Else
              sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                ADOErr.Description
              fDeletedOK = False
            End If
          Next ADOErr
    
          gADOCon.Errors.Clear

          If Not fDeletedOK Then
            mstrErrorString = "The record could not be deleted." & vbCrLf & vbCrLf & sErrorMsg
          End If
        Else
          Select Case .Parameters(0).Value
            Case 2 ' Record has been amended AND is no longer in the given table/view.
              mstrErrorString = "The record has been amended by another user and is no longer in the current view."
            Case Else ' Record deleted OK.
          End Select
        End If
      Loop
    End With
    Set cmADO = Nothing
  End If
  
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  DeleteTableRecord = fDeletedOK
  Exit Function

ErrorTrap:
  fDeletedOK = False
  mstrErrorString = ODBC.FormatError(Err.Description)
  Resume TidyUpAndExit

DeleteErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      Resume DeleteDeadlockRecoveryPoint
    Else
      fDeletedOK = False
      mstrErrorString = "The record could not be deleted." & vbCrLf & vbCrLf & _
        "Another user is deadlocking the database."
      Resume TidyUpAndExit
    End If
  Else
    fDeletedOK = False
    mstrErrorString = ODBC.FormatError(Err.Description)
    Resume TidyUpAndExit
  End If
  
End Function

Public Function UpdateTableRecord(psUpdateSQL As String, _
  plngTableID As Long, _
  psRealSource As String, _
  plngRecordID As Long, _
  Optional pvTimestamp As Variant) As Boolean
  ' Update the given table with the given SQL update command.
  On Error GoTo ErrorTrap
  
  Dim fUpdatedOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sSQL As String
  Dim sErrorMsg As String
  Dim rsInfo As Recordset
  Dim cmADO As ADODB.Command
  Dim pmADO As ADODB.Parameter
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC


  ' Clear the properties each time we run the function
  ClearProperties
  
  iOldCursorLocation = gADOCon.CursorLocation
  fUpdatedOK = True
  iRetryCount = 0
  
  ' Check that the required update stored procedure exists.
  sSQL = "SELECT COUNT(*) as recCount" & _
    " FROM sysobjects" & _
    " WHERE type = 'P'" & _
    " AND name = 'sp_ASRUpdateRecord_" & Trim(Str(plngTableID)) & "'"
  Set rsInfo = datGeneral.GetRecords(sSQL)
  fUpdatedOK = (rsInfo!recCount > 0)
  rsInfo.Close
  Set rsInfo = Nothing
          
  If Not fUpdatedOK Then
    mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & _
      "The required stored procedure 'sp_ASRUpdateRecord_" & Trim(Str(plngTableID)) & "' does not exist."
    mblnFatalError = True
  Else
    Set cmADO = New ADODB.Command
    With cmADO
      .CommandText = "sp_ASRUpdateRecord_" & Trim(Str(plngTableID))
      .CommandType = adCmdStoredProc
      .CommandTimeout = 0
      Set .ActiveConnection = gADOCon
              
      Set pmADO = .CreateParameter("resultCode", adInteger, adParamOutput)
      .Parameters.Append pmADO
            
      Set pmADO = .CreateParameter("updateString", adLongVarChar, adParamInput, -1)
      .Parameters.Append pmADO
      pmADO.Value = psUpdateSQL
              
      Set pmADO = .CreateParameter("realSource", adVarChar, adParamInput, 255)
      .Parameters.Append pmADO
      pmADO.Value = psRealSource
              
      Set pmADO = .CreateParameter("id", adInteger, adParamInput)
      .Parameters.Append pmADO
      pmADO.Value = plngRecordID
              
      Set pmADO = .CreateParameter("timestamp", adInteger, adParamInput)
      .Parameters.Append pmADO
      If IsMissing(pvTimestamp) Then
        pmADO.Value = Null
      Else
        pmADO.Value = CLng(pvTimestamp)
      End If

      Set pmADO = Nothing
  
      fDeadlock = True
      Do While fDeadlock
        fDeadlock = False
                
        ' Change the cursor location to 'client' as the errors that might be raised
        ' during the update cannot be read for 'server' cursors.
        gADOCon.Errors.Clear
        gADOCon.CursorLocation = adUseClient
              
        On Error GoTo UpdateErrorTrap
UpdateDeadlockRecoveryPoint:
        cmADO.Execute
        On Error GoTo ErrorTrap
    
        ' Restore the original cursor location to the ADO connection object.
        gADOCon.CursorLocation = iOldCursorLocation
              
        ' Check if the update prodcued any errors.
        If gADOCon.Errors.Count > 0 Then
          sErrorMsg = ""
                  
          For Each ADOErr In gADOCon.Errors
            ' If any 'deadlocks' occur, try to save changes again.
            ' Do this a few times and if errors still occur then display a more friendly
            ' error message than the ' deadlock victim' one generated by ODBC.
            If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
              (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
                (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
              ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
                (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    
              ' The error is for a deadlock.
              ' Sorry about having to use the err.description to trap the error but the err.number
              ' is not specific and MSDN suggests using the err.description.
              If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
                iRetryCount = iRetryCount + 1
                fDeadlock = True
              Else
                sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                  "Another user is deadlocking the database."
                fUpdatedOK = False
              End If
            Else
              sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                ADOErr.Description
              fUpdatedOK = False
            End If
          Next ADOErr
    
          gADOCon.Errors.Clear

          If Not fUpdatedOK Then
            mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & sErrorMsg
          End If
        Else
          Select Case .Parameters(0).Value
            Case 1 ' Record changed by another user, and still in the current table/view.
              mstrErrorString = "The record has been amended by another user and will be refreshed."
            Case 2 ' Record changed by another user, and is no longer in the current table/view.
              mstrErrorString = "The record has been amended by another user and is no longer in the current view."
            Case 3 ' Record deleted by another user.
              mstrErrorString = "The record has been deleted by another user."
            Case Else ' Record updated OK.
              
          End Select
        End If
      Loop
    End With
    Set cmADO = Nothing
  End If
  
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  UpdateTableRecord = fUpdatedOK
  Exit Function

ErrorTrap:
  fUpdatedOK = False
  mstrErrorString = ODBC.FormatError(Err.Description)
  Resume TidyUpAndExit

UpdateErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      Resume UpdateDeadlockRecoveryPoint
    Else
      fUpdatedOK = False
      mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & _
        "Another user is deadlocking the database."
      Resume TidyUpAndExit
    End If
  Else
    fUpdatedOK = False
    mstrErrorString = ODBC.FormatError(Err.Description)
    Resume TidyUpAndExit
  End If
  
End Function


Public Function UpdateTableRecordJustDoIt(psUpdateSQL As String) As Boolean
  ' Update the given table with the given SQL update command.
  On Error GoTo ErrorTrap
  
  Dim fUpdatedOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sSQL As String
  Dim sErrorMsg As String
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
  Dim lngRecordsAffected As Long
  Dim lngOriginalTimeout As Long


  ' Clear the properties each time we run the function
  ClearProperties
  
  iOldCursorLocation = gADOCon.CursorLocation
  lngOriginalTimeout = gADOCon.CommandTimeout
  fUpdatedOK = True
  iRetryCount = 0
  
'  gADOCon.CommandTimeout = 60
  fDeadlock = True
  Do While fDeadlock
    fDeadlock = False
                
    ' Change the cursor location to 'client' as the errors that might be raised
    ' during the update cannot be read for 'server' cursors.
    gADOCon.Errors.Clear
    gADOCon.CursorLocation = adUseClient
              
        On Error GoTo UpdateErrorTrap
UpdateDeadlockRecoveryPoint:
        'gADOCon.Execute psUpdateSQL, , adExecuteNoRecords
        gADOCon.Execute psUpdateSQL, lngRecordsAffected, adExecuteNoRecords
       
       lngRecordsAffected = 1
       
        On Error GoTo ErrorTrap
    
        ' Restore the original cursor location to the ADO connection object.
        gADOCon.CursorLocation = iOldCursorLocation
              
        ' Check if the update prodcued any errors.
        If gADOCon.Errors.Count > 0 Then
          sErrorMsg = ""
                  
          For Each ADOErr In gADOCon.Errors
            ' If any 'deadlocks' occur, try to save changes again.
            ' Do this a few times and if errors still occur then display a more friendly
            ' error message than the ' deadlock victim' one generated by ODBC.
            If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
              (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
                (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
              ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
                (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    
              ' The error is for a deadlock.
              ' Sorry about having to use the err.description to trap the error but the err.number
              ' is not specific and MSDN suggests using the err.description.
              If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
                iRetryCount = iRetryCount + 1
                fDeadlock = True
              Else
                sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                  "Another user is deadlocking the database."
                fUpdatedOK = False
              End If
            Else
              sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
                ADOErr.Description
              fUpdatedOK = False
            End If
          Next ADOErr
    
          gADOCon.Errors.Clear

          If Not fUpdatedOK Then
            mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & sErrorMsg
          End If
        End If
      Loop
    
  
  
TidyUpAndExit:
  If fUpdatedOK And lngRecordsAffected < 1 Then
    mstrErrorString = "The record could not be updated." & vbCrLf & IIf(lngRecordsAffected = 0, "No matching record(s) found.", "")
    fUpdatedOK = False
  End If

  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  
  gADOCon.CommandTimeout = lngOriginalTimeout
  Set ODBC = Nothing
  UpdateTableRecordJustDoIt = fUpdatedOK
  Exit Function

ErrorTrap:
  fUpdatedOK = False
  mstrErrorString = ODBC.FormatError(Err.Description)
  Resume TidyUpAndExit

UpdateErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      Resume UpdateDeadlockRecoveryPoint
    Else
      fUpdatedOK = False
      mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & _
        "Another user is deadlocking the database."
      Resume TidyUpAndExit
    End If
       
'  ' Query timeout
'  ElseIf (Err.Number = QUERYTIMEOUT_ERRORNUMBER) _
'    And LCase(Err.Description) = LCase(QUERYTIMEOUT_ERRORMESSAGE) Then
'    If iRetryCount < iRETRIES Then
'      iRetryCount = iRetryCount + 1
'      Resume UpdateDeadlockRecoveryPoint
'    Else
'      fUpdatedOK = False
'      mstrErrorString = "The record could not be updated." & vbCrLf & vbCrLf & _
'        "Another user is deadlocking the database."
'      Resume TidyUpAndExit
'    End If

  Else
    fUpdatedOK = False
    mstrErrorString = ODBC.FormatError(Err.Description)
    Resume TidyUpAndExit
  End If
  
End Function

Private Sub ClearProperties()
  
  mblnFatalError = False
  mstrErrorString = vbNullString

End Sub

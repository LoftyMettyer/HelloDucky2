VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsDataAccess"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

Public Function OpenRecordset(sSQL As String, CursorType As ADODB.CursorTypeEnum, _
  LockType As ADODB.LockTypeEnum, Optional varCursorLocation As Variant) As ADODB.Recordset
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.OpenRecordset(sSQL,CursorType,LockType)", Array(sSQL, CursorType, LockType)
  
  ' Open a recordset from the given SQL query, with the given recordset properties.
  Dim rsTemp As ADODB.Recordset
  Dim fDoneOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sErrorMsg As String
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
    
  Const iRETRIES = 5
  Const iPAUSE = 5000
    
  iOldCursorLocation = gADOCon.CursorLocation
  fDoneOK = True
  iRetryCount = 0
    
  'JPD 20031120 Fault 7677
  If IsMissing(varCursorLocation) Then
    varCursorLocation = adUseClient
  End If

  Set rsTemp = New ADODB.Recordset
  
  fDeadlock = True
  Do While fDeadlock
    fDeadlock = False
    
    ' Change the cursor location to 'client' as the errors that might be raised
    ' during the update cannot be read for 'server' cursors.
    gADOCon.Errors.Clear
    
    'JPD 20031120 Fault 7677
    gADOCon.CursorLocation = varCursorLocation
          
    On Error GoTo DeadlockErrorTrap
DeadlockRecoveryPoint:
    rsTemp.Open sSQL, gADOCon, CursorType, LockType, adCmdText

    gADOCon.CursorLocation = iOldCursorLocation
          
    ' Check if the update prodcued any errors.
    If gADOCon.Errors.Count > 0 Then
      sErrorMsg = ""
    
      For Each ADOErr In gADOCon.Errors
        ' If any 'deadlocks' occur, try to save changes again.
        ' Do this a few times and if errors still occur then display a more friendly
        ' error message than the ' deadlock victim' one generated by ODBC.
        If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
          (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
            (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
          ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
            (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then

          ' The error is for a deadlock.
          ' Sorry about having to use the err.description to trap the error but the err.number
          ' is not specific and MSDN suggests using the err.description.
          If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
            iRetryCount = iRetryCount + 1
            fDeadlock = True
            ' Pause before resubmitting the SQL command.
            Sleep iPAUSE
          Else
            sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
              "Another user is deadlocking the database."
            fDoneOK = False
          End If
        Else
          sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
            ADOErr.Description
          fDoneOK = False
        End If
      Next ADOErr
    
      gADOCon.Errors.Clear
  
      If Not fDoneOK Then
        If gobjProgress.Visible Then
          gobjProgress.CloseProgress
        End If
        MsgBox "ERROR." & vbCrLf & vbCrLf & _
          sErrorMsg, vbOKOnly + vbExclamation, App.ProductName
      End If
    End If

    If fDoneOK And (Not fDeadlock) Then
      Set OpenRecordset = rsTemp
    End If
  Loop
        
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  
  gobjErrorStack.PopStack
  Exit Function

ErrorTrap:
  fDoneOK = False
  gobjErrorStack.HandleError
  Exit Function

DeadlockErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      ' Pause before resubmitting the SQL command.
      Sleep iPAUSE
      Resume DeadlockRecoveryPoint
    Else
      fDoneOK = False
      If gobjProgress.Visible Then
        gobjProgress.CloseProgress
      End If
      MsgBox "Another user is deadlocking the database.", _
        vbExclamation + vbOKOnly, Application.Name
      gobjErrorStack.HandleError
      Resume TidyUpAndExit
    End If
  ElseIf InStr(1, Err.Description, CONNECTIONBROKEN_MESSAGE, vbTextCompare) Then
    datGeneral.ReEstablishADOConnection
    Resume DeadlockRecoveryPoint
  ElseIf InStr(1, Err.Description, FRAMEWORK_MESSAGE, vbTextCompare) Then
    fDoneOK = False
    If gobjProgress.Visible Then
      gobjProgress.CloseProgress
    End If
    Resume TidyUpAndExit
  Else
    fDoneOK = False
    If gobjProgress.Visible Then
      gobjProgress.CloseProgress
    End If
    MsgBox ODBC.FormatError(Err.Description), vbExclamation + vbOKOnly, Application.Name
    gobjErrorStack.HandleError
    Resume TidyUpAndExit
  End If

End Function

Public Function OpenPersistentRecordset(sSQL As String, CursorType As ADODB.CursorTypeEnum, _
  LockType As ADODB.LockTypeEnum) As ADODB.Recordset
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.OpenPersistentRecordset(sSQL,CursorType,LockType)", Array(sSQL, CursorType, LockType)
  
  ' Open a recordset from the given SQL query, with the given recordset properties.
  Dim rsTemp As ADODB.Recordset
    
  Set rsTemp = New ADODB.Recordset

  rsTemp.ActiveConnection = gADOCon
  rsTemp.Properties("Preserve On Commit") = True
  rsTemp.Properties("Preserve On Abort") = True
  rsTemp.Open sSQL, , CursorType, LockType, adCmdText
  
  Set OpenPersistentRecordset = rsTemp
        
TidyUpAndExit:
  gobjErrorStack.PopStack
  Exit Function
ErrorTrap:
  gobjErrorStack.HandleError
  
End Function

Public Sub ExecuteSql(sSQL As String)
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.ExecuteSql(sSQL)", Array(sSQL)
  
  ' Execute the given SQL statement.
  gADOCon.Execute sSQL, , adCmdText

TidyUpAndExit:
  gobjErrorStack.PopStack
  Exit Sub
ErrorTrap:
  gobjErrorStack.HandleError

End Sub

Public Function ExecuteSqlReturnAffected(sSQL As String) As Long
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.ExecuteSqlReturnAffected(sSQL)", Array(sSQL)
  
  ' Execute the given SQL statement, and return the number of rows affected.
  Dim lngAffected As Long
    
  gADOCon.Execute sSQL, lngAffected, adCmdText
  ExecuteSqlReturnAffected = lngAffected

TidyUpAndExit:
  gobjErrorStack.PopStack
  Exit Function
ErrorTrap:
  gobjErrorStack.HandleError

End Function


Public Function OpenRecordsetAsync(sSQL As String, CursorType As ADODB.CursorTypeEnum, _
  LockType As ADODB.LockTypeEnum) As ADODB.Recordset
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.OpenRecordsetAsync(sSQL,CursorType,LockType)", Array(sSQL, CursorType, LockType)
  
  ' Open a recordset from the given SQL query, with the given recordset properties.
  Dim rsTemp As ADODB.Recordset
    
  Set rsTemp = New ADODB.Recordset
  rsTemp.Open sSQL, gADOCon, CursorType, LockType, adCmdText + adAsyncExecute
  
  Do While rsTemp.State = adStateExecuting And gobjProgress.Cancelled = False
    DoEvents
  Loop


  Set OpenRecordsetAsync = rsTemp
        
TidyUpAndExit:
  gobjErrorStack.PopStack
  Exit Function
ErrorTrap:
  gobjErrorStack.HandleError

End Function

Public Function OpenTableDirect(sSQL As String, CursorType As ADODB.CursorTypeEnum, _
  LockType As ADODB.LockTypeEnum, Optional varCursorLocation As Variant) As ADODB.Recordset
  
  On Error GoTo ErrorTrap
  gobjErrorStack.PushStack "clsDataAccess.OpenRecordset(sSQL,CursorType,LockType)", Array(sSQL, CursorType, LockType)
  
  ' Open a recordset from the given SQL query, with the given recordset properties.
  Dim rsTemp As ADODB.Recordset
  Dim fDoneOK As Boolean
  Dim fDeadlock As Boolean
  Dim iRetryCount As Integer
  Dim iOldCursorLocation As Integer
  Dim sErrorMsg As String
  Dim ADOErr As ADODB.Error
  Dim ODBC As New ODBC
    
  Const iRETRIES = 5
  Const iPAUSE = 5000
    
  iOldCursorLocation = gADOCon.CursorLocation
  fDoneOK = True
  iRetryCount = 0
    
  'JPD 20031120 Fault 7677
  If IsMissing(varCursorLocation) Then
    varCursorLocation = adUseClient
  End If
  
  Set rsTemp = New ADODB.Recordset
  
  fDeadlock = True
  Do While fDeadlock
    fDeadlock = False
    
    ' Change the cursor location to 'client' as the errors that might be raised
    ' during the update cannot be read for 'server' cursors.
    gADOCon.Errors.Clear
    
    'JPD 20031120 Fault 7677
    gADOCon.CursorLocation = varCursorLocation
          
    On Error GoTo DeadlockErrorTrap
DeadlockRecoveryPoint:
    rsTemp.Open sSQL, gADOCon, CursorType, LockType, adCmdTableDirect

    gADOCon.CursorLocation = iOldCursorLocation
          
    ' Check if the update prodcued any errors.
    If gADOCon.Errors.Count > 0 Then
      sErrorMsg = ""
    
      For Each ADOErr In gADOCon.Errors
        ' If any 'deadlocks' occur, try to save changes again.
        ' Do this a few times and if errors still occur then display a more friendly
        ' error message than the ' deadlock victim' one generated by ODBC.
        If (ADOErr.Number = DEADLOCK_ERRORNUMBER) And _
          (((UCase(Left(ADOErr.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
            (UCase(Right(ADOErr.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
          ((UCase(Left(ADOErr.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
            (InStr(UCase(ADOErr.Description), DEADLOCK2_MESSAGEEND) > 0))) Then

          ' The error is for a deadlock.
          ' Sorry about having to use the err.description to trap the error but the err.number
          ' is not specific and MSDN suggests using the err.description.
          If (iRetryCount < iRETRIES) And (gADOCon.Errors.Count = 1) Then
            iRetryCount = iRetryCount + 1
            fDeadlock = True
            ' Pause before resubmitting the SQL command.
            Sleep iPAUSE
          Else
            sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
              "Another user is deadlocking the database."
            fDoneOK = False
          End If
        Else
          sErrorMsg = sErrorMsg & IIf(Len(sErrorMsg) > 0, vbCrLf, "") & _
            ADOErr.Description
          fDoneOK = False
        End If
      Next ADOErr
    
      gADOCon.Errors.Clear
  
      If Not fDoneOK Then
        If gobjProgress.Visible Then
          gobjProgress.CloseProgress
        End If
        MsgBox "ERROR." & vbCrLf & vbCrLf & _
          sErrorMsg, vbOKOnly + vbExclamation, App.ProductName
      End If
    End If

    If fDoneOK And (Not fDeadlock) Then
      Set OpenTableDirect = rsTemp
    End If
  Loop
        
TidyUpAndExit:
  If (iOldCursorLocation = adUseClient) Or _
    (iOldCursorLocation = adUseServer) Then
    gADOCon.CursorLocation = iOldCursorLocation
  Else
    gADOCon.CursorLocation = adUseServer
  End If
  Set ODBC = Nothing
  
  gobjErrorStack.PopStack
  Exit Function

ErrorTrap:
  fDoneOK = False
  gobjErrorStack.HandleError
  Exit Function

DeadlockErrorTrap:
  ' If any 'deadlocks' occur, try to save changes again.
  ' Do this a few times and if errors still occur then display a more friendly
  ' error message than the 'deadlock victim' one generated by ODBC.
  If (Err.Number = DEADLOCK_ERRORNUMBER) And _
    (((UCase(Left(Err.Description, Len(DEADLOCK_MESSAGESTART))) = DEADLOCK_MESSAGESTART) And _
      (UCase(Right(Err.Description, Len(DEADLOCK_MESSAGEEND))) = DEADLOCK_MESSAGEEND)) Or _
    ((UCase(Left(Err.Description, Len(DEADLOCK2_MESSAGESTART))) = DEADLOCK2_MESSAGESTART) And _
      (InStr(UCase(Err.Description), DEADLOCK2_MESSAGEEND) > 0))) Then
    ' The error is for a deadlock.
    ' Sorry about having to use the err.description to trap the error but the err.number
    ' is not specific and MSDN suggests using the err.description.
    If iRetryCount < iRETRIES Then
      iRetryCount = iRetryCount + 1
      ' Pause before resubmitting the SQL command.
      Sleep iPAUSE
      Resume DeadlockRecoveryPoint
    Else
      fDoneOK = False
      If gobjProgress.Visible Then
        gobjProgress.CloseProgress
      End If
      MsgBox "Another user is deadlocking the database.", _
        vbExclamation + vbOKOnly, Application.Name
      gobjErrorStack.HandleError
      Resume TidyUpAndExit
    End If
  ElseIf InStr(1, Err.Description, CONNECTIONBROKEN_MESSAGE, vbTextCompare) Then
    datGeneral.ReEstablishADOConnection
    Resume DeadlockRecoveryPoint
  Else
    fDoneOK = False
    If gobjProgress.Visible Then
      gobjProgress.CloseProgress
    End If
    MsgBox ODBC.FormatError(Err.Description), vbExclamation + vbOKOnly, Application.Name
    gobjErrorStack.HandleError
    Resume TidyUpAndExit
  End If

End Function

Attribute VB_Name = "modPersonnelSpecifics"
Option Explicit
Public Function ConfigurePersonnelSpecifics() As Boolean

  ' Configure module specific objects (eg. stored procedures)
  On Error GoTo ErrorTrap
  
  Dim mvar_fGeneralOK As Boolean
  Dim mvar_sGeneralMsg As String
  Dim fOK As Boolean
  Dim sErrorMessage As String
  
  mvar_fGeneralOK = True
  mvar_sGeneralMsg = ""
  fOK = True
  
  If gbEnableUDFFunctions Then
    fOK = CreateCapitaliseInitialsUDF
    fOK = CreateInitialsFromForenamesUDF
  End If
    
  If fOK Then
    fOK = CreateSP_GetCurrentUserRecordID
  End If
  
  If fOK Then
    fOK = CreateSP_CalculateHeadcount
  End If
  
  If fOK Then
    sErrorMessage = ""
    If (Not mvar_fGeneralOK) Then
      sErrorMessage = "Personnel specifics not correctly configured." & vbNewLine & _
        "Some functionality will be disabled if you do not change your configuration." & mvar_sGeneralMsg
      
      fOK = (OutputMessage(sErrorMessage & vbNewLine & vbNewLine & "Continue saving changes ?") = vbYes)
    End If
  End If
  
TidyUpAndExit:
  ConfigurePersonnelSpecifics = fOK
  Exit Function
  
ErrorTrap:
  OutputError "Error configuring Personnel specifics"
  fOK = False
  Resume TidyUpAndExit

End Function

Public Function CreateSP_CalculateHeadcount() As Boolean

  Dim sProcSQL As String
  Dim iTempID As Integer
  Dim iPersonnelTableID As Integer
  Dim sPersonnelTableName As String
  Dim sLeavingDateColumn As String
  Dim sStartDateColumn As String
  Dim fCreatedOK As Boolean

  On Error GoTo ErrorTrap

  fCreatedOK = True

  ' Get the Personnel Table ID and Name
  iTempID = 0
  recModuleSetup.Index = "idxModuleParameter"
  recModuleSetup.Seek "=", gsMODULEKEY_PERSONNEL, "Param_TablePersonnel"
  If Not recModuleSetup.NoMatch Then
    iTempID = recModuleSetup!parametervalue
    iPersonnelTableID = iTempID
    recTabEdit.Index = "idxTableID"
    recTabEdit.Seek "=", iTempID
    If Not recTabEdit.NoMatch Then
      sPersonnelTableName = FormatTableName("dbo", recTabEdit!TableName)
    Else
      iPersonnelTableID = 0
      sPersonnelTableName = vbNullString
    End If
  Else
    iPersonnelTableID = 0
    sPersonnelTableName = vbNullString
  End If

      
  sStartDateColumn = GetColumnNameFromModuleSetup(gsMODULEKEY_PERSONNEL, gsPARAMETERKEY_STARTDATE)
  sLeavingDateColumn = GetColumnNameFromModuleSetup(gsMODULEKEY_PERSONNEL, gsPARAMETERKEY_LEAVINGDATE)

  DropProcedure "spASRCalculateHeadcounts"

  sProcSQL = "/* ------------------------------------------------ */" & vbNewLine & _
      "/* Personnel module stored procedure.        */" & vbNewLine & _
      "/* Automatically generated by the System manager.   */" & vbNewLine & _
      "/* ------------------------------------------------ */" & vbNewLine & _
      "CREATE PROCEDURE dbo.spASRCalculateHeadcounts" & vbNewLine & _
      "WITH ENCRYPTION" & vbNewLine & _
      "AS " & vbNewLine & _
      "BEGIN" & vbNewLine & _
      "  SET NOCOUNT ON;" & vbNewLine & vbNewLine & _
      "  DECLARE @TaxYearStart datetime = GETDATE()," & vbNewLine & _
      "    @TaxYearEnd   datetime," & vbNewLine & _
      "    @TaxYearStartDay varchar(6)," & vbNewLine & _
      "    @Today      datetime = GETDATE()," & vbNewLine & _
      "    @p14CountHeadcount  integer," & vbNewLine & _
      "    @HeadCount  integer" & vbNewLine & vbNewLine & _
      "  EXEC spsys_setsystemsetting 'overnight', 'PREnable', 1;" & vbNewLine & vbNewLine & _
      "  DECLARE @CurrentYear integer  = DATEPART(year, @Today);" & vbNewLine & _
      "  SELECT @TaxYearStartDay = SettingValue FROM ASRSysSystemSettings WHERE Section = 'taxyear' AND SettingKey = 'startday';" & vbNewLine
      
  If Len(sStartDateColumn) = 0 Or Len(sLeavingDateColumn) = 0 Or Len(sPersonnelTableName) = 0 Then
      sProcSQL = sProcSQL & "  EXEC spsys_setsystemsetting 'overnight', 'PREnable', 0;" & vbNewLine & vbNewLine
  
  Else
  
    sProcSQL = sProcSQL & _
        "  SET @TaxYearStart = @TaxYearStartDay + cast(@CurrentYear as varchar(4));" & vbNewLine & _
        "  IF @Today < @TaxYearStart SET @TaxYearStart = @TaxYearStartDay + cast(@CurrentYear-1 as varchar(4));" & vbNewLine & _
        "  SET @TaxYearEnd = DATEADD(year, 1, @TaxYearStart) - 1;" & vbNewLine & vbNewLine & _
        "  SELECT @p14CountHeadcount = COUNT(ID) FROM " & sPersonnelTableName & vbNewLine & _
        "    WHERE ([" & sLeavingDateColumn & "] >= @TaxYearStart OR [" & sLeavingDateColumn & "] IS NULL) AND [" & sStartDateColumn & "] <= @TaxYearEnd AND [" & sStartDateColumn & "] IS NOT NULL;" & vbNewLine & vbNewLine & _
        "  SELECT @HeadCount = COUNT(ID) FROM " & sPersonnelTableName & vbNewLine & _
        "    WHERE [" & sStartDateColumn & "] <= @Today AND [" & sStartDateColumn & "] IS NOT NULL  AND ([" & sLeavingDateColumn & "] > @Today OR [" & sLeavingDateColumn & "] IS NULL);" & vbNewLine & vbNewLine
  
    If gobjLicence.LicenceType = LicenceType.Headcount Or gobjLicence.LicenceType = LicenceType.DMIConcurrencyAndHeadcount Then
      sProcSQL = sProcSQL & _
        "  IF @HeadCount >= " & gobjLicence.Headcount & vbNewLine & _
        "    EXEC spsys_setsystemsetting 'overnight', 'PREnable', 0;" & vbNewLine
  
    ElseIf gobjLicence.LicenceType = LicenceType.P14Headcount Or gobjLicence.LicenceType = LicenceType.DMIConcurrencyAndP14 Then
      sProcSQL = sProcSQL & _
        "  IF @p14CountHeadcount >= " & gobjLicence.Headcount & vbNewLine & _
        "    EXEC spsys_setsystemsetting 'overnight', 'PREnable', 0;" & vbNewLine
    
    Else
      sProcSQL = sProcSQL & "  EXEC spsys_setsystemsetting 'overnight', 'PREnable', 1;" & vbNewLine
    
    End If
  
  End If

  sProcSQL = sProcSQL & vbNewLine & _
      "  EXEC spsys_setsystemsetting 'headcount', 'current', @HeadCount;" & vbNewLine & _
      "  EXEC spsys_setsystemsetting 'headcount', 'p14', @p14CountHeadcount;" & vbNewLine & _
  "END"

  gADOCon.Execute sProcSQL, , adExecuteNoRecords
  
  gADOCon.Execute "spASRCalculateHeadcounts"
  
  
TidyUpAndExit:
  CreateSP_CalculateHeadcount = fCreatedOK
  Exit Function

ErrorTrap:
  fCreatedOK = False
  OutputError "Error creating Personnel stored procedure (CreateSP_CalculateHeadcount)"
  Resume TidyUpAndExit

End Function


Public Function CreateSP_GetCurrentUserRecordID() As Boolean
  
  On Error GoTo ErrorTrap

  Dim fCreatedOK As Boolean
  Dim sProcSQL As String
  Dim lngPersonnelTableID As Long
  Dim lngRecordDescriptionID As Long
  Dim sPersonnelTableName As String
  Dim lngLoginColumnID As Long
  Dim sLoginColumnName As String
  Dim lngSecondLoginColumnID As Long
  Dim sSecondLoginColumnName As String
  
  fCreatedOK = True


  DropProcedure "spASRSysGetCurrentUserRecordID"


  With recModuleSetup
    .Index = "idxModuleParameter"
    
    ' Use gsMODULEKEY_WORKFLOW as we default to gsMODULEKEY_PERSONNEL anyway.
    lngPersonnelTableID = GetModuleSetting(gsMODULEKEY_WORKFLOW, gsPARAMETERKEY_PERSONNELTABLE, 0)

    If lngPersonnelTableID > 0 Then
      recTabEdit.Index = "idxTableID"
      recTabEdit.Seek "=", lngPersonnelTableID
      If Not recTabEdit.NoMatch Then
        sPersonnelTableName = recTabEdit!TableName
        lngRecordDescriptionID = recTabEdit!RecordDescExprID
      Else
        lngPersonnelTableID = 0
        sPersonnelTableName = vbNullString
        lngRecordDescriptionID = 0
      End If
    End If

    ' Use gsMODULEKEY_WORKFLOW as we default to gsMODULEKEY_PERSONNEL anyway.
    lngLoginColumnID = GetModuleSetting(gsMODULEKEY_WORKFLOW, gsPARAMETERKEY_LOGINNAME, 0)
    lngSecondLoginColumnID = GetModuleSetting(gsMODULEKEY_WORKFLOW, gsPARAMETERKEY_SECONDLOGINNAME, 0)
    
    If (lngLoginColumnID = 0) And (lngSecondLoginColumnID > 0) Then
      lngLoginColumnID = lngSecondLoginColumnID
      lngSecondLoginColumnID = 0
    End If
    
    If lngLoginColumnID > 0 Then
      recColEdit.Index = "idxColumnID"
      recColEdit.Seek "=", lngLoginColumnID
      If Not recColEdit.NoMatch Then
        sLoginColumnName = recColEdit!ColumnName
      Else
        lngLoginColumnID = 0
        sLoginColumnName = vbNullString
      End If
    End If

    If lngSecondLoginColumnID > 0 Then
      recColEdit.Index = "idxColumnID"
      recColEdit.Seek "=", lngSecondLoginColumnID
      If Not recColEdit.NoMatch Then
        sSecondLoginColumnName = recColEdit!ColumnName
      Else
        lngSecondLoginColumnID = 0
        sSecondLoginColumnName = vbNullString
      End If
    End If
  End With
  
    
    sProcSQL = _
      "/* ------------------------------------------------ */" & vbNewLine & _
      "/* Personnel module stored procedure.        */" & vbNewLine & _
      "/* Automatically generated by the System manager.   */" & vbNewLine & _
      "/* ------------------------------------------------ */" & vbNewLine & _
      "CREATE PROCEDURE dbo.spASRSysGetCurrentUserRecordID(" & vbNewLine & _
      "    @piRecordID integer OUTPUT," & vbNewLine & _
      "    @piRecordCount integer OUTPUT," & vbNewLine & _
      "    @psRecordDescription nvarchar(MAX) OUTPUT" & vbNewLine & _
      ")" & vbNewLine & _
      "AS " & vbNewLine & _
      "BEGIN" & vbNewLine & _
      "    DECLARE @iCount integer;" & vbNewLine & vbNewLine & _
      "    SET @piRecordID = 0;" & vbNewLine & _
      "    SET @piRecordCount = 0;" & vbNewLine & vbNewLine
      
    If (lngPersonnelTableID > 0) _
      And (lngLoginColumnID > 0) Then
      
      sProcSQL = sProcSQL & _
        "    SELECT @piRecordCount = COUNT([" & sLoginColumnName & "])" & vbNewLine & _
        "    FROM " & sPersonnelTableName & vbNewLine & _
        "    WHERE (ISNULL(" & sPersonnelTableName & "." & sLoginColumnName & ", '') = SUSER_SNAME()" & _
        IIf(Len(sSecondLoginColumnName) > 0, vbNewLine & "            OR ISNULL(" & sPersonnelTableName & "." & sSecondLoginColumnName & ", '') = SUSER_SNAME()", "") & ")" & vbNewLine & vbNewLine
      
      sProcSQL = sProcSQL & _
        "    IF @piRecordCount = 1" & vbNewLine & _
        "    BEGIN" & vbNewLine & _
        "        SELECT @piRecordID = " & sPersonnelTableName & ".ID" & vbNewLine & _
        "        FROM " & sPersonnelTableName & vbNewLine & _
        "        WHERE (ISNULL(" & sPersonnelTableName & "." & sLoginColumnName & ", '') = SUSER_SNAME()" & _
        IIf(Len(sSecondLoginColumnName) > 0, vbNewLine & "            OR ISNULL(" & sPersonnelTableName & "." & sSecondLoginColumnName & ", '') = SUSER_SNAME()", "") & ")" & vbNewLine

      If lngRecordDescriptionID > 0 Then
        sProcSQL = sProcSQL & vbNewLine & _
          "        EXEC [sp_ASRExpr_" & lngRecordDescriptionID & "] @psRecordDescription OUTPUT, @piRecordID;" & vbNewLine & vbNewLine
      Else
        sProcSQL = sProcSQL & _
          "        SET @psRecordDescription = '';" & vbNewLine & vbNewLine
      End If

      sProcSQL = sProcSQL & _
        "    END" & vbNewLine
        
    End If
        
    sProcSQL = sProcSQL & _
      "END"
  
    gADOCon.Execute sProcSQL, , adExecuteNoRecords
  
  
TidyUpAndExit:
  CreateSP_GetCurrentUserRecordID = fCreatedOK
  Exit Function

ErrorTrap:
  fCreatedOK = False
  OutputError "Error creating Personnel stored procedure (spASRSysGetCurrentUserRecordID)"
  Resume TidyUpAndExit
  
End Function





Private Function DropCapitalizeInitialsUDF() As Boolean
  ' Drop any existing UDF.
  On Error GoTo ErrorTrap
  
  Dim fOK As Boolean
  Dim sSQL As String
  
  fOK = True
  
  sSQL = "IF EXISTS" & _
    " (SELECT Name" & _
    "   FROM sysobjects" & _
    "   WHERE id = object_id('udf_ASRFn_CapitalizeInitials')" & _
    "     AND sysstat & 0xf = 0)" & _
    " DROP FUNCTION udf_ASRFn_CapitalizeInitials"
  gADOCon.Execute sSQL, , adExecuteNoRecords

TidyUpAndExit:
  DropCapitalizeInitialsUDF = fOK
  Exit Function
  
ErrorTrap:
  fOK = False
  OutputError "Error dropping Capitalize initials user defined function (Personnel)"
  Resume TidyUpAndExit

End Function

Private Function DropInitialsFromForenamesUDF() As Boolean
  ' Drop any existing UDF.
  On Error GoTo ErrorTrap
  
  Dim fOK As Boolean
  Dim sSQL As String
  
  fOK = True
  
  sSQL = "IF EXISTS" & _
    " (SELECT Name" & _
    "   FROM sysobjects" & _
    "   WHERE id = object_id('udf_ASRFn_InitialsFromForenames')" & _
    "     AND sysstat & 0xf = 0)" & _
    " DROP FUNCTION udf_ASRFn_InitialsFromForenames"
  gADOCon.Execute sSQL, , adExecuteNoRecords

TidyUpAndExit:
  DropInitialsFromForenamesUDF = fOK
  Exit Function
  
ErrorTrap:
  fOK = False
  OutputError "Error dropping Initials from forenames user defined function (Personnel)"
  Resume TidyUpAndExit

End Function

Private Function CreateCapitaliseInitialsUDF() As Boolean

  On Error GoTo ErrorTrap

  Dim strUDF As String
  Dim bCreatedOK As Boolean

  ' Drop exiting user defined function
  bCreatedOK = DropCapitalizeInitialsUDF

  If bCreatedOK Then
  
    strUDF = "/* ------------------------------------------------ */" & vbNewLine & _
               "/* Personnel module user defined function.   */" & vbNewLine & _
               "/* Automatically generated by the System manager.   */" & vbNewLine & _
               "/* ------------------------------------------------ */" & vbNewLine & _
               "CREATE FUNCTION dbo.udf_ASRFn_CapitalizeInitials (" & vbNewLine & _
               "@psString varchar(MAX)" & vbNewLine & _
               ")" & vbNewLine & _
               "RETURNS varchar(MAX)" & vbNewLine & _
               "AS" & vbNewLine & _
               "BEGIN" & vbNewLine
  
    strUDF = strUDF & vbNewLine & _
               "    DECLARE @psResult varchar(MAX);" & vbNewLine & _
               "    DECLARE @iCounter integer;" & vbNewLine & _
               "    DECLARE @sTemp varchar(1);" & vbNewLine & vbNewLine & _
               "    SET @iCounter = 1;" & vbNewLine & vbNewLine & _
               "    WHILE @iCounter < len(@psString)" & vbNewLine & _
               "       BEGIN" & vbNewLine & _
               "         IF substring(@psString, @iCounter, 1) = ' '" & vbNewLine & _
               "           BEGIN" & vbNewLine & _
               "             SET @sTemp = substring(@psString, @iCounter+1, 1);" & vbNewLine & _
               "             SET @psString = stuff(@psString, @iCounter+1, 1, upper(@sTemp));" & vbNewLine & _
               "           END" & vbNewLine & _
               "         ELSE" & vbNewLine & _
               "           BEGIN" & vbNewLine & _
               "             SET @sTemp = substring(@psString, @iCounter+1, 1);" & vbNewLine & _
               "             SET @psString = stuff(@psString, @iCounter+1, 1, lower(@sTemp));" & vbNewLine & _
               "           END" & vbNewLine & vbNewLine & _
               "           SET @iCounter = @iCounter + 1;" & vbNewLine & _
               "         END" & vbNewLine & vbNewLine & _
               "         /*Change the first letter too*/" & vbNewLine & _
               "         SET @sTemp = substring(@psString, 1, 1);" & vbNewLine & _
               "         SET @psString = stuff(@psString, 1, 1, upper(@sTemp));" & vbNewLine & vbNewLine & _
               "         SET @psResult = @psString;" & vbNewLine & vbNewLine & _
               "         RETURN @psResult" & vbNewLine & vbNewLine & _
               "END"
    
    ' Generate the UDF
    gADOCon.Execute strUDF, , adExecuteNoRecords
  
  End If


TidyUpAndExit:
  On Error GoTo ErrorTrap
  CreateCapitaliseInitialsUDF = bCreatedOK
  Exit Function

ErrorTrap:
  bCreatedOK = False
  OutputError "Error creating Capitalise Initials user defined function"
  Resume TidyUpAndExit

End Function


Private Function CreateInitialsFromForenamesUDF() As Boolean

  On Error GoTo ErrorTrap

  Dim strUDF As String
  Dim bCreatedOK As Boolean

  ' Drop exiting user defined function
  bCreatedOK = DropInitialsFromForenamesUDF

  If bCreatedOK Then
  
    strUDF = "/* ------------------------------------------------ */" & vbNewLine & _
               "/* Personnel module user defined function.   */" & vbNewLine & _
               "/* Automatically generated by the System manager.   */" & vbNewLine & _
               "/* ------------------------------------------------ */" & vbNewLine & _
               "CREATE FUNCTION dbo.udf_ASRFn_InitialsFromForenames (" & vbNewLine & _
               "@psForenames  varchar(MAX)" & vbNewLine & _
               ")" & vbNewLine & _
               "RETURNS varchar(MAX)" & vbNewLine & _
               "AS" & vbNewLine & _
               "BEGIN" & vbNewLine
  
    strUDF = strUDF & _
               "  DECLARE @psResult   varchar(MAX);" & vbNewLine & _
               "  DECLARE @iCounter integer;" & vbNewLine & vbNewLine & _
               "  SET @iCounter = 1;" & vbNewLine & vbNewLine & _
               "  IF len(@psForenames) > 0" & vbNewLine & _
               "  BEGIN" & vbNewLine & _
               "    SET @psResult = upper(left(@psForenames,1));" & vbNewLine & vbNewLine & _
               "    WHILE @iCounter < len(@psForenames)" & vbNewLine & _
               "    BEGIN" & vbNewLine & _
               "      IF substring(@psForenames, @iCounter, 1) = ' '" & vbNewLine & _
               "        BEGIN" & vbNewLine & _
               "          SET @psResult = @psResult + upper(substring(@psForenames, @iCounter+1, 1));" & vbNewLine & _
               "        END" & vbNewLine & vbNewLine & _
               "      SET @iCounter = @iCounter +1;" & vbNewLine & _
               "    END" & vbNewLine & vbNewLine & _
               "    SET @psResult = @psResult + ' ';" & vbNewLine & _
               "  END" & vbNewLine & vbNewLine & _
               "  RETURN @psResult" & vbNewLine & _
               "END"
  
    ' Generate the UDF
    gADOCon.Execute strUDF, , adExecuteNoRecords
  
  End If

TidyUpAndExit:
  On Error GoTo ErrorTrap
  CreateInitialsFromForenamesUDF = bCreatedOK
  Exit Function

ErrorTrap:
  bCreatedOK = False
  OutputError "Error creating Initials From Forenames user defined function"
  Resume TidyUpAndExit

End Function

Public Function GetColumnNameFromModuleSetup(ByVal module As String, ByVal key As String)

  Dim lngKey As Long
  Dim sValue As String

  With recModuleSetup
    .Index = "idxModuleParameter"
    .Seek "=", module, key
    If .NoMatch Then
      lngKey = 0
    Else
      lngKey = IIf(IsNull(!parametervalue), 0, val(!parametervalue))
      sValue = GetColumnName(lngKey, True)
    End If
  End With
          
  GetColumnNameFromModuleSetup = sValue

End Function


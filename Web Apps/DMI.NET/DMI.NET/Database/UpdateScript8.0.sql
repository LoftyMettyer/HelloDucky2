/*
Deployment script for OpenHR52_MASTER

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ENABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Dropping [dbo].[DEL_ASRSysAccordTransactions]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysAccordTransactions];


GO
PRINT N'Dropping [dbo].[UPD_ASRSysAccordTransactions]...';


GO
DROP TRIGGER [dbo].[UPD_ASRSysAccordTransactions];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysCrossTab]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysCrossTab];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysCustomReportsName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysCustomReportsName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysDataTransferName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysDataTransferName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysEventLog]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysEventLog];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysExportName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysExportName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysExpressions]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysExpressions];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysGlobalFunctions]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysGlobalFunctions];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysImportName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysImportName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysMailMergeName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysMailMergeName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysMatchReportName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysMatchReportName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysOutlookLinks]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysOutlookLinks];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysRecordProfileName]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysRecordProfileName];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysWorkflowElementItemValues]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysWorkflowElementItemValues];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysWorkflowInstances]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysWorkflowInstances];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysWorkflowInstanceSteps]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysWorkflowInstanceSteps];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysWorkflowQueue]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysWorkflowQueue];


GO
PRINT N'Dropping [dbo].[DEL_ASRSysWorkflowTriggeredLinks]...';


GO
DROP TRIGGER [dbo].[DEL_ASRSysWorkflowTriggeredLinks];


GO
PRINT N'Dropping [dbo].[ASRSysColumns].[idx_columnid]...';


GO
DROP INDEX [idx_columnid]
    ON [dbo].[ASRSysColumns];


GO
PRINT N'Dropping [dbo].[ASRSysTables].[idx_tableid]...';


GO
DROP INDEX [idx_tableid]
    ON [dbo].[ASRSysTables];


GO
PRINT N'Dropping [dbo].[ASRSysAccordTransactionData].[TransactionID]...';


GO
DROP INDEX [TransactionID]
    ON [dbo].[ASRSysAccordTransactionData];


GO
PRINT N'Dropping [dbo].[ASRSysColumnControlValues].[IDX_ColumnSequence]...';


GO
DROP INDEX [IDX_ColumnSequence]
    ON [dbo].[ASRSysColumnControlValues];


GO
PRINT N'Dropping [dbo].[ASRSysControls].[IDX_ScreenID]...';


GO
DROP INDEX [IDX_ScreenID]
    ON [dbo].[ASRSysControls];


GO
PRINT N'Dropping [dbo].[ASRSysControls].[IDX_TableID]...';


GO
DROP INDEX [IDX_TableID]
    ON [dbo].[ASRSysControls];


GO
PRINT N'Dropping [dbo].[ASRSysCustomReportAccess].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysCustomReportAccess];


GO
PRINT N'Dropping [dbo].[ASRSysCustomReportsChildDetails].[IDX_CustomReportID]...';


GO
DROP INDEX [IDX_CustomReportID]
    ON [dbo].[ASRSysCustomReportsChildDetails];


GO
PRINT N'Dropping [dbo].[ASRSysCustomReportsDetails].[IDX_CustomReportID]...';


GO
DROP INDEX [IDX_CustomReportID]
    ON [dbo].[ASRSysCustomReportsDetails];


GO
PRINT N'Dropping [dbo].[ASRSysDataTransferName].[IDX_FromTableID]...';


GO
DROP INDEX [IDX_FromTableID]
    ON [dbo].[ASRSysDataTransferName];


GO
PRINT N'Dropping [dbo].[ASRSysDiaryEvents].[ASRSysDiaryEventsIndex1]...';


GO
DROP INDEX [ASRSysDiaryEventsIndex1]
    ON [dbo].[ASRSysDiaryEvents];


GO
PRINT N'Dropping [dbo].[ASRSysDiaryEvents].[IDX_DateEventID]...';


GO
DROP INDEX [IDX_DateEventID]
    ON [dbo].[ASRSysDiaryEvents];


GO
PRINT N'Dropping [dbo].[ASRSysDiaryLinks].[IDX_ColumnID]...';


GO
DROP INDEX [IDX_ColumnID]
    ON [dbo].[ASRSysDiaryLinks];


GO
PRINT N'Dropping [dbo].[ASRSysEmailAddress].[IDX_TableID]...';


GO
DROP INDEX [IDX_TableID]
    ON [dbo].[ASRSysEmailAddress];


GO
PRINT N'Dropping [dbo].[ASRSysEmailQueue].[IDX_LinkRecordID]...';


GO
DROP INDEX [IDX_LinkRecordID]
    ON [dbo].[ASRSysEmailQueue];


GO
PRINT N'Dropping [dbo].[ASRSysEmailQueue].[IDX_RecordTableID]...';


GO
DROP INDEX [IDX_RecordTableID]
    ON [dbo].[ASRSysEmailQueue];


GO
PRINT N'Dropping [dbo].[ASRSysEventLogDetails].[IDX_EventLogID]...';


GO
DROP INDEX [IDX_EventLogID]
    ON [dbo].[ASRSysEventLogDetails];


GO
PRINT N'Dropping [dbo].[ASRSysExprComponents].[IDX_ExprID]...';


GO
DROP INDEX [IDX_ExprID]
    ON [dbo].[ASRSysExprComponents];


GO
PRINT N'Dropping [dbo].[ASRSysExpressions].[IDX_ParentComponentID]...';


GO
DROP INDEX [IDX_ParentComponentID]
    ON [dbo].[ASRSysExpressions];


GO
PRINT N'Dropping [dbo].[ASRSysFunctionParameters].[IDX_FunctionID]...';


GO
DROP INDEX [IDX_FunctionID]
    ON [dbo].[ASRSysFunctionParameters];


GO
PRINT N'Dropping [dbo].[ASRSysGroupPermissions].[IDX_GroupName]...';


GO
DROP INDEX [IDX_GroupName]
    ON [dbo].[ASRSysGroupPermissions];


GO
PRINT N'Dropping [dbo].[ASRSysGroupPermissions].[IDX_ItemID]...';


GO
DROP INDEX [IDX_ItemID]
    ON [dbo].[ASRSysGroupPermissions];


GO
PRINT N'Dropping [dbo].[ASRSysLock].[IDX_Priority]...';


GO
DROP INDEX [IDX_Priority]
    ON [dbo].[ASRSysLock];


GO
PRINT N'Dropping [dbo].[ASRSysMailMergeColumns].[IDX_MailMergeID]...';


GO
DROP INDEX [IDX_MailMergeID]
    ON [dbo].[ASRSysMailMergeColumns];


GO
PRINT N'Dropping [dbo].[ASRSysMailMergeName].[IDX_TableID]...';


GO
DROP INDEX [IDX_TableID]
    ON [dbo].[ASRSysMailMergeName];


GO
PRINT N'Dropping [dbo].[ASRSysMatchReportName].[IDX_TypeTableID]...';


GO
DROP INDEX [IDX_TypeTableID]
    ON [dbo].[ASRSysMatchReportName];


GO
PRINT N'Dropping [dbo].[ASRSysModuleSetup].[IDX_ModuleParameterKey]...';


GO
DROP INDEX [IDX_ModuleParameterKey]
    ON [dbo].[ASRSysModuleSetup];


GO
PRINT N'Dropping [dbo].[ASRSysOperatorParameters].[IDX_OperatorID]...';


GO
DROP INDEX [IDX_OperatorID]
    ON [dbo].[ASRSysOperatorParameters];


GO
PRINT N'Dropping [dbo].[ASRSysOrderItems].[IDX_ColumnID]...';


GO
DROP INDEX [IDX_ColumnID]
    ON [dbo].[ASRSysOrderItems];


GO
PRINT N'Dropping [dbo].[ASRSysOrderItems].[IDX_OrderSequence]...';


GO
DROP INDEX [IDX_OrderSequence]
    ON [dbo].[ASRSysOrderItems];


GO
PRINT N'Dropping [dbo].[ASRSysOutlookEvents].[IDX_LinkRecordID]...';


GO
DROP INDEX [IDX_LinkRecordID]
    ON [dbo].[ASRSysOutlookEvents];


GO
PRINT N'Dropping [dbo].[ASRSysPageCaptions].[IDX_ScreenID]...';


GO
DROP INDEX [IDX_ScreenID]
    ON [dbo].[ASRSysPageCaptions];


GO
PRINT N'Dropping [dbo].[ASRSysPermissionCategories].[IDX_CategoryKeyID]...';


GO
DROP INDEX [IDX_CategoryKeyID]
    ON [dbo].[ASRSysPermissionCategories];


GO
PRINT N'Dropping [dbo].[ASRSysPermissionItems].[IDX_ItemKey]...';


GO
DROP INDEX [IDX_ItemKey]
    ON [dbo].[ASRSysPermissionItems];


GO
PRINT N'Dropping [dbo].[ASRSysPurgePeriods].[IDX_PurgeKey]...';


GO
DROP INDEX [IDX_PurgeKey]
    ON [dbo].[ASRSysPurgePeriods];


GO
PRINT N'Dropping [dbo].[ASRSysRecordProfileName].[IDX_BaseTableID]...';


GO
DROP INDEX [IDX_BaseTableID]
    ON [dbo].[ASRSysRecordProfileName];


GO
PRINT N'Dropping [dbo].[ASRSysRelations].[IDX_ParentChildID]...';


GO
DROP INDEX [IDX_ParentChildID]
    ON [dbo].[ASRSysRelations];


GO
PRINT N'Dropping [dbo].[ASRSysScreens].[IDX_TableID]...';


GO
DROP INDEX [IDX_TableID]
    ON [dbo].[ASRSysScreens];


GO
PRINT N'Dropping [dbo].[ASRSysSSIHiddenGroups].[IDX_LinkID]...';


GO
DROP INDEX [IDX_LinkID]
    ON [dbo].[ASRSysSSIHiddenGroups];


GO
PRINT N'Dropping [dbo].[ASRSysSSIntranetLinks].[IDX_ViewID]...';


GO
DROP INDEX [IDX_ViewID]
    ON [dbo].[ASRSysSSIntranetLinks];


GO
PRINT N'Dropping [dbo].[ASRSysSummaryFields].[IDX_HistoryTableSequenceID]...';


GO
DROP INDEX [IDX_HistoryTableSequenceID]
    ON [dbo].[ASRSysSummaryFields];


GO
PRINT N'Dropping [dbo].[ASRSysSystemSettings].[IDX_SectionSettingKey]...';


GO
DROP INDEX [IDX_SectionSettingKey]
    ON [dbo].[ASRSysSystemSettings];


GO
PRINT N'Dropping [dbo].[ASRSysUserSettings].[IDX_SettingID]...';


GO
DROP INDEX [IDX_SettingID]
    ON [dbo].[ASRSysUserSettings];


GO
PRINT N'Dropping [dbo].[ASRSysUtilAccessLog].[IDX_UtilIDType]...';


GO
DROP INDEX [IDX_UtilIDType]
    ON [dbo].[ASRSysUtilAccessLog];


GO
PRINT N'Dropping [dbo].[ASRSysViewColumns].[IDX_ViewID]...';


GO
DROP INDEX [IDX_ViewID]
    ON [dbo].[ASRSysViewColumns];


GO
PRINT N'Dropping [dbo].[ASRSysViewMenuPermissions].[IDX_GroupName]...';


GO
DROP INDEX [IDX_GroupName]
    ON [dbo].[ASRSysViewMenuPermissions];


GO
PRINT N'Dropping [dbo].[ASRSysViewScreens].[IDX_ScreenViewID]...';


GO
DROP INDEX [IDX_ScreenViewID]
    ON [dbo].[ASRSysViewScreens];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowElementItems].[IDX_ElementTypeIdentifier]...';


GO
DROP INDEX [IDX_ElementTypeIdentifier]
    ON [dbo].[ASRSysWorkflowElementItems];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowElementItems].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowElementItems];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowElementItemValues].[IDX_itemID]...';


GO
DROP INDEX [IDX_itemID]
    ON [dbo].[ASRSysWorkflowElementItemValues];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowElements].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowElements];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowElements].[IDX_WorkflowTypeIdentifier]...';


GO
DROP INDEX [IDX_WorkflowTypeIdentifier]
    ON [dbo].[ASRSysWorkflowElements];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstances].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowInstances];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstances].[IDX_Workflow]...';


GO
DROP INDEX [IDX_Workflow]
    ON [dbo].[ASRSysWorkflowInstances];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstanceSteps].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowInstanceSteps];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstanceSteps].[IDX_InstanceElement]...';


GO
DROP INDEX [IDX_InstanceElement]
    ON [dbo].[ASRSysWorkflowInstanceSteps];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstanceValues].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowInstanceValues];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowInstanceValues].[IDX_InstanceElementIdentifier]...';


GO
DROP INDEX [IDX_InstanceElementIdentifier]
    ON [dbo].[ASRSysWorkflowInstanceValues];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowLinks].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowLinks];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowLinks].[IDX_WorkflowStartEnd]...';


GO
DROP INDEX [IDX_WorkflowStartEnd]
    ON [dbo].[ASRSysWorkflowLinks];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowQueue].[IDX_Instance]...';


GO
DROP INDEX [IDX_Instance]
    ON [dbo].[ASRSysWorkflowQueue];


GO
PRINT N'Dropping [dbo].[ASRSysWorkflowStepDelegation].[IDX_ID]...';


GO
DROP INDEX [IDX_ID]
    ON [dbo].[ASRSysWorkflowStepDelegation];


GO
PRINT N'Dropping [dbo].[tbsys_columns].[FK_TableID]...';


GO
DROP INDEX [FK_TableID]
    ON [dbo].[tbsys_columns];


GO
PRINT N'Dropping [dbo].[tbsys_columns].[IDX_TableID]...';


GO
DROP INDEX [IDX_TableID]
    ON [dbo].[tbsys_columns];


GO
PRINT N'Dropping [dbo].[tbsys_intransactiontrigger].[IDX_Transaction]...';


GO
DROP INDEX [IDX_Transaction]
    ON [dbo].[tbsys_intransactiontrigger];


GO
PRINT N'Dropping [dbo].[tbsys_scriptedobjects].[IDX_TargetObjectID]...';


GO
DROP INDEX [IDX_TargetObjectID]
    ON [dbo].[tbsys_scriptedobjects];


GO
PRINT N'Dropping [dbo].[ASRSysViews].[idx_viewid]...';


GO
DROP INDEX [idx_viewid]
    ON [dbo].[ASRSysViews];


GO
PRINT N'Dropping [dbo].[udfASRNetCountCurrentLogins]...';


GO
DROP FUNCTION [dbo].[udfASRNetCountCurrentLogins];


GO
PRINT N'Dropping [dbo].[udfASRNetCountCurrentUsersInApp]...';


GO
DROP FUNCTION [dbo].[udfASRNetCountCurrentUsersInApp];


GO
PRINT N'Dropping [dbo].[udfASRNetGetDomains]...';


GO
DROP FUNCTION [dbo].[udfASRNetGetDomains];


GO
PRINT N'Dropping [dbo].[udfASRNetGetLicenceKey]...';


GO
DROP FUNCTION [dbo].[udfASRNetGetLicenceKey];


GO
PRINT N'Dropping [dbo].[udfASRNetGetUsers]...';


GO
DROP FUNCTION [dbo].[udfASRNetGetUsers];


GO
PRINT N'Dropping [dbo].[udfASRNetGetWorkflowQueryString]...';


GO
DROP FUNCTION [dbo].[udfASRNetGetWorkflowQueryString];


GO
PRINT N'Dropping [dbo].[udfASRNetIsModuleLicensed]...';


GO
DROP FUNCTION [dbo].[udfASRNetIsModuleLicensed];


GO
PRINT N'Removing schema binding from [dbo].[udfsys_triggerrequiresrefresh]...';


GO
ALTER FUNCTION [dbo].[udfsys_triggerrequiresrefresh]
( )
RETURNS BIT
AS
BEGIN
    DECLARE @result AS BIT, @lastsavedate AS DATETIME, @lastovernight AS DATETIME;
    SELECT @result = 1;
    SELECT @lastovernight = DATEADD(mi, 1, CONVERT (DATETIME, [SettingValue], 103))
    FROM   dbo.[ASRSysSystemSettings]
    WHERE  section = 'overnight'
           AND settingKey = 'last completed';
    SELECT @lastsavedate = CONVERT (DATETIME, [SettingValue], 103)
    FROM   dbo.[ASRSysSystemSettings]
    WHERE  section = 'database'
           AND settingKey = 'SystemLastSaveDate';
    IF @lastsavedate < @lastovernight
       AND dbo.[udfsys_isovernightprocess]() = 0
        SET @result = 0;
    RETURN @result;
END


GO
PRINT N'Removing schema binding from [dbo].[udfsys_servicelength]...';


GO
ALTER FUNCTION [dbo].[udfsys_servicelength]
(@startdate DATETIME, @leavingdate DATETIME, @period NVARCHAR (2))
RETURNS INT
AS
BEGIN
    DECLARE @result AS INT;
    DECLARE @amount AS INT;
    IF @startdate > GETDATE()
        RETURN 0;
    IF @leavingdate IS NULL
       OR @leavingdate > GETDATE()
        SET @leavingdate = GETDATE();
    SET @amount = [dbo].[udfsys_wholeyearsbetweentwodates](@startdate, @leavingdate);
    IF @period = 'Y'
        SET @result = @amount;
    ELSE
        IF @period = 'M'
            SET @result = [dbo].[udfsys_wholemonthsbetweentwodates](@startdate, @leavingdate) - (@amount * 12);
    RETURN ISNULL(@result, 0);
END


GO
PRINT N'Removing schema binding from [dbo].[udfsys_statutoryredundancypay]...';


GO
ALTER FUNCTION [dbo].[udfsys_statutoryredundancypay]
(@pdtStartDate DATETIME, @pdtLeaveDate DATETIME, @pdtDOB DATETIME, @pdblWeeklyRate FLOAT (53), @pdblStatLimit FLOAT (53))
RETURNS FLOAT (53)
AS
BEGIN
    DECLARE @pdblRedundancyPay AS FLOAT, @dtMinAgeBirthday AS DATETIME, @dtServiceFrom AS DATETIME, @iServiceYears AS INT, @iAgeY AS INT, @iAgeM AS INT, @dblRate1 AS FLOAT, @dblRate2 AS FLOAT, @dblRate3 AS FLOAT, @dtTempDate AS DATETIME, @iTempAgeY AS INT, @iTemp AS INT, @dblTemp2 AS FLOAT, @iAfterOct2006 AS BIT, @iMinAge AS INT;
    SET @pdblRedundancyPay = 0;
    SET @iAfterOct2006 = CASE WHEN DATEDIFF(dd, @pdtLeaveDate, '10/01/2006') <= 0 THEN 1 ELSE 0 END;
    IF @iAfterOct2006 = 1
        SET @iMinAge = 15;
    ELSE
        SET @iMinAge = 18;
    IF (@pdtStartDate IS NULL)
       OR (@pdtLeaveDate IS NULL)
       OR (@pdtDOB IS NULL)
        RETURN 0;
    SET @pdtStartDate = CONVERT (DATETIME, CONVERT (VARCHAR (20), @pdtStartDate, 101));
    SET @pdtLeaveDate = CONVERT (DATETIME, CONVERT (VARCHAR (20), @pdtLeaveDate, 101));
    SET @pdtDOB = CONVERT (DATETIME, CONVERT (VARCHAR (20), @pdtDOB, 101));
    SET @dtServiceFrom = @pdtStartDate;
    IF @iAfterOct2006 = 0
        BEGIN
            SET @dtMinAgeBirthday = DATEADD(yy, @iMinAge, @pdtDOB);
            IF @dtMinAgeBirthday >= @pdtStartDate
                SET @dtServiceFrom = @dtMinAgeBirthday;
        END
    SELECT @iServiceYears = dbo.udfsys_wholeyearsbetweentwodates(@dtServiceFrom, @pdtLeaveDate);
    IF @iServiceYears < 2
        RETURN 0;
    SELECT @iAgeY = dbo.udfsys_wholeyearsbetweentwodates(@pdtDOB, @pdtLeaveDate);
    SET @dtTempDate = DATEADD(yy, @iAgeY, @pdtDOB);
    SELECT @iAgeM = dbo.udfsys_wholemonthsbetweentwodates(@dtTempDate, @pdtLeaveDate);
    SELECT @iServiceYears = CASE WHEN @iServiceYears < 20 THEN @iServiceYears ELSE 20 END;
    SET @iTempAgeY = @iAgeY;
    SET @dblRate1 = 0;
    SET @dblRate2 = 0;
    SET @dblRate3 = 0;
    IF @iTempAgeY >= 41
        BEGIN
            SET @iTemp = @iTempAgeY - 41;
            SELECT @dblRate1 = CASE WHEN @iServiceYears < @iTemp THEN @iServiceYears ELSE @iTemp END;
            SET @iTempAgeY = 41;
            SET @iServiceYears = @iServiceYears - @dblRate1;
        END
    IF @iTempAgeY >= 22
        BEGIN
            SET @iTemp = @iTempAgeY - 22;
            SELECT @dblRate2 = CASE WHEN @iServiceYears < @iTemp THEN @iServiceYears ELSE @iTemp END;
            SET @iTempAgeY = 22;
            SET @iServiceYears = @iServiceYears - @dblRate2;
        END
    IF @iTempAgeY >= @iMinAge
        BEGIN
            SET @iTemp = @iTempAgeY - @iMinAge;
            SELECT @dblRate3 = CASE WHEN @iServiceYears < @iTemp THEN @iServiceYears ELSE @iTemp END;
        END
    SELECT @dblTemp2 = CASE WHEN @pdblStatLimit < @pdblWeeklyRate THEN @pdblStatLimit ELSE @pdblWeeklyRate END;
    SET @pdblRedundancyPay = ((@dblRate1 * 1.5) + (@dblRate2) + (@dblRate3 * 0.5)) * @dblTemp2;
    IF @iAfterOct2006 = 0
       AND @iAgeY = 64
        SET @pdblRedundancyPay = @pdblRedundancyPay * (12 - @iAgeM) / 12;
    RETURN ISNULL(@pdblRedundancyPay, 0);
END


GO
PRINT N'Removing schema binding from [dbo].[udfstat_ParentalLeaveEntitlement]...';


GO
ALTER FUNCTION [dbo].[udfstat_ParentalLeaveEntitlement]
(@DateOfBirth DATETIME, @AdoptedDate DATETIME, @Disabled BIT, @Region VARCHAR (MAX))
RETURNS FLOAT (53)
AS
BEGIN
    DECLARE @pdblResult AS FLOAT, @Today AS DATETIME, @ChildAge AS INT, @Adopted AS BIT, @YearsOfResponsibility AS INT, @StartDate AS DATETIME, @Standard AS INT, @Extended AS INT;
    SET @Standard = 65;
    SET @Extended = 90;
    SET @Today = GETDATE();
    IF @Region = 'Rep of Ireland'
        BEGIN
            SET @Standard = 70;
            SET @Extended = 70;
        END
    IF DATEDIFF(d, '03-08-2013', @Today) >= 0
        BEGIN
            SET @Standard = 90;
            SET @Extended = 90;
        END
    SET @Adopted = 0;
    SET @StartDate = @DateOfBirth;
    IF NOT @AdoptedDate IS NULL
        BEGIN
            SET @Adopted = 1;
            SET @StartDate = @AdoptedDate;
        END
    SELECT @ChildAge = [dbo].[udfsys_wholeyearsbetweentwodates](@DateOfBirth, @Today);
    SELECT @YearsOfResponsibility = [dbo].[udfsys_wholeyearsbetweentwodates](@StartDate, @Today);
    SELECT @pdblResult = CASE WHEN @Disabled = 0
                                   AND @Adopted = 0
                                   AND @ChildAge < 5 THEN @Standard WHEN @Disabled = 0
                                                                         AND @Adopted = 1
                                                                         AND @ChildAge < 18
                                                                         AND @YearsOfResponsibility < 5 THEN @Standard WHEN @Disabled = 1
                                                                                                                            AND @Adopted = 0
                                                                                                                            AND @ChildAge < 18
                                                                                                                            AND DATEDIFF(d, '12/15/1994', @DateOfBirth) >= 0 THEN @Extended WHEN @Disabled = 1
                                                                                                                                                                                                 AND @Adopted = 1
                                                                                                                                                                                                 AND @ChildAge < 18
                                                                                                                                                                                                 AND DATEDIFF(d, '12/15/1994', @AdoptedDate) >= 0 THEN @Extended ELSE 0 END;
    RETURN ISNULL(@pdblResult, 0);
END


GO
PRINT N'Dropping [dbo].[spadmin_commitresetpassword]...';


GO
DROP PROCEDURE [dbo].[spadmin_commitresetpassword];


GO
PRINT N'Dropping [dbo].[spASRGetDomainPolicyFromAssembly]...';


GO
DROP PROCEDURE [dbo].[spASRGetDomainPolicyFromAssembly];


GO
PRINT N'Dropping [dbo].[spASRGroupsUserIsMemberOf]...';


GO
DROP PROCEDURE [dbo].[spASRGroupsUserIsMemberOf];


GO
PRINT N'Dropping [dbo].[spASRStoredDataFileActions]...';


GO
DROP PROCEDURE [dbo].[spASRStoredDataFileActions];


GO
PRINT N'Altering [ASRSysGroup]...';


GO
ALTER AUTHORIZATION
    ON SCHEMA::[ASRSysGroup]
    TO [dbo];


GO
PRINT N'Creating [dbo].[DataPermissions]...';


GO
CREATE TYPE [dbo].[DataPermissions] AS TABLE (
    [name] VARCHAR (255) NULL);


GO
PRINT N'Creating [dbo].[ASRSysProtectsCache]...';


GO
CREATE TABLE [dbo].[ASRSysProtectsCache] (
    [ID]          INT              NOT NULL,
    [Action]      TINYINT          NOT NULL,
    [Columns]     VARBINARY (8000) NULL,
    [ProtectType] INT              NOT NULL,
    [UID]         INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[ASRSysProtectsCache].[IDX_ProtectsCache_UID]...';


GO
CREATE CLUSTERED INDEX [IDX_ProtectsCache_UID]
    ON [dbo].[ASRSysProtectsCache]([UID] ASC);


GO
PRINT N'Altering [dbo].[INS_ASRSysViews]...';


GO
ALTER TRIGGER [dbo].[INS_ASRSysViews]
ON [dbo].[ASRSysViews]
INSTEAD OF INSERT
AS
BEGIN

	SET NOCOUNT ON;

	-- Update objects table
	IF NOT EXISTS(SELECT [guid]
		FROM dbo.[tbsys_scriptedobjects] o
		INNER JOIN inserted i ON i.viewid = o.targetid AND o.objecttype = 3)
	BEGIN
		INSERT dbo.[tbsys_scriptedobjects] ([guid], [objecttype], [targetid], [ownerid], [effectivedate], [revision], [locked], [lastupdated])
			SELECT NEWID(), 3, [viewid], dbo.[udfsys_getownerid](), '01/01/1900',1,0, GETDATE()
				FROM inserted;
	END

	-- Update base table								
	INSERT dbo.[tbsys_views] ([ViewID], [ViewName], [ViewDescription], [ViewTableID], [ViewSQL], [ExpressionID]) 
		SELECT [ViewID], [ViewName], [ViewDescription], [ViewTableID], [ViewSQL], [ExpressionID] FROM inserted;

END
GO
PRINT N'Altering [dbo].[udfASRDateOverlap]...';


GO
ALTER FUNCTION udfASRDateOverlap(
	@pdStartDate1		datetime,
	@psStartSession1	nvarchar(2),
	@pdEndDate1			datetime,
	@psEndSession1		nvarchar(2),
	@psType1			nvarchar(MAX),
	@pdStartDate2		datetime,
	@psStartSession2	nvarchar(2),
	@pdEndDate2			datetime,
	@psEndSession2		nvarchar(2),
	@psType2			nvarchar(MAX))
RETURNS bit
AS
BEGIN
	
	DECLARE @bFound bit;
	SET @bFound = 0;
	
	-- 1st of data is the inserted, 2nd is physical database values.	
	SET @pdStartDate1 = DATEADD(D, 0, DATEDIFF(D, 0, @pdStartDate1));
	SET @pdEndDate1 = ISNULL(DATEADD(D, 0, DATEDIFF(D, 0, @pdEndDate1)), CONVERT(datetime,'9999-12-31'));
	SET @pdStartDate2 = DATEADD(D, 0, DATEDIFF(D, 0, @pdStartDate2));
	SET @pdEndDate2 = ISNULL(DATEADD(D, 0, DATEDIFF(D, 0, @pdEndDate2)), CONVERT(datetime,'9999-12-31'));

	-- Put the AM/PM stuff into the above dates.
	IF @psStartSession1 = 'PM' SET @pdStartDate1 = DATEADD(hh, 12, @pdStartDate1);
	IF @psEndSession1 = 'PM' SET @pdEndDate1 = DATEADD(hh, 23, @pdEndDate1);
	IF @psStartSession2 = 'PM' SET @pdStartDate2 = DATEADD(hh, 12, @pdStartDate2);
	IF @psEndSession2 = 'PM' SET @pdEndDate2 = DATEADD(hh, 23, @pdEndDate2);

	-- Check to see if this date overlaps.
	IF ((@pdStartDate1 BETWEEN @pdStartDate2 AND @pdEndDate2)
		OR (@pdEndDate1 BETWEEN @pdStartDate2 AND @pdEndDate2)
		OR (@pdStartDate1 < @pdStartDate2 AND @pdEndDate1 > @pdEndDate2))
		AND (@psType1 = @psType2 OR @psType1 IS NULL)
			SET @bFound = 1;

	RETURN @bFound;

END
GO
PRINT N'Creating [dbo].[udfASRNetCountCurrentLogins]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetCountCurrentLogins](@loginToCheck [nvarchar](4000))
RETURNS [int] WITH EXECUTE AS CALLER
AS 
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetCountCurrentUsersInApp]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetCountCurrentUsersInApp](@appName [nvarchar](4000))
RETURNS [int] WITH EXECUTE AS CALLER
AS
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetGetDomains]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetGetDomains]()
RETURNS [nvarchar](4000) 
AS
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetGetLicenceKey]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetGetLicenceKey](@inKey [nvarchar](4000), @moduleName [nvarchar](4000))
RETURNS [int] WITH EXECUTE AS CALLER
AS
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetGetUsers]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetGetUsers](@domainPath [nvarchar](4000))
RETURNS [nvarchar](max)
AS 
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetGetWorkflowQueryString]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetGetWorkflowQueryString](@instanceID [int], @stepID [int], @userPwd [nvarchar](4000), @server [nvarchar](4000), @database [nvarchar](4000))
RETURNS [nvarchar](4000) WITH EXECUTE AS CALLER
AS
BEGIN
	RETURN 0
END
GO
PRINT N'Creating [dbo].[udfASRNetIsModuleLicensed]...';


GO
-- Generated by the server assembly
CREATE FUNCTION [dbo].[udfASRNetIsModuleLicensed](@inKey [nvarchar](4000), @iModuleCode [int])
RETURNS [bit] WITH EXECUTE AS CALLER
AS 
BEGIN
	RETURN 0
END
GO
PRINT N'Altering [dbo].[udfASRSQLVersion]...';


GO
ALTER FUNCTION [dbo].[udfASRSQLVersion]
	(
	)
	RETURNS integer
	AS
	BEGIN
		RETURN convert(int,convert(float,substring(@@version,charindex('-',@@version)+2,2)))
	END
GO
PRINT N'Altering [dbo].[udfsys_firstnamefromforenames]...';


GO
ALTER FUNCTION [dbo].[udfsys_firstnamefromforenames] 
(
	@forenames nvarchar(max)
)
RETURNS nvarchar(max)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result nvarchar(max);

	IF (LEN(@forenames) = 0 ) OR (@forenames IS null)
	BEGIN
		SET @result = '';
	END
	ELSE
	BEGIN
		IF CHARINDEX(' ', @forenames) > 0
			SET @result = LEFT(@forenames, CHARINDEX(' ', @forenames));
		ELSE
			SET @result = @forenames;
	END
	
	RETURN @result;
	
END
GO
PRINT N'Altering [dbo].[udfsys_getfieldfromdatabaserecord]...';


GO
ALTER FUNCTION [dbo].[udfsys_getfieldfromdatabaserecord](
	@searchcolumn AS nvarchar(255),
	@searchexpression AS nvarchar(MAX),
	@returnfield AS nvarchar(255))
RETURNS nvarchar(MAX)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result nvarchar(MAX);
	RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_getfunctionparametertype]...';


GO
ALTER FUNCTION [dbo].[udfsys_getfunctionparametertype]
	(@functionid integer, @parameterindex integer)
RETURNS integer
AS
BEGIN

	DECLARE @result integer;

	SELECT @result = [parametertype] FROM ASRSysFunctionParameters
		WHERE @functionid = [functionID] AND @parameterindex = [parameterIndex];

	RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_initialsfromforenames]...';


GO
ALTER FUNCTION [dbo].[udfsys_initialsfromforenames] 
(
	@forenames	varchar(8000),
	@padwithspace bit
)
RETURNS nvarchar(10)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result nvarchar(10) = '';
	DECLARE @icounter integer = 1;

	IF LEN(@forenames) > 0 
	BEGIN
		SET @result = UPPER(left(@forenames,1));

		WHILE @icounter < LEN(@forenames)
		BEGIN
			IF SUBSTRING(@forenames, @icounter, 1) = ' '
			BEGIN
				IF @padwithspace = 1
					SET @result = @result + ' ' + UPPER(SUBSTRING(@forenames, @icounter+1, 1));
				ELSE
					SET @result = @result + UPPER(SUBSTRING(@forenames, @icounter+1, 1));
			END
	
			SET @icounter = @icounter +1;
		END

		SET @result = @result + ' '
	
	END

	RETURN @result

END
GO
PRINT N'Altering [dbo].[udfsys_isfieldpopulated]...';


GO
ALTER FUNCTION [dbo].[udfsys_isfieldpopulated](
	@inputcolumn as nvarchar(MAX))
RETURNS bit
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result bit = 0;
	SELECT @result = (
		CASE 
			WHEN @inputcolumn IS NULL THEN 0 
			ELSE
				CASE
--					WHEN LEN(convert(nvarchar(1),@inputcolumn)) = 0 THEN 0
					WHEN DATALENGTH(@inputcolumn) = 0 THEN 0
					ELSE 1
				END
			END);

	RETURN @result;
	
END
GO
PRINT N'Altering [dbo].[udfsys_isovernightprocess]...';


GO
ALTER FUNCTION [dbo].[udfsys_isovernightprocess] ()
RETURNS bit 
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result bit = 0;
	
    RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_maternityexpectedreturndate]...';


GO
ALTER FUNCTION [dbo].[udfsys_maternityexpectedreturndate] (
     @id		integer)
RETURNS datetime
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result datetime;
	
	SET @result = GETDATE()
        
    RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_nicedate]...';


GO
ALTER FUNCTION [dbo].[udfsys_nicedate](
	@inputdate as datetime)
RETURNS nvarchar(max)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result varchar(MAX) = '';
	SELECT @result = CONVERT(nvarchar(2),DATEPART(day, @inputdate))
		+ ' ' + DATENAME(month, @inputdate) 
		+ ' ' + CONVERT(nvarchar(4),DATEPART(YYYY, @inputdate));

	RETURN @result;
	
END
GO
PRINT N'Altering [dbo].[udfsys_nicetime]...';


GO
ALTER FUNCTION [dbo].[udfsys_nicetime](
	@inputdate as datetime)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result varchar(255) = '';

	SELECT @result =convert(char(8), @inputdate, 108)

	RETURN @result;
	
END
GO
PRINT N'Altering [dbo].[udfsys_parentalleaveentitlement]...';


GO
ALTER FUNCTION [dbo].[udfsys_parentalleaveentitlement] (
     @id		integer)
RETURNS integer
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer;
	
	SET @result = 10;
        
    RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_parentalleavetaken]...';


GO
ALTER FUNCTION [dbo].[udfsys_parentalleavetaken] (
     @id		integer)
RETURNS integer
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer;
	
	SET @result = 0;
        
    RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_propercase]...';


GO
ALTER FUNCTION [dbo].[udfsys_propercase](
	@text as nvarchar(max))
RETURNS nvarchar(max)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @reset	bit = 1;
	DECLARE @result varchar(8000) = '';
	DECLARE @i		int = 1;
	DECLARE @c		char(1);
      
	WHILE (@i <= len(@text))
		SELECT @c= substring(@text,@i,1)
			, @result = @result + CASE WHEN @reset=1 THEN UPPER(@c) 
									   ELSE LOWER(@c) END
			, @reset = CASE WHEN @c LIKE '[a-zA-Z]' THEN 0
							ELSE 1
							END
			, @i = @i + 1;

	RETURN @result;
	
END
GO
PRINT N'Altering [dbo].[udfsys_wholemonthsbetweentwodates]...';


GO
ALTER FUNCTION [dbo].[udfsys_wholemonthsbetweentwodates] 
(
	@date1 	datetime,
	@date2 	datetime
)
RETURNS integer
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer;

	-- Clean dates (trim time part)
	SET @date1 = DATEADD(D, 0, DATEDIFF(D, 0, @date1));
	SET @date2 = DATEADD(D, 0, DATEDIFF(D, 0, @date2));

	IF @date1 < @date2
	BEGIN

		-- Get the total number of months
		SET @result = DATEDIFF(mm, @date1, @date2);
      
		-- See if the day field of pvParam2 < pvParam1 day field and if so - 1
		IF DAY(@date2) < DAY(@date1)
		BEGIN
			SET @result = @result -1;
		END
	END
	
	RETURN @result
	
END
GO
PRINT N'Altering [dbo].[udfsys_wholeyearsbetweentwodates]...';


GO
ALTER FUNCTION [dbo].[udfsys_wholeyearsbetweentwodates] (
     @date1  datetime,
     @date2  datetime )
RETURNS integer 
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer = 0;
	
    -- Get the number of whole years
    SET @result = YEAR(@date2) - YEAR(@date1);

    -- See if the date passed in months are greater than todays month
    IF MONTH(@date1) > MONTH(@date2)
    BEGIN
		SET @result = @result - 1;
    END
    
    -- See if the months are equal and if they are test the day value
    IF MONTH(@date1) = MONTH(@date2)
    BEGIN
        IF DAY(@date1) > DAY(@date2)
            BEGIN
				SET @result = @result - 1;
            END
        END
        
    RETURN @result;

END
GO
PRINT N'Creating [dbo].[udfsys_absencebetweentwodates]...';


GO
CREATE FUNCTION [dbo].[udfsys_absencebetweentwodates] (
     @date1		datetime,
     @date2		datetime,
     @type		nvarchar(MAX) )
RETURNS integer 
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer = 0;
	
    -- Get the number of whole years
    SET @result = YEAR(@date2) - YEAR(@date1);

    -- See if the date passed in months are greater than todays month
    IF MONTH(@date1) > MONTH(@date2)
    BEGIN
		SET @result = @result - 1;
    END
    
    -- See if the months are equal and if they are test the day value
    IF MONTH(@date1) = MONTH(@date2)
    BEGIN
        IF DAY(@date1) > DAY(@date2)
            BEGIN
				SET @result = @result - 1;
            END
        END
        
    RETURN @result;

END
GO
PRINT N'Creating [dbo].[udfsys_justdate]...';


GO
CREATE FUNCTION udfsys_justdate
	(@date datetime)
RETURNS datetime
WITH SCHEMABINDING
AS
BEGIN
	RETURN DATEADD(D, 0, DATEDIFF(D, 0, @date));
END
GO
PRINT N'Creating [dbo].[udfsys_uniquecode]...';


GO
CREATE FUNCTION [dbo].[udfsys_uniquecode](
	@prefix AS nvarchar(max),
	@coderoot AS numeric(10,2))
RETURNS numeric(10,0)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result numeric(10,0);

	SET @result = 0;

	--SELECT @result = [maxcodesuffix] 
	--	FROM [dbo].[tb_uniquecodes]
	--	WHERE [codeprefix] = @prefix;

	-- Update existing value 
	/*
	You can't run an execute or an update in a UDF, so will have to create an extended
	stored procedure which should be able to do it. Otherwise tack something into the end
	of the update trigger on the base table that calls this function. (code stub already in
	the admin module.
	*/

	RETURN @result;

END
GO
PRINT N'Creating [dbo].[udfsys_username]...';


GO
CREATE FUNCTION [dbo].[udfsys_username]
	(@userid as integer)
RETURNS varchar(255)
WITH SCHEMABINDING
AS
BEGIN

	RETURN SYSTEM_USER;

END
GO
PRINT N'Altering [dbo].[udfsys_servicelength]...';


GO
ALTER FUNCTION [dbo].[udfsys_servicelength] (
     @startdate  datetime,
     @leavingdate  datetime,
     @period nvarchar(2))
RETURNS integer 
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer;
	DECLARE @amount integer;

	-- If start date is in the future ignore
	IF @startdate > GETDATE()
		RETURN 0;
	
	-- Trim the leaving date
	IF @leavingdate IS NULL OR @leavingdate > GETDATE()
		SET @leavingdate = GETDATE();


	SET @amount = [dbo].[udfsys_wholeyearsbetweentwodates]
		(@startdate, @leavingdate);

	-- Years	
	IF @period = 'Y' SET @result = @amount
	
	--Months
	ELSE IF @period = 'M'
		SET @result = [dbo].[udfsys_wholemonthsbetweentwodates]
			(@startdate, @leavingdate) - (@amount * 12);
	
    RETURN @result;

END
GO
PRINT N'Adding schema binding to [dbo].[udfsys_servicelength]...';


GO
ALTER FUNCTION [dbo].[udfsys_servicelength] (
     @startdate  datetime,
     @leavingdate  datetime,
     @period nvarchar(2))
RETURNS integer 
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result integer;
	DECLARE @amount integer;

	-- If start date is in the future ignore
	IF @startdate > GETDATE()
		RETURN 0;
	
	-- Trim the leaving date
	IF @leavingdate IS NULL OR @leavingdate > GETDATE()
		SET @leavingdate = GETDATE();


	SET @amount = [dbo].[udfsys_wholeyearsbetweentwodates]
		(@startdate, @leavingdate);

	-- Years	
	IF @period = 'Y' SET @result = @amount
	
	--Months
	ELSE IF @period = 'M'
		SET @result = [dbo].[udfsys_wholemonthsbetweentwodates]
			(@startdate, @leavingdate) - (@amount * 12);
	
    RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfsys_statutoryredundancypay]...';


GO
ALTER FUNCTION [dbo].[udfsys_statutoryredundancypay](
	@startdate AS datetime,
	@leavingdate AS datetime,
	@dateofbirth AS datetime,
	@weeklyrate AS numeric(10,2),
	@limit as numeric(10,2))
RETURNS numeric(10,2)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result numeric(10,2);
	DECLARE @service_years integer;
	
	--/* First three parameters are compulsory, so return 0 and exit if they are not set */
	IF (@startdate IS null) OR (@leavingdate IS null) OR (@weeklyrate IS null)
	BEGIN
		SET @result = 0;
		RETURN @result;
	END

	-- Calculate service years
	SET @service_years = [dbo].[udfsys_wholeyearsbetweentwodates](@startdate, @leavingdate);

	SET @result = @service_years * @weeklyrate;

	RETURN @result;

END
GO
PRINT N'Adding schema binding to [dbo].[udfsys_statutoryredundancypay]...';


GO
ALTER FUNCTION [dbo].[udfsys_statutoryredundancypay](
	@startdate AS datetime,
	@leavingdate AS datetime,
	@dateofbirth AS datetime,
	@weeklyrate AS numeric(10,2),
	@limit as numeric(10,2))
RETURNS numeric(10,2)
WITH SCHEMABINDING
AS
BEGIN

	DECLARE @result numeric(10,2);
	DECLARE @service_years integer;
	
	--/* First three parameters are compulsory, so return 0 and exit if they are not set */
	IF (@startdate IS null) OR (@leavingdate IS null) OR (@weeklyrate IS null)
	BEGIN
		SET @result = 0;
		RETURN @result;
	END

	-- Calculate service years
	SET @service_years = [dbo].[udfsys_wholeyearsbetweentwodates](@startdate, @leavingdate);

	SET @result = @service_years * @weeklyrate;

	RETURN @result;

END
GO
PRINT N'Altering [dbo].[udfASRGetWorkflowDelegatedRecords]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER FUNCTION [dbo].[udfASRGetWorkflowDelegatedRecords]
(
	@psOriginalRecipient varchar(MAX)
)
RETURNS @returntable TABLE
(
	id integer, 
	emailAddress varchar(MAX), 
	delegated bit, 
	delegatedTo varchar(MAX)
)
AS
BEGIN

	RETURN

END
GO
PRINT N'Altering [dbo].[ASRSysColumns]...';


GO
ALTER VIEW [dbo].[ASRSysColumns]
					WITH SCHEMABINDING
					AS SELECT base.[columnid] AS [columnId], base.[tableid] AS [tableId]
						, base.[columntype], base.[datatype], base.[defaultvalue], base.[size], base.[decimals], base.[lookuptableid], base.[lookupcolumnid], base.[controltype], base.[spinnerminimum], base.[spinnermaximum], base.[spinnerincrement], base.[audit], base.[duplicate], base.[mandatory], base.[uniquecheck], base.[convertcase], base.[mask], base.[alphaonly], base.[blankifzero], base.[multiline], base.[alignment], base.[calcexprid], base.[gotfocusexprid], base.[lostfocusexprid], base.[calctrigger], base.[readonly], base.[statusbarmessage], base.[errormessage], base.[linktableid], base.[afdenabled], base.[afdindividual], base.[afdforename], base.[afdsurname], base.[afdinitial], base.[afdtelephone], base.[afdaddress], base.[afdproperty], base.[afdstreet], base.[afdlocality], base.[afdtown], base.[afdcounty], base.[dfltvalueexprid], base.[linkorderid], base.[oleonserver], base.[childuniquecheck], base.[linkviewid], base.[defaultdisplaywidth], base.[columnname], base.[uniquechecktype], base.[trimming], base.[use1000separator], base.[lookupfiltercolumnid], base.[lookupfiltervalueid], base.[qaddressenabled], base.[qaindividual], base.[qaaddress], base.[qaproperty], base.[qastreet], base.[qalocality], base.[qatown], base.[qacounty], base.[lookupfilteroperator], base.[embedded], base.[oletype], base.[maxolesizeenabled], base.[maxolesize], base.[autoupdatelookupvalues], base.[calculateifempty],  obj.[locked], obj.[lastupdated], obj.[lastupdatedby]
						FROM dbo.[tbsys_columns] base
						INNER JOIN dbo.[tbsys_scriptedobjects] obj ON obj.targetid = base.columnid AND obj.objecttype = 2
						INNER JOIN dbo.[tbstat_effectivedates] dt ON dt.[type] = 1
						WHERE obj.effectivedate <= dt.[date]
GO
PRINT N'Altering [dbo].[ASRSysGroups]...';


GO
ALTER VIEW [dbo].[ASRSysGroups] AS
	SELECT principal_id AS ID, name FROM sys.database_principals
	WHERE type = 'R' AND is_fixed_role = 0
		AND (principal_id > 0) AND NOT (name LIKE 'ASRSys%');
GO
PRINT N'Altering [dbo].[ASRSysTables]...';


GO
ALTER VIEW [dbo].[ASRSysTables]
					WITH SCHEMABINDING
					AS SELECT base.[tableid] AS [tableId], base.[tabletype], base.[defaultorderid], base.[recorddescexprid], base.[defaultemailid], base.[tablename], base.[manualsummarycolumnbreaks], base.[auditinsert], base.[auditdelete], base.[isremoteview],  obj.[locked], obj.[lastupdated], obj.[lastupdatedby]
						FROM dbo.[tbsys_tables] base
						INNER JOIN dbo.[tbsys_scriptedobjects] obj ON obj.targetid = base.tableid AND obj.objecttype = 1
						INNER JOIN dbo.[tbstat_effectivedates] dt ON dt.[type] = 1
						WHERE obj.effectivedate <= dt.[date]
GO
PRINT N'Altering [dbo].[INS_ASRSysColumns]...';


GO
ALTER TRIGGER [dbo].[INS_ASRSysColumns]
ON [dbo].[ASRSysColumns]
INSTEAD OF INSERT
AS
BEGIN

	SET NOCOUNT ON;

	-- Update objects table
	IF NOT EXISTS(SELECT [guid]
		FROM dbo.[tbsys_scriptedobjects] o
		INNER JOIN inserted i ON i.columnid = o.targetid AND o.objecttype = 2)
	BEGIN
		INSERT dbo.[tbsys_scriptedobjects] ([guid], [objecttype], [targetid], [ownerid], [effectivedate], [revision], [locked], [lastupdated])
			SELECT NEWID(), 2, [columnid], dbo.[udfsys_getownerid](), '01/01/1900',1,0, GETDATE()
				FROM inserted;
	END

	-- Update base table								
	INSERT dbo.[tbsys_columns] ([columnID], [tableID], [columnType], [datatype], [defaultValue], [size], [decimals], [lookupTableID], [lookupColumnID], [controltype], [spinnerMinimum], [spinnerMaximum], [spinnerIncrement], [audit], [duplicate], [mandatory], [uniquecheck], [convertcase], [mask], [alphaonly], [blankIfZero], [multiline], [alignment], [calcExprID], [gotFocusExprID], [lostFocusExprID], [calcTrigger], [readOnly], [statusBarMessage], [errorMessage], [linkTableID], [Afdenabled], [Afdindividual], [Afdforename], [Afdsurname], [Afdinitial], [Afdtelephone], [Afdaddress], [Afdproperty], [Afdstreet], [Afdlocality], [Afdtown], [Afdcounty], [dfltValueExprID], [linkOrderID], [OleOnServer], [childUniqueCheck], [LinkViewID], [DefaultDisplayWidth], [ColumnName], [UniqueCheckType], [Trimming], [Use1000Separator], [LookupFilterColumnID], [LookupFilterValueID], [QAddressEnabled], [QAIndividual], [QAAddress], [QAProperty], [QAStreet], [QALocality], [QATown], [QACounty], [LookupFilterOperator], [Embedded], [OLEType], [MaxOLESizeEnabled], [MaxOLESize], [AutoUpdateLookupValues], [CalculateIfEmpty]) 
		SELECT [columnID], [tableID], [columnType], [datatype], [defaultValue], [size], [decimals], [lookupTableID], [lookupColumnID], [controltype], [spinnerMinimum], [spinnerMaximum], [spinnerIncrement], [audit], [duplicate], [mandatory], [uniquecheck], [convertcase], [mask], [alphaonly], [blankIfZero], [multiline], [alignment], [calcExprID], [gotFocusExprID], [lostFocusExprID], [calcTrigger], [readOnly], [statusBarMessage], [errorMessage], [linkTableID], [Afdenabled], [Afdindividual], [Afdforename], [Afdsurname], [Afdinitial], [Afdtelephone], [Afdaddress], [Afdproperty], [Afdstreet], [Afdlocality], [Afdtown], [Afdcounty], [dfltValueExprID], [linkOrderID], [OleOnServer], [childUniqueCheck], [LinkViewID], [DefaultDisplayWidth], [ColumnName], [UniqueCheckType], [Trimming], [Use1000Separator], [LookupFilterColumnID], [LookupFilterValueID], [QAddressEnabled], [QAIndividual], [QAAddress], [QAProperty], [QAStreet], [QALocality], [QATown], [QACounty], [LookupFilterOperator], [Embedded], [OLEType], [MaxOLESizeEnabled], [MaxOLESize], [AutoUpdateLookupValues], [CalculateIfEmpty] FROM inserted;

END
GO
PRINT N'Altering [dbo].[DEL_ASRSysTables]...';


GO
ALTER TRIGGER [DEL_ASRSysTables]
ON [dbo].[ASRSysTables]
INSTEAD OF DELETE
AS
BEGIN
	SET NOCOUNT ON;

	DELETE FROM [tbsys_tables] WHERE tableid IN (SELECT tableid FROM deleted);
	DELETE FROM [tbsys_scriptedobjects] WHERE targetid IN (SELECT tableid FROM deleted) AND objecttype = 1;

END
GO
PRINT N'Altering [dbo].[sp_ASR_AbsenceBreakdown_Calculate]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[sp_ASR_AbsenceBreakdown_Calculate](
	@pdblResult                       float OUTPUT,
	@pfMonTotal                      float OUTPUT,
	@pfTueTotal                      float OUTPUT,
	@pfWedTotal                      float OUTPUT,
	@pfThuTotal                      float OUTPUT,
	@pfFriTotal                      float OUTPUT,
	@pfSatTotal                      float OUTPUT,
	@pfSunTotal                      float OUTPUT,
	@pdtStartDate                     datetime,
	@psStartSession                   varchar(255),
	@pdtEndDate                       datetime,
	@psEndSession                     varchar(255),
	@iPersonnelID                     int
	) 
AS 
BEGIN
	RETURN 0
END
GO
PRINT N'Altering [dbo].[sp_ASR_AbsenceBreakdown_Run]...';


GO
ALTER PROCEDURE [dbo].[sp_ASR_AbsenceBreakdown_Run]
(
	@pdReportStart      datetime,
	@pdReportEnd		datetime,
	@pcReportTableName  char(30)
) 
AS 
BEGIN

	SET NOCOUNT ON;

	declare @pdStartDate as datetime
	declare @pdEndDate as datetime
	declare @pcStartSession as char(2)
	declare @pcEndSession as char(2)
	declare @pcType as char(50)
	declare @pcRecordDescription as char(100)

	declare @pfDuration as float
	declare @pdblSun as float
	declare @pdblMon as float
	declare @pdblTue as float
	declare @pdblWed as float
	declare @pdblThu as float
	declare @pdblFri as float
	declare @pdblSat as float

	declare @sSQL as varchar(MAX)
	declare @piParentID as integer
	declare @piID as integer
	declare @pbProcessed as bit

	declare @pdTempStartDate as datetime
	declare @pdTempEndDate as datetime
	declare @pcTempStartSession as char(2)
	declare @pcTempEndSession as char(2)
	declare @sTempEndDate as varchar(50)

	declare @pfCount as float
	declare @psVer as char(80)

	/* Alter the structure of the temporary table so it can hold the text for the days */
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ALTER COLUMN Hor NVARCHAR(10)'
	execute(@sSQL)
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ADD Processed BIT'
	execute(@sSQL)
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ADD DisplayOrder INT'
	execute(@sSQL)
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ALTER COLUMN Value decimal(10,5)'
	execute(@sSQL)

	/* Load the values from the temporary cursor */
	Set @sSQL = 'DECLARE AbsenceBreakdownCursor CURSOR STATIC FOR SELECT ID, Personnel_ID, Start_Date, End_Date, Start_Session, End_Session, Ver, RecDesc, Processed FROM ' + @pcReportTableName
	execute(@sSQL)
	open AbsenceBreakdownCursor

	/* Loop through the records in the absence breakdown report table */
	Fetch Next From AbsenceBreakdownCursor Into @piID, @piParentID, @pdStartDate, @pdEndDate, @pcStartSession, @pcEndSession, @pcType, @pcRecordDescription, @pbProcessed
	while @@FETCH_STATUS = 0
		begin

		Set @pdblSun = 0
		Set @pdblMon = 0
		Set @pdblTue = 0
		Set @pdblWed = 0
		Set @pdblThu = 0
		Set @pdblFri = 0
		Set @pdblSat = 0

		/* The absence should only calculate for absence within the reporting period */
		set @pdTempStartDate = @pdStartDate
		set @pcTempStartSession = @pcStartSession
		set @pdTempEndDate = @pdEndDate
		set @pcTempEndSession = @pcEndSession

		--/* If blank leaving date set it to todays date */
		if @pdTempEndDate is Null set @pdTempEndDate = getdate()

		if @pdStartDate <  @pdReportStart
			begin
			set @pdTempStartDate = @pdReportStart
			set @pcTempStartSession = 'AM'
			end
		if @pdTempEndDate >  @pdReportEnd
			begin
			set @pdTempEndDate = @pdReportEnd
			set @pcTempEndSession = 'PM'
			end

		set @sTempEndDate = case when @pdEndDate is null then 'null' else '''' + convert(varchar(40),@pdEndDate) + '''' end

		/* Calculate the days this absence takes up */
		execute sp_ASR_AbsenceBreakdown_Calculate @pfDuration OUTPUT, @pdblMon OUTPUT, @pdblTue OUTPUT, @pdblWed OUTPUT, @pdblThu OUTPUT, @pdblFri OUTPUT, @pdblSat OUTPUT, @pdblSun OUTPUT, @pdTempStartDate, @pcTempStartSession, @pdTempEndDate, @pcTempEndSession, @piParentID

		/* Strip out dodgy characters */
		set @pcRecordDescription = replace(@pcRecordDescription,'''','')
		set @pcType = replace(@pcType,'''','')

		/* Add Mondays records */
		if @pdblMon > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 0) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblMon) + ',''' + convert(varchar(20),@pdStartDate) + ''',1,1,' + @sTempEndDate + ',1)'
			execute(@sSQL)
			end

		/* Add Tuesday records */
		if @pdblTue > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 1) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblTue) +  ',''' + convert(varchar(20),@pdStartDate) + ''',2,1,' + @sTempEndDate +',2)'
			execute(@sSQL)
			end

		/* Add Wednesdays records */
		if @pdblWed > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 2) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblWed) +  ',''' + convert(varchar(20),@pdStartDate) +  ''',3,1,' + @sTempEndDate +',3)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Thursdays were found */
		if @pdblThu > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 3) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblThu) +  ',''' + convert(varchar(20),@pdStartDate) + ''',4,1,' + @sTempEndDate +',4)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Fridays were found */
		if @pdblFri > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 4) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblFri) + ',''' + convert(varchar(20),@pdStartDate) + ''',5,1,' + @sTempEndDate +',5)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Saturdays were found */
		if @pdblSat > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 5) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblSat) + ','''+ convert(varchar(20),@pdStartDate) + ''',6,1,' + @sTempEndDate +',6)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Sundays were found */
		if @pdblSun > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 5) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblSun) + ',''' + convert(varchar(20),@pdStartDate) + ''',7,1,' + @sTempEndDate +',0)'
			execute(@sSQL)
			end

		/* Calculate total duraton of absence */
		set @pfDuration = @pdblMon + @pdblTue + @pdblWed + @pdblThu + @pdblFri + @pdblSat + @pdblSun

		if @pfDuration > 0
			begin
			/* Write records for average, totals and count */
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''Total'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pfDuration) + ',''' + convert(varchar(20),@pdStartDate) + ''',9,1,' + @sTempEndDate +',8)'
			execute(@sSQL)

			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''Count'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),1) + ',''' + convert(varchar(20),@pdStartDate) + ''',10,1,' + @sTempEndDate +',10)'
			execute(@sSQL)

			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (' + Convert(varchar(10),@piParentID) + ',''Average'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pfDuration) + ',''' + convert(varchar(20),@pdStartDate) + ''',9,1,' + @sTempEndDate +',9)'
			execute(@sSQL)
			end

		/* Process next record */
		Fetch Next From AbsenceBreakdownCursor Into @piID, @piParentID, @pdStartDate, @pdEndDate, @pcStartSession, @pcEndSession, @pcType, @pcRecordDescription, @pbProcessed

		end

	/* Delete this record from our collection as it's now been processed */
	set @sSQL = 'DELETE FROM ' + @pcReportTableName + ' Where Processed IS NULL'
	execute(@sSQL)

	Set @sSQL = 'DECLARE CalculateAverage CURSOR STATIC FOR SELECT Ver,(SUM(Value) / COUNT(Value)) / COUNT(Value) FROM ' + @pcReportTableName + ' WHERE hor = ''Average'' GROUP BY Ver'
	execute(@sSQL)
	open CalculateAverage

	Fetch Next From CalculateAverage Into @psVer, @pfCount
	while @@FETCH_STATUS = 0
		begin
  			Set @sSQL = 'UPDATE ' + @pcReportTableName + ' SET Value = ' + Convert(varchar(10),@pfCount) + ' WHERE Ver =  ''' + @psVer + ''' AND Hor = ''Average'''
		execute(@sSQL)
			Fetch Next From CalculateAverage Into @psVer, @pfCount
		end

	/* Tidy up */
	close AbsenceBreakdownCursor
	close CalculateAverage
	deallocate AbsenceBreakdownCursor
	deallocate CalculateAverage

END
GO
PRINT N'Altering [dbo].[sp_ASR_Bradford_DeleteAbsences]...';


GO
ALTER PROCEDURE [dbo].[sp_ASR_Bradford_DeleteAbsences]
(
	@pdReportStart	  	datetime,
	@pdReportEnd				datetime,
	@pbOmitBeforeStart	bit,
	@pbOmitAfterEnd			bit,
	@pcReportTableName	char(30)
)
AS
BEGIN

	SET NOCOUNT ON;

	declare @piID as integer;
	declare @pdStartDate as datetime;
	declare @pdEndDate as datetime;
	declare @iDuration as float;
	declare @pbDeleteThisAbsence as bit;
	declare @sSQL as varchar(MAX);

	set @sSQL = 'DECLARE BradfordIndexCursor2 CURSOR FOR SELECT Absence_ID, Start_Date, End_Date, Duration FROM ' + @pcReportTableName;
	execute(@sSQL);
	open BradfordIndexCursor2;

	Fetch Next From BradfordIndexCursor2 Into @piID, @pdStartDate, @pdEndDate, @iDuration;
	while @@FETCH_STATUS = 0
		begin
			set @pbDeleteThisAbsence = 0;
			if @pdEndDate < @pdReportStart set @pbDeleteThisAbsence = 1;
			if @pdStartDate > @pdReportEnd set @pbDeleteThisAbsence = 1;
			if @iDuration = 0 set @pbDeleteThisAbsence = 1;

			if @pbOmitBeforeStart = 1 and (@pdStartDate < @pdReportStart)  set @pbDeleteThisAbsence = 1;
			if @pbOmitAfterEnd = 1 and (@pdEndDate > @pdReportEnd)  set @pbDeleteThisAbsence = 1;

			if @pbDeleteThisAbsence = 1
				begin
					set @sSQL = 'DELETE FROM ' + @pcReportTableName + ' Where Absence_ID = Convert(Int,' + Convert(char(10),@piId) + ')';
					execute(@sSQL);
				end

			Fetch Next From BradfordIndexCursor2 Into @piID, @pdStartDate, @pdEndDate, @iDuration;
		end

	close BradfordIndexCursor2;
	deallocate BradfordIndexCursor2;

END
GO
PRINT N'Altering [dbo].[sp_ASR_Bradford_MergeAbsences]...';


GO
ALTER PROCEDURE [dbo].[sp_ASR_Bradford_MergeAbsences]
(
	@pdReportStart	  	datetime,
	@pdReportEnd		datetime,
	@pcReportTableName	char(30)
)
AS
BEGIN

	SET NOCOUNT ON;

	declare @sSql as varchar(MAX);

	/* Variables to hold current absence record */
	declare @pdStartDate as datetime;
	declare @pdEndDate as datetime;
	declare @pcStartSession as char(2);
	declare @pfDuration as float;
	declare @piID as integer;
	declare @piPersonnelID as integer;
	declare @pbContinuous as bit;

	/* Variables to hold last absence record */
	declare @pdLastStartDate as datetime;
	declare @pcLastStartSession as char(2);
	declare @pfLastDuration as float;
	declare @piLastID as integer;
	declare @piLastPersonnelID as integer;

	/* Open the passed in table */
	set @sSQL = 'DECLARE BradfordIndexCursor CURSOR FOR SELECT Start_Date, Start_Session, Duration, Absence_ID, Continuous, Personnel_ID FROM ' + @pcReportTableName + ' ORDER BY Personnel_ID, Start_Date ASC';
	execute(@sSQL);
	open BradfordIndexCursor;

	/* Loop through the records in the bradford report table */
	Fetch next From BradfordIndexCursor Into @pdStartDate, @pcStartSession, @pfDuration, @piID, @pbContinuous, @piPersonnelID;
	while @@FETCH_STATUS = 0
	begin

		if @pbContinuous = 0 Or (@piPersonnelID <> @piLastPersonnelID)
		begin
			Set @pdLastStartDate = @pdStartDate;
			Set @pcLastStartSession = @pcStartSession;
			Set @pfLastDuration = @pfDuration;
			Set @piLastID = @piID;

		end
		else
		begin

			Set @pfLastDuration = @pfLastDuration + @pfDuration;

			/* update start date */
			set @sSQL = 'UPDATE ' + @pcReportTableName + ' SET Start_Date = ''' + convert(varchar(20),@pdLastStartDate) + ''', Start_Session = ''' + @pcLastStartSession + ''', Duration = ' + Convert(Char(10), @pfLastDuration) + ', Included_Days = ' + Convert(Char(10), @pfLastDuration) + ' Where Absence_ID = ' + Convert(varchar(10),@piId);
			execute(@sSQL);

			/* Delete the previous record from our collection */
			set @sSQL = 'DELETE FROM ' + @pcReportTableName + ' Where Absence_ID = ' + Convert(varchar(10),@piLastId);
			execute(@sSQL);

			Set @piLastID = @piID;

		end

		/* Get next absence record */
		Set @piLastPersonnelID = @piPersonnelID;
		
		Fetch next From BradfordIndexCursor Into @pdStartDate, @pcStartSession, @pfDuration, @piID, @pbContinuous, @piPersonnelID;
	end

	close BradfordIndexCursor;
	deallocate BradfordIndexCursor;

END
GO
PRINT N'Altering [dbo].[sp_ASR_TBCheckOverbooking]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[sp_ASR_TBCheckOverbooking]
AS
	SELECT 0
RETURN 0
GO
PRINT N'Altering [dbo].[sp_ASR_TBCheckOverlappedBooking]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[sp_ASR_TBCheckOverlappedBooking] (
	@plngCourseRecordID int,
	@plngEmployeeRecordID int,
	@plngBookingRecordID int,
	@piReturnCode int OUTPUT
)
AS
BEGIN
	SET @piReturnCode = 1;
END
GO
PRINT N'Altering [dbo].[sp_ASR_TBCheckPreRequisites]...';


GO
ALTER  PROCEDURE [dbo].[sp_ASR_TBCheckPreRequisites] (
		@plngCourseRecordID int,
		@plngEmployeeRecordID int,
		@piPreReqsMet int OUTPUT
)
AS
BEGIN

	SET @piPreReqsMet = 0;

END
GO
PRINT N'Altering [dbo].[sp_ASR_TBCheckUnavailability]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[sp_ASR_TBCheckUnavailability] (
	@plngCourseRecordID int,
	@plngEmployeeRecordID int,
	@piReturnCode int OUTPUT
)
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[sp_ASRAuditLogPurge]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRAuditLogPurge]
AS
BEGIN

	DECLARE @intFrequency	integer,
			@strPeriod		char(2);

	SET @strPeriod = null;
	SET @intFrequency = null;

	SELECT @intFrequency = Frequency
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Users';

	SELECT @strPeriod = Period
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Users';

	IF (@intFrequency IS NOT NULL) AND (@strPeriod IS NOT NULL)
	BEGIN

		IF @strPeriod = 'dd'
			DELETE FROM ASRSysAuditGroup WHERE [DateTimeStamp] < DATEADD(dd,-@intfrequency,getdate());

		IF @strPeriod = 'wk'
			DELETE FROM ASRSysAuditGroup WHERE [DateTimeStamp] < DATEADD(wk,-@intfrequency,getdate());

		IF @strPeriod = 'mm'
			DELETE FROM ASRSysAuditGroup WHERE [DateTimeStamp] < DATEADD(mm,-@intfrequency,getdate());

		IF @strPeriod = 'yy'
			DELETE FROM ASRSysAuditGroup WHERE [DateTimeStamp] < DATEADD(yy,-@intfrequency,getdate());

	END

	SET @strPeriod = null;
	SET @intFrequency = null;

	SELECT @intFrequency = Frequency
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Permissions';

	SELECT @strPeriod = Period
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Permissions';

	IF (@intFrequency IS NOT NULL) AND (@strPeriod IS NOT NULL)
	BEGIN
		IF @strPeriod = 'dd'
			DELETE FROM ASRSysAuditPermissions WHERE [DateTimeStamp] < DATEADD(dd,-@intfrequency,getdate());

		IF @strPeriod = 'wk'
			DELETE FROM ASRSysAuditPermissions WHERE [DateTimeStamp] < DATEADD(wk,-@intfrequency,getdate());

		IF @strPeriod = 'mm'
			DELETE FROM ASRSysAuditPermissions WHERE [DateTimeStamp] < DATEADD(mm,-@intfrequency,getdate());

		IF @strPeriod = 'yy'
			DELETE FROM ASRSysAuditPermissions WHERE [DateTimeStamp] < DATEADD(yy,-@intfrequency,getdate());
	END

	SET @strPeriod = null;
	SET @intFrequency = null;

	SELECT @intFrequency = Frequency
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Data';

	SELECT @strPeriod = Period
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Data';

	IF (@intFrequency IS NOT NULL) AND (@strPeriod IS NOT NULL)
	BEGIN
		IF @strPeriod = 'dd'
			DELETE FROM ASRSysAuditTrail  WHERE [DateTimeStamp] < DATEADD(dd,-@intfrequency,getdate());

		IF @strPeriod = 'wk'
			DELETE FROM ASRSysAuditTrail WHERE [DateTimeStamp] < DATEADD(wk,-@intfrequency,getdate());

		IF @strPeriod = 'mm'
			DELETE FROM ASRSysAuditTrail WHERE [DateTimeStamp] < DATEADD(mm,-@intfrequency,getdate());

		IF @strPeriod = 'yy'
			DELETE FROM ASRSysAuditTrail WHERE [DateTimeStamp] < DATEADD(yy,-@intfrequency,getdate());

	END

	SET @strPeriod = null;
	SET @intFrequency = null;

	SELECT @intFrequency = Frequency
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Access';

	SELECT @strPeriod = Period
	FROM ASRSysAuditCleardown
	WHERE [Type] = 'Access';

	IF (@intFrequency IS NOT NULL) AND (@strPeriod IS NOT NULL)
	BEGIN

		IF @strPeriod = 'dd'
			DELETE FROM ASRSysAuditAccess WHERE [DateTimeStamp] < DATEADD(dd,-@intfrequency,getdate());

		IF @strPeriod = 'wk'
			DELETE FROM ASRSysAuditAccess WHERE [DateTimeStamp] < DATEADD(wk,-@intfrequency,getdate());

		IF @strPeriod = 'mm'
			DELETE FROM ASRSysAuditAccess WHERE [DateTimeStamp] < DATEADD(mm,-@intfrequency,getdate());

		IF @strPeriod = 'yy'
			DELETE FROM ASRSysAuditAccess WHERE [DateTimeStamp] < DATEADD(yy,-@intfrequency,getdate());

	END
END
GO
PRINT N'Altering [dbo].[sp_ASRCrossTabsRecDescs]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRCrossTabsRecDescs]
	(@tablename varchar(8000), @recordDescid int)
AS
BEGIN

	DECLARE @sSQL nvarchar(MAX);

	IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'sp_ASRExpr_' + convert(varchar,@RecordDescID))
	BEGIN
		SET @sSQL = '
			declare @tableid int;
			declare @recordid int;
			declare @recorddesc varchar(MAX);

			DECLARE table_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ID FROM '+ convert(nvarchar(MAX), @tablename) +'; 

			OPEN table_cursor;
			FETCH NEXT FROM table_cursor INTO @recordid;

			WHILE (@@fetch_status = 0)
			BEGIN
				exec sp_ASRExpr_' + convert(nvarchar(128),@RecordDescID) + ' @RecordDesc OUTPUT, @Recordid
				UPDATE ' + convert(nvarchar(128), @tablename) + ' SET RecDesc = @recordDesc WHERE id = @Recordid; 
				FETCH NEXT FROM table_cursor INTO @recordid
			END
			CLOSE table_cursor
			DEALLOCATE table_cursor';
		EXEC sp_executesql @ssql

	END

END
GO
PRINT N'Altering [dbo].[sp_AsrEventLogPurge]...';


GO
ALTER PROCEDURE [sp_AsrEventLogPurge] AS

/* First retrieve the frequency/period info from the ASRSysEventLogPurge table */
DECLARE @intFrequency int,
        @strPeriod char(2)

/* Get the start date of the given course. */
SELECT @intFrequency = Frequency
FROM ASRSysEventLogPurge

SELECT @strPeriod = Period
FROM ASRSysEventLogPurge

IF (@intFrequency IS NOT NULL) AND (@strPeriod IS NOT NULL)

BEGIN

  /* Delete rows from the EventLog Header table that are older than the criteria specified */

  IF @strPeriod = 'dd'
  BEGIN
    DELETE FROM ASRSysEventLog WHERE [DateTime] < DATEADD(dd,-@intfrequency,getdate())
  END

  IF @strPeriod = 'wk'
  BEGIN
    DELETE FROM ASRSysEventLog WHERE [DateTime] < DATEADD(wk,-@intfrequency,getdate())
  END

  IF @strPeriod = 'mm'
  BEGIN
    DELETE FROM ASRSysEventLog WHERE [DateTime] < DATEADD(mm,-@intfrequency,getdate())
  END

  IF @strPeriod = 'yy'
  BEGIN
    DELETE FROM ASRSysEventLog WHERE [DateTime] < DATEADD(yy,-@intfrequency,getdate())
  END

  /* Delete the child rows for the header records we have just deleted */
  DELETE FROM ASRSysEventLogDetails WHERE [EventLogID] NOT IN (SELECT ID FROM ASRSysEventLog)

END
GO
PRINT N'Altering [dbo].[sp_ASRFn_AbsenceDuration]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[sp_ASRFn_AbsenceDuration](
	 @pdblResult                       float OUTPUT,
	 @pdtStartDate                     datetime,
	 @psStartSession                   varchar(255),
	 @pdtEndDate                       datetime,
	 @psEndSession                     varchar(255),
	 @iPersonnelID                     int
	 ) 
AS 
	RETURN 0
GO
PRINT N'Altering [dbo].[sp_ASRFn_ConvertToPropercase]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_ConvertToPropercase]
(
	@psOutput	varchar(MAX) OUTPUT,
	@psInput 	varchar(MAX)
)
AS
BEGIN

	DECLARE @Index	integer,
			@Char	char(1);

	SET @psOutput = LOWER(@psInput);
	SET @Index = 1;
	SET @psOutput = STUFF(@psOutput, 1, 1,UPPER(SUBSTRING(@psInput,1,1)));

	WHILE @Index <= LEN(@psInput)
	BEGIN

		SET @Char = SUBSTRING(@psInput, @Index, 1);

		IF @Char IN ('m','M',' ', ';', ':', '!', '?', ',', '.', '_', '-', '/', '&','''','(',char(9), char(13), char(10))
		BEGIN
			IF @Index + 1 <= LEN(@psInput)
			BEGIN
				IF @Char = '' AND UPPER(SUBSTRING(@psInput, @Index + 1, 1)) != 'S'
					SET @psOutput = STUFF(@psOutput, @Index + 1, 1,UPPER(SUBSTRING(@psInput, @Index + 1, 1)));
				ELSE IF UPPER(@Char) != 'M'
					SET @psOutput = STUFF(@psOutput, @Index + 1, 1,UPPER(SUBSTRING(@psInput, @Index + 1, 1)));

				-- Catch the McName
				IF UPPER(@Char) = 'M' AND UPPER(SUBSTRING(@psInput, @Index + 1, 1)) = 'C' AND UPPER(SUBSTRING(@psInput, @Index - 1, 1)) = ''
				BEGIN
					SET @psOutput = STUFF(@psOutput, @Index + 1, 1,LOWER(SUBSTRING(@psInput, @Index + 1, 1)));
					SET @psOutput = STUFF(@psOutput, @Index + 2, 1,UPPER(SUBSTRING(@psInput, @Index + 2, 1)));
					SET @Index = @Index + 1;
				END
			END
		END

	SET @Index = @Index + 1;
	END

END
GO
PRINT N'Altering [dbo].[sp_ASRFn_GetFieldFromDatabase]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_GetFieldFromDatabase] (
	@psCharResult		varchar(255) OUTPUT,
	@pfBitResult		bit	OUTPUT,
	@pfltNumResult		float OUTPUT,
	@pdtDateResult		datetime OUTPUT,
	@piSearchColumnID	int,
	@psCharSearchValue	varchar(255),
	@pfBitSearchValue	bit,
	@pfltNumSearchValue	float,
	@pdtDateSearchValue	datetime,
	@piReturnColumnID	int)
AS
BEGIN
	DECLARE @sSearchColumnName	sysname,
		@sSearchTableName		sysname,
		@sReturnColumnName		sysname,
		@sReturnTableName		sysname,
		@iSearchColumnType		int,
		@iReturnColumnType		int,
		@sCommandString			nvarchar(MAX),
		@sReturnString			nvarchar(MAX),
		@sParamDefinition		nvarchar(500),
		@sNewCharSearchValue	varchar(MAX),
		@iCharacterIndex		int,
		@iStringLength			int,
		@sCurrentChar 			varchar(1)

	/* Replace any single quote characters in the character search string 
	with two single quote characters so that the SQL Select string which is 
	constructed below is still valid for execution. */
	SET @sNewCharSearchValue = '';
	SET @iCharacterIndex = 0;
	SET @iStringLength = LEN(@psCharSearchValue);

	WHILE @iCharacterIndex < @iStringLength
	BEGIN
		SET @iCharacterIndex = @iCharacterIndex + 1;
		SET @sCurrentChar = SUBSTRING(@psCharSearchValue, @iCharacterIndex, 1);
		SET @sNewCharSearchValue = @sNewCharSearchValue + @sCurrentChar;
	
		IF @sCurrentChar = ''''
		BEGIN
			SET @sNewCharSearchValue = @sNewCharSearchValue + @sCurrentChar;
		END
	END

	SET @psCharSearchValue = @sNewCharSearchValue;

	/* Get the name of the search column. */
	SELECT @sSearchColumnName = ASRSysColumns.columnName, 
		@sSearchTableName = ASRSysTables.tableName, 
		@iSearchColumnType = ASRSysColumns.dataType
	FROM ASRSysColumns
	JOIN ASRSysTables 
		ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysColumns.columnId = @piSearchColumnID;

	/* Get the name of the return column. */
	SELECT @sReturnColumnName = ASRSysColumns.columnName, 
		@sReturnTableName = ASRSysTables.tableName, 
		@iReturnColumnType = ASRSysColumns.dataType
	FROM ASRSysColumns
	JOIN ASRSysTables 
		ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysColumns.columnId = @piReturnColumnID;

	IF (NOT @sSearchColumnName IS NULL) 
		AND (NOT @sSearchTableName IS NULL) 
		AND(NOT @sReturnColumnName IS NULL) 
		AND (NOT @sReturnTableName IS NULL)
		AND ((@iSearchColumnType = 12) OR (@iSearchColumnType = -7) OR (@iSearchColumnType = 4) OR (@iSearchColumnType = 2) OR (@iSearchColumnType = 11)) 
		AND ((@iReturnColumnType = 12) OR (@iReturnColumnType = -7) OR (@iReturnColumnType = 4) OR (@iReturnColumnType = 2) OR (@iReturnColumnType = 11)) 
		AND (@sSearchTableName = @sReturnTableName)
	BEGIN
		IF @iReturnColumnType = 12 
		BEGIN
			SET @sReturnString = '@charResult';
			SET @sParamDefinition = N'@charResult varchar(255) OUTPUT';
		END

		IF @iReturnColumnType = -7 
		BEGIN
			SET @sReturnString = '@bitResult';
			SET @sParamDefinition = N'@bitResult bit OUTPUT';
		END

		IF (@iReturnColumnType = 4) OR (@iReturnColumnType = 2) 
		BEGIN
			SET @sReturnString = '@numResult';
			SET @sParamDefinition = N'@numResult float OUTPUT';
		END

		IF @iReturnColumnType = 11 
		BEGIN
			SET @sReturnString = '@datetimeResult';
			SET @sParamDefinition = N'@dateResult datetime OUTPUT';
		END

		IF @iSearchColumnType = 12 
		BEGIN
			SET @sCommandString = 'SELECT ' + @sReturnString + ' = ' + @sReturnColumnName + ' FROM ' + @sReturnTableName + ' WHERE ' + @sSearchColumnName + ' = ''' + @psCharSearchValue + '''';
		END

		IF @iSearchColumnType = -7 
		BEGIN
			SET @sCommandString = 'SELECT  ' + @sReturnString + ' = ' + @sReturnColumnName + ' FROM ' + @sReturnTableName + ' WHERE ' + @sSearchColumnName + ' = ' + convert(varchar(MAX), @pfBitSearchValue);
		END

		IF (@iSearchColumnType = 4) OR (@iSearchColumnType = 2) 
		BEGIN
			SET @sCommandString = 'SELECT  ' + @sReturnString + ' = ' + @sReturnColumnName + ' FROM ' + @sReturnTableName + ' WHERE ' + @sSearchColumnName + ' = ' + convert(varchar(MAX), @pfltNumSearchValue)
		END
	
		IF @iSearchColumnType = 11 
		BEGIN
			SET @sCommandString = 'SELECT  ' + @sReturnString + ' = ' + @sReturnColumnName + ' FROM ' + @sReturnTableName + ' WHERE ' + @sSearchColumnName + ' = ''' + convert(varchar(MAX), @pdtDateSearchValue, 101) + ''''
		END
		IF @iReturnColumnType = 12 EXECUTE sp_executesql @sCommandString, @sParamDefinition, @psCharResult OUTPUT;
		IF @iReturnColumnType = -7 EXECUTE sp_executesql @sCommandString, @sParamDefinition, @pfBitResult OUTPUT;
		IF (@iReturnColumnType = 4) OR (@iReturnColumnType = 2) EXECUTE sp_executesql @sCommandString, @sParamDefinition, @pfltNumResult OUTPUT;
		IF @iReturnColumnType = 11 EXECUTE sp_executesql @sCommandString, @sParamDefinition, @pdtDateResult OUTPUT;
	END

	/* Return the result. */
	IF @iReturnColumnType = 12 SELECT @psCharResult AS result;
	IF @iReturnColumnType = -7 SELECT @pfBitResult AS result;
	IF ((@iReturnColumnType = 4) OR (@iReturnColumnType = 2)) SELECT @pfltNumResult AS result;
	IF @iReturnColumnType = 11 SELECT @pdtDateResult AS result;
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_IFThenElse]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_IFThenElse]
(
	@testvalue		bit,
	@date1			datetime,
	@date2			datetime,
	@retdate   		datetime OUTPUT,
	@char1			varchar(MAX),
	@char2			varchar(MAX),
	@retchar   		varchar(MAX) OUTPUT,
	@numeric1		numeric,
	@numeric2		numeric,
	@retnumeric   	numeric OUTPUT,
	@logic1			bit,
	@logic2			bit,
	@retlogic		bit OUTPUT
)
AS
BEGIN

	IF @date1 IS NOT NULL
	BEGIN
		IF @testvalue = 1
		BEGIN
			SET @retdate = @date1;
			SELECT @retdate AS result;
		END
		IF @testvalue = 0
		BEGIN
			SET @retdate = @date2;
			SELECT @retdate AS result;
		END	
	END

	IF @char1 IS NOT NULL
	BEGIN
		IF @testvalue = 1
		BEGIN
			SET @retchar = @char1;
			SELECT @retchar AS result;
		END
		IF @testvalue = 0
		BEGIN
			SET @retchar = @char2;
			SELECT @retchar AS result;
		END	
	END

	IF @numeric1 IS NOT NULL
	BEGIN
		IF @testvalue = 1
		BEGIN
			SET @retnumeric = @numeric1;
			SELECT @retnumeric AS result;
		END
		IF @testvalue = 0
		BEGIN
			SET @retnumeric = @numeric2;
			SELECT @retnumeric AS result;
		END	
	END

	IF @logic1 IS NOT NULL
	BEGIN
		IF @testvalue = 1
		BEGIN
			SET @retlogic = @logic1;
			SELECT @retlogic AS result;
		END
		IF @testvalue = 0
		BEGIN
			SET @retlogic = @logic2;
			SELECT @retlogic AS result;
		END	

	END
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_NumberOfWorkingDaysPerWeek]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_NumberOfWorkingDaysPerWeek]
(
	@pdblResult 	float OUTPUT,
	@psPattern 		varchar(MAX)		
	/* Working pattern. 14 characters long in the format 'SsMmTtWwTtFfSs'
	where a uppercase letter relates to the morning, and the lowercase letter relates to the afternnon of the appropriate day. 
	A space means that the morning/afternoon is not worked, anything else means that the session is worked. */
)
AS
BEGIN
	DECLARE @iCounter	integer;

	SET @pdblResult = 0;
	SET @iCounter = 0;

	WHILE @iCounter <= LEN(@psPattern)
	BEGIN
		IF SUBSTRING(@psPattern, @iCounter, 1) <> ' '
		BEGIN
			SET @pdblResult = @pdblResult + 0.5;
		END

		SET @iCounter = @iCounter + 1;
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_RemainingMonthsSinceWholeYears]...';


GO

ALTER PROCEDURE sp_ASRFn_RemainingMonthsSinceWholeYears 
(
	@piResult	integer OUTPUT,
	@pdtDate 	datetime
)
AS
BEGIN
	DECLARE @dtToday	datetime

	SET @dtToday = getdate()
	SET @pdtDate = convert(datetime, convert(varchar(20), @pdtDate, 101))

	/* Get the number of whole months */
	SET @piResult = month(@dtToday) - month(@pdtDate)
 
	/* Test the day value */
	IF day(@pdtDate) > day(@dtToday)
	BEGIN
		SET @piResult = @piResult - 1
	END

	IF @piResult < 0
	BEGIN
		SET @piResult = @piResult + 12
	END

END
GO
PRINT N'Altering [dbo].[sp_ASRFn_RoundDateToStartOfNearestMonth]...';


GO

ALTER PROCEDURE sp_ASRFn_RoundDateToStartOfNearestMonth 
(
	@pdtResult 	datetime OUTPUT,
	@pdtDate 	datetime
)
AS
BEGIN
	DECLARE @dtDateNextMonth	datetime, /* start of next month */
		@dtDateThisMonth 	datetime /* start of this month */

	SET @pdtDate = convert(datetime, convert(varchar(20), @pdtDate, 101))

	/* Create a date with one month added to the date and move it to the first day of that month */
	SET @dtDateNextMonth = dateAdd(mm, 1, @pdtDate)
	SET @dtDateNextMonth = dateAdd(dd, -1 * (day(@dtDateNextMonth) - 1), @dtDateNextMonth)

	/* Create a date which is the first of the month passed in */
	SET @dtDateThisMonth = dateAdd(dd, -1 * (day(@pdtDate) - 1), @pdtDate)
    
	/* See which is the greatest gap between the two start month dates and the passed in date */
	IF (@pdtDate - (@dtDateThisMonth) + 1) < ((@dtDateNextMonth) - (@pdtDate))
	BEGIN
		SET @pdtResult = @dtDateThisMonth
	END
	ELSE
	BEGIN
		SET @pdtResult = @dtDateNextMonth
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_RoundDownToNearestWholeNumber]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_RoundDownToNearestWholeNumber]
(
	@piResult 	integer OUTPUT,	
	@pdblNumber float
)
AS
BEGIN
	SET @piResult = ROUND(@pdblNumber, 0, 1);
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_RoundUpToNearestWholeNumber]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_RoundUpToNearestWholeNumber]
(
	@piResult 		integer OUTPUT,	
	@pdblNumber 	float
)
AS
BEGIN
	SET @piResult = CASE WHEN @pdblNumber < 0 THEN floor(@pdblNumber)
		ELSE ceiling(@pdblNumber)
		END;
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_StatutoryRedundancyPay]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_StatutoryRedundancyPay]
(
	@pdblRedundancyPay	float OUTPUT,
	@pdtStartDate 		datetime,
	@pdtLeaveDate 		datetime,
	@pdtDOB				datetime,
	@pdblWeeklyRate 	float,
	@pdblStatLimit 		float
)
AS
BEGIN
	DECLARE @dtMinAgeBirthday	datetime,
		@dtServiceFrom			datetime,
		@iServiceYears 			integer,
		@iAgeY					integer,
		@iAgeM 					integer,
		@dblRate1 				float,
		@dblRate2 				float,
		@dblRate3 				float,
		@dtTempDate 			datetime,
		@iTempAgeY				integer,
		@iTemp					integer,
		@dblTemp2 				float,
		@iAfterOct2006			bit,
		@iMinAge				integer;

	SET @pdblRedundancyPay = 0
	SET @iAfterOct2006 = case when datediff(dd,@pdtLeaveDate,'10/01/2006') <= 0 then 1 else 0 end

	if @iAfterOct2006 = 1
		SET @iMinAge = 16
	else
		SET @iMinAge = 18

	/* First three parameters are compulsory, so return 0 and exit if they are not set */
	IF (@pdtStartDate IS null) OR (@pdtLeaveDate IS null) OR (@pdtDOB IS null)
	BEGIN
		RETURN
	END

	SET @pdtStartDate = convert(datetime, convert(varchar(20), @pdtStartDate, 101))
	SET @pdtLeaveDate = convert(datetime, convert(varchar(20), @pdtLeaveDate, 101))
	SET @pdtDOB = convert(datetime, convert(varchar(20), @pdtDOB, 101))


	/* Calc start date */
   	SET @dtServiceFrom = @pdtStartDate
	if @iAfterOct2006 = 0
	BEGIN
		SET @dtMinAgeBirthday = dateadd(yy, @iMinAge, @pdtDOB)
		IF @dtMinAgeBirthday >= @pdtStartDate
			SET @dtServiceFrom = @dtMinAgeBirthday
	END


	/* Calc number of applicable complete yrs the employee has been employed */
	exec sp_ASRFn_WholeYearsBetweenTwoDates @iServiceYears OUTPUT, @dtServiceFrom, @pdtLeaveDate

	/* exit if its less than 2 years */
	IF @iServiceYears < 2 
	BEGIN
		RETURN
	END

	/* calculate the employees years and months to the leave date */
	exec sp_ASRFn_WholeYearsBetweenTwoDates @iAgeY OUTPUT, @pdtDOB, @pdtLeaveDate

	SET @dtTempDate = dateadd(yy, @iAgeY, @pdtDOB)
	exec sp_ASRFn_WholeMonthsBetweenTwoDates @iAgeM OUTPUT, @dtTempDate, @pdtLeaveDate

	/* only count up to 20 years for redundancy */
	exec sp_ASRFn_Minimum @iServiceYears OUTPUT, 20, @iServiceYears

	/* fill in the rates depending on service and age */
	SET @iTempAgeY = @iAgeY
	SET @dblRate1 = 0
	SET @dblRate2 = 0
	SET @dblRate3 = 0

	IF @iTempAgeY >= 41
	BEGIN
		SET @iTemp = @iTempAgeY - 41
		exec sp_ASRFn_Minimum @dblRate1 OUTPUT, @iTemp, @iServiceYears
		SET @iTempAgeY = 41
		SET @iServiceYears = @iServiceYears - @dblRate1
	END

	IF @iTempAgeY >= 22
	BEGIN
		SET @iTemp = @iTempAgeY - 22
		exec sp_ASRFn_Minimum @dblRate2 OUTPUT, @iTemp, @iServiceYears
		SET @iTempAgeY = 22
		SET @iServiceYears = @iServiceYears - @dblRate2
	END

	IF @iTempAgeY >= @iMinAge
	BEGIN
		SET @iTemp = @iTempAgeY - @iMinAge
		exec sp_ASRFn_Minimum @dblRate3 OUTPUT, @iTemp, @iServiceYears
	END

	/* calc the redundancy pay */
	exec sp_ASRFn_Minimum @dblTemp2 OUTPUT, @pdblWeeklyRate, @pdblStatLimit

	SET @pdblRedundancyPay = ((@dblRate1 * 1.5) + (@dblRate2) + (@dblRate3 * 0.5)) * @dblTemp2

	if @iAfterOct2006 = 0
	begin
		IF @iAgeY = 64 
		BEGIN
			SET @pdblRedundancyPay = @pdblRedundancyPay * (12 - @iAgeM) / 12
		END
	end
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_StatutorySickPay]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRFn_StatutorySickPay]
(
	@piAbsenceRecordID		int
)
AS
BEGIN
	/* Refresh the SSP fields in the Absence records for the Personnel record that is the parent of the given Absence record ID. */

	/* Absence module - Personnel table variables. */
	DECLARE @iPersonnelTableID				integer,
		@sPersonnelTableName 				varchar(128),
		@sWorkingDaysNum_ColumnName 		varchar(128),
		@sWorkingDaysPattern_ColumnName 	varchar(128),
		@sDateOfBirth_ColumnName 			varchar(128);

	/* Personnel record variables. */
	DECLARE @iPersonnelRecordID 			integer,
		@iWorkingDaysPerWeek 				integer,
		@sWorkingPattern 					varchar(MAX),
		@dtDateOfBirth						datetime,
		@dtRetirementDate					datetime,
		@dtSixteenthBirthday				datetime;

	/* Absence module - Absence table variables. */
	DECLARE @sAbsenceTableName				varchar(128),
		@sAbsence_StartDateColumnName		varchar(128),
		@sAbsence_EndDateColumnName			varchar(128),
		@sAbsence_StartSessionColumnName	varchar(128),
		@sAbsence_EndSessionColumnName		varchar(128),
		@sAbsence_TypeColumnName			varchar(128),
		@sAbsence_SSPAppliesColumnName 		varchar(128),
		@sAbsence_QualifyingDaysColumnName 	varchar(128),
		@sAbsence_WaitingDaysColumnName 	varchar(128),
		@sAbsence_PaidDaysColumnName 		varchar(128),
		@iAbsence_WorkingDaysType 			integer;

	/* Absence record variables. */
	DECLARE @cursAbsenceRecords			cursor,
		@cursFollowingAbsenceRecords	cursor,
		@iAbsenceRecordID 				integer,
		@dtStartDate 					datetime,
		@dtEndDate 						datetime,
		@sStartSession					varchar(MAX),
		@sEndSession 					varchar(MAX),
		@dtWholeStartDate 				datetime,
		@dtWholeEndDate 				datetime,
		@dtFollowingStartDate 			datetime,
		@dtFollowingEndDate 			datetime,
		@sFollowingStartSession	 		varchar(MAX),
		@sFollowingEndSession 			varchar(MAX),
		@dtFollowingWholeStartDate 		datetime,
		@dtFollowingWholeEndDate 		datetime,
		@fOriginalSSPApplies			bit,
		@dblOriginalQualifyingDays		float,
		@dblOriginalWaitingDays			float,
		@dblOriginalPaidDays			float;

	/* Absence module - Absence Type table variables. */
	DECLARE @sAbsenceTypeTableName			varchar(128),
		@sAbsenceType_TypeColumnName		varchar(128),
		@sAbsenceType_SSPAppliesColumnName	varchar(128);

	/* General procedure handling variables. */
	DECLARE @fOK	 					bit,
		@iLoop							integer,
		@iIndex							integer,
		@sCommandString					nvarchar(MAX),
		@sParamDefinition				nvarchar(500),
		@dblWaitEntitlement 			float,
		@dblAbsenceEntitlement 			float,
		@dblQualifyingDays 				float,
		@dblWaitingDays 				float,
		@dblPaidDays 					float,
		@fSSPApplies					bit,
		@dtTempDate						datetime,
		@fAddOK							bit,
		@dblAddAmount					float,
		@fContinue 						bit,
		@iConsecutiveRecords			integer,
		@dtConsecutiveStartDate 		datetime,
		@dtConsecutiveEndDate 			datetime,
		@dtConsecutiveWholeStartDate 	datetime,
		@dtConsecutiveWholeEndDate 		datetime,
		@sConsecutiveStartSession 		varchar(MAX),
		@sConsecutiveEndSession 		varchar(MAX),
		@dtLastWholeEndDate 			datetime,
		@dtFirstLinkedWholeStartDate 	datetime,
		@iYearDifference 				integer;

	SET @fOK = 1;

	/* Get the Absence module parameters. */
	/* Get the Personnel table name and ID. */
	SELECT @iPersonnelTableID = convert(integer, parameterValue), 
		@sPersonnelTableName = ASRSysTables.tableName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysTables 
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysTables.tableID
	WHERE moduleKey = 'MODULE_PERSONNEL'
	AND parameterKey = 'Param_TablePersonnel';

	/* Get the Personnel - Date Of Birth column name. */
	SELECT @sDateOfBirth_ColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_PERSONNEL'
	AND parameterKey = 'Param_FieldsDateOfBirth';

	/* Get the Absence table name. */
	SELECT @sAbsenceTableName = ASRSysTables.tableName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysTables 
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysTables.tableID
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_TableAbsence';

	/* Get the Absence - Start Date column name. */
	SELECT @sAbsence_StartDateColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldStartDate';

	/* Get the Absence - End Date column name. */
	SELECT @sAbsence_EndDateColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldEndDate';

	/* Get the Absence - Start Session column name. */
	SELECT @sAbsence_StartSessionColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldStartSession';

	/* Get the Absence - End Session column name. */
	SELECT @sAbsence_EndSessionColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldEndSession';

	/* Get the Absence - Type column name. */
	SELECT @sAbsence_TypeColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldType';

	/* Get the Absence - SSP Applies column name. */
	SELECT @sAbsence_SSPAppliesColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldSSPApplies';

	/* Get the Absence - Qualifying Days column name. */
	SELECT @sAbsence_QualifyingDaysColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldQualifyingDays';

	/* Get the Absence - Waiting Days column name. */
	SELECT @sAbsence_WaitingDaysColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldWaitingDays';

	/* Get the Absence - Paid Days column name. */
	SELECT @sAbsence_PaidDaysColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldPaidDays';

	/* Get the Absence - Working Days selection type. */
	SELECT @iAbsence_WorkingDaysType = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_WorkingDaysType';

	/* Get the Absence Type table name. */
	SELECT @sAbsenceTypeTableName = ASRSysTables.tableName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysTables
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysTables.tableID
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_TableAbsenceType';

	/* Get the Absence Type - Type column name. */
	SELECT @sAbsenceType_TypeColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldTypeType';

	/* Get the Absence Type - SSP Applies column name. */
	SELECT @sAbsenceType_SSPAppliesColumnName = ASRSysColumns.columnName
	FROM ASRSysModuleSetup
	INNER JOIN ASRSysColumns
		ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
	WHERE moduleKey = 'MODULE_ABSENCE'
	AND parameterKey = 'Param_FieldTypeSSP';

	/* Validate the Absence module variables. */
	IF (@iPersonnelTableID IS null)
		OR (@sPersonnelTableName IS null)
		OR (@sAbsenceTableName IS null) 
		OR (@sAbsence_StartDateColumnName IS null) 
		OR (@sAbsence_EndDateColumnName IS null) 
		OR (@sAbsence_StartSessionColumnName IS null) 
		OR (@sAbsence_EndSessionColumnName IS null)  
		OR (@sAbsence_TypeColumnName IS null)   
		OR (@sAbsence_SSPAppliesColumnName IS null)
		OR (@sAbsence_QualifyingDaysColumnName IS null)
		OR (@sAbsence_WaitingDaysColumnName IS null)
		OR (@sAbsence_PaidDaysColumnName IS null)
		OR (@iAbsence_WorkingDaysType IS null)
		OR (@sAbsenceTypeTableName IS null)   
		OR (@sAbsenceType_TypeColumnName IS null)    
		OR (@sAbsenceType_SSPAppliesColumnName IS null) SET @fOK = 0;

	IF @fOK = 1
	BEGIN
		/* Get the ID  of the associated record in the Personnel table. */
		SET @sParamDefinition = N'@recordID integer OUTPUT';
		SET @sCommandString = 'SELECT @recordID = id_' + convert(varchar(128), @iPersonnelTableID) + 
			' FROM ' + @sAbsenceTableName + 
			' WHERE id = ' + convert(varchar(128), @piAbsenceRecordID);
		EXECUTE sp_executesql @sCommandString, @sParamDefinition, @iPersonnelRecordID OUTPUT;

		IF (@iPersonnelRecordID IS null) OR (@iPersonnelRecordID <= 0) SET @fOK = 0;
	END

	IF (@fOK = 1) AND (NOT @sDateOfBirth_ColumnName IS null) 
	BEGIN
		/* Get the retirement date, and the date of the person's sixteenth birthday. */
		SET @sParamDefinition = N'@dateOfBirth datetime OUTPUT';
		SET @sCommandString = 'SELECT @dateOfBirth = convert(datetime, convert(varchar(20), ' + @sDateOfBirth_ColumnName + ', 101))' +
			' FROM ' + @sPersonnelTableName + 
			' WHERE id = ' + convert(varchar(128), @iPersonnelRecordID);
		EXECUTE sp_executesql @sCommandString, @sParamDefinition, @dtDateOfBirth OUTPUT;

		IF (NOT @dtDateOfBirth IS null) SET @dtRetirementDate = dateadd(yy, 65, @dtDateOfBirth);
		IF (NOT @dtDateOfBirth IS null) SET @dtSixteenthBirthday = dateadd(yy, 16, @dtDateOfBirth);
	END

	IF @fOK = 1 
	BEGIN
		/* Get the number of working days per week. */
		SET @iWorkingDaysPerWeek = 0;
		SET @sWorkingPattern = '';

		IF @iAbsence_WorkingDaysType = 0	/* The Working Days are an straight numeric value. */
		BEGIN
			SELECT @iWorkingDaysPerWeek = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_ABSENCE'
			AND parameterKey = 'Param_WorkingDaysNum';

			IF @iWorkingDaysPerWeek IS null SET @fOK = 0;
		END

		IF @iAbsence_WorkingDaysType = 1	/* The Working Days are an straight working pattern value. */
		BEGIN
			SELECT @sWorkingPattern = parameterValue
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_ABSENCE'
			AND parameterKey = 'Param_WorkingDaysPattern';
			
			IF @sWorkingPattern IS null SET @fOK = 0;
		END

		IF @iAbsence_WorkingDaysType = 2	/* The Working Days are a numeric field reference. */
		BEGIN
			SELECT @sWorkingDaysNum_ColumnName = ASRSysColumns.columnName
			FROM ASRSysModuleSetup
			INNER JOIN ASRSysColumns
				ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
			WHERE moduleKey = 'MODULE_ABSENCE'
			AND parameterKey = 'Param_FieldWorkingDays';

			IF @sWorkingDaysNum_ColumnName IS null SET @fOK = 0;

			IF @fOK = 1
			BEGIN
				SET @sParamDefinition = N'@workingDays varchar(MAX) OUTPUT'
				SET @sCommandString = 'SELECT @workingDays = ' + @sWorkingDaysNum_ColumnName + 
					' FROM ' + @sPersonnelTableName + 
					' WHERE id = ' + convert(varchar(128), @iPersonnelRecordID);
				EXECUTE sp_executesql @sCommandString, @sParamDefinition, @iWorkingDaysPerWeek OUTPUT;

				IF (@iWorkingDaysPerWeek IS null) SET @fOK = 0;
			END
		END

		IF @iAbsence_WorkingDaysType = 3	/* The Working Days are an working pattern field. */
		BEGIN
			SELECT @sWorkingDaysPattern_ColumnName = ASRSysColumns.columnName
			FROM ASRSysModuleSetup
			INNER JOIN ASRSysColumns
				ON convert(integer, ASRSysModuleSetup.parameterValue) = ASRSysColumns.columnId
			WHERE moduleKey = 'MODULE_ABSENCE'
			AND parameterKey = 'Param_FieldWorkingDays';

			IF @sWorkingDaysPattern_ColumnName IS null SET @fOK = 0;

			IF @fOK = 1
			BEGIN
				SET @sParamDefinition = N'@workingDaysPattern varchar(MAX) OUTPUT'
				SET @sCommandString = 'SELECT @workingDaysPattern = ' + @sWorkingDaysNum_ColumnName + 
					' FROM ' + @sPersonnelTableName + 
					' WHERE id = ' + convert(varchar(128), @iPersonnelRecordID);
				EXECUTE sp_executesql @sCommandString, @sParamDefinition, @sWorkingPattern OUTPUT;

				IF (@sWorkingPattern IS null) SET @fOK = 0;
			END
		END

		IF @fOK = 1
		BEGIN
			/* Calculate the number of qualifying days per week. */
			IF len(@sWorkingPattern) > 0
			BEGIN
				SET @iLoop = 1;

				WHILE (len(@sWorkingPattern) >= (@iLoop * 2)) AND (@iLoop <=14)
				BEGIN
					IF (substring(@sWorkingPattern, @iLoop, 1) <> ' ') AND (substring(@sWorkingPattern, @iLoop + 1, 1) <> ' ')
					BEGIN
						SET @iWorkingDaysPerWeek = @iWorkingDaysPerWeek + 1;
					END
				
					SET @iLoop = @iLoop + 2;
				END
			END

			IF @iWorkingDaysPerWeek <= 0 SET @fOK = 0;
		END
	END

	IF @fOK = 1
	BEGIN
		SET @iConsecutiveRecords = 0;
		SET @dtLastWholeEndDate = null;

		/* Create a cursor of the absence records for the current person. */
		SET @sParamDefinition = N'@absenceRecs cursor OUTPUT'
		SET @sCommandString = 'SET @absenceRecs = CURSOR  LOCAL FAST_FORWARD FOR' +
			' SELECT ' + @sAbsenceTableName + '.id, ' + 
				'convert(datetime, convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', 101)), ' + 
				'convert(datetime, convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_EndDateColumnName + ', 101)), ' +
				'upper(left(' + @sAbsenceTableName + '.' + @sAbsence_StartSessionColumnName + ', 2)), ' +
				'upper(left(' + @sAbsenceTableName + '.' + @sAbsence_EndSessionColumnName + ', 2)), ' + 
				@sAbsenceTableName + '.' + @sAbsence_SSPAppliesColumnName + ', ' +
				@sAbsenceTableName + '.' + @sAbsence_QualifyingDaysColumnName + ', ' +
				@sAbsenceTableName + '.' + @sAbsence_WaitingDaysColumnName + ', ' +
				@sAbsenceTableName + '.' + @sAbsence_PaidDaysColumnName + 
			' FROM ' + @sAbsenceTableName + 
			' INNER JOIN ' + @sAbsenceTypeTableName + ' ON ' + @sAbsenceTableName + '.' + @sAbsence_TypeColumnName + ' = ' + @sAbsenceTypeTableName + '.' + @sAbsenceType_TypeColumnName +
			' WHERE ' + @sAbsenceTableName + '.id_' + convert(varchar(128), @iPersonnelTableID) + ' = ' + convert(varchar(128), @iPersonnelRecordID) +
			' AND ' + @sAbsenceTypeTableName + '.' + @sAbsenceType_SSPAppliesColumnName + ' = 1' +
			' ORDER BY ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', ' + @sAbsenceTableName + '.id' +
			' OPEN @absenceRecs';
		EXECUTE sp_executesql @sCommandString, @sParamDefinition, @cursAbsenceRecords OUTPUT;

		/* Loop through the absence records, calculating SSP for each record. 
		NB. We check if any periods of absence are consecutive before checking for SSP application. */
		FETCH NEXT FROM @cursAbsenceRecords INTO @iAbsenceRecordID, @dtStartDate, @dtEndDate, @sStartSession, @sEndSession, @fOriginalSSPApplies, @dblOriginalQualifyingDays, @dblOriginalWaitingDays, @dblOriginalPaidDays;
		WHILE (@@fetch_status = 0)
		BEGIN
			/* Ignore incomplete absence records. */
			IF (NOT @dtStartDate IS null) AND (NOT @dtEndDate IS null)
			BEGIN
				/* Ignore absence after retirement. */
				IF NOT @dtRetirementDate IS null
				BEGIN
					IF (@dtRetirementDate < @dtEndDate) 
					BEGIN
						SET @dtEndDate = @dtRetirementDate;
						SET @sEndSession = 'PM';
					END
				END
				/* Ignore absence before the sixteenth birthday. */
				IF NOT @dtSixteenthBirthday IS null
				BEGIN
					IF (@dtSixteenthBirthday > @dtStartDate) 
					BEGIN
						SET @dtStartDate = @dtSixteenthBirthday;
						SET @sStartSession = 'AM';
					END
				END

				/* Get the start and end dates (whole days only) of the current absence record. */
				SET @dtWholeStartDate = @dtStartDate;
				SET @dtWholeEndDate = @dtEndDate;
				IF @sStartSession = 'PM' SET @dtWholeStartDate = @dtWholeStartDate + 1;
				IF @sEndSession = 'AM' SET @dtWholeEndDate = @dtWholeEndDate - 1;

				IF @iConsecutiveRecords = 0 
				BEGIN
					SET @dtConsecutiveStartDate = @dtStartDate;
					SET @dtConsecutiveEndDate = @dtEndDate;
					SET @sConsecutiveStartSession = @sStartSession;
					SET @sConsecutiveEndSession = @sEndSession;
					SET @dtConsecutiveWholeStartDate = @dtWholeStartDate;
					SET @dtConsecutiveWholeEndDate = @dtWholeEndDate;

					/* Create a cursor of the absence records for the current person that follow the current absence record. */
					SET @sParamDefinition = N'@followingAbsenceRecs cursor OUTPUT';
					SET @sCommandString = 'SET @followingAbsenceRecs = CURSOR  LOCAL FAST_FORWARD FOR' +
						' SELECT convert(datetime, convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', 101)), ' + 
							'convert(datetime, convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_EndDateColumnName + ', 101)), ' +
							'upper(left(' + @sAbsenceTableName + '.' + @sAbsence_StartSessionColumnName + ', 2)), ' +
							'upper(left(' + @sAbsenceTableName + '.' + @sAbsence_EndSessionColumnName + ', 2)) ' + 
						' FROM ' + @sAbsenceTableName + 
						' INNER JOIN ' + @sAbsenceTypeTableName + ' ON ' + @sAbsenceTableName + '.' + @sAbsence_TypeColumnName + ' = ' + @sAbsenceTypeTableName + '.' + @sAbsenceType_TypeColumnName +
						' WHERE ' + @sAbsenceTableName + '.id_' + convert(varchar(128), @iPersonnelTableID) + ' = ' + convert(varchar(128), @iPersonnelRecordID) +
						' AND ' + @sAbsenceTypeTableName + '.' + @sAbsenceType_SSPAppliesColumnName + ' = 1' +
						' AND (NOT ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ' IS null)' + 
						' AND (NOT ' + @sAbsenceTableName + '.' + @sAbsence_EndDateColumnName + ' IS null)' +
						' AND ((convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', 112) > ' + convert(varchar(20), @dtStartDate, 112) + ')' +
						' OR ((convert(varchar(20), ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', 112) = ' + convert(varchar(20), @dtStartDate, 112) + ') AND (' + @sAbsenceTableName + '.id > ' + convert(varchar(128), @iAbsenceRecordID) + ')))' +
						' ORDER BY ' + @sAbsenceTableName + '.' + @sAbsence_StartDateColumnName + ', ' + @sAbsenceTableName + '.id' +
						' OPEN @followingAbsenceRecs';
					EXECUTE sp_executesql @sCommandString, @sParamDefinition, @cursFollowingAbsenceRecords OUTPUT;

					SET @fContinue = 1;
					FETCH NEXT FROM @cursFollowingAbsenceRecords INTO @dtFollowingStartDate, @dtFollowingEndDate, @sFollowingStartSession, @sFollowingEndSession;
					WHILE (@@fetch_status = 0) AND (@fContinue = 1)
					BEGIN
						SET @fContinue = 0;
			
						/* Get the start and end dates (whole days only) of the current absence records. */
						SET @dtFollowingWholeStartDate = @dtFollowingStartDate;
						SET @dtFollowingWholeEndDate = @dtFollowingEndDate;
						IF @sFollowingStartSession = 'PM' SET @dtFollowingWholeStartDate = @dtFollowingWholeStartDate + 1;
						IF @sFollowingEndSession = 'AM' SET @dtFollowingWholeEndDate = @dtFollowingWholeEndDate - 1;

						IF ((@dtConsecutiveEndDate = @dtFollowingStartDate) AND (@sConsecutiveEndSession = 'AM') AND (@sFollowingStartSession = 'PM'))
							OR (@dtConsecutiveWholeEndDate + 1 >= @dtFollowingWholeStartDate)
						BEGIN
							SET @iConsecutiveRecords = @iConsecutiveRecords + 1;
							SET @dtConsecutiveEndDate = @dtFollowingEndDate;
							SET @sConsecutiveEndSession = @sFollowingEndSession;
							SET @dtConsecutiveWholeEndDate = @dtFollowingWholeEndDate;
							SET @fContinue = 1;
						END

						FETCH NEXT FROM @cursFollowingAbsenceRecords INTO @dtFollowingStartDate, @dtFollowingEndDate, @sFollowingStartSession, @sFollowingEndSession;
					END

					CLOSE @cursFollowingAbsenceRecords;
					DEALLOCATE @cursFollowingAbsenceRecords;

				END
				ELSE
				BEGIN
					SET @iConsecutiveRecords = @iConsecutiveRecords - 1;
				END

				/* SSP Applies if the absence period is greater than 3 days. */
				SET @fSSPApplies = 0;
				IF (datediff(dd, @dtConsecutiveWholeStartDate, @dtConsecutiveWholeEndDate) + 1) > 3 SET @fSSPApplies = 1;

				IF @fSSPApplies = 1
				BEGIN
					/* Check if 56 days have passed since the previous absence period. */
					IF @dtLastWholeEndDate IS null
					BEGIN
						/* First absence record so use default values. */
						SET @dblWaitEntitlement = 3;
						SET @dblAbsenceEntitlement = @iWorkingDaysPerWeek * 28;
						SET @dtFirstLinkedWholeStartDate = @dtWholeStartDate;
					END
					ELSE
					BEGIN
						IF (datediff(dd, @dtLastWholeEndDate, @dtWholeStartDate) - 1) > 56
						BEGIN
							/* More than 56 days since the previous absence record so use default values. */
							SET @dblWaitEntitlement = 3;
							SET @dblAbsenceEntitlement = @iWorkingDaysPerWeek * 28;
							SET @dtFirstLinkedWholeStartDate = @dtWholeStartDate;
						END
					END
		
					/* Calculate SSP qualifying, waiting and paid days.
					NB. The start and end dates should already take into account the start and end periods (AM/PM)
					so that only whole absence days are used. */
					SET @dblQualifyingDays = 0;

					/* Loop from the start date to the end date, incrementing the number of qualifying days for each date that qualifies. */
					SET @dtTempDate = @dtStartDate;

					WHILE (@dtTempDate <= @dtEndDate)
					BEGIN
						SET @fAddOK = 0;
						SET @dblAddAmount = 0;

						IF len(@sWorkingPattern) = 0
						BEGIN
							/* No working pattern passed in, so use the 'daysPerWeek' variable. */
							IF (@iWorkingDaysPerWeek = 7) OR 
								((datepart(dw, @dtTempDate) >= 2) AND (datepart(dw, @dtTempDate) <= 6))
							BEGIN
								/* The current date qualifies if 7 days per week are worked, or if the current date is a weekday. */
								SET @fAddOK = 1;
							END
						END
						ELSE	
						BEGIN
							/* Use the working pattern. */
							SET @iIndex = (2 * datepart(dw, @dtTempDate)) -1;
							IF len(@sWorkingPattern) >= (@iIndex +1)
							BEGIN
								/* The current date qualifies if its 'day of the week' is worked in the working pattern.
								NB. Both AM and PM sessions must be worked for the day to qualify. */
								IF (substring(@sWorkingPattern, @iIndex, 1) <> ' ') AND (substring(@sWorkingPattern, @iIndex + 1, 1) <> ' ')
								BEGIN
									SET @fAddOK = 1;
								END
							END
						END

						IF @fAddOK = 1 
						BEGIN
							/* If the person is older than retirement age, then the day does not qualify. */
							IF NOT @dtRetirementDate IS null
							BEGIN
								IF @dtTempDate > @dtRetirementDate SET @fAddOK = 0;
							END
						END

						IF @fAddOK = 1 
						BEGIN
							/* If the person is less than sixteen then the day does not qualify. */
							IF (NOT @dtSixteenthBirthday IS null) 
							BEGIN
								IF @dtTempDate < @dtSixteenthBirthday SET @fAddOK = 0;
							END
						END

						IF @fAddOK = 1 
						BEGIN
							/* Days linked after 3 years from the start of the link do not count. */
							exec sp_ASRFn_WholeYearsBetweenTwoDates @iYearDifference OUTPUT, @dtFirstLinkedWholeStartDate, @dtTempDate;
							IF @iYearDifference >= 3  SET @fAddOK = 0;
						END

						/* Calculate how much to add to the Qualifying Days. */
						IF @fAddOK = 1 
						BEGIN
							SET @dblAddAmount = 0;

							IF @dtTempDate < @dtWholeStartDate
							BEGIN
								/* The current date is the half day before the whole dated period starts.
								A half day qualifies only if this period of absence consecutively follows another. */
								IF (@dtConsecutiveStartDate < @dtStartDate) OR 
									((@dtConsecutiveStartDate = @dtStartDate) AND (@sConsecutiveStartSession <> @sStartSession)) SET @dblAddAmount = 0.5;
							END
							ELSE
							BEGIN
								IF @dtTempDate > @dtWholeEndDate
								BEGIN
									/* The current date is the half day after the whole dated period end.
									A half day qualifies only if this period of absence is consecutively followed by another. */
									IF (@dtConsecutiveEndDate > @dtEndDate) OR 
										((@dtConsecutiveEndDate = @dtEndDate) AND (@sConsecutiveEndSession <> @sStartSession)) SET @dblAddAmount = 0.5;
								END
								ELSE
								BEGIN
									/* The current date lies within the whole dated period, so a whole day qualifies. */
									SET @dblAddAmount = 1;
								END
							END
						END


						/* Increment the number of qualifying days. */
						SET @dblQualifyingDays = @dblQualifyingDays + @dblAddAmount;

						SET @dtTempDate = @dtTempDate + 1;
					END

					/* Take off any waiting entitlement. */
					IF @dblWaitEntitlement > @dblQualifyingDays
					BEGIN
						SET @dblWaitingDays = @dblQualifyingDays;
						SET @dblWaitEntitlement = @dblWaitEntitlement - @dblQualifyingDays;
					END
					ELSE
					BEGIN
						SET @dblWaitingDays = @dblWaitEntitlement;
						SET @dblWaitEntitlement = 0;
					END

					/* Paid days is the difference providing there is enough entitlement. */
					SET @dblPaidDays = @dblQualifyingDays - @dblWaitingDays;

					IF @dblPaidDays > @dblAbsenceEntitlement
					BEGIN
						SET @dblPaidDays = @dblAbsenceEntitlement;
						SET @dblAbsenceEntitlement = 0;
					END
					ELSE
					BEGIN
						SET @dblAbsenceEntitlement = @dblAbsenceEntitlement - @dblPaidDays;
					END	

					SET @dtLastWholeEndDate = @dtWholeEndDate;

					/* Update the SSP fields in the current absence record if required. */
					IF (@fOriginalSSPApplies IS null) OR
						(@fOriginalSSPApplies = 0) OR
						(@dblOriginalQualifyingDays IS null) OR
						(@dblOriginalQualifyingDays <> @dblQualifyingDays) OR
						(@dblOriginalWaitingDays IS null) OR
						(@dblOriginalWaitingDays <> @dblWaitingDays) OR
						(@dblOriginalPaidDays IS null) OR
						(@dblOriginalPaidDays <> @dblPaidDays)
					BEGIN
						SET @sCommandString = 'UPDATE ' + @sAbsenceTableName +
							' SET ' + @sAbsence_SSPAppliesColumnName + ' = 1, ' +
							@sAbsence_QualifyingDaysColumnName + ' = ' + convert(varchar(MAX), @dblQualifyingDays) + ', ' +
							@sAbsence_WaitingDaysColumnName + ' = ' + convert(varchar(MAX), @dblWaitingDays) + ', ' +
							@sAbsence_PaidDaysColumnName + ' = ' + convert(varchar(MAX), @dblPaidDays) + 
							' WHERE id = ' + convert(varchar(128), @iAbsenceRecordID);
						exec sp_executesql @sCommandString;
					END
				END
				ELSE			
				BEGIN
					/* Update the SSP fields in the current absence record. */
					IF (@fOriginalSSPApplies IS null) OR
						(@fOriginalSSPApplies = 1) OR
						(@dblOriginalQualifyingDays IS null) OR
						(@dblOriginalQualifyingDays <> 0) OR
						(@dblOriginalWaitingDays IS null) OR
						(@dblOriginalWaitingDays <> 0) OR
						(@dblOriginalPaidDays IS null) OR
						(@dblOriginalPaidDays <> 0)
					BEGIN
						SET @sCommandString = 'UPDATE ' + @sAbsenceTableName +
							' SET ' + @sAbsence_SSPAppliesColumnName + ' = 0, ' +
							@sAbsence_QualifyingDaysColumnName + ' = 0, ' +
							@sAbsence_WaitingDaysColumnName + ' = 0, ' +
							@sAbsence_PaidDaysColumnName + ' = 0' + 
							' WHERE id = ' + convert(varchar(128), @iAbsenceRecordID);
						exec sp_executesql @sCommandString;
					END
				END
			END
			ELSE
			BEGIN
				/* Update the SSP fields in the current absence record. */
				IF (@fOriginalSSPApplies IS null) OR
					(@fOriginalSSPApplies = 1) OR
					(@dblOriginalQualifyingDays IS null) OR
					(@dblOriginalQualifyingDays <> 0) OR
					(@dblOriginalWaitingDays IS null) OR
					(@dblOriginalWaitingDays <> 0) OR
					(@dblOriginalPaidDays IS null) OR
					(@dblOriginalPaidDays <> 0)
				BEGIN
					SET @sCommandString = 'UPDATE ' + @sAbsenceTableName +
						' SET ' + @sAbsence_SSPAppliesColumnName + ' = 0, ' +
						@sAbsence_QualifyingDaysColumnName + ' = 0, ' +
						@sAbsence_WaitingDaysColumnName + ' = 0, ' +
						@sAbsence_PaidDaysColumnName + ' = 0' + 
						' WHERE id = ' + convert(varchar(128), @iAbsenceRecordID);
					exec sp_executesql @sCommandString;
				END
			END

			FETCH NEXT FROM @cursAbsenceRecords INTO @iAbsenceRecordID, @dtStartDate, @dtEndDate, @sStartSession, @sEndSession, @fOriginalSSPApplies, @dblOriginalQualifyingDays, @dblOriginalWaitingDays, @dblOriginalPaidDays;
		END
		CLOSE @cursAbsenceRecords;
		DEALLOCATE @cursAbsenceRecords;
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRFn_WeekdaysFromStartAndEndDates]...';


GO

ALTER PROCEDURE sp_ASRFn_WeekdaysFromStartAndEndDates 
(
	@piResult	integer OUTPUT,
	@pdtDate1 	datetime,
	@pdtDate2 	datetime
)
AS
BEGIN
	DECLARE @iCounter	integer

	SET @piResult = 0
	SET @iCounter = 0
	SET @pdtDate1 = convert(datetime, convert(varchar(20), @pdtDate1, 101))
	SET @pdtDate2 = convert(datetime, convert(varchar(20), @pdtDate2, 101))

	WHILE @iCounter <= datediff(day, @pdtDate1, @pdtDate2)
	BEGIN
		IF datepart(dw, dateadd(day, @iCounter, @pdtDate1)) <> 1
		BEGIN
			IF datepart(dw, dateadd(day, @iCounter, @pdtDate1)) <> 7
			BEGIN
				SET @piResult = @piResult + 1
			END
		END

		SET @iCounter = @iCounter + 1
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRGetHistoryScreens]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRGetHistoryScreens]
	(@piParentScreenID	integer)
AS
BEGIN
	/* Return a recordset of the history screens that hang off the given parent screen. */
	SELECT ASRSysTables.tableName, 
		ASRSysTables.tableID,
		childScreens.screenID,
		childScreens.name,
		childScreens.pictureID
	FROM ASRSysScreens parentScreen
	INNER JOIN ASRSysHistoryScreens 
		ON parentScreen.screenID = ASRSysHistoryScreens.parentScreenID
	INNER JOIN ASRSysScreens childScreens 
		ON ASRSysHistoryScreens.historyScreenID = childScreens.screenID
	INNER JOIN ASRSysTables 
		ON childScreens.tableID = ASRSysTables.tableID
	WHERE parentScreen.screenID = @piParentScreenID
		AND childScreens.quickEntry = 0;
END
GO
PRINT N'Altering [dbo].[sp_ASRGetMessages]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRGetMessages]
AS
BEGIN
	DECLARE @iDBID		integer,
		@iID			integer,
		@dtLoginTime	datetime,
		@sLoginName		varchar(256),
		@iCount			integer,
		@Realspid		integer;

	-- Need to get spid of parent process
	SELECT @Realspid = a.spid
	FROM master..sysprocesses a
	FULL OUTER JOIN master..sysprocesses b
		ON a.hostname = b.hostname
		AND a.hostprocess = b.hostprocess
		AND a.spid <> b.spid
	WHERE b.spid = @@Spid;

	-- If there is no parent spid then use current spid
	IF @Realspid is null SET @Realspid = @@spid;

	-- Get the current user's process information.
	SELECT @iDBID = dbID,
		@dtLoginTime = login_time,
		@sLoginName = loginame
	FROM master..sysprocesses
	WHERE spid = @Realspid;

	-- Return the recordset of messages.
	SELECT 'Message from user ''' + ltrim(rtrim(messageFrom)) + 
		''' using ' + ltrim(rtrim(messageSource)) + 
		' (' + convert(varchar(100), messageTime, 100) +')' + 
		char(10) + message
	FROM ASRSysMessages
	WHERE loginName = @sLoginName
		AND dbID = @iDBID
		AND loginTime = @dtLoginTime
		AND spid = @Realspid;

	-- Remove any messages that have just been picked up.
	DELETE
	FROM ASRSysMessages
	WHERE loginName = @sLoginName
		AND dbID = @iDBID
		AND loginTime = @dtLoginTime
		AND spid = @Realspid;

END
GO
PRINT N'Altering [dbo].[sp_ASRGetSummaryFields]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRGetSummaryFields] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer)
AS
BEGIN
	SELECT DISTINCT ASRSysSummaryFields.sequence, 
	    ASRSysSummaryFields.startOfGroup, 
		ASRSysColumns.columnName, 
		ASRSysColumns.columnId, 
		ASRSysColumns.tableID, 
		ASRSysColumns.dataType, 
		ASRSysColumns.size, 
		ASRSysColumns.decimals, 
		ASRSysColumns.controlType, 
		ASRSysColumns.columnType, 
		ASRSysColumns.multiline,
		ASRSysColumns.alignment,
		ASRSysColumns.BlankIfZero,
		ASRSysColumns.Use1000Separator,		
	    ASRSysSummaryFields.StartOfColumn
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns 
		ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;
END
GO
PRINT N'Altering [dbo].[sp_ASRInsertNewUtility]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRInsertNewUtility]
(
    @piNewRecordID	integer OUTPUT,   /* Output variable to hold the new record ID. */
    @psInsertString nvarchar(MAX),    /* SQL Insert string to insert the new record. */
    @psTableName	varchar(255),		 /* Table Name you want to retrieve */
    @psIDColumnName varchar(30)      /* Name of the ID column  */
)
AS
BEGIN
    DECLARE @sCommand		nvarchar(MAX),
		@sParamDefinition 	nvarchar(MAX);

    BEGIN TRANSACTION;

    /* Run the given SQL INSERT string. */
    EXECUTE sp_ExecuteSQL @psInsertString;

    /* Get the ID of the inserted record.
    NB. We do not use @@IDENTITY as the insertion that we have just performed may have triggered
    other insertions (eg. into the Audit Trail table. The @@IDENTITY variable would then be the last IDENTITY value
    entered in the Audit Trail table.*/
    SET @sCommand = 'SELECT @recordID = MAX(' + @psIDColumnName + ') FROM ' + @psTableName + ';';

    SET @sParamDefinition = N'@recordID integer OUTPUT';
    EXEC sp_executesql @sCommand,  @sParamDefinition, @piNewRecordID OUTPUT;

    COMMIT TRANSACTION;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntAddEventLogHeader]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntAddEventLogHeader]
(
    @piNewRecordID	integer OUTPUT,   /* Output variable to hold the new record ID. */
    @piType			integer,
    @psName			varchar(150), 
    @psUserName		varchar(50),
    @psBatchName	varchar(50),
    @piBatchRunID	integer,
    @piBatchJobID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLog] (
		[DateTime],	[Type],	[Name], [Status], [Username],
		[Mode], [BatchName], [SuccessCount], [FailCount], [BatchRunID], [BatchJobID])
	VALUES (GETDATE(), @piType, @psName, 0, @psUserName,
		CASE
			WHEN len(@psBatchName) = 0 THEN 0
			ELSE 1
		END,    
		@psBatchName, NULL,NULL,
		CASE
			WHEN @piBatchRunID > 0 THEN @piBatchRunID
			ELSE null
		END,
		CASE 
			WHEN @piBatchJobID > 0 THEN @piBatchJobID
			ELSE null
		END);
                  
    -- Get the ID of the inserted record.
    SELECT @piNewRecordID = MAX(id) FROM [dbo].[ASRSysEventLog];

END
GO
PRINT N'Altering [dbo].[sp_ASRIntDefProperties]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntDefProperties] (
	@intType int, 
	@intID int
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the details with which to populate the intranet defproperties page. */
	SELECT convert(varchar, CreatedDate,103) + ' ' + convert(varchar, CreatedDate,108) as 'CreatedDate', 
		convert(varchar, SavedDate,103) + ' ' + convert(varchar, SavedDate,108) as 'SavedDate', 
		convert(varchar, RunDate,103) + ' ' + convert(varchar, RunDate,108) as 'RunDate', 
		Createdby, 
		Savedby, 
		Runby 
	FROM [dbo].[ASRSysUtilAccessLog]
	WHERE UtilID = @intID 
		AND [Type] = @intType;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntDeleteUtility]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntDeleteUtility] (
	@piUtilType	integer,
	@piUtilID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iExprID	integer;

	IF @piUtilType = 0
	BEGIN
		/* Batch Jobs */
		DELETE FROM ASRSysBatchJobName WHERE ID = @piUtilID;
		DELETE FROM ASRSysBatchJobDetails WHERE BatchJobNameID = @piUtilID;
		DELETE FROM ASRSysBatchJobAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 1
	BEGIN
		/* Cross Tabs */
		DELETE FROM ASRSysCrossTab WHERE CrossTabID = @piUtilID;
		DELETE FROM ASRSysCrossTabAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 2
	BEGIN
		/* Custom Reports. */
		DELETE FROM ASRSysCustomReportsName WHERE id = @piUtilID;
		DELETE FROM ASRSysCustomReportsDetails WHERE customReportID= @piUtilID;
		DELETE FROM ASRSysCustomReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 3
	BEGIN
		/* Data Transfer. */
		DELETE FROM ASRSysDataTransferName WHERE DataTransferID = @piUtilID;
		DELETE FROM ASRSysDataTransferAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 4
	BEGIN
		/* Export. */
		DELETE FROM ASRSysExportName WHERE ID = @piUtilID;
		DELETE FROM ASRSysExportDetails WHERE ExportID = @piUtilID;
		DELETE FROM ASRSysExportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 5) OR (@piUtilType = 6) OR (@piUtilType = 7)
	BEGIN
		/* Globals. */
		DELETE FROM ASRSysGlobalFunctions  WHERE FunctionID = @piUtilID;
		DELETE FROM ASRSysGlobalAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 8
	BEGIN
		/* Import. */
		DELETE FROM ASRSysImportName  WHERE ID = @piUtilID;
		DELETE FROM ASRSysImportDetails WHERE ImportID = @piUtilID;
		DELETE FROM ASRSysImportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 9) OR (@piUtilType = 18)
	BEGIN
		/* Mail Merge/ Envelopes & Labels. */
		DELETE FROM ASRSysMailMergeName  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeColumns  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 10
	BEGIN
		/* Picklists. */
		DELETE FROM ASRSysPickListName WHERE picklistID = @piUtilID;
		DELETE FROM ASRSysPickListItems WHERE picklistID = @piUtilID;
	END
	
	IF @piUtilType = 11 OR @piUtilType = 12
	BEGIN
		/* Filters and Calculations. */
		DECLARE subExpressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.exprID
			FROM ASRSysExpressions
			INNER JOIN ASRSysExprComponents ON ASRSysExpressions.parentComponentID = ASRSysExprComponents.componentID
			AND ASRSysExprComponents.exprID = @piUtilID;
		OPEN subExpressions_cursor;
		FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		WHILE (@@fetch_status = 0)
		BEGIN
			exec [dbo].[sp_ASRIntDeleteUtility] @piUtilType, @iExprID;
			
			FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		END
		CLOSE subExpressions_cursor;
		DEALLOCATE subExpressions_cursor;

		DELETE FROM ASRSysExprComponents
		WHERE exprID = @piUtilID;

		DELETE FROM ASRSysExpressions WHERE exprID = @piUtilID;
	END	

	IF (@piUtilType = 14) OR (@piUtilType = 23) OR (@piUtilType = 24)
	BEGIN
		/* Match Reports/Succession Planning/Career Progression. */
		DELETE FROM ASRSysMatchReportName WHERE MatchReportID = @piUtilID;
		DELETE FROM ASRSysMatchReportAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 17 
	BEGIN
		/*Calendar Reports*/
		DELETE FROM ASRSysCalendarReports WHERE ID = @piUtilID;
		DELETE FROM ASRSysCalendarReportEvents WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportOrder WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 20 
	BEGIN
		/*Record Profile*/
		DELETE FROM ASRSysRecordProfileName WHERE recordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileDetails WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileTables WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileAccess WHERE ID = @piUtilID;
	END
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntExpressionHasHiddenComponents]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntExpressionHasHiddenComponents] (
	@piExprID 			integer, 
	@pfHasHiddenComponents	bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Check if the given expression has any hidden componeonts. */
	DECLARE @iExprID	integer,
		@sAccess		varchar(MAX),
		@fTemp			bit;

	SET @pfHasHiddenComponents = 0

	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		CASE
			WHEN ASRSysExprComponents.type = 10 THEN	ASRSysExprComponents.filterID
			WHEN ASRSysExprComponents.type = 3 THEN	ASRSysExprComponents.calculationID
			ELSE ASRSysExprComponents.fieldSelectionFilter
		END AS [exprID]
	FROM ASRSysExprComponents
	WHERE exprID = @piExprID
		AND ((type = 3) 
			OR (type = 10) 
			OR ((type = 1) AND (fieldSelectionFilter > 0)))
	OPEN components_cursor
	FETCH NEXT FROM components_cursor INTO @iExprID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @sAccess = access
		FROM ASRSysExpressions
		WHERE exprID = @iExprID	

		IF @sAccess = 'HD'
		BEGIN
			/* The filter/calc is hidden. */
			SET @pfHasHiddenComponents = 1
			RETURN
		END
		ELSE
		BEGIN
			/* The filter/calc is NOT hidden. Check the sub-components. */
			execute sp_ASRIntExpressionHasHiddenComponents @iExprID, @fTemp OUTPUT

			IF @fTemp = 1
			BEGIN
				SET @pfHasHiddenComponents = 1
				RETURN
			END	
		END

		FETCH NEXT FROM components_cursor INTO @iExprID
	END
	CLOSE components_cursor
	DEALLOCATE components_cursor	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateExpression]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateExpression] (
	@psUtilName 			varchar(255), 
	@piUtilID 				integer, 
	@piUtilType 			integer, 
	@psUtilOwner 			sysname, 
	@piBaseTableID 			integer, 
	@psComponentDefn		varchar(MAX),
	@piTimestamp 			integer, 
	@psDeletedKeys			varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any deleted calcs/filters. */
	@psHiddenOwnerKeys		varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any hidden calcs/filters that the current user owns. */
	@psHiddenNotOwnerKeys	varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any hidden calcs/filters that the current user does not own. */
	@psDeletedDescs			varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any deleted calcs/filters. */
	@psHiddenOwnerDescs		varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any hidden calcs/filters that the current user owns. */
	@psHiddenNotOwnerDescs	varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any hidden calcs/filters that the current user does not own. */
	@piErrorCode			integer 		OUTPUT	/* 	0 = No error (but must check the strings of keys above)
										1 = Expression deleted by another user. Save as new ? 
										2 = Made hidden/read-only by another user. Save as new ? 
										3 = Modified by another user (still writable). Overwrite ? 
										4 = Non-unique name. Save fails */
	/* 	If there are any keys in the @psDeletedKeys string then these components need to be removed from the expression. The save fails.
		If there are any keys in the @psHiddenOwnerKeys or @psHiddenNotOwnerKeys strings then
			If current user does NOT own the expression then
				the expression needs to be made hidden, and the current user cannot edit it. Save and edit fails.
			Else
				If there are any keys in the @psHiddenNotOwnerKeys string then
					the hidden components need to be removed from the expression. Save fails.
				Else
					expression must also be made hidden
	*/
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp			integer,
			@sOwner				varchar(255),
			@sTemp				varchar(MAX),
			@sCompType			char(1),		/* 'U' = unknown, 'E' = expression, 'C' = component */
			@sParameter			varchar(MAX),
			@iComponentIndex	integer,
			@sTempAccess		varchar(MAX),
			@fHidden			bit,
			@sTempOwner			varchar(255),
			@sCurrentUser		sysname,
			@iCount				integer,
			@sExprID			varchar(100),
			@sName				varchar(255),
			@sTableID			varchar(100),
			@sReturnType		varchar(100),
			@sReturnSize		varchar(100),
			@sReturnDecimals	varchar(100),
			@sType				varchar(100),
			@sParentComponentID	varchar(100),
			@sUserName			varchar(255),
			@sAccess			varchar(MAX),
			@sDescription		varchar(MAX),
			@sTimestamp			varchar(100),
			@sViewInColour		varchar(100),
			@sExpandedNode		varchar(100),
			@fTemp				bit,
			@iCalculationID		integer,
			@sNodeKey			varchar(100),
			@sCompID			varchar(100),
			@sFieldColumnID		varchar(100),
			@sFieldPassBy			varchar(100),
			@sFieldSelectionTableID	varchar(100),
			@sFieldSelectionRecord	varchar(100),
			@sFieldSelectionLine	varchar(100),
			@sFieldSelectionOrderID	varchar(100),
			@sFieldSelectionFilter	varchar(MAX),
			@sFunctionID			varchar(100),
			@sCalculationID			varchar(100),
			@sOperatorID			varchar(100),
			@sValueType				varchar(100),
			@sValueCharacter		varchar(MAX),
			@sValueNumeric			varchar(100),
			@sValueLogic			varchar(100),
			@sValueDate				varchar(100),
			@sPromptDescription		varchar(MAX),
			@sPromptMask			varchar(MAX),
			@sPromptSize			varchar(100),
			@sPromptDecimals		varchar(100),
			@sFunctionReturnType	varchar(100),
			@sLookupTableID			varchar(100),
			@sLookupColumnID		varchar(100),
			@sFilterID				varchar(100),
			@sPromptDateType		varchar(100),
			@sFieldTableID			varchar(100),
			@sFieldSelectionOrderName	varchar(255),
			@sFieldSelectionFilterName	varchar(255);

	SET @sCurrentUser = SYSTEM_USER
	SET @piErrorCode = 0
	SET @psDeletedKeys = ''
	SET @psHiddenOwnerKeys = ''
	SET @psHiddenNotOwnerKeys = ''
	SET @psDeletedDescs = ''
	SET @psHiddenOwnerDescs = ''
	SET @psHiddenNotOwnerDescs = ''

	/* Loop through each component in the definition. */
	SET @sTemp = @psComponentDefn
	SET @sCompType = 'U'

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sParameter = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
		END
		ELSE
		BEGIN
			SET @sParameter = @sTemp
			SET @sTemp = ''
		END

		IF @sCompType = 'U' 
		BEGIN
			/* Reading a new component. */
			IF @sParameter = 'ROOT'
			BEGIN
				SET @sCompType = 'C'
			END
			ELSE
			BEGIN
				IF left(@sParameter, 1) = 'C'
				BEGIN
					SET @sCompType = 'E'
				END
				ELSE
				BEGIN
					SET @sCompType = 'C'
				END
			END	

			SET @iComponentIndex = 1
		END
		ELSE
		BEGIN
			IF @sCompType = 'E' 
			BEGIN
				/* Currently reading an expression. */
				IF @iComponentIndex = 1 SET @sNodeKey = @sParameter
				IF @iComponentIndex = 2 SET @sExprID = @sParameter
				IF @iComponentIndex = 3 SET @sName = @sParameter
				IF @iComponentIndex = 4 SET @sTableID = @sParameter
				IF @iComponentIndex = 5 SET @sReturnType = @sParameter
				IF @iComponentIndex = 6 SET @sReturnSize = @sParameter
				IF @iComponentIndex = 7 SET @sReturnDecimals = @sParameter
				IF @iComponentIndex = 8 SET @sType = @sParameter
				IF @iComponentIndex = 9 SET @sParentComponentID = @sParameter
				IF @iComponentIndex = 10 SET @sUserName = @sParameter
				IF @iComponentIndex = 11 SET @sAccess = @sParameter
				IF @iComponentIndex = 12 SET @sDescription = @sParameter
				IF @iComponentIndex = 13 SET @sTimestamp = @sParameter
				IF @iComponentIndex = 14 SET @sViewInColour = @sParameter
				IF @iComponentIndex = 15 
				BEGIN
					SET @sExpandedNode = @sParameter
					SET @sCompType = 'U'
				END
			END
			ELSE
			BEGIN
				/* Currently reading a component. */
				IF @iComponentIndex = 1 SET @sNodeKey = @sParameter
				IF @iComponentIndex = 2 SET @sCompID = @sParameter
				IF @iComponentIndex = 3 SET @sExprID = @sParameter
				IF @iComponentIndex = 4 SET @sType = @sParameter
				IF @iComponentIndex = 5 SET @sFieldColumnID = @sParameter
				IF @iComponentIndex = 6 SET @sFieldPassBy = @sParameter
				IF @iComponentIndex = 7 SET @sFieldSelectionTableID = @sParameter
				IF @iComponentIndex = 8 SET @sFieldSelectionRecord = @sParameter
				IF @iComponentIndex = 9 SET @sFieldSelectionLine = @sParameter
				IF @iComponentIndex = 10 SET @sFieldSelectionOrderID = @sParameter
				IF @iComponentIndex = 11 SET @sFieldSelectionFilter = @sParameter
				IF @iComponentIndex = 12 SET @sFunctionID = @sParameter
				IF @iComponentIndex = 13 SET @sCalculationID = @sParameter
				IF @iComponentIndex = 14 SET @sOperatorID = @sParameter
				IF @iComponentIndex = 15 SET @sValueType = @sParameter
				IF @iComponentIndex = 16 SET @sValueCharacter = @sParameter
				IF @iComponentIndex = 17 SET @sValueNumeric = @sParameter
				IF @iComponentIndex = 18 SET @sValueLogic = @sParameter
				IF @iComponentIndex = 19 SET @sValueDate = @sParameter
				IF @iComponentIndex = 20 SET @sPromptDescription = @sParameter
				IF @iComponentIndex = 21 SET @sPromptMask = @sParameter
				IF @iComponentIndex = 22 SET @sPromptSize = @sParameter
				IF @iComponentIndex = 23 SET @sPromptDecimals = @sParameter
				IF @iComponentIndex = 24 SET @sFunctionReturnType = @sParameter
				IF @iComponentIndex = 25 SET @sLookupTableID = @sParameter
				IF @iComponentIndex = 26 SET @sLookupColumnID = @sParameter
				IF @iComponentIndex = 27 SET @sFilterID = @sParameter
				IF @iComponentIndex = 28 SET @sExpandedNode = @sParameter
				IF @iComponentIndex = 29 SET @sPromptDateType = @sParameter
				IF @iComponentIndex = 30 SET @sDescription = @sParameter
				IF @iComponentIndex = 31 SET @sFieldTableID = @sParameter
				IF @iComponentIndex = 32 SET @sFieldSelectionOrderName = @sParameter
				IF @iComponentIndex = 33 
				BEGIN
					SET @sFieldSelectionFilterName = @sParameter
					SET @sCompType = 'U'
					IF (@sType = '3') 
						OR (@sType = '10') 
						OR ((@sType = '1') AND (convert(integer, @sFieldSelectionFilter) > 0))
					BEGIN
						/* Check if the calculation/filter still exists and hasn't been made hidden. */
						IF (@sType = '3') 
						BEGIN
							SET @iCalculationID = convert(integer, @sCalculationID)
						END
						ELSE
						BEGIN
							IF (@sType = '10') 
							BEGIN
								SET @iCalculationID = convert(integer, @sFilterID)
							END
							ELSE
							BEGIN
								SET @iCalculationID = convert(integer, @sFieldSelectionFilter)
							END
						END

						SELECT @sTempAccess = Access ,
							 @sTempOwner = userName 
						FROM ASRSysExpressions
						WHERE exprID = @iCalculationID
						IF @sTempAccess IS null
						BEGIN
							/* Calculation has been deleted. */
							SET @psDeletedKeys = @psDeletedKeys +
								CASE 
									WHEN len(@psDeletedKeys) > 0 THEN char(9)
									ELSE ''
								END +
								@sNodeKey
							SET @psDeletedDescs = @psDeletedDescs +
								CASE 
									WHEN len(@psDeletedDescs) > 0 THEN char(9)
									ELSE ''
								END +
								@sDescription
						END
						ELSE 
						BEGIN
							/* Calculation still exists. Is it hidden ? */
							SET @fHidden = 0
							
							IF @sTempAccess = 'HD'
							BEGIN
								SET @fHidden = 1
							END
							ELSE
							BEGIN
								/* The calc isn't hidden. Are any sub-components hidden ? */
								execute sp_ASRIntExpressionHasHiddenComponents @iCalculationID, @fTemp OUTPUT

								IF @fTemp = 1 
								BEGIN
									SET @fHidden = 1
								END
							END

							IF @fHidden = 1
							BEGIN
								IF @sTempOwner = @sCurrentUser
								BEGIN
									SET @psHiddenOwnerKeys = @psHiddenOwnerKeys +
										CASE 
											WHEN len(@psHiddenOwnerKeys) > 0 THEN char(9)
											ELSE ''
										END +
										@sNodeKey
									SET  @psHiddenOwnerDescs = @psHiddenOwnerDescs +
										CASE 
											WHEN len(@psHiddenOwnerDescs) > 0 THEN char(9)
											ELSE ''
										END +
										@sDescription
								END
								ELSE
								BEGIN
									SET @psHiddenNotOwnerKeys = @psHiddenNotOwnerKeys +
										CASE 
											WHEN len(@psHiddenNotOwnerKeys) > 0 THEN char(9)
											ELSE ''
										END +
										@sNodeKey
									SET  @psHiddenNotOwnerDescs = @psHiddenNotOwnerDescs +
										CASE 
											WHEN len(@psHiddenNotOwnerDescs) > 0 THEN char(9)
											ELSE ''
										END +
										@sDescription
								END
							END
						END
					END
				END
			END		

			SET @iComponentIndex = @iComponentIndex + 1
		END
	END

	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions
		WHERE exprID = @piUtilID

		IF @iCount = 0
		BEGIN
			/* Expression has been deleted by another user. Save as new ? */
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sAccess = Access, 
				@sOwner = userName
			FROM ASRSysExpressions
			WHERE exprID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW')
				BEGIN
					/* Modified by another user, and made hidden/read-only. Save as new ? */
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					/* Modified by another user, still writable. Overwrite ? */
					SET @piErrorCode = 3
				END
			END
		END
	END

	/* Check that the expression name is unique. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysExpressions
	WHERE exprID <> @piUtilID
		AND parentComponentID = 0
		AND name = @psUtilName
		AND TableID = @piBaseTableID
		AND type = @piUtilType

	IF @iCount > 0 
	BEGIN
		SET @piErrorCode = 4
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetAbsenceTypes]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetAbsenceTypes]
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sExecString	nvarchar(MAX),
		@sTableName			varchar(255),
		@sColumnName		varchar(255),
		@iTableID			integer,
		@iColumnID			integer,
		@sParameterValue	varchar(MAX);

	SET @sTableName = '';
	SET @sColumnName = '';
	SET @sParameterValue = '';

	/* Get the Absence Type table name. */
	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_TableAbsenceType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iTableID = convert(integer, @sParameterValue);

		SELECT @sTableName = tableName 
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @iTableID;
		
 	END

	/* Get the Absence Type Column name. */
	SET @sParameterValue = '';

	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_FieldTypeType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iColumnID = convert(integer, @sParameterValue);

		SELECT @sColumnName = columnName 
		FROM [dbo].[ASRSysColumns]
		WHERE columnID = @iColumnID;
		
 	END

	/* Get the Absence Types if everything is ok. */
	IF len(@sTableName) > 0
		AND len(@sColumnName) > 0
	BEGIN
		SET @sExecString = 'SELECT ' + @sColumnName + 
			' FROM ' + @sTableName +
			' ORDER BY ' + @sColumnName;

		/* Return a recordset of the absence types */
		EXECUTE sp_executeSQL @sExecString;
		
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetAvailableLogins]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetAvailableLogins] 
AS
BEGIN

	SET NOCOUNT ON;

	SELECT name FROM sys.server_principals
	WHERE NOT EXISTS (SELECT sysusers.sid
						FROM sysusers
						WHERE sysusers.sid = sys.server_principals.sid)
	AND TYPE IN ('S', 'U')
	AND name != 'NT AUTHORITY\SYSTEM'
	AND is_disabled = 0;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetCalendarReportColumns]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetCalendarReportColumns] (
	@piBaseTableID 		integer
	)
AS
BEGIN

	SET NOCOUNT ON;
	
	/* Return a recordset of the columns for the given table IDs.*/
	DECLARE @sUserName sysname;

	SELECT @sUserName = SYSTEM_USER;

	SELECT 	ASRSysColumns.tableID,
			ASRSysColumns.columnId,
			ASRSysTables.tableName,
			ASRSysColumns.columnName
	FROM ASRSysColumns
			INNER JOIN ASRSysTables 
			ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysTables.tableID = @piBaseTableID
			AND ASRSysColumns.columnType NOT IN (3,4) 
			AND ASRSysColumns.dataType NOT IN (-3, -4)
	ORDER BY ASRSysColumns.columnName;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetColumns]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetColumns] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ColumnID, ColumnName, OLEType
		FROM [dbo].[ASRSysColumns]
		WHERE tableID = @piTableID AND NOT(ColumnName = 'ID')
		ORDER BY ColumnName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetEmailAddresses]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetEmailAddresses]
(@baseTableID int)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT convert(char(10),ASRSysEmailAddress.emailid)+(case when (ASRSystables.DefaultEmailID = ASRSysEmailAddress.emailid) then '1 ' else '0 ' end)+ASRSysEmailAddress.name AS 'columnDefn'
		FROM ASRSysEmailAddress
		LEFT OUTER JOIN ASRSystables ON ASRSystables.tableid = ASRSysEmailAddress.tableid
		WHERE ASRSysEmailAddress.tableid = @baseTableID OR ASRSysEmailAddress.tableid = 0
		ORDER BY ASRSysEmailAddress.name;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprCalcs]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprCalcs] (
	@piCurrentExprID	integer,
	@piBaseTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the calc definitions. */
	DECLARE @sUserName	sysname;

	SET @sUserName = SYSTEM_USER;

	SELECT Name + char(9) +
		convert(varchar(255), exprID) + char(9) +
		userName AS [definitionString],
		[Description]
	FROM [dbo].[ASRSysExpressions]
	WHERE ExprID <> @piCurrentExprID
		AND Type = 10
		AND TableID = @piBaseTableID
		AND parentComponentID = 0
		AND (Username = @sUserName OR access <> 'HD')
	ORDER BY name;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprColumns]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprColumns] (
	@piTableID			integer,
	@piComponentType	integer,
	@piNumericsOnly		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted column definitions ;
	<column id><tab><column name><tab><data type> */
	DECLARE @iDataType	integer;

	IF @piComponentType = 1
	BEGIN
		SET @iDataType = -3;
	END
	ELSE
	BEGIN
		SET @iDataType = -7;
		SET @piNumericsOnly = 0;
	END

	SELECT 
		convert(varchar(255), columnID) + char(9) +
		columnName + char(9) +
		convert(varchar(255), dataType) AS [definitionString]
	FROM [dbo].[ASRSysColumns]
	WHERE tableID = @piTableID
		AND dataType <> -4
		AND dataType <> -3
		AND dataType <> @iDataType
		AND columnType <> 4
		AND columnType <> 3
		AND ((@piNumericsOnly = 0) OR (dataType = 2) OR (dataType = 4))
	ORDER BY columnName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprFilters]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprFilters] (
	@piCurrentExprID	integer,
	@piBaseTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the filter definitions. */
	DECLARE @sUserName	sysname;

	SET @sUserName = SYSTEM_USER;

	SELECT name + char(9) +
		convert(varchar(255), exprID) + char(9) +
		userName AS [definitionString],
		[description]
	FROM [dbo].[ASRSysExpressions]
	WHERE exprID <> @piCurrentExprID
		AND type = 11
		AND TableID = @piBaseTableID
		AND parentComponentID = 0
		AND (Username = @sUserName OR access <> 'HD')
	ORDER BY name;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprFunctionParameters]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprFunctionParameters] 
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the runtiume function partameter definitions. */
	DECLARE @fEnableUDFFunctions	bit,
			@sSQLVersion int

	SET @fEnableUDFFunctions = 0
	SELECT @sSQLVersion = dbo.udfASRSQLVersion()

	IF @sSQLVersion >= 8
	BEGIN  
		SET @fEnableUDFFunctions = 1
	END
	SELECT ASRSysFunctions.functionID, 
		ASRSysFunctionParameters.parameterName
	FROM ASRSysFunctions
	LEFT OUTER JOIN ASRSysFunctionParameters ON ASRSysFunctions.functionID = ASRSysFunctionParameters.functionID
	WHERE (ASRSysFunctions.runtime = 1)
		OR ((ASRSysFunctions.UDF = 1) AND (@fEnableUDFFunctions = 1))
	ORDER BY ASRSysFunctions.functionID, ASRSysFunctionParameters.parameterIndex
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprOperators]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprOperators]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted operator definitions ;
	<operator id><tab><operator name><tab><operator category> */
	SELECT 
		convert(varchar(100), operatorID) + char(9) +
		name + 
		CASE 
			WHEN len(shortcutKeys) > 0 THEN ' (' + shortcutKeys + ')'
			ELSE ''
		END + char(9) +
		category AS [definitionString]
	FROM [dbo].[ASRSysOperators];
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprTables]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprTables] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted table definitions ;
	<table id><tab><table name><tab><table type><tab><related to base table ?><tab><is child of base table ?> */
	SELECT 
		convert(varchar(255), tableID) + char(9) +
		tableName + char(9) +
		convert(varchar(255), tableType) + char(9) +
		CASE 
			WHEN (tableID = @piTableID) OR (children.childID IS NOT null) OR (parents.parentID IS NOT null) THEN '1'
			ELSE '0'
		END + char(9) +
		CASE 
			WHEN (children.childID IS NOT null) THEN '1'
			ELSE '0'
		END AS [definitionString]
	FROM [dbo].[ASRSysTables]
	LEFT OUTER JOIN ASRSysRelations children ON	(ASRSysTables.tableid = children.childID AND children.parentID = @piTableID)
	LEFT OUTER JOIN ASRSysRelations parents ON	(ASRSysTables.tableid = parents.parentID AND parents.childID = @piTableID)
	ORDER BY tableName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetFilterPromptedValues]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValues] (
	@piFilterID 		integer,
	@psComponents		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a list of the prompted values in the given filter (and sub-filters). */
	DECLARE	@iComponentID	integer, 
			@iType			integer,
			@sComponents	varchar(MAX),
			@iExprID		integer,
			@iFieldFilterID	integer;

	SET @psComponents = '';

	/* Get the prompted value components, and also the subexpressions (sub-filters and function parameters). */
	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID, 
			type, 
			CASE 
				WHEN type = 3 THEN calculationID
				ELSE filterID
			END AS filterID, 
			fieldSelectionFilter
		FROM [dbo].[ASRSysExprComponents]
		WHERE exprID = @piFilterID
			AND ((type = 7) 
				OR ((type = 1) AND (fieldSelectionFilter > 0)) 
				OR (type = 2) 
				OR (type = 3) 
				OR (type = 10))
		ORDER BY componentID;
		
	OPEN components_cursor;
	FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iType = 1
		BEGIN
			/* Field value with filter. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFieldFilterID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END

		IF @iType = 7
		BEGIN
			/* Prompted value. */
			SET @psComponents = @psComponents + 
				CASE
					WHEN LEN(@psComponents) > 0 THEN ','
					ELSE ''
				END +
				convert(varchar(255), @iComponentID);
		END

		IF (@iType = 10) OR (@iType = 3)
		BEGIN
			/* Sub-filter or calculation. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END
	
		IF @iType = 2
		BEGIN
			/* Function. Check if there are any prompted values in the parameter expressions.. */
			DECLARE function_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT exprID 
				FROM [dbo].[ASRSysExpressions]
				WHERE parentComponentID = @iComponentID;
				
			OPEN function_cursor;
			FETCH NEXT FROM function_cursor INTO @iExprID;
			WHILE (@@fetch_status = 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

				IF LEN(@sComponents) > 0
				BEGIN
					SET @psComponents = @psComponents + 
						CASE
							WHEN LEN(@psComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents;
				END

				FETCH NEXT FROM function_cursor INTO @iExprID;
			END
			CLOSE function_cursor;
			DEALLOCATE function_cursor;
		END
	
		FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	END
	
	CLOSE components_cursor;
	DEALLOCATE components_cursor;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetFindWindowInfo]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetFindWindowInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry 	bit 			OUTPUT, 
	@plngScreenID	integer,
	@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the find window title for the given screen. 	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* Get the screen name. */
	IF @plngScreenID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @psTitle = name,
			@pfQuickEntry = quickEntry
		FROM [dbo].[ASRSysScreens]
		WHERE screenID = @plngScreenID;

		IF @psTitle IS NULL 
		BEGIN
			SET @psTitle = '<unknown screen>';
		END
		IF @pfQuickEntry IS NULL 
		BEGIN
			SET @pfQuickEntry = 0;
		END
	END
	ELSE
	BEGIN
		SET @psTitle = '<unknown screen>';
	END	

	/* Get the view name. */
	IF @plngViewID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @sViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @plngViewID;

		IF @sViewName IS NULL 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetLookupFindRecords]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetLookupFindRecords] (
	@piColumnID 		integer,
	@piRecordsRequired	integer,
	@pfFirstPage		bit			OUTPUT,
	@pfLastPage			bit			OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer		OUTPUT,
	@piColumnSize		integer		OUTPUT,
	@piColumnDecimals	integer		OUTPUT,
	@psAction			varchar(100),
	@piTotalRecCount	integer		OUTPUT,
	@piFirstRecPos		integer		OUTPUT,
	@piCurrentRecCount	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the lookup find records, given the table and column IDs.
		@piTableID = the ID of the table on which the find is based.
		@piColumnID = the ID of the column on which the find is based.
	NB. No permissions need to be read, as all users have read permission on lookup tables.
	*/
	DECLARE @sTableName		sysname,
		@iTableID 			integer, 
		@sColumnName 		sysname,
		@sColumnName2 		sysname,
		@iOrderID			integer,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@iGetCount			integer;

	/* Initialise variables. */
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @sExecString = '';
	SET @sReverseOrderSQL = '';

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000;
	SET @psAction = UPPER(@psAction);
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST';
	END

	/* Get the column name. */
	SELECT @sColumnName = ASRSysColumns.columnName,
		@iTableID = ASRSysColumns.tableID,
		@piColumnType = ASRSysColumns.dataType,
		@piColumnSize = ASRSysColumns.size,
		@piColumnDecimals = ASRSysColumns.decimals
	FROM [dbo].[ASRSysColumns]
	WHERE ASRSysColumns.columnId = @piColumnID;

	/* Get the table name and default order. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iOrderID = ASRSysTables.defaultOrderID
	FROM [dbo].[ASRSysTables]
	WHERE ASRSysTables.tableID = @iTableID;

	SET @sSelectSQL = @sTableName + '.' + @sColumnName;
	SET @sOrderSQL = @sTableName + '.' + @sColumnName + ', ' + @sTableName + '.ID';

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnName
	FROM ASRSysOrderItems
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysOrderItems.orderID = @iOrderID
		AND ASRSysOrderItems.type = 'F'
		AND ASRSysOrderItems.columnID <> @piColumnID
	ORDER BY ASRSysOrderItems.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @sColumnName2;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sSelectSQL = @sSelectSQL +  ','  + @sTableName + '.' + @sColumnName2;

		FETCH NEXT FROM orderCursor INTO @sColumnName2;
	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sReverseOrderSQL = @sTableName + '.' + @sColumnName + ' DESC, ' + @sTableName + '.ID DESC';
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sTableName + '.id) FROM ' + @sTableName;
	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;

	SET @sExecString = 'SELECT ';

	IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
	BEGIN
		SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
	END
	SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sTableName;

	IF (@psAction = 'MOVELAST') 
	BEGIN
		SET @sExecString = @sExecString + 
			' WHERE ' + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName;
	END
	
	IF @psAction = 'MOVENEXT' 
	BEGIN
		IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
		BEGIN
			SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
		END
		ELSE
		BEGIN
			SET @iGetCount = @piRecordsRequired;
		END
		SET @sExecString = @sExecString + 
			' WHERE ' + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName;

		SET @sExecString = @sExecString + 
			' WHERE ' + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(8000), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired  - 1) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName;
			
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		IF @piFirstRecPos <= @piRecordsRequired
		BEGIN
			SET @iGetCount = @piFirstRecPos - 1;
		END
		ELSE
		BEGIN
			SET @iGetCount = @piRecordsRequired;
		END
		SET @sExecString = @sExecString + 
			' WHERE ' + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName;

		SET @sExecString = @sExecString + 
			' WHERE ' + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName;
	END

	IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
	BEGIN
		SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL + ')';
	END
	IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
	BEGIN
		SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')';
	END

	IF (@psAction = 'LOCATE')
	BEGIN
		SET @sLocateCode = ' WHERE (' + @sTableName + '.' + @sColumnName;

		IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ''' + replace(@psLocateValue, '''', '''''') + '''';

			IF len(@psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' OR ' + @sTableName + '.' + @sColumnName + ' IS NULL';
			END
		END

		IF @piColumnType = 11 /* Date column */
		BEGIN
			IF len(@psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sTableName + '.' + @sColumnName + ' IS NULL';
			END
			ELSE
			BEGIN
				SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
			END
		END

		IF @piColumnType = -7 /* Logic column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ' + 
				CASE
					WHEN @psLocateValue = 'True' THEN '1'
					ELSE '0'
				END;
		END

		IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue;

			IF convert(float, @psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' OR ' + @sTableName + '.' + @sColumnName + ' IS NULL';
			END
		END

		SET @sLocateCode = @sLocateCode + ')';
		SET @sExecString = @sExecString + @sLocateCode;
	END

	/* Add the ORDER BY code to the find record selection string if required. */
	SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1;
		SET @pfFirstPage = 1;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
		SET @pfFirstPage = 0;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;		
	END
	
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 1;
	END
	
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sTableName + '.id) FROM ' + @sTableName + @sLocateCode;
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT;

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1;
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1;
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END;
	END

	-- Return a recordset of the required columns in the required order from the given table/view.
	EXECUTE sp_executeSQL @sExecString;
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetLookupValues]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetLookupValues] (
	@piColumnID 	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the lookup values for the given lookup column. */
	DECLARE	@sColumnName	sysname,
			@sTableName		sysname,
			@sExecString	nvarchar(MAX);

	SELECT @sTableName = ASRSysTables.tableName,
		@sColumnName = ASRSysColumns.columnName
	FROM ASRSysColumns
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE columnID = @piColumnID;

	SET @sExecString = 'SELECT ' + @sColumnName + 
		' FROM ' + @sTableName +
		' ORDER BY ' + @sColumnName;

	/* Return a recordset of the required columns in the required order from the given table/view. */
	EXECUTE sp_executeSQL @sExecString;
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetModuleParameter]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetModuleParameter]
(
	@psModuleKey 		varchar(255), 
	@psParameterKey 	varchar(255),
	@psParameter		varchar(1000) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psParameter = parameterValue 
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = @psModuleKey 
		AND parameterKey = @psParameterKey;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetOrders]...';


GO
ALTER PROCEDURE sp_ASRIntGetOrders (@plngTableID int, @plngViewID int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the orders available for the given table/view. */
	DECLARE @lngTableID		int,
		@lngDefaultOrderID	int

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @plngViewID
	END

	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #orderInfo
	(
		orderID			int,
		orderName		sysname,
		defaultOrder		bit
	)

	/* Populate the temporary table with information on the order for the given table. */
   	 INSERT INTO #orderInfo (
		orderID, 
		orderName,
		defaultOrder)	
	(SELECT ASRSysOrders.OrderID, 
		ASRSysOrders.name,
		0
	FROM ASRSysOrders
	WHERE ASRSysOrders.tableID = @lngTableID)

	/* Get the table's default order. */
	SELECT @lngDefaultOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @lngTableID

	IF @lngDefaultOrderID > 0 
	BEGIN
		UPDATE #orderInfo
		SET defaultOrder = 1 
		WHERE orderID = @lngDefaultOrderID
	END

	/* Return the resultset. */
	SELECT *
	FROM #orderInfo 
	ORDER BY orderName
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetRecordDescription]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetRecordDescription] (
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@sEvalRecDesc		varchar(8000),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500);

	SET @psRecDesc = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM  [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piTableID;
	END

	/* Get the record description. */
	IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
	BEGIN
		SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(255), @iRecDescID) + ' @recDesc OUTPUT, @recID';
		SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
		EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;

		IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetRecordEditInfo]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetRecordEditInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry	bit				OUTPUT, 
	@piScreenID 	integer, 
	@piViewID 		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the Record Edit window title for the given screen/view . 
	    The title is in the format <screen name>[ - <view name> view)]	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* The title always starts with the screen name. */
	SELECT @psTitle = ASRSysScreens.name,
		@pfQuickEntry = ASRSysScreens.quickEntry
	FROM ASRSysScreens
	WHERE ASRSysScreens.ScreenID = @piScreenID;

	IF @psTitle IS NULL 
	BEGIN
		SET @psTitle = '<unknown screen>';
	END
	IF @pfQuickEntry IS NULL 
	BEGIN
		SET @pfQuickEntry = 0;
	END

	IF @piViewID > 0
	BEGIN
		/* Find title is the table name with the view name in brackets. */
		SELECT @sViewName = ASRSysViews.viewName
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @piViewID;

		IF (@sViewName IS NULL) 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetReportChilds]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetReportChilds] (
	@piReportID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the child table information based on the passed report ID */
	SELECT  
		CONVERT(varchar(255), C.ChildTable) + char(9) 
			+ T.TableName + char(9) 
			+ CONVERT(varchar(10), CASE 
				WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.ExprID, 0)
				ELSE 0
			END) + char(9)
			+ CASE 
				WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.Name, '')
				ELSE ''
			END + char(9)
			+ CONVERT(varchar(255), isnull(O.OrderID, 0)) + char(9) 
			+ isnull(O.Name, ' ' ) + char(9)
			+ CASE 
				WHEN C.ChildMaxRecords = 0 THEN 'All Records'
				ELSE CONVERT(varchar(100), C.ChildMaxRecords) 
			END AS [gridstring],
		C.ChildTable AS [TableID],
		T.TableName AS [Table],
		CASE 
			WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.ExprID, 0)
			ELSE 0
		END AS [FilterID],
		CASE 
			WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.Name, '')
			ELSE ''
		END AS [Filter],
		isnull(O.OrderID, 0) AS [OrderID],
	  O.Name AS [Order],
	  C.ChildMaxRecords AS [Records], 
		CASE 
			WHEN (X.Access = 'HD') AND (X.userName = system_user) THEN 'Y'
			ELSE 'N'
		END AS [FilterHidden],
		CASE 
			WHEN isnull(O.OrderID, 0) <> isnull(C.ChildOrder,0) THEN 'Y'
			ELSE 'N'
		END AS [OrderDeleted],
		CASE 
			WHEN isnull(X.ExprID, 0) <> isnull(C.ChildFilter,0) THEN 'Y'
			ELSE 'N'
		END AS [FilterDeleted],
		CASE 
			WHEN (X.Access = 'HD') AND (X.userName <> system_user) THEN 'Y'
			ELSE 'N'
		END AS [FilterHiddenByOther]
	FROM [dbo].[ASRSysCustomReportsChildDetails] C 
	INNER JOIN [dbo].[ASRSysTables] T ON C.ChildTable = T.TableID 
		LEFT OUTER JOIN [dbo].[ASRSysExpressions] X ON C.ChildFilter = X.ExprID 
		LEFT OUTER JOIN [dbo].[ASRSysOrders] O ON C.ChildOrder = O.OrderID
	WHERE C.CustomReportID = @piReportID
	ORDER BY T.TableName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetRootExpressionIDs]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetRootExpressionIDs] (
	@piCompID		integer,
	@piRootExprID	varchar(255)	OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iParentCompID	integer;

	SELECT @iParentCompID = ASRSysExpressions.parentComponentID, 
		@piRootExprID = ASRSysExpressions.ExprID
	FROM [dbo].[ASRSysExpressions]
	JOIN ASRSysExprComponents ON ASRSysExpressions.exprID = ASRSysExprComponents.exprID
	WHERE ASRSysExprComponents.componentID = @piCompID;

	IF (@iParentCompID > 0)
	BEGIN
		EXECUTE [dbo].[sp_ASRIntGetRootExpressionIDs] @iParentCompID, @piRootExprID OUTPUT;
	END

	IF @piRootExprID IS null SET @piRootExprID = 0;
END
GO
PRINT N'Altering [dbo].[spASRIntGetAllExprRootIDs]...';


GO
ALTER PROCEDURE spASRIntGetAllExprRootIDs
(
		@iExprID integer,
		@superExpressions cursor varying output
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a cursor of the expressions that use the given expression. */
	DECLARE	@iComponentID	integer,
					@iRootExprID	integer,
					@superCursor	cursor,
					@iTemp				integer

	CREATE TABLE #superExpressionIDs (id integer)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID
		FROM ASRSysExprComponents
		WHERE (calculationID = @iExprID)
			OR (filterID = @iExprID)
			OR ((fieldSelectionFilter = @iExprID) AND (type = 1))

	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iComponentID
	WHILE (@@fetch_status = 0)
	BEGIN
		exec sp_ASRIntGetRootExpressionIDs @iComponentID, @iRootExprID	OUTPUT

		INSERT INTO #superExpressionIDs (id) VALUES (@iRootExprID)
		
		exec spASRIntGetAllExprRootIDs @iRootExprID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO #superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		FETCH NEXT FROM check_cursor INTO @iComponentID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor
	
	SET @superExpressions = CURSOR FORWARD_ONLY STATIC FOR
		SELECT id FROM #superExpressionIDs
	OPEN @superExpressions
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetScreenControls]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetScreenControls] (
	@plngScreenID 	int,
	@plngViewId	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the controls in the given screen. */
	SELECT tableID, columnID, controlType,
		topCoord, leftCoord, height, width,	caption
	FROM [dbo].[ASRSysControls]
	WHERE ScreenID = @plngScreenID;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetSetting]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetSetting] (
	@psSection		varchar(MAX),
	@psKey			varchar(MAX),
	@psDefault		varchar(MAX),
	@pfUserSetting	bit,
	@psResult		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the required user or system setting. */
	DECLARE	@iCount	integer;

	IF @pfUserSetting = 1
	BEGIN
		SELECT @iCount = COUNT(userName)
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER
			AND section = @psSection		
			AND settingKey = @psKey;

		SELECT @psResult = settingValue 
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER
			AND section = @psSection		
			AND settingKey = @psKey;
	END
	ELSE
	BEGIN
		SELECT @iCount = COUNT(settingKey)
		FROM ASRSysSystemSettings
		WHERE section = @psSection		
			AND settingKey = @psKey;

		SELECT @psResult = settingValue 
		FROM ASRSysSystemSettings
		WHERE section = @psSection		
			AND settingKey = @psKey;
	END

	IF @iCount = 0
	BEGIN
		SET @psResult = @psDefault;	
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetSubExpressionsAndComponents]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetSubExpressionsAndComponents] (
	@piExprID				integer, 
	@psTempExprIDs 			varchar(MAX)	OUTPUT, 
	@psTempComponentIDs		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iComponentID		integer,
		@iExpressionID		integer,
		@sSubExprIDs 		varchar(MAX), 
		@sSubComponentIDs	varchar(MAX);	

	SET @psTempExprIDs = '';
	SET @psTempComponentIDs = '';

	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysExprComponents.componentID
		FROM ASRSysExprComponents
		WHERE ASRSysExprComponents.exprID = @piExprID;
	OPEN components_cursor;
	FETCH NEXT FROM components_cursor INTO @iComponentID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psTempComponentIDs = @psTempComponentIDs +
			CASE
				WHEN len(@psTempComponentIDs) > 0 THEN ','
				ELSE ''
			END +
			convert(varchar(100), @iComponentID);
			
		FETCH NEXT FROM components_cursor INTO @iComponentID;
	END
	CLOSE components_cursor;
	DEALLOCATE components_cursor;

	DECLARE expressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysExpressions.exprID
		FROM ASRSysExpressions
		WHERE ASRSysExpressions.parentComponentID IN
			(SELECT ASRSysExprComponents.componentID
			FROM ASRSysExprComponents
			WHERE ASRSysExprComponents.exprID = @piExprID);
	OPEN expressions_cursor;
	FETCH NEXT FROM expressions_cursor INTO @iExpressionID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psTempExprIDs = @psTempExprIDs +
			CASE
				WHEN len(@psTempExprIDs) > 0 THEN ','
				ELSE ''
			END +
			convert(varchar(100), @iExpressionID);
		
		exec [dbo].[sp_ASRIntGetSubExpressionsAndComponents] @iExpressionID, @sSubExprIDs OUTPUT, @sSubComponentIDs OUTPUT;
		
		IF len(@sSubExprIDs) > 0
		BEGIN
			SET @psTempExprIDs = @psTempExprIDs +
				CASE
					WHEN len(@psTempExprIDs) > 0 THEN ','
					ELSE ''
				END +
				@sSubExprIDs;
		END

		IF len(@sSubComponentIDs) > 0
		BEGIN
			SET @psTempComponentIDs = @psTempComponentIDs +
				CASE
					WHEN len(@psTempComponentIDs) > 0 THEN ','
					ELSE ''
				END +
				@sSubComponentIDs;
		END

		FETCH NEXT FROM expressions_cursor INTO @iExpressionID;
	END
	CLOSE expressions_cursor;
	DEALLOCATE expressions_cursor;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetSystemSetting]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetSystemSetting] (
	@psNewSection		varchar(255),			/* Section value in the new ASRSysSystemSettings table. */
	@psNewKey			varchar(255),			/* Key value in the new ASRSysSystemSettings table. */
	@psOldColumnName	varchar(255),			/* Column name in the old ASRSysConfig table. */
	@psResult			varchar(MAX)	OUTPUT,
	@pfNewSettingFound	bit				OUTPUT,
	@pfOldSettingFound	bit				OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sValue					varchar(MAX);

	SET @pfNewSettingFound = 0;
	SET @pfOldSettingFound = 0;
	IF (@psOldColumnName IS NULL) SET @psOldColumnName = '';

	/* Clean the input string parameters. */
	IF len(@psNewSection) > 0 SET @psNewSection = replace(@psNewSection, '''', '''''');
	IF len(@psNewKey) > 0 SET @psNewKey = replace(@psNewKey, '''', '''''');

	/* Check if the 'ASRSysSystemSettings' table exists. */
	SELECT @iCount = count(Name)
	FROM sysobjects 
	WHERE name = 'ASRSysSystemSettings';
		
	IF @iCount = 1
	BEGIN
		/* The ASRSysSystemSettings table exists. See if the required records exists in it. */
		SET @sTempExecString = 'SELECT @sValue = settingValue' +
			' FROM ASRSysSystemSettings' +
			' WHERE section = ''' + @psNewSection + '''' +
			' AND settingKey = ''' + @psNewKey +'''';
		SET @sTempParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sValue OUTPUT;
	
		IF NOT @sValue IS NULL
		BEGIN
			SET @psResult = @sValue;
			SET @pfNewSettingFound = 1;
		END
	END

	IF @pfNewSettingFound = 0
	BEGIN
		SELECT @iCount = count(syscolumns.name)
		FROM syscolumns 
		INNER JOIN sysobjects ON syscolumns.id = sysobjects.id
		WHERE syscolumns.name = @psOldColumnName
			AND sysobjects.name = 'ASRSysConfig';

		IF @iCount = 1
		BEGIN
			/* Clean the input string parameter. */
			IF len(@psOldColumnName) > 0 SET @psOldColumnName = replace(@psOldColumnName, '''', '''''');

			SET @sTempExecString = 'SELECT @sValue = convert(varchar(8000), ' + @psOldColumnName + ') FROM ASRSysConfig';
			SET @sTempParamDefinition = N'@sValue varchar(100) OUTPUT';
			EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sValue OUTPUT;

			IF NOT @sValue IS NULL
			BEGIN
				SET @psResult = @sValue;
				SET @pfOldSettingFound = 1;
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRIntActivateModule]...';


GO
ALTER PROCEDURE [dbo].[spASRIntActivateModule](
	@sModule	varchar(50),
	@bLicensed	bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iCustomerNo		integer,
			@sModuleCode		varchar(100),
			@sValue				varchar(MAX),
			@fNewModuleCode		bit,
			@fNewSettingFound	bit,
			@fOldSettingFound	bit,
			@iModule			int,
			@iSuccessFlag		smallint,
			@objectToken 		integer,
			@hResult 			integer,
			@iValue				integer,
			@sErrorMessage		varchar(MAX),
			@sSQLVersion		int;

	IF @sModule = 'PERSONNEL' SET @iModule = 1;
	IF @sModule = 'RECRUITMENT' SET @iModule = 2;
	IF @sModule = 'ABSENCE' SET @iModule = 4;
	IF @sModule = 'TRAINING' SET @iModule = 8;
	IF @sModule = 'INTRANET' SET @iModule = 16;
	IF @sModule = 'AFD' SET @iModule = 32;
	IF @sModule = 'FULLSYSTEMMANGER' SET @iModule = 64;
	IF @sModule = 'CMG' SET @iModule = 128;
	IF @sModule = 'QADDRESS' SET @iModule = 256;
	IF @sModule = 'ACCORD' SET @iModule = 512;
	IF @sModule = 'WORKFLOW' SET @iModule = 1024;
	IF @sModule = 'VERSIONONE' SET @iModule = 2048;
	IF @sModule = 'MOBILE' SET @iModule = 4096;

	/* Get the module license code. */
	SET @sModuleCode = '';
	SET @fNewModuleCode = 0;
	EXEC [dbo].[sp_ASRIntGetSystemSetting] 'Licence', 'Key', 'moduleCode', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT;
	IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
	BEGIN
		SET @sModuleCode = @sValue;
		SET @fNewModuleCode = @fNewSettingFound;
	END

	SELECT @bLicensed = dbo.udfASRNetIsModuleLicensed(@sModuleCode,@iModule);

END
GO
PRINT N'Altering [dbo].[spASRIntGetLicenceInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetLicenceInfo](
	@fSelfService		integer,
	@piSuccessFlag		integer			OUTPUT,
	@fIntranetEnabled	bit				OUTPUT,
	@iSSUsers			integer			OUTPUT,
	@iFullUsers			integer			OUTPUT,
	@iSSIUsers			integer			OUTPUT,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iCustomerNo		integer,
			@sModuleCode		varchar(100),
			@sValue				varchar(MAX),
			@fNewModuleCode		bit,
			@fNewSettingFound	bit,
			@fOldSettingFound	bit,
			@iSuccessFlag		smallint,
			@objectToken 		integer,
			@hResult 			integer,
			@iValue				integer,
			@iSQLVersion		int;

	SELECT @iSQLVersion = dbo.udfASRSQLVersion();

	/* Get the module license code. */
	SET @sModuleCode = '';
	SET @fNewModuleCode = 0;
	EXEC sp_ASRIntGetSystemSetting 'Licence', 'Key', 'moduleCode', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT;
	IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
	BEGIN
		SET @sModuleCode = @sValue;
		SET @fNewModuleCode = @fNewSettingFound;
	END

	SET @psErrorMessage = '';
	SELECT @fIntranetEnabled = dbo.udfASRNetIsModuleLicensed(@sModuleCode,16);
	IF @fIntranetEnabled = 0
		SET @psErrorMessage = 'You are not licensed to use the intranet module.';
	ELSE
	BEGIN
		SET @piSuccessFlag = 1
		SELECT @iSSIUsers = dbo.udfASRNetGetLicenceKey(@sModuleCode,'SSISUsers');
		SELECT @iFullUsers = dbo.udfASRNetGetLicenceKey(@sModuleCode,'DMIMUsers');
		SELECT @iSSUsers = dbo.udfASRNetGetLicenceKey(@sModuleCode,'DMISUsers');
	END

END
GO
PRINT N'Altering [dbo].[spASRIntGetWorkflowParameters]...';


GO
ALTER PROCEDURE spASRIntGetWorkflowParameters 
(
	@pfWFEnabled			bit	OUTPUT
)
AS
BEGIN
	
	SET NOCOUNT ON;

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'WORKFLOW', @pfWFEnabled OUTPUT;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetTables]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetTables] AS
BEGIN

	SET NOCOUNT ON;

	SELECT tableID, tableName
		FROM [dbo].[ASRSysTables]
		ORDER BY tableName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntPasswordOK]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntPasswordOK]
AS
BEGIN

	SET NOCOUNT ON;

	/* Update the current user's record into ASRSysPassword table.. */
	DECLARE @iCount		integer,
		@sCurrentUser	sysname;

	SET @sCurrentUser = system_user;

	/* Check that the current user has a record in the table. */
	SELECT @iCount = COUNT(userName)
	FROM ASRSysPasswords
	WHERE userName = @sCurrentUser;

	IF @iCount = 0
	BEGIN
		INSERT INTO ASRSysPasswords (userName, lastChanged, forceChange)
		VALUES (@sCurrentUser, GETDATE(), 0);
	END
	ELSE
	BEGIN
		UPDATE ASRSysPasswords 
		SET lastChanged = GETDATE(), 
			forceChange = 0
		WHERE userName = @sCurrentUser;
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntSaveCrossTab]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntSaveCrossTab] (
	@psName				varchar(255),
	@psDescription		varchar(MAX),
	@piTableID			integer,
	@piSelection		integer,
	@piPicklistID		integer,
	@piFilterID			integer,
	@pfPrintFilter		bit,
	@psUserName			varchar(255),
	@piHColID			integer,
	@psHStart			varchar(100),
	@psHStop			varchar(100),
	@psHStep			varchar(100),
	@piVColID			integer,
	@psVStart			varchar(100),
	@psVStop			varchar(100),
	@psVStep			varchar(100),
	@piPColID			integer,
	@psPStart			varchar(100),
	@psPStop			varchar(100),
	@psPStep			varchar(100),
	@piIType			integer,
	@piIColID			integer,
	@pfPercentage		bit,
	@pfPerPage			bit,
	@pfSuppress			bit,
	@pfUse1000Separator	bit,
	@pfOutputPreview	bit,
	@piOutputFormat		integer,
	@pfOutputScreen		bit,
	@pfOutputPrinter	bit,
	@psOutputPrinterName	varchar(MAX),
	@pfOutputSave		bit,
	@piOutputSaveExisting	integer,
	@pfOutputEmail		bit,
	@piOutputEmailAddr	integer,
	@psOutputEmailSubject	varchar(MAX),
	@psOutputEmailAttachAs	varchar(MAX),
	@psOutputFilename	varchar(MAX),
	@psAccess			varchar(MAX),
	@psJobsToHide		varchar(MAX),
	@psJobsToHideGroups	varchar(MAX),
	@piID				integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
			@fIsNew		bit,
			@sTemp		varchar(MAX),
			@iCount		integer,
			@sGroup		varchar(MAX),
			@sAccess	varchar(MAX),
			@sSQL		nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')

	SET @fIsNew = 0

	/* Insert/update the report header. */
	IF (@piID = 0)
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysCrossTab (
			Name, 
			Description, 
			TableID, 
			Selection, 
			PicklistID, 
			FilterID, 
 			PrintFilterHeader, 
 			UserName, 
 			HorizontalColID, 
 			HorizontalStart, 
 			HorizontalStop, 
 			HorizontalStep, 
			VerticalColID, 
			VerticalStart, 
			VerticalStop, 
			VerticalStep, 
			PageBreakColID, 
			PageBreakStart, 
			PageBreakStop, 
			PageBreakStep, 
			IntersectionType, 
			IntersectionColID, 
			Percentage, 
			PercentageofPage, 
			SuppressZeros, 
			ThousandSeparators, 
			OutputPreview, 
			OutputFormat, 
			OutputScreen, 
			OutputPrinter, 
			OutputPrinterName, 
			OutputSave, 
			OutputSaveExisting, 
			OutputEmail, 
			OutputEmailAddr, 
			OutputEmailSubject, 
			OutputEmailAttachAs, 
			OutputFileName)
		VALUES (
			@psName,
			@psDescription,
			@piTableID,
			@piSelection,
			@piPicklistID,
			@piFilterID,
			@pfPrintFilter,
			@psUserName,
			@piHColID,
			@psHStart,
			@psHStop,
			@psHStep,
			@piVColID,
			@psVStart,
			@psVStop,
			@psVStep,
			@piPColID,
			@psPStart,
			@psPStop,
			@psPStep,
			@piIType,
			@piIColID,
			@pfPercentage,
			@pfPerPage,
			@pfSuppress,
			@pfUse1000Separator,
			@pfOutputPreview,
			@piOutputFormat,
			@pfOutputScreen,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@pfOutputSave,
			@piOutputSaveExisting,
			@pfOutputEmail,
			@piOutputEmailAddr,
			@psOutputEmailSubject,
			@psOutputEmailAttachAs,
			@psOutputFilename
		)

		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(CrossTabID) FROM ASRSysCrossTab
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysCrossTab SET 
			Name = @psName,
			Description = @psDescription,
			TableID = @piTableID,
			Selection = @piSelection,
			PicklistID = @piPicklistID,
			FilterID = @piFilterID,
			PrintFilterHeader = @pfPrintFilter,
			HorizontalColID = @piHColID,
			HorizontalStart = @psHStart,
			HorizontalStop = @psHStop,
			HorizontalStep = @psHStep,	
			VerticalColID = @piVColID,
			VerticalStart = @psVStart,
			VerticalStop = @psVStop,
			VerticalStep = @psVStep,	
			PageBreakColID = @piPColID,
			PageBreakStart = @psPStart,
			PageBreakStop = @psPStop,
			PageBreakStep = @psPStep,	
			IntersectionType = @piIType,
			IntersectionColID = @piIColID,
			Percentage = @pfPercentage,
			PercentageofPage = @pfPerPage,
			SuppressZeros = @pfSuppress,
			ThousandSeparators = @pfUse1000Separator,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @piOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename
		WHERE CrossTabID = @piID
	END

	DELETE FROM ASRSysCrossTabAccess WHERE ID = @piID

	INSERT INTO ASRSysCrossTabAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)

	SET @sTemp = @psAccess
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysCrossTabAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCrossTabAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (1, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 1

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (1, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 1
		END
	END
	
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''
		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' + @psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntSaveCustomReport]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntSaveCustomReport] (
	@psName						varchar(255),
	@psDescription				varchar(MAX),
	@piBaseTableID				integer,
	@pfAllRecords				bit,
	@piPicklistID				integer,
	@piFilterID					integer,
	@piParent1TableID			integer,
	@piParent1FilterID			integer,
	@piParent2TableID			integer,
	@piParent2FilterID			integer,
	@pfSummary					bit,
	@pfPrintFilterHeader		bit,
	@psUserName					varchar(255),
	@pfOutputPreview			bit,
	@piOutputFormat				integer,
	@pfOutputScreen				bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName		varchar(MAX),
	@pfOutputSave				bit,
	@piOutputSaveExisting		integer,
	@pfOutputEmail				bit,
	@piOutputEmailAddr			integer,
	@psOutputEmailSubject		varchar(MAX),
	@psOutputEmailAttachAs		varchar(MAX),
	@psOutputFilename			varchar(MAX),
	@pfParent1AllRecords		bit,
	@piParent1Picklist			integer,
	@pfParent2AllRecords		bit,
	@piParent2Picklist			integer,
	@psAccess					varchar(MAX),
	@psJobsToHide				varchar(MAX),
	@psJobsToHideGroups			varchar(MAX),
	@psColumns					varchar(MAX),
	@psColumns2					varchar(MAX),
	@psChildString				varchar(MAX),
	@piID						integer					OUTPUT,
	@pfIgnoreZeros				bit
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sTemp					varchar(MAX),
			@sColumnDefn			varchar(MAX),
			@sColumnParam			varchar(MAX),
			@iSequence				integer,
			@sType					varchar(MAX),
			@iColExprID				integer,
			@sHeading				varchar(MAX),
			@iSize					integer,
			@iDP					integer,
			@fIsNumeric				bit,
			@fAvge					bit,
			@fCnt					bit,
			@fTot					bit,
			@fHidden				bit,
			@fGroupWithNext			bit,
			@iSortOrderSequence		integer,
			@sSortOrder				varchar(MAX),
			@fBOC					bit,
			@fPOC					bit,
			@fVOC					bit,
			@fSRV					bit,
			@fRepetition 			integer,
			@iCount					integer,
			@fIsNew					bit,
			@iChildTableID			integer,
			@iChildFilterID			integer,
			@iChildOrderID			integer,
			@iChildMaxRecords		integer,
			@sChildDefn				varchar(MAX),
			@sChildParam			varchar(MAX),
			@sGroup					varchar(255),
			@sAccess				varchar(MAX),
			@sSQL					nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')

	SET @fIsNew = 0

	/* Insert/update the report header. */
	IF (@piID = 0)
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysCustomReportsName (
			Name, 
			[Description], 
			BaseTable, 
			AllRecords, 
			Picklist, 
			Filter, 
 			Parent1Table, 
 			Parent1Filter, 
 			Parent2Table, 
 			Parent2Filter, 
 			Summary,
 			IgnoreZeros, 
 			PrintFilterHeader, 
 			UserName, 
 			OutputPreview, 
 			OutputFormat, 
 			OutputScreen, 
 			OutputPrinter, 
 			OutputPrinterName, 
 			OutputSave, 
 			OutputSaveExisting, 
 			OutputEmail, 
 			OutputEmailAddr, 
 			OutputEmailSubject, 
 			OutputEmailAttachAs, 
 			OutputFileName, 
 			Parent1AllRecords, 
 			Parent1Picklist, 
 			Parent2AllRecords, 
 			Parent2Picklist)
 		VALUES (
 			@psName,
 			@psDescription,
 			@piBaseTableID,
 			@pfAllRecords,
 			@piPicklistID,
 			@piFilterID,
 			@piParent1TableID,
 			@piParent1FilterID,
 			@piParent2TableID,
 			@piParent2FilterID,
 			@pfSummary,
 			@pfIgnoreZeros,
 			@pfPrintFilterHeader,
 			@psUserName,
 			@pfOutputPreview,
 			@piOutputFormat,
 			@pfOutputScreen,
 			@pfOutputPrinter,
 			@psOutputPrinterName,
 			@pfOutputSave,
 			@piOutputSaveExisting,
 			@pfOutputEmail,
 			@piOutputEmailAddr,
 			@psOutputEmailSubject,
 			@psOutputEmailAttachAs,
 			@psOutputFilename,
 			@pfParent1AllRecords,
 			@piParent1Picklist,
 			@pfParent2AllRecords,
 			@piParent2Picklist
		)

		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(ID) FROM ASRSysCustomReportsName
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSYSCustomReportsName SET 
			Name = @psName,
			Description = @psDescription,
			BaseTable = @piBaseTableID,
			AllRecords = @pfAllRecords,
			Picklist = @piPicklistID,
			Filter = @piFilterID,
			Parent1Table = @piParent1TableID,
			Parent1Filter = @piParent1FilterID,
			Parent2Table = @piParent2TableID,
			Parent2Filter = @piParent2FilterID,
			Summary = @pfSummary,
			IgnoreZeros = @pfIgnoreZeros,
			PrintFilterHeader = @pfPrintFilterHeader,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @piOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename,
			Parent1AllRecords = @pfParent1AllRecords,
			Parent1Picklist = @piParent1Picklist,
			Parent2AllRecords = @pfParent2AllRecords,
			Parent2Picklist = @piParent2Picklist
		WHERE ID = @piID

		/* Delete existing report details. */
		DELETE FROM ASRSysCustomReportsDetails 
		WHERE customReportID = @piID
	END

	/* Create the details records. */
	SET @sTemp = @psColumns

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sColumnDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)

			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psColumns2, 1000)
				IF len(@psColumns2) > 1000
				BEGIN
					SET @psColumns2 = SUBSTRING(@psColumns2, 1001, len(@psColumns2) - 1000)
				END
				ELSE
				BEGIN
					SET @psColumns2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sColumnDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the column definition parameters. */
		SET @iSequence = 0
		SET @sType = ''
		SET @iColExprID = 0
		SET @sHeading = ''
		SET @iSize = 0
		SET @iDP = 0
		SET @fIsNumeric = 0
		SET @fAvge = 0
		SET @fCnt = 0
		SET @fTot = 0
		SET @fHidden = 0
		SET @fGroupWithNext = 0
		SET @iSortOrderSequence = 0
		SET @sSortOrder = ''
		SET @fBOC = 0
		SET @fPOC = 0
		SET @fVOC = 0
		SET @fSRV = 0
		SET @fRepetition = 0
		SET @iCount = 0
		
		WHILE LEN(@sColumnDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sColumnDefn) > 0
			BEGIN
				SET @sColumnParam = LEFT(@sColumnDefn, CHARINDEX('||', @sColumnDefn) - 1)
				SET @sColumnDefn = RIGHT(@sColumnDefn, LEN(@sColumnDefn) - CHARINDEX('||', @sColumnDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sColumnParam = @sColumnDefn
				SET @sColumnDefn = ''
			END

			IF @iCount = 0 SET @iSequence = convert(integer, @sColumnParam)
			IF @iCount = 1 SET @sType = @sColumnParam
			IF @iCount = 2 SET @iColExprID = convert(integer, @sColumnParam)
			IF @iCount = 3 SET @sHeading = @sColumnParam
			IF @iCount = 4 SET @iSize = convert(integer, @sColumnParam)
			IF @iCount = 5 SET @iDP = convert(integer, @sColumnParam)
			IF @iCount = 6 SET @fIsNumeric = convert(bit, @sColumnParam)
			IF @iCount = 7 SET @fAvge = convert(bit, @sColumnParam)
			IF @iCount = 8 SET @fCnt = convert(bit, @sColumnParam)
			IF @iCount = 9 SET @fTot = convert(bit, @sColumnParam)
			IF @iCount = 10 SET @fHidden = convert(bit, @sColumnParam)
			IF @iCount = 11 SET @fGroupWithNext = convert(bit, @sColumnParam)
			IF @iCount = 12 SET @iSortOrderSequence = convert(integer, @sColumnParam)
			IF @iCount = 13 SET @sSortOrder = @sColumnParam
			IF @iCount = 14 SET @fBOC = convert(bit, @sColumnParam)
			IF @iCount = 15 SET @fPOC = convert(bit, @sColumnParam)
			IF @iCount = 16 SET @fVOC = convert(bit, @sColumnParam)
			IF @iCount = 17 SET @fSRV = convert(bit, @sColumnParam)
			IF @iCount = 18 SET @fRepetition = convert(integer, @sColumnParam)

			SET @iCount = @iCount + 1
		END

		INSERT ASRSysCustomReportsDetails 
			(customReportID, sequence, type, colExprID, heading, size, dp, isNumeric, avge, 
			cnt, tot, hidden, GroupWithNextColumn, 	sortOrderSequence, sortOrder, boc, poc, voc, srv, repetition) 
		VALUES (@piID, @iSequence, @sType, @iColExprID, @sHeading, @iSize, @iDP, @fIsNumeric, @fAvge, 
			@fCnt, @fTot, @fHidden, @fGroupWithNext, @iSortOrderSequence, @sSortOrder, @fBOC, @fPOC, @fVOC, @fSRV, @fRepetition)

	END

	/* Create the table records. */

	IF (@fIsNew = 0)
	BEGIN
		/* Delete existing report child tables. */
		DELETE FROM ASRSysCustomReportsChildDetails 
		WHERE customReportID = @piID
	END

	SET @sTemp = @psChildString

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sChildDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)
		END
		ELSE
		BEGIN
			SET @sChildDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the column definition parameters. */
		SET @iChildTableID = 0
		SET @iChildFilterID = 0
		SET @iChildOrderID = 0
		SET @iChildMaxRecords = 0
		SET @iCount = 0
		
		WHILE LEN(@sChildDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sChildDefn) > 0
			BEGIN
				SET @sChildParam = LEFT(@sChildDefn, CHARINDEX('||', @sChildDefn) - 1)
				SET @sChildDefn = RIGHT(@sChildDefn, LEN(@sChildDefn) - CHARINDEX('||', @sChildDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sChildParam = @sChildDefn
				SET @sChildDefn = ''
			END

			IF @iCount = 0 SET @iChildTableID = convert(integer, @sChildParam)
			IF @iCount = 1 SET @iChildFilterID = convert(integer, @sChildParam)
			IF @iCount = 2 SET @iChildOrderID = convert(integer, @sChildParam)
			IF @iCount = 3 SET @iChildMaxRecords = convert(integer, @sChildParam)
	
			SET @iCount = @iCount + 1
		END

		INSERT ASRSysCustomReportsChildDetails 
			(customReportID, childtable, childfilter, childorder, childmaxrecords) 
		VALUES (@piID, @iChildTableID, @iChildFilterID, @iChildOrderID, @iChildMaxRecords)

	END

	DELETE FROM ASRSysCustomReportAccess WHERE ID = @piID
	INSERT INTO ASRSysCustomReportAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)

	SET @sTemp = @psAccess
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysCustomReportAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCustomReportAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (2, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 2

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (2, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 2
		END
	END

	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''

		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntSaveMailMerge]...';


GO
/****** Object:  StoredProcedure [dbo].[sp_ASRIntSaveMailMerge]    Script Date: 04/08/2010 13:42:14 ******/
ALTER PROCEDURE [dbo].[sp_ASRIntSaveMailMerge] (
	@psName				varchar(255),
	@psDescription		varchar(MAX),
	@piTableID			integer,
	@piSelection		integer,
	@piPicklistID		integer,
	@piFilterID			integer,
	@piOutputFormat			integer,
	@pfOutputSave			bit,
	@psOutputFilename		varchar(MAX),
	@piEmailAddrID		integer,
	@psEmailSubject		varchar(MAX),
	@psTemplateFileName	varchar(MAX),
	@pfOutputScreen			bit,
	@psUserName			varchar(255),
	@pfEmailAsAttachment	bit,
	@psEmailAttachmentName	varchar(MAX),
	@pfSuppressBlanks		bit,
	@pfPauseBeforeMerge		bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName	varchar(255),
	@piDocumentMapID			integer,
	@pfManualDocManHeader		bit,	
	@psAccess			varchar(MAX),
	@psJobsToHide		varchar(MAX),
	@psJobsToHideGroups	varchar(MAX),
	@psColumns			varchar(MAX),
	@psColumns2			varchar(MAX),
	@piID				integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sTemp			varchar(MAX),
			@sColumnDefn	varchar(MAX),
			@sColumnParam	varchar(MAX),
			@iSequence		integer,
			@sType			varchar(MAX),
			@iColExprID		integer,
			@sHeading		varchar(MAX),
			@iSize			integer,
			@iDP			integer,
			@fIsNumeric		bit,
			@fAvge			bit,
			@fCnt			bit,
			@fTot			bit,
			@iSortOrderSequence	integer,
			@sSortOrder		varchar(MAX),
			@fBOC			bit,
			@fPOC			bit,
			@fVOC			bit,
			@fSRV			bit,
			@iCount			integer,
			@fIsNew			bit,
			@sGroup			varchar(255),
			@sAccess		varchar(MAX),
			@sSQL			nvarchar(MAX);
	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')
	SET @fIsNew = 0
	/* Insert/update the report header. */
	IF @piID = 0
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysMailMergeName (
			Name, 
			Description, 
			TableID, 
			Selection, 
			PicklistID, 
			FilterID, 
			OutputFormat, 
			OutputSave, 
			OutputFilename, 
			EmailAddrID, 
			EmailSubject, 
			TemplateFileName, 
			OutputScreen, 
			UserName, 
			EMailAsAttachment,
			EmailAttachmentName, 
			SuppressBlanks, 
			PauseBeforeMerge, 
			OutputPrinter,
			OutputPrinterName,
			DocumentMapID,
			ManualDocManHeader,			
			IsLabel, 
			LabelTypeID, 
			PromptStart) 
		VALUES (
			@psName,
			@psDescription,
			@piTableID,
			@piSelection,
			@piPicklistID,
			@piFilterID,
			@piOutputFormat,
			@pfOutputSave,
			@psOutputFilename,
			@piEmailAddrID,
			@psEmailSubject,
			@psTemplateFileName,
			@pfOutputScreen,
			@psUserName,
			@pfEmailAsAttachment,
			@psEmailAttachmentName,
			@pfSuppressBlanks,
			@pfPauseBeforeMerge,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@piDocumentMapID,
			@pfManualDocManHeader,
			0, 
			0, 
			0)
		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(MailMergeID) FROM ASRSysMailMergeName
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysMailMergeName SET 
			Name = @psName,
			Description = @psDescription,
			TableID = @piTableID,
			Selection = @piSelection,
			PicklistID = @piPicklistID,
			FilterID = @piFilterID,
			OutputFormat = @piOutputFormat,
			OutputSave = @pfOutputSave,
			OutputFilename = @psOutputFilename,
			EmailAddrID = @piEmailAddrID,
			EmailSubject = @psEmailSubject,
			TemplateFileName = @psTemplateFileName,
			OutputScreen = @pfOutputScreen,
			EMailAsAttachment = @pfEmailAsAttachment,
			EmailAttachmentName = @psEmailAttachmentName,
			SuppressBlanks = @pfSuppressBlanks,
			PauseBeforeMerge = @pfPauseBeforeMerge,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			DocumentMapID = @piDocumentMapID,
			ManualDocManHeader = @pfManualDocManHeader,
			IsLabel = 0,
			LabelTypeID = 0,
			PromptStart = 0
		WHERE MailMergeID = @piID
		/* Delete existing report details. */
		DELETE FROM ASRSysMailMergeColumns
		WHERE MailMergeID = @piID
	END
	/* Create the details records. */
	SET @sTemp = @psColumns
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sColumnDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)
			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psColumns2, 1000)
				IF len(@psColumns2) > 1000
				BEGIN
					SET @psColumns2 = SUBSTRING(@psColumns2, 1001, len(@psColumns2) - 1000)
				END
				ELSE
				BEGIN
					SET @psColumns2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sColumnDefn = @sTemp
			SET @sTemp = ''
		END
		/* Rip out the column definition parameters. */
		SET @iSequence = 0
		SET @sType = ''
		SET @iColExprID = 0
		SET @iSize = 0
		SET @iDP = 0
		SET @fIsNumeric = 0
		SET @iSortOrderSequence = 0
		SET @sSortOrder = ''
		SET @fBOC = 0
		SET @fPOC = 0
		SET @fVOC = 0
		SET @fSRV = 0
		SET @iCount = 0
		WHILE LEN(@sColumnDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sColumnDefn) > 0
			BEGIN
				SET @sColumnParam = LEFT(@sColumnDefn, CHARINDEX('||', @sColumnDefn) - 1)
				SET @sColumnDefn = RIGHT(@sColumnDefn, LEN(@sColumnDefn) - CHARINDEX('||', @sColumnDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sColumnParam = @sColumnDefn
				SET @sColumnDefn = ''
			END
			IF @iCount = 0 SET @iSequence = convert(integer, @sColumnParam)
			IF @iCount = 1 SET @sType = @sColumnParam
			IF @iCount = 2 SET @iColExprID = convert(integer, @sColumnParam)
			IF @iCount = 3 SET @iSize = convert(integer, @sColumnParam)
			IF @iCount = 4 SET @iDP = convert(integer, @sColumnParam)
			IF @iCount = 5 SET @fIsNumeric = convert(bit, @sColumnParam)
			IF @iCount = 6 SET @iSortOrderSequence = convert(integer, @sColumnParam)
			IF @iCount = 7 SET @sSortOrder = @sColumnParam
			SET @iCount = @iCount + 1
		END
		INSERT ASRSysMailMergeColumns (MailMergeID,Type, ColumnID, SortOrderSequence, SortOrder, Size, Decimals)
		VALUES (@piID, @sType, @iColExprID, @iSortOrderSequence, @sSortOrder, @iSize, @iDP)
	END
	DELETE FROM ASRSysMailMergeAccess WHERE ID = @piID
	INSERT INTO ASRSysMailMergeAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)
	SET @sTemp = @psAccess
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysMailMergeAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysMailMergeAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END
	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (9, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 9
		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (9, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 9
		END
	END
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''
		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL
		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')

						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntSaveSetting]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntSaveSetting] (
	@psSection		varchar(255),
	@psKey			varchar(255),
	@pfUserSetting	bit,
	@psValue		varchar(MAX)	
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Save the given user or system setting. */
	IF @pfUserSetting = 1
	BEGIN
		DELETE FROM [dbo].[ASRSysUserSettings]
		WHERE section = @psSection
			AND settingKey = @psKey
			AND userName = SYSTEM_USER;

		INSERT INTO [dbo].[ASRSysUserSettings]
			(section, settingKey, settingValue, userName)
		VALUES (@psSection, @psKey, @psValue, SYSTEM_USER);
	END
	ELSE
	BEGIN
		DELETE FROM [dbo].[ASRSysSystemSettings]
		WHERE section = @psSection
			AND settingKey = @psKey;

		INSERT INTO [dbo].[ASRSysSystemSettings]
			(section, settingKey, settingValue)
		VALUES (@psSection, @psKey, @psValue);
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidatePicklist]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidatePicklist] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@psAccess 			varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								2 = definition changed by someone else, overwrite ? */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp			integer,
			@sAccess			varchar(MAX),
			@sOwner				varchar(255),
			@iCount				integer,
			@sCurrentUser		sysname;

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysPickListName]
		WHERE picklistID = @piUtilID;

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The picklist has been deleted by another user.<BR>Save as a new definition ?';
			SET @piErrorCode = 1;
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sAccess = access, 
				@sOwner = userName
			FROM [dbo].[ASRSysPickListName]
			WHERE picklistID = @piUtilID;

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user and is now Read Only.<BR>Save as a new definition ?';
					SET @piErrorCode = 1;
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user.<BR>Would you like to overwrite this definition ?';
					SET @piErrorCode = 2;
				END
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIsSysSecMgr]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIsSysSecMgr] (
	@psGroupName		sysname,
	@pfSysSecMgr		bit	OUTPUT
)
AS
BEGIN
	DECLARE @iUserGroupID integer;

	/* Get the current user's group ID. */
	SELECT @iUserGroupID = sysusers.gid
	FROM sysusers
	WHERE sysusers.name = @psGroupName;

	SELECT @pfSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
END
GO
PRINT N'Altering [dbo].[sp_ASRRemoveLock]...';


GO
ALTER PROCEDURE sp_ASRRemoveLock
AS
BEGIN
	IF EXISTS(SELECT * FROM sysobjects WHERE name = 'tmpLock') DELETE FROM tmpLock	
	DROP TABLE tmpLock
END
GO
PRINT N'Altering [dbo].[sp_ASRUniqueObjectName]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRUniqueObjectName](
		  @psUniqueObjectName sysname OUTPUT
		, @Prefix sysname
		, @Type int)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @NewObj 		as sysname
		, @Count 			as integer
		, @sUserName		as sysname
		, @sCommandString	nvarchar(MAX)	
 		, @sParamDefinition	nvarchar(500);

	SET @sUserName = SYSTEM_USER;
	SET @Count = 1;
	SET @NewObj = @Prefix + CONVERT(varchar(100),@Count);

	WHILE (EXISTS (SELECT * FROM sysobjects WHERE id = object_id(@NewObj) AND sysstat & 0xf = @Type))
		OR (EXISTS (SELECT * FROM ASRSysSQLObjects WHERE Name = @NewObj AND Type = @Type))
		BEGIN
			SET @Count = @Count + 1;
			SET @NewObj = @Prefix + CONVERT(varchar(10),@Count);
		END

	INSERT INTO [dbo].[ASRSysSQLObjects] ([Name], [Type], [DateCreated], [Owner])
		VALUES (@NewObj, @Type, GETDATE(), @sUserName);

	SET @sCommandString = 'SELECT @psUniqueObjectName = ''' + @NewObj + '''';
	SET @sParamDefinition = N'@psUniqueObjectName sysname output';
	EXECUTE sp_executesql @sCommandString, @sParamDefinition, @psUniqueObjectName output;

END
GO
PRINT N'Creating [dbo].[spadmin_commitresetpassword]...';


GO
-- Generated by the server assembly
CREATE PROCEDURE [dbo].[spadmin_commitresetpassword]
	@code nvarchar(4000),
	@NewPassword	nvarchar(4000),
	@ErrorMessage nvarchar(4000)
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[spadmin_resetpassword]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spadmin_resetpassword]
		@psWebsiteURL VARCHAR(255),
		@psUserName VARCHAR(255),
		@psEncryptedLink VARCHAR(MAX),
		@psMessage VARCHAR(MAX) OUTPUT
AS
	RETURN 0;
GO
PRINT N'Altering [dbo].[spASRAccordPopulateTransactionData]...';


GO
ALTER PROCEDURE [dbo].[spASRAccordPopulateTransactionData] (
		@piTransactionID int,
		@piColumnID int,
		@psOldValue varchar(255),
		@psNewValue varchar(255)
		)
	AS
	BEGIN	
		DECLARE @iRecCount int

		SET NOCOUNT ON

		SELECT @iRecCount = COUNT(FieldID) FROM ASRSysAccordTransactionData WHERE @piTransactionID = TransactionID and FieldID = @piColumnID

		-- Insert a record into the Accord Transaction table.	
		IF @iRecCount = 0
			INSERT INTO ASRSysAccordTransactionData
				([TransactionID],[FieldID], [OldData], [NewData])
			VALUES 
				(@piTransactionID,@piColumnID,@psOldValue,@psNewValue)
		ELSE
			UPDATE ASRSysAccordTransactionData SET [OldData] = @psOldValue
				WHERE @piTransactionID = TransactionID and FieldID = @piColumnID
	END
GO
PRINT N'Altering [dbo].[spASRAccordPurgeTemp]...';


GO
ALTER PROCEDURE spASRAccordPurgeTemp (
			@piTriggerLevel int)
	AS
	BEGIN	
	
		-- This stored procedure is called from every table trigger and resets the Accord transaction id whenever the trigger level is 1
		IF @piTriggerLevel = 1 DELETE FROM ASRSysAccordTransactionProcessInfo WHERE spid = @@SPID
	END
GO
PRINT N'Altering [dbo].[spASRAccordVoidPreviousTransactions]...';


GO
ALTER PROCEDURE [dbo].[spASRAccordVoidPreviousTransactions] (
	@piTransferType int ,
	@piHRProRecordID int)
AS
BEGIN	

	SET NOCOUNT ON;

	UPDATE ASRSysAccordTransactions SET [Status] = 31
		WHERE [HRProRecordID] = @piHRProRecordID AND [TransferType] = @piTransferType;

END
GO
PRINT N'Altering [dbo].[spASRCancelPendingPrecedingWorkflowElements]...';


GO
ALTER PROCEDURE dbo.spASRCancelPendingPrecedingWorkflowElements
			(
				@piInstanceID			integer,
				@piElementID			integer
			)
			AS
			BEGIN
				/* Cancel (ie. set status to 0 for all workflow pending (ie. status 1 or 2) elements that precede the given element.
				This ignores connection elements.
				NB. This does work for elements with multiple inbound flows. */
				UPDATE ASRSysWorkflowInstanceSteps
				SET status = 0
				WHERE instanceID = @piInstanceID
					AND elementID IN (SELECT ID FROM [dbo].[udfASRGetAllPrecedingWorkflowElements](@piElementID))
					AND status IN (1, 2, 7) -- 1 = pending engine action, 2 = pending user action, 7 = pending user completion
			END
GO
PRINT N'Altering [dbo].[spASRDefragIndexes]...';


GO
ALTER PROCEDURE [dbo].[spASRDefragIndexes]
	(@maxfrag DECIMAL)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @tablename		varchar(128),
			@sSQL			nvarchar(MAX),
			@objectid		int,
			@objectowner	varchar(255),
			@indexid		int,
			@frag			decimal,
			@indexname		char(255),
			@dbname			sysname,
			@tableid		int,
			@tableidchar	varchar(255);

	-- Checking fragmentation
	DECLARE tables CURSOR FOR
		SELECT sc.[Name]  + '.' + so.[Name]
		FROM sys.sysobjects so
			INNER JOIN sys.sysindexes si ON so.id = si.id
			INNER JOIN sys.schemas sc ON so.uid  = sc.schema_id
		WHERE so.type ='U' AND si.indid < 2 AND si.rows > 0
		ORDER BY sc.name, so.[Name];

	-- Create the temporary table to hold fragmentation information
	DECLARE @fraglist TABLE (
		ObjectName CHAR (255),
		ObjectId INT,
		IndexName CHAR (255),
		IndexId INT,
		Lvl INT,
		CountPages INT,
		CountRows INT,
		MinRecSize INT,
		MaxRecSize INT,
		AvgRecSize INT,
		ForRecCount INT,
		Extents INT,
		ExtentSwitches INT,
		AvgFreeBytes INT,
		AvgPageDensity INT,
		ScanDensity DECIMAL,
		BestCount INT,
		ActualCount INT,
		LogicalFrag DECIMAL,
		ExtentFrag DECIMAL);

	-- Open the cursor
	OPEN tables;

	-- Loop through all the tables in the database running dbcc showcontig on each one
	FETCH NEXT FROM tables INTO @tableidchar;

	WHILE @@FETCH_STATUS = 0
	BEGIN
	
		-- Do the showcontig of all indexes of the table
		INSERT INTO @fraglist 
			EXEC ('DBCC SHOWCONTIG (''' + @tableidchar + ''') WITH FAST, TABLERESULTS, ALL_INDEXES, NO_INFOMSGS');

		FETCH NEXT FROM tables INTO @tableidchar;
	END

	-- Close and deallocate the cursor
	CLOSE tables;
	DEALLOCATE tables;

	-- Begin Stage 2: (defrag) declare cursor for list of indexes to be defragged
	DECLARE indexes CURSOR FOR
	SELECT ObjectName, ObjectOwner = schema_name(so.uid), ObjectId, IndexName, ScanDensity
	FROM @fraglist f
	JOIN sysobjects so ON f.ObjectId=so.id
	WHERE ScanDensity <= @maxfrag
		AND INDEXPROPERTY (ObjectId, IndexName, 'IndexDepth') > 0;

	-- Open the cursor
	OPEN indexes

	-- Loop through the indexes
	FETCH NEXT FROM indexes	INTO @tablename, @objectowner, @objectid, @indexname, @frag;

	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET QUOTED_IDENTIFIER ON;

		SET @sSQL = 'ALTER INDEX [' +  RTRIM(@indexname) + '] ON ' + RTRIM(@objectowner) + '.' + RTRIM(@tablename) + ' REBUILD;';

		EXECUTE sp_executeSQL @sSQL;

		SET QUOTED_IDENTIFIER OFF;

		FETCH NEXT FROM indexes INTO @tablename, @objectowner, @objectid, @indexname, @frag;
	END

	-- Close and deallocate the cursor
	CLOSE indexes;
	DEALLOCATE indexes;

END
GO
PRINT N'Altering [dbo].[spASRDeleteInvalidLogins]...';


GO
ALTER PROCEDURE [dbo].[spASRDeleteInvalidLogins]
	(@pstrDomainName	varchar(100))
AS
BEGIN

	DECLARE @cursLogins cursor,
			@loginName	nvarchar(255);

	-- Are we privileged enough to run this script
	IF IS_SRVROLEMEMBER('securityadmin') = 0 and IS_SRVROLEMEMBER('sysadmin') = 0
	BEGIN
		RETURN 0;
	END

	-- Lets get the invalid accounts into a swish little cursor
	SET @cursLogins = CURSOR LOCAL FAST_FORWARD FOR
	SELECT loginName from master.dbo.syslogins
		WHERE isntname = 1
		AND loginname like @pstrDomainName + '\%'
		AND ((sid <> SUSER_SID(loginname) and SUSER_SID(loginname) is not null)	OR SUSER_SID(loginname) is null);

	-- Now lets get rid of the invalid accounts
	OPEN @cursLogins;
	FETCH NEXT FROM @cursLogins INTO @LoginName;
	WHILE (@@fetch_status = 0)
	BEGIN
		EXEC sp_revokelogin @LoginName;
		FETCH NEXT FROM @cursLogins INTO @LoginName;
	END

	-- Tidy Up
	CLOSE @cursLogins;
	DEALLOCATE @cursLogins;

	RETURN 0;

END
GO
PRINT N'Altering [dbo].[spASRDropTempObjects]...';


GO
ALTER PROCEDURE [dbo].[spASRDropTempObjects]
AS
BEGIN

	DECLARE	@sObjectName varchar(255),
			@sUsername varchar(255),
			@sXType varchar(50);
				
	DECLARE tempObjects CURSOR LOCAL FAST_FORWARD FOR 
	SELECT [dbo].[sysobjects].[name], [sys].[schemas].[name], [dbo].[sysobjects].[xtype]
	FROM [dbo].[sysobjects] 
			INNER JOIN [sys].[schemas]
			ON [dbo].[sysobjects].[uid] = [sys].[schemas].[schema_id]
	WHERE LOWER([sys].[schemas].[name]) != 'dbo' AND LOWER([sys].[schemas].[name]) != 'messagebus'
			AND (OBJECTPROPERTY(id, N'IsUserTable') = 1
				OR OBJECTPROPERTY(id, N'IsProcedure') = 1
				OR OBJECTPROPERTY(id, N'IsInlineFunction') = 1
				OR OBJECTPROPERTY(id, N'IsScalarFunction') = 1
				OR OBJECTPROPERTY(id, N'IsTableFunction') = 1);

	OPEN tempObjects;
	FETCH NEXT FROM tempObjects INTO @sObjectName, @sUsername, @sXType;
	WHILE (@@fetch_status <> -1)
	BEGIN		
		IF UPPER(@sXType) = 'U'
			-- user table
			BEGIN
				EXEC ('DROP TABLE [' + @sUsername + '].[' + @sObjectName + ']');
			END

		IF UPPER(@sXType) = 'P'
			-- procedure
			BEGIN
				EXEC ('DROP PROCEDURE [' + @sUsername + '].[' + @sObjectName + ']');
			END

		IF UPPER(@sXType) = 'TF'
			-- UDF
			BEGIN
				EXEC ('DROP FUNCTION [' + @sUsername + '].[' + @sObjectName + ']');
			END

		IF UPPER(@sXType) = 'FN'
			-- UDF
			BEGIN
				EXEC ('DROP FUNCTION [' + @sUsername + '].[' + @sObjectName + ']');
			END
		
		FETCH NEXT FROM tempObjects INTO @sObjectName, @sUsername, @sXType;
		
	END
	CLOSE tempObjects;
	DEALLOCATE tempObjects;
	
	EXEC ('DELETE FROM [dbo].[ASRSysSQLObjects]');


	-- Clear out any temporary tables that may have got left behind from the createunique function
	DECLARE tempObjects CURSOR LOCAL FAST_FORWARD FOR 
	SELECT [dbo].[sysobjects].[name]
	FROM [dbo].[sysobjects] 
	INNER JOIN [dbo].[sysusers]	ON [dbo].[sysobjects].[uid] = [dbo].[sysusers].[uid]
	LEFT JOIN ASRSysTables ON sysobjects.[name] = ASRSysTables.TableName
	WHERE LOWER([dbo].[sysusers].[name]) = 'dbo'
		AND OBJECTPROPERTY(sysobjects.id, N'IsUserTable') = 1
		AND ASRSysTables.TableName IS NULL
		AND [dbo].[sysobjects].[name] LIKE 'tmp%';

	OPEN tempObjects;
	FETCH NEXT FROM tempObjects INTO @sObjectName;
	WHILE (@@fetch_status <> -1)
	BEGIN		
		EXEC ('DROP TABLE [dbo].[' + @sObjectName + ']');
		FETCH NEXT FROM tempObjects INTO @sObjectName;
	END

	CLOSE tempObjects;
	DEALLOCATE tempObjects;

END
GO
PRINT N'Altering [dbo].[spASRGetCurrentUsers]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spASRGetCurrentUsers]
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[spASRGetDomainPolicy]...';


GO
ALTER PROCEDURE [dbo].[spASRGetDomainPolicy]
	(@LockoutDuration int OUTPUT,
	 @lockoutThreshold int OUTPUT,
	 @lockoutObservationWindow int OUTPUT,
	 @maxPwdAge int OUTPUT, 
	 @minPwdAge int OUTPUT,
	 @minPwdLength int OUTPUT, 
	 @pwdHistoryLength int OUTPUT, 
	 @pwdProperties int OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	-- Initialise the variables
	SET @LockoutDuration = 0;
	SET @lockoutThreshold  = 0;
	SET @lockoutObservationWindow  = 0;
	SET @maxPwdAge  = 0;
	SET @minPwdAge  = 0;
	SET @minPwdLength  = 0;
	SET @pwdHistoryLength  = 0;
	SET @pwdProperties  = 0;

	EXEC sp_executesql N'EXEC spASRGetDomainPolicyFromAssembly
			@lockoutDuration OUTPUT, @lockoutThreshold OUTPUT,
			@lockoutObservationWindow OUTPUT, @maxPwdAge OUTPUT,
			@minPwdAge OUTPUT, @minPwdLength OUTPUT,
			@pwdHistoryLength OUTPUT, @pwdProperties OUTPUT'
		, N'@lockoutDuration int OUT, @lockoutThreshold int OUT,
			@lockoutObservationWindow int OUT, @maxPwdAge int OUT,
			@minPwdAge int OUT,	@minPwdLength int OUT,
			@pwdHistoryLength int OUT, @pwdProperties int OUT'
		, @LockoutDuration OUT, @lockoutThreshold OUT
		, @lockoutObservationWindow OUT, @maxPwdAge OUT
		, @minPwdAge OUT, @minPwdLength OUT
		, @pwdHistoryLength OUT, @pwdProperties OUT;

END
GO
PRINT N'Creating [dbo].[spASRGetDomainPolicyFromAssembly]...';


GO
-- Generated by the server assembly
CREATE PROCEDURE [dbo].[spASRGetDomainPolicyFromAssembly]
	@lockoutDuration [bigint] OUTPUT,
	@lockoutThreshold [bigint] OUTPUT,
	@lockoutObservationWindow [bigint] OUTPUT,
	@maxPwdAge [bigint] OUTPUT,
	@minPwdAge [bigint] OUTPUT,
	@minPwdLength [bigint] OUTPUT,
	@pwdHistoryLength [bigint] OUTPUT,
	@pwdProperties [bigint] OUTPUT
	AS
		RETURN 0
GO
PRINT N'Creating [dbo].[spASRGroupsUserIsMemberOf]...';


GO
-- Generated by the server assembly
CREATE PROCEDURE [dbo].[spASRGroupsUserIsMemberOf]
	@user [nvarchar](4000)
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[spASRIntCheckSPExists]...';


GO
ALTER PROCEDURE [dbo].[spASRIntCheckSPExists]
(
	@psPrefix			varchar(255),
	@plngTableID		integer,
	@pfExists			bit		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSPName	varchar(MAX),
			@iCount		integer;

	SET @pfExists = 0;
	SET @sSPName = @psPrefix + convert(varchar(255), @plngTableID);

	IF NOT @sSPName IS null
	BEGIN
		SELECT @iCount = COUNT([Name])
		FROM sysobjects
		WHERE type = 'P'
			AND name = @sSPName;

		IF @iCount > 0 
		BEGIN
			SET @pfExists = 1;
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRIntCurrentAccessForRole]...';


GO
ALTER PROCEDURE [dbo].[spASRIntCurrentAccessForRole] (
	@psRoleName		sysname,
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(2)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fEnabled			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @psRoleName + ''''

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END
GO
PRINT N'Altering [dbo].[spASRIntGetActualLogin]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetActualLogin]
(
	@psActualLogin		nvarchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound	integer;

	/* Is this user logged in under a specific login, or as part of a Windows Group login */
	SELECT @iFound = Count(*) FROM sysusers WHERE name = SYSTEM_USER;
	IF (@iFound > 0)
		SET @psActualLogin = SYSTEM_USER;
	ELSE
		SELECT TOP 1 @psActualLogin = name FROM sysusers
			WHERE is_member(Name) & IsNTGroup = 1;

END
GO
PRINT N'Altering [dbo].[spASRIntGetActualUserDetailsForLogin]...';


GO
ALTER Procedure spASRIntGetActualUserDetailsForLogin
(
		@psLogin sysname,
		@psUserName sysname OUTPUT,
		@psUserGroup sysname OUTPUT,
		@piUserGroupID integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound		int

	SELECT @iFound = COUNT(*) 
	FROM sysusers usu 
	LEFT OUTER JOIN	(sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = @psLogin
		AND CASE
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
		END NOT LIKE 'ASRSys%'

	IF (@iFound > 0)
	BEGIN
		SELECT	@psUserName = usu.name,
			@psUserGroup = CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND lo.loginname = @psLogin
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END NOT LIKE 'ASRSys%'
	END
	ELSE
	BEGIN
		SELECT @psUserName = usu.name, 
			@psUserGroup = CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND is_member(lo.loginname) = 1
			AND CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END NOT LIKE 'ASRSys%'
	END
END
GO
PRINT N'Altering [dbo].[spASRIntGetAvailableFilters]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetAvailableFilters] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO
PRINT N'Altering [dbo].[spASRIntGetAvailableFiltersInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetAvailableFiltersInfo] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name, 
		username, 
		access 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO
PRINT N'Altering [dbo].[spASRIntGetAvailableOrdersInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetAvailableOrdersInfo] (
	@plngTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT orderid AS [ID], 
		name, 
		'' AS username, 
		'' AS access 
	FROM ASRSysOrders 
	WHERE tableid = @plngTableID  
		AND type = 1 
		ORDER BY [name];
END
GO
PRINT N'Altering [dbo].[spASRIntGetAvailablePicklists]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetAvailablePicklists] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT picklistid AS [ID], 
		name 
	FROM [dbo].[ASRSysPicklistName]
	WHERE tableid = @plngTableID 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO
PRINT N'Altering [dbo].[spASRIntGetCalendarColours]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetCalendarColours]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ASRSysColours.ColOrder, 
		ASRSysColours.ColValue,
		ASRSysColours.ColDesc, 
		ASRSysColours.WordColourIndex,
		ASRSysColours.CalendarLegendColour
	FROM ASRSysColours
	WHERE (ASRSysColours.CalendarLegendColour = 1)
		AND (ASRSysColours.ColValue NOT IN (13434879))
	ORDER BY ASRSysColours.ColOrder;
END
GO
PRINT N'Altering [dbo].[spASRIntGetCalendarReportColumns]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetCalendarReportColumns]
	(
	@piBaseTableID 		integer,
	@piEventTableID		integer
	)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the columns for the given table IDs.*/
	SELECT ASRSysColumns.ColumnID, ASRSysColumns.TableID, ASRSysColumns.ColumnName, ASRSysColumns.DataType, 
           ASRSysColumns.ColumnType, ASRSysColumns.Size, ASRSystables.TableName,
           ASRSysColumns.LookupTableID, ASRSysColumns.LookupColumnID
    FROM ASRSysColumns 
		INNER JOIN ASRSystables 
		ON ASRSysColumns.TableID = ASRSystables.TableID
    WHERE (ASRSysColumns.TableID = @piBaseTableID
			OR ASRSysColumns.TableID = @piEventTableID)
		AND ASRSysColumns.columnType <> 3
		AND ASRSysColumns.columnType <> 4
		AND ASRSysColumns.dataType <> -3
		AND ASRSysColumns.dataType <> -4
	ORDER BY ASRSystables.TableName, ASRSysColumns.ColumnName;

END
GO
PRINT N'Altering [dbo].[spASRIntGetCalendarReportOrder]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetCalendarReportOrder]
	(
	@piCalendarReportID 	integer, 
	@psErrorMsg				varchar(MAX)	OUTPUT
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount	integer;

	SET @psErrorMsg = '';
	
	/* Check the calendar report exists. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCalendarReports]
	WHERE ID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report has been deleted by another user.';
		RETURN;
	END

	/* Check the calendar report has sort order details. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCalendarReportOrder]
	WHERE calendarReportID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report contains no sort order details.';
		RETURN;
	END
	
	SELECT 
		CONVERT(varchar,ASRSysCalendarReportOrder.ColumnID) + char(9) +
		(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ASRSysCalendarReportOrder.TableID) + 
		'.' + 
		(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportOrder.ColumnID) + char(9) +
		OrderType AS [OrderString]
	FROM [dbo].[ASRSysCalendarReportOrder]
	WHERE calendarReportID = @piCalendarReportID
	ORDER BY OrderSequence;
END
GO
PRINT N'Altering [dbo].[spASRIntGetColumnsFromTablesAndViews]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetColumnsFromTablesAndViews]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT UPPER(c.columnName) AS [ColumnName], c.columnType, c.dataType
		, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
		, UPPER(t.tableName) AS tableViewName
	FROM dbo.ASRSysColumns c
	INNER JOIN ASRSysTables t ON c.tableID = t.tableID
	UNION 
	SELECT UPPER(c.columnName) AS [ColumnName], c.columnType, c.dataType
		, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
		, UPPER(v.viewName) AS tableViewName 
	FROM dbo.ASRSysColumns c
	INNER JOIN ASRSysViews v ON c.tableID = v.viewTableID 
	LEFT OUTER JOIN ASRSysViewColumns vc ON (v.viewID = vc.viewID 
			AND c.columnID = vc.columnID)
	WHERE vc.inView = 1 OR c.columnType = 3 
	ORDER BY tableViewName;

END
GO
PRINT N'Altering [dbo].[spASRIntGetDefaultOrder]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetDefaultOrder] (
	@piTableID	integer,
	@piOrderID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piOrderID = defaultOrderID
	FROM ASRSysTables
	WHERE tableID = @piTableID;
END
GO
PRINT N'Altering [dbo].[spASRIntGetEmailGroupAddresses]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEmailGroupAddresses]
	(@EmailGroupID int)
AS
BEGIN

	SET NOCOUNT ON;

	select Fixed from ASRSysEmailAddress
	where EmailID in
	(select EmailDefID from ASRSysEmailGroupItems where EmailGroupID = @EmailGroupID)
	order by [Name];

END
GO
PRINT N'Altering [dbo].[spASRIntGetEmailGroups]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEmailGroups]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT emailGroupID, 
		name, 
		userName, 
		access 
	FROM ASRSysEmailGroupName 
	ORDER BY [name];
END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogBatchDetails]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails] (
	@piBatchRunID 	integer,
	@piEventID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sExecString		nvarchar(MAX),
			@sSelectString 		varchar(MAX),
			@sFromString		varchar(MAX),
			@sWhereString		varchar(MAX),
			@sOrderString 		varchar(MAX);

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 
		 ID, 
		 DateTime,
		 EndTime,
		 IsNull(Duration,-1) AS Duration,
		 Username,
		 CASE Type 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
		 END AS Type,
		 Name,
		 CASE Mode 
			WHEN 1 THEN ''Batch''
			WHEN 0 THEN ''Manual''
			ELSE ''Unknown''
		 END AS Mode, 
		 CASE Status 
				WHEN 0 THEN ''Pending''
		   	WHEN 1 THEN ''Cancelled'' 
				WHEN 2 THEN ''Failed'' 
				WHEN 3 THEN ''Successful'' 
				WHEN 4 THEN ''Skipped'' 
				WHEN 5 THEN ''Error''
				ELSE ''Unknown'' 
		 END AS Status,
		 IsNull(BatchName,'''') AS BatchName,
		 IsNull(convert(varchar,SuccessCount), ''N/A'') AS SuccessCount,
		 IsNull(convert(varchar,FailCount), ''N/A'') AS FailCount,
		 IsNull(convert(varchar,BatchJobID), ''N/A'') AS BatchJobID,
		 IsNull(convert(varchar,BatchRunID), ''N/A'') AS BatchRunID';

	SET @sFromString = ' FROM ASRSysEventLog ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE BatchRunID = ' + convert(varchar, @piBatchRunID);
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE ID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY DateTime ASC ';

	SET @sExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;

	-- Run generated statement
	EXEC sp_executeSQL @sExecString;
	
END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogDetails]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEventLogDetails] (
	@piBatchRunID	integer,
	@piEventID		integer,
	@piExists		integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sSelectString			varchar(MAX),
			@sFromString			varchar(255),
			@sWhereString			varchar(MAX),
			@sOrderString 			varchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer;

	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(*) FROM ASRSysEventLog WHERE ID = ' + convert(varchar,@piEventID);

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piExists = @iCount;
	/****************************************************************************************************************************************/

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT [ID], [EventLogID], IsNull([Notes],'''') AS ''Notes'' ';

	SET @sFromString = ' FROM ASRSysEventLogDetails ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE ASRSysEventLogDetails.EventLogID IN (SELECT ID FROM ASRSysEventLog WHERE BatchRunID = ' + convert(varchar, @piBatchRunID) + ')';
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE ASRSysEventLogDetails.EventLogID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY ASRSysEventLogDetails.[ID] ';
	
	SET @sTempExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;
	EXEC sp_executesql @sTempExecString;
	
END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogEmailInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo] (
	@psSelectedIDs	varchar(MAX),
	@psSubject		varchar(MAX) OUTPUT,
	@psOrderColumn	varchar(MAX),
	@psOrderOrder	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSelectString 	nvarchar(MAX),
			@sOrderSQL		varchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	SELECT @psSubject = IsNull(SettingValue,'<<Unknown Customer>>') + ' - Event Log' 
	FROM ASRSysSystemSettings 
	WHERE Lower(Section) = 'licence' 
		AND Lower(SettingKey) = 'customer name';

	SET @sSelectString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 	A.ID, 
		A.Name, 
		A.DateTime,
		A.EndTime,
		IsNull(A.Duration,-1) AS Duration, 
		A.Username, 
		CASE A.Mode 
			WHEN 1 THEN ''Batch'' 
			ELSE ''Manual'' 
		END AS ''Mode'', 
		CASE A.Status 
			WHEN 0 THEN ''Pending''
		  WHEN 1 THEN ''Cancelled'' 
			WHEN 2 THEN ''Failed'' 
			WHEN 3 THEN ''Successful'' 
			WHEN 4 THEN ''Skipped'' 
			WHEN 5 THEN ''Error''
			ELSE ''Unknown'' 
		END AS Status, 
		CASE A.Type 
			WHEN 0 THEN ''Unknown''
			WHEN 1 THEN ''Cross Tab'' 
			WHEN 2 THEN ''Custom Report'' 
			WHEN 3 THEN ''Data Transfer'' 
			WHEN 4 THEN ''Export'' 
			WHEN 5 THEN ''Global Add'' 
			WHEN 6 THEN ''Global Delete'' 
			WHEN 7 THEN ''Global Update'' 
			WHEN 8 THEN ''Import'' 
			WHEN 9 THEN ''Mail Merge'' 
			WHEN 10 THEN ''Diary Delete'' 
			WHEN 11 THEN ''Diary Rebuild''
			WHEN 12 THEN ''Email Rebuild''
			WHEN 13 THEN ''Standard Report''
			WHEN 14 THEN ''Record Editing''
			WHEN 15 THEN ''System Error''
			WHEN 16 THEN ''Match Report''
			WHEN 17 THEN ''Calendar Report''
			WHEN 18 THEN ''Envelopes & Labels''
			WHEN 19 THEN ''Label Definition''
			WHEN 20 THEN ''Record Profile''
			WHEN 21	THEN ''Succession Planning''
			WHEN 22 THEN ''Career Progression''
			WHEN 25 THEN ''Workflow Rebuild''
			ELSE ''Unknown''  
		END AS Type,
		CASE 
			WHEN A.SuccessCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.SuccessCount)
		END AS SuccessCount,
		CASE
			WHEN A.FailCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.FailCount)
		END AS FailCount,
		A.BatchName AS BatchName,
		A.BatchJobID AS BatchJobID,
		A.BatchRunID AS BatchRunID,
		B.Notes, 
		B.ID AS ''DetailsID'' ,
		(SELECT count(ID) 
			FROM ASRSysEventLogDetails C 
			WHERE C.EventLogID = A.ID) as ''count''
		FROM ASRSysEventLog A
		LEFT OUTER JOIN ASRSysEventLogDetails B
			ON A.ID = B.EventLogID
		WHERE A.ID IN (' + @psSelectedIDs + ')';

	SET @sOrderSQL = '';
	
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
				WHEN 1 THEN ''Cross Tab''
				WHEN 2 THEN ''Custom Report''
				WHEN 3 THEN ''Data Transfer''
				WHEN 4 THEN ''Export''
				WHEN 5 THEN ''Global Add''
				WHEN 6 THEN ''Global Delete''
				WHEN 7 THEN ''Global Update''
				WHEN 8 THEN ''Import''
				WHEN 9 THEN ''Mail Merge''
				WHEN 10 THEN ''Diary Delete''
				WHEN 11 THEN ''Diary Rebuild''
				WHEN 12 THEN ''Email Rebuild''
				WHEN 13 THEN ''Standard Report''
				WHEN 14 THEN ''Record Editing''
				WHEN 15 THEN ''System Error''
				WHEN 16 THEN ''Match Report''
				WHEN 17 THEN ''Calendar Report''
				WHEN 18 THEN ''Envelopes & Labels''
				WHEN 19 THEN ''Label Definition''
				WHEN 20 THEN ''Record Profile''
				WHEN 21 THEN ''Succession Planning''
				WHEN 22 THEN ''Career Progression''
				WHEN 25 THEN ''Workflow Rebuild''
				ELSE ''Unknown''
			END ';
	END

	IF @psOrderColumn = 'Mode'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Mode] 
				WHEN 1 THEN ''Batch''
				WHEN 0 THEN ''Manual''
				ELSE ''Unknown''
			END ';
	END
	
	IF @psOrderColumn = 'Status'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Status] 
				WHEN 0 THEN ''Pending''
				WHEN 1 THEN ''Cancelled''
				WHEN 2 THEN ''Failed''
				WHEN 3 THEN ''Successful''
				WHEN 4 THEN ''Skipped''
				WHEN 5 THEN ''Error''
				ELSE ''Unknown''
			END ';
	END
	
	IF len(@sOrderSQL) = 0
	BEGIN
		SET @sOrderSQL = @psOrderColumn;
	END
	
	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder;

	IF LEN(LTRIM(RTRIM(@sOrderSQL))) > 0 
	BEGIN
		SET @sSelectString = @sSelectString + ' ORDER BY ' + @sOrderSQL;
	END

	EXEC sp_executeSQL @sSelectString;
END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogEmails]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEventLogEmails]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT [ASRSysEmailGroupName].[EmailGroupID] AS 'EmailGroupID', 
					[ASRSysEmailGroupName].[Name] AS 'Name'
	FROM [ASRSysEmailGroupName]
	UNION
	SELECT -1  AS 'EmailGroupID',
				(SELECT [ASRSysSystemSettings].[SettingValue]
			FROM [ASRSysSystemSettings]
			WHERE ([ASRSysSystemSettings].[Section] = 'Support')
				AND ([ASRSysSystemSettings].[SettingKey] = 'Email')
			) AS 'Name'
	ORDER BY 'Name';

END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogPurgeDetails]...';


GO
ALTER Procedure spASRIntGetEventLogPurgeDetails
AS
BEGIN
	SET NOCOUNT ON;

	SELECT * FROM ASRSysEventLogPurge;
END
GO
PRINT N'Altering [dbo].[spASRIntGetEventLogRecords]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetEventLogRecords] (
	@pfError 						bit 				OUTPUT, 
	@psFilterUser					varchar(MAX),
	@piFilterType					integer,
	@piFilterStatus					integer,
	@piFilterMode					integer,
	@psOrderColumn					varchar(MAX),
	@psOrderOrder					varchar(MAX),
	@piRecordsRequired				integer,
	@pfFirstPage					bit					OUTPUT,
	@pfLastPage						bit					OUTPUT,
	@psAction						varchar(100),
	@piTotalRecCount				integer				OUTPUT,
	@piFirstRecPos					integer				OUTPUT,
	@piCurrentRecCount				integer
)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE	@sRealSource 			sysname,
			@sSelectSQL				varchar(MAX),
			@iTempCount 			integer,
			@sExecString			nvarchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer,
			@iGetCount				integer,
			@sFilterSQL				varchar(MAX),
			@sOrderSQL				varchar(MAX),
			@sReverseOrderSQL		varchar(MAX);
			
	/* Clean the input string parameters. */
	IF len(@psAction) > 0 SET @psAction = replace(@psAction, '''', '''''');
	IF len(@psFilterUser) > 0 SET @psFilterUser = replace(@psFilterUser, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sExecString = '';
	SET @sRealSource = 'ASRSysEventLog';
	SET @psAction = UPPER(@psAction);

	IF (@psAction <> 'MOVEPREVIOUS') AND (@psAction <> 'MOVENEXT') AND (@psAction <> 'MOVELAST') 
		BEGIN
			SET @psAction = 'MOVEFIRST';
		END

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 50;

	/* Construct the filter SQL from ther input parameters. */
	SET @sFilterSQL = '';
	
	SET @sFilterSQL = @sFilterSQL + ' Type NOT IN (23, 24) ';

	IF @psFilterUser <> '-1' 
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' LOWER(username) = ''' + lower(@psFilterUser) + '''';
	END
	IF @piFilterType <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Type = ' + convert(varchar(MAX), @piFilterType) + ' ';
	END
	IF @piFilterStatus <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Status = ' + convert(varchar(MAX), @piFilterStatus) + ' ';
	END
	IF @piFilterMode <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Mode = ' + convert(varchar(MAX), @piFilterMode) + ' ';
	END
	
	/* Construct the order SQL from ther input parameters. */
	SET @sOrderSQL = '';
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
					WHEN 1 THEN ''Cross Tab''
					WHEN 2 THEN ''Custom Report''
					WHEN 3 THEN ''Data Transfer''
					WHEN 4 THEN ''Export''
					WHEN 5 THEN ''Global Add''
					WHEN 6 THEN ''Global Delete''
					WHEN 7 THEN ''Global Update''
					WHEN 8 THEN ''Import''
					WHEN 9 THEN ''Mail Merge''
					WHEN 10 THEN ''Diary Delete''
					WHEN 11 THEN ''Diary Rebuild''
					WHEN 12 THEN ''Email Rebuild''
					WHEN 13 THEN ''Standard Report''
					WHEN 14 THEN ''Record Editing''
					WHEN 15 THEN ''System Error''
					WHEN 16 THEN ''Match Report''
					WHEN 17 THEN ''Calendar Report''
					WHEN 18 THEN ''Envelopes & Labels''
					WHEN 19 THEN ''Label Definition''
					WHEN 20 THEN ''Record Profile''
					WHEN 21 THEN ''Succession Planning''
					WHEN 22 THEN ''Career Progression''
					WHEN 25 THEN ''Workflow Rebuild''
					ELSE ''Unknown''
				END ';
	END
	ELSE
	BEGIN
		IF @psOrderColumn = 'Mode'
		BEGIN
			SET @sOrderSQL =	
				' CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
					END ';
		END
		ELSE 
		BEGIN
			IF @psOrderColumn = 'Status'
			BEGIN
				SET @sOrderSQL =	
					' CASE [Status]
							WHEN 0 THEN ''Pending''
							WHEN 1 THEN ''Cancelled''
							WHEN 2 THEN ''Failed''
							WHEN 3 THEN ''Successful''
							WHEN 4 THEN ''Skipped''
							WHEN 5 THEN ''Error''
							ELSE ''Unknown''
						END ';
			END
			ELSE
			BEGIN
				SET @sOrderSQL = @psOrderColumn;
			END
		END
	END
	
	SET @sReverseOrderSQL = @sOrderSQL;
	if @psOrderOrder = 'DESC'
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' ASC ';
	END
	ELSE
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' DESC ';
	END

	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder + ' ';


	SET @sSelectSQL = '[DateTime],
					[EndTime],
					IsNull([Duration],-1) AS ''Duration'', 
		 			CASE [Type] 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
					END + char(9) + 
				 	[Name] + char(9) + 
		 			CASE Status 
						WHEN 0 THEN ''Pending''
					  WHEN 1 THEN ''Cancelled'' 
						WHEN 2 THEN ''Failed'' 
						WHEN 3 THEN ''Successful'' 
						WHEN 4 THEN ''Skipped'' 
						WHEN 5 THEN ''Error''
						ELSE ''Unknown'' 
					END + char(9) +
					CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
				 	END + char(9) + 
					[Username] + char(9) + 
					IsNull(convert(varchar, [BatchJobID]), ''0'') + char(9) +
					IsNull(convert(varchar, [BatchRunID]), ''0'') + char(9) +
					IsNull([BatchName],'''') + char(9) +
					IsNull(convert(varchar, [SuccessCount]),''0'') + char(9) +
					IsNull(convert(varchar, [FailCount]), ''0'') AS EventInfo ';

		
	
	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.ID) FROM ' + @sRealSource;

	IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;
	/****************************************************************************************************************************************/
	
	IF len(@sSelectSQL) > 0 
		BEGIN
			SET @sSelectSQL = @sRealSource + '.ID, ' + @sSelectSQL;
			SET @sExecString = 'SELECT ' ;

			IF @psAction = 'MOVEFIRST'
				BEGIN
					SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
					
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource ;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = 1;
					SET @pfFirstPage = 1;
					SET @pfLastPage = 
					CASE 
						WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
						ELSE 0
					END;
				END
		
			IF (@psAction = 'MOVELAST')
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
					
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')'

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
					IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
					SET @pfFirstPage = 	CASE 
									WHEN @piFirstRecPos = 1 THEN 1
									ELSE 0
								END;
					SET @pfLastPage = 1;

				END

			IF (@psAction = 'MOVENEXT') 
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
						BEGIN
							SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')';

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
					SET @pfFirstPage = 0
					SET @pfLastPage = 	CASE 
									WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
									ELSE 0
								END;
				END

			IF @psAction = 'MOVEPREVIOUS'
				BEGIN	
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF @piFirstRecPos <= @piRecordsRequired
						BEGIN
							SET @iGetCount = @piFirstRecPos - 1;
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END
		
					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
				
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')';
						END
					
					SET @sExecString = @sExecString

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
		
					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
					IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
					SET @pfFirstPage = CASE WHEN @piFirstRecPos = 1 
															THEN 1
															ELSE 0
														 END;
					SET @pfLastPage = CASE WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount 
															THEN 1
															ELSE 0
														END;
				END

		END

	EXECUTE sp_executeSQL @sExecString;
END
GO
PRINT N'Altering [dbo].[spASRIntGetLinkInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetLinkInfo]
(
	@piLinkID 		integer,
	@piScreenID		integer			OUTPUT,
	@piTableID		integer			OUTPUT,
	@psTitle		varchar(MAX)	OUTPUT,
	@piStartMode	integer			OUTPUT, 
	@piTableType	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT 
		@piScreenID = ASRSysSSIntranetLinks.screenID,
		@piTableID = ASRSysScreens.tableID,
		@psTitle = ASRSysSSIntranetLinks.pageTitle,
		@piStartMode = ASRSysSSIntranetLinks.startMode,
		@piTableType = ASRSysTables.TableType
	FROM ASRSysSSIntranetLinks
			INNER JOIN ASRSysScreens 
			ON ASRSysSSIntranetLinks.screenID = ASRSysScreens.ScreenID
				INNER JOIN ASRSysTables
				ON ASRSysScreens.TableID = ASRSysTables.TableID
	WHERE ID = @piLinkID;
END
GO
PRINT N'Altering [dbo].[spASRIntGetLookupFindColumnInfo]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetLookupFindColumnInfo] (
	@piLookupColumnID 		integer,
	@ps1000SeparatorCols	varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@iTableID			integer,
		@bUse1000Separator	bit,
		@iOrderID			integer;
		
	/* Get the column name. */
	SELECT @iTableID = tableID,
		@bUse1000Separator = Use1000Separator
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @piLookupColumnID;

	SET @ps1000SeparatorCols = 
		CASE
			WHEN @bUse1000Separator = 1 THEN '1'
			ELSE '0'
		END;

	/* Get the table name and default order. */
	SELECT @iOrderID = defaultOrderID
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iTableID;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.Use1000Separator
	FROM ASRSysOrderItems
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysOrderItems.orderID = @iOrderID
		AND ASRSysOrderItems.type = 'F'
		AND ASRSysOrderItems.columnID <> @piLookupColumnID
	ORDER BY ASRSysOrderItems.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @bUse1000Separator;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
			CASE
				WHEN @bUse1000Separator = 1 THEN '1'
				ELSE '0'
			END;

		FETCH NEXT FROM orderCursor INTO @bUse1000Separator;
	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

END
GO
PRINT N'Altering [dbo].[spASRIntGetOpFuncShortcuts]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetOpFuncShortcuts]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the operators and functions that have shortcut keys. */
	DECLARE	@iFunctionID		integer, 
			@sParameter			varchar(MAX),
			@iLastFunctionID	integer,
			@sParameters		varchar(MAX);

	SET @iLastFunctionID = 0;
	SET @sParameters = '';

	DECLARE @tempParams TABLE(
		[functionID]	integer,
		[parameters]	varchar(MAX));

	DECLARE paramsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysFunctionParameters.functionID, 
			ASRSysFunctionParameters.parameterName
		FROM ASRSysFunctionParameters
		INNER JOIN ASRSysFunctions ON ASRSysFunctionParameters.functionID = ASRSysFunctions.functionID
			AND LEN(ASRSysFunctions.shortcutKeys) > 0
		ORDER BY ASRSysFunctionParameters.functionID, ASRSysFunctionParameters.parameterIndex;

	OPEN paramsCursor;
	FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iFunctionID <> @iLastFunctionID
		BEGIN
			IF LEN(@sParameters) >0 
			BEGIN
				INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
			END

			SET @iLastFunctionID = @iFunctionID;
			SET @sParameters = @sParameter;
		END
		ELSE
		BEGIN
			SET @sParameters = @sParameters + char(9) + @sParameter;
		END

		FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	END

	IF LEN(@sParameters) >0 
	BEGIN
		INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
	END

	SET @iLastFunctionID = @iFunctionID;
	SET @sParameters = @sParameter;

	CLOSE paramsCursor;
	DEALLOCATE paramsCursor;
	
	SELECT 5 AS [componentType], 
		ASRSysOperators.operatorID AS [ID], 
		ASRSysOperators.shortcutKeys, 
		'' AS [params],
		name AS [name]
	FROM ASRSysOperators
	WHERE len(shortcutKeys) > 0 
	UNION
	SELECT 2 AS [componentType], 
		ASRSysFunctions.functionID AS [ID], 
		ASRSysFunctions.shortcutKeys, 
		tmp.[parameters] AS [params],
		functionName AS [name]
	FROM ASRSysFunctions
	INNER JOIN @tempParams tmp ON ASRSysFunctions.functionID = tmp.functionID
	WHERE len(shortcutKeys) > 0;

END
GO
PRINT N'Altering [dbo].[spASRIntGetPageTitle]...';


GO
ALTER PROCEDURE spASRIntGetPageTitle (
	@piTableID		integer,
	@piViewID		integer,
	@psPageTitle	varchar(200) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psPageTitle = PageTitle
	FROM ASRSysSSIViews
	WHERE (TableID = @piTableID) AND  (ViewID = @piViewID);

END
GO
PRINT N'Altering [dbo].[spASRIntGetRecordDescriptionInView]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetRecordDescriptionInView] (
	@piViewID 			integer,
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@iCount				integer,
			@sEvalRecDesc		varchar(MAX),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500),
			@sViewName			sysname;

	SET @psRecDesc = '';
	SET @psErrorMessage = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables 
		WHERE ASRSysTables.tableID = @piTableID;
	END

	IF @iRecordID > 0 
	BEGIN
		/* Check that the given record is still in the given view */
		SELECT @sViewName = viewName
		FROM ASRSysViews
		WHERE viewID = @piViewID;
	
		SET @sExecString = 'SELECT @iCount = COUNT(*) FROM [' + @sViewName + '] WHERE ID = ' + convert(nvarchar(100), @iRecordID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sExecString, @sParamDefinition, @iCount OUTPUT;
		
		IF @iCount = 0 
		BEGIN
			SET @psErrorMessage = 'The requested record is not in the current view.';
		END
		ELSE
		BEGIN
			/* Get the record description. */
			IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
			BEGIN
				SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(100), @iRecDescID) + ' @recDesc OUTPUT, @recID';
				SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
				EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;
		
				IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRIntGetSingleRecordViewID]...';


GO
ALTER PROCEDURE spASRIntGetSingleRecordViewID 
(
		@piTableID		integer OUTPUT,
		@piViewID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piTableID = TableID, @piViewID = ViewID
	FROM ASRSysSSIViews
	WHERE SingleRecordView = 1;

	IF @piTableID IS NULL SET @piTableID = 0;
	IF @piViewID IS NULL SET @piViewID = 0;

END
GO
PRINT N'Altering [dbo].[spASRIntGetSortOrderColumns]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetSortOrderColumns] (
	@psIncludedColumns		varchar(MAX),
	@psExcludedColumns		varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sSQL nvarchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psIncludedColumns) > 0 SET @psIncludedColumns = replace(@psIncludedColumns, '''', '''''');
	IF len(@psExcludedColumns) > 0 SET @psExcludedColumns = replace(@psExcludedColumns, '''', '''''');

	SET @sSQL = 'SELECT ASRSysColumns.columnId, ' +
		'ASRSysTables.tableName + ''.'' + ASRSysColumns.columnName AS [columnName] ' +
		'FROM ASRSysColumns ' +
		'INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID ' +
		'WHERE ASRSysColumns.columnId IN ('+ @psIncludedColumns + ')';

	IF len(@psExcludedColumns) > 0
	BEGIN
		SET @sSQL = @sSQL + ' AND [columnID] NOT IN (' + @psExcludedColumns + ')';
	END

	SET @sSQL = @sSQL + ' ORDER BY [columnName] ASC';
	
	EXECUTE sp_executeSQL @sSQL;
END
GO
PRINT N'Altering [dbo].[spASRIntGetSSIWelcomeDetails]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetSSIWelcomeDetails]	
(
		@piWelcomeColumnID integer,
		@piPhotographColumnID integer,
		@piSingleRecordViewID integer,
		@psUserName varchar(255),	
		@psWelcomeMessage varchar(255) OUTPUT,
		@psSelfServiceWelcomeColumn varchar(255) OUTPUT,
		@psSelfServicePhotograph varbinary(max) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sql nvarchar(max)
	DECLARE @dtLastLogon datetime
	DECLARE @myval varchar(max)
	DECLARE @myvalVarBinary as varbinary(max)
	DECLARE @psLogonTime varchar(20)
	DECLARE @psLogonDay varchar(20)
	DECLARE @psWelcomeName varchar(255)
	DECLARE @psLastLogon varchar(50)		

	--- try to get the users welcome name

	BEGIN TRY
		SELECT @sql = 'SELECT @outparm = ['+c.columnname+'] FROM ['+v.viewname+']'
			FROM ASRSysColumns c, ASRSysViews v
			WHERE c.columnID = @piWelcomeColumnID AND v.ViewID = @piSingleRecordViewID

		EXEC sp_executesql @sql, N'@outparm nvarchar(max) output', @myval OUTPUT
	
		IF LEN(LTRIM(RTRIM(@myval))) = 0 OR @@ROWCOUNT = 0 or ISNULL(@myval, '') = ''
		BEGIN
			SET @psWelcomeName = ''
		END
		ELSE
		BEGIN
			SET @psWelcomeName = ' ' + isnull(@myval, '')
		END

	END TRY
	
	BEGIN CATCH
		SET @psWelcomeName = ''
	END CATCH
	
	-- Get the user's photograph
	BEGIN TRY
		SELECT @sql = 'SELECT @outparm = ['+c.columnname+'] FROM ['+v.viewname+']'
			FROM ASRSysColumns c, ASRSysViews v
			WHERE c.columnID = @piPhotographColumnID AND v.ViewID = @piSingleRecordViewID

		EXEC sp_executesql @sql, N'@outparm varbinary(max) output', @myvalVarBinary OUTPUT
	
		SET @psSelfServicePhotograph = @myvalVarBinary
	END TRY
	
	BEGIN CATCH
		SET @psSelfServicePhotograph = null
	END CATCH

	--- Now get the last logon details

	SELECT TOP 1 @dtLastLogon = DateTimeStamp
        FROM ASRSysAuditAccess WHERE [UserName] = @psUserName
        AND [HRProModule] = 'Intranet' AND [Action] = 'log in'
              AND ID NOT IN (                  
															SELECT top 1 ID
															FROM ASRSysAuditAccess WHERE [UserName] = @psUserName
															AND [HRProModule] = 'Intranet' AND [Action] = 'log in'
															ORDER BY DateTimeStamp DESC)                  
	ORDER BY DateTimeStamp DESC
      

	IF @@ROWCOUNT > 0 
	BEGIN
		SET @psLogonTime = CONVERT(varchar(5),@dtLastLogon, 108)
		SELECT @psLogonDay = 
			CASE datediff(day, @dtLastLogon, GETDATE())
			WHEN 0 THEN 'today'
			WHEN 1 THEN 'yesterday'
			ELSE 'on ' + CAST(DAY(@dtLastLogon) AS VARCHAR(2)) + ' ' + DATENAME(MM, @dtLastLogon) + ' ' + CAST(YEAR(@dtLastLogon) AS VARCHAR(4))
		END
		SET @psWelcomeMessage = 'Welcome back' + @psWelcomeName + ', you last logged in at ' + @psLogonTime + ' ' + @psLogonDay
	END
	ELSE
	BEGIN
		SET @psWelcomeMessage = 'Welcome ' + @psWelcomeName
	END

	SET @psSelfServiceWelcomeColumn = @psWelcomeName;

END
GO
PRINT N'Altering [dbo].[spASRIntGetTimestamp]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetTimestamp] (
	@piTimestamp 	int 		OUTPUT, 
	@piRecordID		integer,
	@psRealsource	varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500);

	/* Clean the input string parameters. */
	IF len(@psRealsource) > 0 SET @psRealsource = replace(@psRealsource, '''', '''''');
	
	SET @sTempExecString = 'SELECT @iTimestamp = convert(integer, timestamp) FROM ' + convert(nvarchar(255), @psRealsource) + ' where ID = ' + convert(nvarchar(100), @piRecordID);
	SET @sTempParamDefinition = N'@iTimestamp integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piTimestamp OUTPUT;
END
GO
PRINT N'Altering [dbo].[spASRIntGetUtilityAccessRecords]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords] (
	@piUtilityType		integer,
	@piID				integer,
	@piFromCopy			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sDefaultAccess	varchar(2),
		@sAccessTable	sysname,
		@sKey			varchar(255),
		@sSQL			nvarchar(MAX);

	SET @sAccessTable = '';

	IF @piUtilityType = 17
	BEGIN
		/* Calendar Reports */
		SET @sAccessTable = 'ASRSysCalendarReportAccess';
		SET @sKey = 'dfltaccess CalendarReports';
	END

	IF @piUtilityType = 1
	BEGIN
		/* Cross Tabs */
		SET @sAccessTable = 'ASRSysCrossTabAccess';
		SET @sKey = 'dfltaccess CrossTabs';
	END

	IF @piUtilityType = 2
	BEGIN
		/* Custom Reports */
		SET @sAccessTable = 'ASRSysCustomReportAccess';
		SET @sKey = 'dfltaccess CustomReports';
	END

	IF @piUtilityType = 9
	BEGIN
		/* Mail Merge */
		SET @sAccessTable = 'ASRSysMailMergeAccess';
		SET @sKey = 'dfltaccess MailMerge';
	END

	IF LEN(@sAccessTable) > 0
	BEGIN
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SELECT @sDefaultAccess = SettingValue 
			FROM ASRSysUserSettings
			WHERE UserName = system_user
				AND Section = 'utils&reports'
				AND SettingKey = @sKey;
	
			IF (@sDefaultAccess IS null)
			BEGIN
				SET @sDefaultAccess = 'RW';
			END
		END
		ELSE
		BEGIN
			SET @sDefaultAccess = 'HD';
		END
		
		SET @sSQL = 'SELECT sysusers.name + char(9) +
				CASE WHEN	
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE sysusers.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						ELSE ';
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RW'' THEN ''Read / Write''
			 WHEN	CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
			ELSE '
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RO'' THEN ''Read Only''
			ELSE ''Hidden'' 
			END + char(9) +
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
 						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''1''
				ELSE
					''0''
			END AS [accessDefinition]
			FROM sysusers
			LEFT OUTER JOIN ' + @sAccessTable + ' ON (sysusers.name = ' + @sAccessTable + '.groupName
				AND ' + @sAccessTable + '.id = ' + convert(nvarchar(100), @piID) + ')
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0 AND NOT (sysusers.name LIKE ''ASRSys%'') AND NOT (sysusers.name LIKE ''db_%'')
			ORDER BY sysusers.name';

			EXEC sp_executesql @sSQL;
	END

END
GO
PRINT N'Altering [dbo].[spASRIntGetUtilityBaseTable]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetUtilityBaseTable] (
	@piUtilityType	integer,
	@plngID			integer,
	@piBaseTableID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName				sysname,
		@sIDColumnName			sysname,
		@sBaseTableColumnName	sysname,
		@sSQL					nvarchar(MAX),
		@sParamDefinition		nvarchar(500);

	SET @sTableName = '';
	SET @piBaseTableID = 0;
	SET @sBaseTableColumnName = '';
	
	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sIDColumnName = 'ID';
		/* No base table for batch jobs. */
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sIDColumnName = 'ID';
		SET @sBaseTableColumnName = 'BaseTable';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
		SET @sBaseTableColumnName = 'TableID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sIDColumnName = 'ID';
		SET @sBaseTableColumnName = 'BaseTable';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sIDColumnName = 'DataTransferID';
		SET @sBaseTableColumnName = 'FromTableID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sIDColumnName = 'ID';
		SET @sBaseTableColumnName = 'BaseTable';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sIDColumnName = 'functionID';
		SET @sBaseTableColumnName = 'TableID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sIDColumnName = 'ID';
		SET @sBaseTableColumnName = 'BaseTable';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sIDColumnName = 'mailMergeID';
		SET @sBaseTableColumnName = 'TableID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sIDColumnName = 'recordProfileID';
		SET @sBaseTableColumnName = 'BaseTable';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sIDColumnName = 'matchReportID';
		SET @sBaseTableColumnName = 'Table1ID';
 	END

	IF (len(@sTableName) > 0) 
		AND (len(@sBaseTableColumnName) > 0)
	BEGIN
		SET @sSQL = 'SELECT @iTableID = [' + @sTableName + '].[' + @sBaseTableColumnName + ']
				FROM [' + @sTableName + ']
				WHERE [' + @sTableName + '].[' + @sIDColumnName + '] = ' + convert(nvarchar(100), @plngID);

		SET @sParamDefinition = N'@iTableID integer OUTPUT';
		EXEC sp_executesql @sSQL, @sParamDefinition, @piBaseTableID OUTPUT;
	END

	IF @piBaseTableID IS null SET @piBaseTableID = 0;
END
GO
PRINT N'Altering [dbo].[spASRIntGetUtilityName]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetUtilityName] (
	@piUtilityType	integer,
	@plngID			integer,
	@psName			varchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500);

	SET @sTableName = '';
	SET @psName = '<unknown>';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
    END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sIDColumnName = 'ID';
    END
        
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sIDColumnName = 'DataTransferID';
    END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sIDColumnName = 'functionID';
    END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sIDColumnName = 'mailMergeID';
    END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sIDColumnName = 'recordProfileID';
    END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sIDColumnName = 'matchReportID';
    END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SET @sTableName = 'ASRSysWorkflows';
		SET @sIDColumnName = 'ID';
	END
      	
	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sName = [' + @sTableName + '].[name]
				FROM [' + @sTableName + ']
				WHERE [' + @sTableName + '].[' + @sIDColumnName + '] = ' + convert(nvarchar(255), @plngID);

		SET @sParamDefinition = N'@sName varchar(255) OUTPUT';
		EXEC sp_executesql @sSQL, @sParamDefinition, @psName OUTPUT;
	END

	IF @psName IS null SET @psName = '<unknown>';
END
GO
PRINT N'Altering [dbo].[spASRIntGetViewName]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetViewName] (
	@piViewID	integer,
	@psViewName	varchar(255) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @piViewID;

END
GO
PRINT N'Altering [dbo].[spASRIntSaveCalendarReport]...';


GO
ALTER PROCEDURE [dbo].[spASRIntSaveCalendarReport]
	(
	@psName						varchar(255),
	@psDescription				varchar(MAX),
	@piBaseTable				integer,
	@pfAllRecords				bit,
	@piPicklist					integer,
	@piFilter					integer,
	@pfPrintFilterHeader		bit,
	@psUserName					varchar(255),
	@piDescription1				integer,
	@piDescription2				integer,
	@piDescriptionExpr			integer,
	@piRegion					integer,
	@pfGroupByDesc				bit,
	@psDescSeparator			varchar(100),
	@piStartType				integer,
	@psFixedStart				varchar(100),
	@piStartFrequency			integer,
	@piStartPeriod				integer,
	@piStartDateExpr			integer,
	@piEndType					integer,
	@psFixedEnd					varchar(100),
	@piEndFrequency				integer,
	@piEndPeriod				integer,
	@piEndDateExpr				integer,
	@pfShowBankHols				bit,
	@pfShowCaptions				bit,
	@pfShowWeekends				bit,
	@pfStartOnCurrentMonth		bit,
	@pfIncludeWorkdays			bit,
	@pfIncludeBankHols			bit,
	@pfOutputPreview			bit,
	@piOutputFormat				integer,
	@pfOutputScreen				bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName		varchar(MAX),
	@pfOutputSave				bit,
	@piOutputSaveExisting		integer,
	@pfOutputEmail				bit,
	@pfOutputEmailAddr			integer,
	@psOutputEmailSubject		varchar(MAX),
	@psOutputEmailAttachAs		varchar(MAX),
	@psOutputFilename			varchar(MAX),
	@psAccess					varchar(MAX),
	@psJobsToHide				varchar(MAX),
	@psJobsToHideGroups			varchar(MAX),
	@psEvents					varchar(MAX),
	@psEvents2					varchar(MAX),
	@psOrderString				varchar(MAX),
	@piID						integer	OUTPUT
	)
AS
BEGIN 

	SET NOCOUNT ON;

	DECLARE	@sTemp					varchar(MAX),
			@iCount					integer,
			@fIsNew					bit,
			@sEventDefn				varchar(MAX),
			@sEventParam			varchar(MAX),
			@sEventKey				varchar(MAX),
			@sEventName				varchar(MAX),
			@iEventTableID			integer,
			@iEventFilterID			integer,
			@iEventStartDateID		integer,
			@iEventStartSessionID	integer,
			@iEventEndDateID		integer,
			@iEventEndSessionID		integer,
			@iEventDurationID		integer,
			@iLegendType			integer,
			@sLegendCharacter		varchar(2),
			@iLegendLookupTableID	integer,
			@iLegendLookupColumnID	integer,
			@iLegendLookupCodeID	integer,
			@iLegendEventColumnID	integer,
			@iEventDesc1ColumnID	integer,
			@iEventDesc2ColumnID	integer,
			@sOrderDefn				varchar(MAX),
			@sOrderParam			varchar(MAX),
			@iOrderTableID			integer,
			@iOrderColumnID			integer,
			@iOrderSequence			integer,
			@sOrderType				varchar(20),
			@sGroup					varchar(255),
			@sAccess				varchar(MAX),
			@sSQL					nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''');
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''');

	SET @fIsNew = 0;

	/* Insert/update the report header. */
	IF @piID = 0
	BEGIN
		/* Creating a new report. */
		INSERT ASRSYSCalendarReports (
			Name, 
			[Description], 
			BaseTable, 
			AllRecords, 
			Picklist, 
			Filter, 
			PrintFilterHeader, 
			UserName, 
			Description1, 
			Description2, 
			DescriptionExpr, 
			Region,
			GroupByDesc,
			DescriptionSeparator, 
			StartType, 
			FixedStart, 
			StartFrequency,
			StartPeriod,
			StartDateExpr,
			EndType,
			FixedEnd,
			EndFrequency,
			EndPeriod,
			EndDateExpr,
			ShowBankHolidays,
			ShowCaptions,
			ShowWeekends,
			StartOnCurrentMonth, 
			IncludeWorkingDaysOnly, 
			IncludeBankHolidays,
			OutputPreview, 
			OutputFormat, 
			OutputScreen, 
			OutputPrinter, 
			OutputPrinterName, 
			OutputSave, 
			OutputSaveExisting, 
			OutputEmail, 
			OutputEmailAddr, 
			OutputEmailSubject, 
			OutputEmailAttachAs, 
			OutputFileName)
		VALUES (
			@psName,
			@psDescription,
			@piBaseTable,
			@pfAllRecords,
			@piPicklist,
			@piFilter,
			@pfPrintFilterHeader,
			@psUserName,
			@piDescription1,
			@piDescription2,
			@piDescriptionExpr,
			@piRegion,
			@pfGroupByDesc,
			@psDescSeparator,
			@piStartType,
			@psFixedStart,
			@piStartFrequency,
			@piStartPeriod,
			@piStartDateExpr,
			@piEndType,
			@psFixedEnd,
			@piEndFrequency,
			@piEndPeriod,
			@piEndDateExpr,
			@pfShowBankHols,
			@pfShowCaptions,
			@pfShowWeekends,
			@pfStartOnCurrentMonth,
			@pfIncludeWorkdays,
			@pfIncludeBankHols,
			@pfOutputPreview,
			@piOutputFormat,
			@pfOutputScreen,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@pfOutputSave,
			@piOutputSaveExisting,
			@pfOutputEmail,
			@pfOutputEmailAddr,
			@psOutputEmailSubject,
			@psOutputEmailAttachAs,
			@psOutputFilename
		);
		
		SET @fIsNew = 1;
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(ID) FROM ASRSysCalendarReports;
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysCalendarReports SET 
			Name = @psName,
			[Description] = @psDescription, 
			BaseTable = @piBaseTable, 
			AllRecords = @pfAllRecords, 
			Picklist = @piPicklist, 
			Filter = @piFilter,
			PrintFilterHeader = @pfPrintFilterHeader,
			Description1 = @piDescription1,
			Description2 = @piDescription2,
			DescriptionExpr = @piDescriptionExpr,
			Region = @piRegion,
			GroupByDesc = @pfGroupByDesc,
			DescriptionSeparator = @psDescSeparator,
			StartType = @piStartType,
			FixedStart = @psFixedStart, 
			StartFrequency = @piStartFrequency,
			StartPeriod = @piStartPeriod,
			StartDateExpr = @piStartDateExpr,
			EndType = @piEndType,
			FixedEnd = @psFixedEnd, 
			EndFrequency = @piEndFrequency,
			EndPeriod = @piEndPeriod,
			EndDateExpr = @piEndDateExpr,
			ShowBankHolidays = @pfShowBankHols,
			ShowCaptions = @pfShowCaptions,
			ShowWeekends = @pfShowWeekends,
			StartOnCurrentMonth = @pfStartOnCurrentMonth,
			IncludeWorkingDaysOnly = @pfIncludeWorkdays,
			IncludeBankHolidays = @pfIncludeBankHols,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName, 
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @pfOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename  
			WHERE ID = @piID;
		
		/* Delete existing report event details. */
		DELETE FROM ASRSysCalendarReportEvents 
		WHERE calendarReportID = @piID;
	END

	/* Create the report's event details records. */
	SET @sTemp = @psEvents;

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sEventDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)

			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psEvents2, 1000)
				IF len(@psEvents2) > 1000
				BEGIN
					SET @psEvents2 = SUBSTRING(@psEvents2, 1001, len(@psEvents2) - 1000)
				END
				ELSE
				BEGIN
					SET @psEvents2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sEventDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the event definition parameters. */
		SET @sEventKey = '';
		SET @sEventName = '';
		SET @iEventTableID = 0;
		SET @iEventFilterID = 0;
		SET @iEventStartDateID = 0;
		SET @iEventStartSessionID = 0;
		SET @iEventEndDateID = 0;
		SET @iEventEndSessionID = 0;
		SET @iEventDurationID = 0;
		SET @iLegendType = 0;
		SET @sLegendCharacter = '';
		SET @iLegendLookupTableID = 0;
		SET @iLegendLookupColumnID = 0;
		SET @iLegendLookupCodeID = 0;
		SET @iLegendEventColumnID = 0;
		SET @iEventDesc1ColumnID = 0;
		SET @iEventDesc2ColumnID = 0;
		
		SET @iCount = 0;
		
		WHILE LEN(@sEventDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sEventDefn) > 0
			BEGIN
				SET @sEventParam = LEFT(@sEventDefn, CHARINDEX('||', @sEventDefn) - 1)
				SET @sEventDefn = RIGHT(@sEventDefn, LEN(@sEventDefn) - CHARINDEX('||', @sEventDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sEventParam = @sEventDefn
				SET @sEventDefn = ''
			END

			IF @iCount = 0 SET @sEventKey = @sEventParam;
			IF @iCount = 1 SET @sEventName = @sEventParam;
			IF @iCount = 2 SET @iEventTableID = convert(integer, @sEventParam);
			IF @iCount = 3 SET @iEventFilterID = convert(integer, @sEventParam);
			IF @iCount = 4 SET @iEventStartDateID = convert(integer, @sEventParam);
			IF @iCount = 5 SET @iEventStartSessionID = convert(integer, @sEventParam);
			IF @iCount = 6 SET @iEventEndDateID = convert(integer, @sEventParam);
			IF @iCount = 7 SET @iEventEndSessionID = convert(integer, @sEventParam);
			IF @iCount = 8 SET @iEventDurationID = convert(integer, @sEventParam);
			IF @iCount = 9 SET @iLegendType = convert(integer, @sEventParam);
			
			IF (@iCount = 10)
				BEGIN 
					IF @iLegendType = 0
						BEGIN
							SET @sLegendCharacter = LEFT(@sEventParam,2);
						END	
					ELSE
						BEGIN
							SET @sLegendCharacter = '';
						END
				END
			IF @iCount = 11 SET @iLegendLookupTableID = convert(integer, @sEventParam);
			IF @iCount = 12 SET @iLegendLookupColumnID = convert(integer, @sEventParam);
			IF @iCount = 13 SET @iLegendLookupCodeID = convert(integer, @sEventParam);
			IF @iCount = 14 SET @iLegendEventColumnID = convert(integer, @sEventParam);
			IF @iCount = 15 SET @iEventDesc1ColumnID = convert(integer, @sEventParam);
			IF @iCount = 16 SET @iEventDesc2ColumnID = convert(integer, @sEventParam);

			SET @iCount = @iCount + 1;
		END

		INSERT ASRSysCalendarReportEvents (EventKey, CalendarReportID, Name, TableID, FilterID, 
				EventStartDateID, EventStartSessionID, EventEndDateID, EventEndSessionID, 
				EventDurationID, LegendType, LegendCharacter, LegendLookupTableID, LegendLookupColumnID, 
				LegendLookupCodeID, LegendEventColumnID, EventDesc1ColumnID, EventDesc2ColumnID)
		VALUES (@sEventKey, @piID, @sEventName, @iEventTableID, @iEventFilterID, 
				@iEventStartDateID, @iEventStartSessionID, @iEventEndDateID, @iEventEndSessionID, 
				@iEventDurationID, @iLegendType, @sLegendCharacter, @iLegendLookupTableID, @iLegendLookupColumnID, 
				@iLegendLookupCodeID, @iLegendEventColumnID, @iEventDesc1ColumnID, @iEventDesc2ColumnID);

	END


	/* Create the report's sort order details records. */
	IF (@fIsNew = 0)
	BEGIN
		/* Delete existing report sort order details. */
		DELETE FROM ASRSysCalendarReportOrder 
		WHERE calendarReportID = @piID;
	END

	SET @sTemp = @psOrderString;

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sOrderDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1);
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1);
		END
		ELSE
		BEGIN
			SET @sOrderDefn = @sTemp;
			SET @sTemp = '';
		END

		/* Rip out the column definition parameters. */
		SET @iOrderTableID = 0;
		SET @iOrderColumnID = 0;
		SET @iOrderSequence = 0;
		SET @sOrderType = '';
		
		SET @iCount = 0;

		WHILE LEN(@sOrderDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sOrderDefn) > 0
			BEGIN
				SET @sOrderParam = LEFT(@sOrderDefn, CHARINDEX('||', @sOrderDefn) - 1);
				SET @sOrderDefn = RIGHT(@sOrderDefn, LEN(@sOrderDefn) - CHARINDEX('||', @sOrderDefn) - 1);
			END
			ELSE
			BEGIN
				SET @sOrderParam = @sOrderDefn;
				SET @sOrderDefn = '';
			END

			--IF @iCount = 0 SET @iOrderTableID = convert(integer, @sOrderParam)
			IF @iCount = 0 SET @iOrderColumnID = convert(integer, @sOrderParam);
			IF @iCount = 1 SET @iOrderSequence = convert(integer, @sOrderParam);
			IF @iCount = 2 SET @sOrderType = @sOrderParam;
	
			SET @iCount = @iCount + 1;
		END

		SELECT @iOrderTableID = ASRSysColumns.TableID
		FROM ASRSysColumns
		WHERE ASRSysColumns.ColumnID = @iOrderColumnID;
		
		INSERT ASRSysCalendarReportOrder 
			(CalendarReportID, TableID, ColumnID, OrderSequence, OrderType) 
		VALUES (@piID, @iOrderTableID, @iOrderColumnID, @iOrderSequence, @sOrderType);

	END
	
	DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piID
	INSERT INTO ASRSysCalendarReportAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0);

	SET @sTemp = @psAccess;
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1);
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)));
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1);
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)));
	
			IF EXISTS (SELECT * FROM ASRSysCalendarReportAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCalendarReportAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup;
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (17, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name());
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND [type] = 17;

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				([type], utilID, savedBy, savedDate, savedHost)
			VALUES (17, @piID, system_user, getdate(), host_name());
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND [type] = 17;
		END
	END
	
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + '''';

		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')';
		EXEC sp_executesql @sSQL;

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))';
		EXEC sp_executesql @sSQL;
	END
END
GO
PRINT N'Altering [dbo].[spASRIntSetEventLogPurge]...';


GO
ALTER PROCEDURE [dbo].[spASRIntSetEventLogPurge]
(
		@psPeriod		varchar(2),
		@piFrequency	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLogPurge] (Period,Frequency)
	VALUES (@psPeriod, @piFrequency);

END
GO
PRINT N'Altering [dbo].[spASRNetOutlookBatch]...';


GO
ALTER PROCEDURE [dbo].[spASRNetOutlookBatch]
(
	@Content			varchar(MAX)	OUTPUT,
	@AllDayEvent		bit OUTPUT,
	@StartDate			datetime		OUTPUT,
	@EndDate			datetime		OUTPUT,
	@StartTime			varchar(100)	OUTPUT,
	@EndTime			varchar(100)	OUTPUT,
	@Subject			varchar(MAX)	OUTPUT,
	@Folder				varchar(MAX)	OUTPUT,
	@LinkID				integer,
	@RecordID			integer,
	@FolderID			integer,
	@StartDateColumnID	integer,
	@EndDateColumnID	integer,
	@FixedStartTime		varchar(100),
	@FixedEndTime		varchar(100),
	@StartTimeColumnID	integer,
	@EndTimeColumnID	integer,
	@TimeRange			integer,
	@Title				varchar(MAX),
	@SubjectExprID		integer,
	@RecordDescExprID	integer,
	@DateFormat			varchar(100),
	@FolderPath			varchar(MAX),
	@FolderType			integer,
	@FolderExprID		integer)
AS
BEGIN

	DECLARE @sSQL nvarchar(MAX);
	DECLARE @sParamDefinition nvarchar(500);
	DECLARE @CharValue varchar(MAX);
	DECLARE @Heading varchar(MAX);
	DECLARE @TableName varchar(MAX);
	DECLARE @ColumnName varchar(MAX);
	DECLARE @DataType integer;
		
	SELECT @sSQL = 'SELECT @StartDate=['+ColumnName+'] FROM ['+TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
	FROM ASRSysColumns JOIN ASRSysTables ON ASRSysColumns.TableID = ASRSysTables.TableID
	WHERE ColumnID = @StartDateColumnID;
	SET @sParamDefinition = N'@StartDate datetime OUTPUT';
	EXEC sp_executesql @sSQL,  @sParamDefinition, @StartDate OUTPUT;

	SET @EndDate = Null
	IF @EndDateColumnID > 0
	BEGIN
		SELECT @sSQL = 'SELECT @EndDate=['+ColumnName+'] FROM ['+TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		FROM ASRSysColumns JOIN ASRSysTables ON ASRSysColumns.TableID = ASRSysTables.TableID
		WHERE ColumnID = @EndDateColumnID
		SET @sParamDefinition = N'@EndDate datetime OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @EndDate OUTPUT
		IF rtrim(@EndDate) = '' SET @EndDate = null
	END

	IF @TimeRange = 0
	BEGIN
		SET @AllDayEvent = 1
		SET @StartTime = ''
		SET @EndTime = ''
	END
	IF @TimeRange = 1
	BEGIN
		SET @AllDayEvent = 0
		SET @StartTime = @FixedStartTime
		SET @EndTime = @FixedEndTime
	END
	IF @TimeRange = 2
	BEGIN
		SET @AllDayEvent = 0

		SELECT @sSQL = 'SELECT @StartTime=['+ColumnName+'] FROM ['+TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		FROM ASRSysColumns JOIN ASRSysTables ON ASRSysColumns.TableID = ASRSysTables.TableID
		WHERE ColumnID = @StartTimeColumnID
		SET @sParamDefinition = N'@StartTime varchar(100) OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @StartTime OUTPUT

		SELECT @sSQL = 'SELECT @EndTime=['+ColumnName+'] FROM ['+TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		FROM ASRSysColumns JOIN ASRSysTables ON ASRSysColumns.TableID = ASRSysTables.TableID
		WHERE ColumnID = @EndTimeColumnID
		SET @sParamDefinition = N'@EndTime varchar(100) OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @EndTime OUTPUT

		IF UPPER(@StartTime) = 'AM'
			SELECT @StartTime = SettingValue FROM ASRSysSystemSettings
			WHERE [Section] = 'outlook' and [Settingkey] = 'amstarttime'
		IF UPPER(@StartTime) = 'PM'
			SELECT @StartTime = SettingValue FROM ASRSysSystemSettings
			WHERE [Section] = 'outlook' and [Settingkey] = 'pmstarttime'
		IF UPPER(@EndTime) = 'AM'
			SELECT @EndTime = SettingValue FROM ASRSysSystemSettings
			WHERE [Section] = 'outlook' and [Settingkey] = 'amendtime'
		IF UPPER(@EndTime) = 'PM'
			SELECT @EndTime = SettingValue FROM ASRSysSystemSettings
			WHERE [Section] = 'outlook' and [Settingkey] = 'pmendtime'
	END


	SET @Subject = ''
	IF @SubjectExprID > 0
	BEGIN
		SET @sSQL = 'DECLARE @hResult int
			IF EXISTS(SELECT * FROM sysobjects WHERE type = ''P'' AND name = ''sp_ASRExpr_'+convert(nvarchar(100),@SubjectExprID)+''')
		             BEGIN
		                EXEC @hResult = sp_ASRExpr_'+convert(nvarchar(100),@SubjectExprID)+' @Subject OUTPUT, '+convert(nvarchar(100),@RecordID)+'
		                IF @hResult <> 0 SET @Subject = ''''
		                SET @Subject = CONVERT(varchar(255), @Subject)
			     END
			     ELSE SET @Subject = '''''
		SET @sParamDefinition = N'@Subject varchar(MAX) OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @Subject OUTPUT
	END
	ELSE
	BEGIN
		IF @RecordDescExprID > 0
		BEGIN
			SET @sSQL = 'DECLARE @hResult int
				IF EXISTS(SELECT * FROM sysobjects WHERE type = ''P'' AND name = ''sp_ASRExpr_'+convert(nvarchar(100),@RecordDescExprID)+''')
			             BEGIN
			                EXEC @hResult = sp_ASRExpr_'+convert(nvarchar(100),@RecordDescExprID)+' @Subject OUTPUT, '+convert(nvarchar(100),@RecordID)+'
			                IF @hResult <> 0 SET @Subject = ''''
			                SET @Subject = CONVERT(varchar(255), @Subject)
				     END
				     ELSE SET @Subject = '''''
			SET @sParamDefinition = N'@Subject varchar(MAX) OUTPUT'
			EXEC sp_executesql @sSQL,  @sParamDefinition, @Subject OUTPUT
			IF @Subject <> ''
				SET @Subject = ': '+@Subject
		END
		SET @Subject = @Title+@Subject
	END


	SET @Folder = @FolderPath
	IF @FolderType > 0
	BEGIN
		SET @sSQL = 'DECLARE @hResult int
			IF EXISTS(SELECT * FROM sysobjects WHERE type = ''P'' AND name = ''sp_ASRExpr_'+convert(nvarchar(100),@FolderExprID)+''')
		             BEGIN
		                EXEC @hResult = sp_ASRExpr_'+convert(nvarchar(100),@FolderExprID)+' @Folder OUTPUT, '+convert(nvarchar(100),@RecordID)+'
		                IF @hResult <> 0 SET @Folder = ''''
			     END
			     ELSE SET @Folder = '''''
		SET @sParamDefinition = N'@Folder varchar(MAX) OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @Folder OUTPUT
	END


	DECLARE CursorColumns CURSOR FOR 
	SELECT isnull(ASRSysOutlookLinksColumns.Heading,''),
		ASRSysTables.TableName,
		ASRSysColumns.ColumnName,
		ASRSysColumns.DataType
	FROM ASRSysOutlookLinksColumns
	JOIN ASRSysColumns
		ON ASRSysColumns.ColumnID = ASRSysOutlookLinksColumns.ColumnID
	JOIN ASRSysTables
		ON ASRSysColumns.TableID = ASRSysTables.TableID
	WHERE LinkID = @LinkID
	ORDER BY [Sequence] DESC

	SET @Content = char(13) + @Content

	OPEN CursorColumns
	FETCH NEXT FROM CursorColumns
	INTO	@Heading, @TableName, @ColumnName, @DataType

	WHILE @@FETCH_STATUS = 0
	BEGIN

		IF @Heading <> '' SET @Heading = @Heading+': '

		IF @DataType = 12
			SELECT @sSQL = 'SELECT @CharValue='''+@Heading+'''+isnull(['+@ColumnName+'],'''') FROM ['+@TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		IF @DataType = 11
			SELECT @sSQL = 'SELECT @CharValue='''+@Heading+'''+case when ['+@ColumnName+'] is null then ''<Empty>'' else convert(varchar(255),['+@ColumnName+'],'+@DateFormat+') end FROM ['+@TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		IF @DataType = -7
			SELECT @sSQL = 'SELECT @CharValue='''+@Heading+'''+case when ['+@ColumnName+'] = 1 then ''Y'' else ''N'' end FROM ['+@TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)
		IF @DataType <> 11 AND @DataType <> 12 AND @DataType <> -7
			SELECT @sSQL = 'SELECT @CharValue='''+@Heading+'''+convert(varchar(255),isnull(['+@ColumnName+'],'''')) FROM ['+@TableName+'] WHERE ID = '+convert(nvarchar(100),@RecordID)

		SET @sParamDefinition = N'@CharValue varchar(MAX) OUTPUT'
		EXEC sp_executesql @sSQL,  @sParamDefinition, @CharValue OUTPUT

		IF @CharValue IS Null SET @CharValue = ''
		SET @Content = @CharValue + char(13) + @Content

		FETCH NEXT FROM CursorColumns
		INTO	@Heading, @TableName, @ColumnName, @DataType
	END

	CLOSE CursorColumns
	DEALLOCATE CursorColumns

END
GO
PRINT N'Altering [dbo].[spASROutlookEventRefresh]...';


GO
ALTER PROCEDURE [dbo].[spASROutlookEventRefresh](
	@LinkID		integer,
	@FolderID	integer,
	@TableID	integer,
	@RecordID	integer)
AS
BEGIN

	IF EXISTS(SELECT * FROM ASRSysOutlookEvents WHERE LinkID = @LinkID AND FolderID = @FolderID AND TableID = @TableID AND RecordID = @RecordID)
		UPDATE ASRSysOutlookEvents SET Refresh = 1 WHERE LinkID = @LinkID AND FolderID = @FolderID AND TableID = @TableID AND RecordID = @RecordID;
	ELSE
		INSERT ASRSysOutlookEvents(LinkID, FolderID, TableID, RecordID, Refresh, Deleted) VALUES (@LinkID,@FolderID, @TableID, @RecordID, 1, 0);

END
GO
PRINT N'Altering [dbo].[spASRSaveSetting]...';


GO
ALTER PROCEDURE [dbo].[spASRSaveSetting] (
	@psSection		varchar(50),
	@psKey			varchar(50),
	@psValue		varchar(200)	
)
AS
BEGIN

	/* Save the given system setting. */
	DELETE FROM [dbo].[ASRSysSystemSettings]
	WHERE section = @psSection
		AND [settingKey] = @psKey;
	
	INSERT INTO [dbo].[ASRSysSystemSettings]
		([section], [settingKey], [settingValue])
	VALUES (@psSection, @psKey, @psValue);
	
END
GO
PRINT N'Altering [dbo].[spASRSendMail]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spASRSendMail](
	@hResult int OUTPUT,
	@To varchar(MAX),
	@CC varchar(MAX),
	@BCC varchar(MAX),
	@Subject varchar(MAX),
	@Message varchar(MAX),
	@Attachment varchar(MAX))
AS
	RETURN 0;
GO
PRINT N'Creating [dbo].[spASRStoredDataFileActions]...';


GO
-- Generated by the server assembly
CREATE PROCEDURE [dbo].[spASRStoredDataFileActions]
	@piInstanceID [int],
	@piElementID [int],
	@piRecordID [int]
WITH EXECUTE AS CALLER
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[spASRSysEmailAddr]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spASRSysEmailAddr] (
	@param1 varchar(MAX) OUTPUT,
	@param2 int,
	@param3	int)
AS
	RETURN 0;
GO
PRINT N'Altering [dbo].[spASRSysWorkflowCalculation]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spASRSysWorkflowCalculation]
(
	@piInstanceID integer,
	@piExprID integer,
	@piResultType integer OUTPUT,
	@psResult varchar(MAX) OUTPUT,
	@pfResult bit OUTPUT,
	@pdtResult datetime OUTPUT,
	@pfltResult float OUTPUT,
	@piTempElement int
)
AS
	RETURN 0
GO
PRINT N'Altering [dbo].[spASRSysWorkflowParentRecord]...';


GO
-- This stored procedure is a code stub and will be regenerated by a System Manager save.
ALTER PROCEDURE [dbo].[spASRSysWorkflowParentRecord]
(
	@piChildTableID integer,
	@piChildRecordID integer,
	@piParentTableID integer,
	@piParentRecordID integer OUTPUT
)
AS
BEGIN
	RETURN 0
END
GO
PRINT N'Altering [dbo].[spASRTidyUpNonASRUsers]...';


GO
ALTER PROCEDURE [dbo].[spASRTidyUpNonASRUsers]
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @iGroupID int;

	SELECT @iGroupID = uid FROM sysusers WHERE isSQLRole = 1 AND name = 'ASRSysGroup';

	SELECT * FROM sysusers WHERE uid NOT IN (SELECT uid FROM sysmembers
	INNER JOIN sysusers ON sysusers.uid = sysmembers.memberuid
	WHERE groupuid = @iGroupID)
	AND IsSQLRole = 0 AND NOT (name = 'dbo' OR name= 'guest' OR name='sys' OR name='INFORMATION_SCHEMA');

	RETURN;

END
GO
PRINT N'Altering [dbo].[spASRWorkflowActionFailed]...';


GO
ALTER PROCEDURE [dbo].[spASRWorkflowActionFailed]
(
	@piInstanceID		integer,
	@piElementID		integer,
	@psMessage			varchar(MAX)
)
AS
BEGIN
	DECLARE
		@iFailureFlows	integer,
		@iCount			integer;

	-- Check if the failed element has an outbound flow for failures.
	SELECT @iFailureFlows = COUNT(*)
	FROM ASRSysWorkflowElements Es
	INNER JOIN ASRSysWorkflowLinks Ls ON Es.ID = Ls.startElementID
		AND Ls.startOutboundFlowCode = 1
	WHERE Es.ID = @piElementID
		AND Es.type = 5; -- 5 = StoredData

	IF @iFailureFlows = 0
	BEGIN
		UPDATE ASRSysWorkflowInstanceSteps
		SET status = 4,	-- 4 = failed
			message = @psMessage,
			failedCount = isnull(failedCount, 0) + 1
		WHERE instanceID = @piInstanceID
			AND elementID = @piElementID;

		UPDATE ASRSysWorkflowInstances
		SET status = 2	-- 2 = error
		WHERE ID = @piInstanceID;
	END
	ELSE
	BEGIN
		UPDATE ASRSysWorkflowInstanceSteps
		SET status = 8,	-- 8 = failed action
			message = @psMessage,
			failedCount = isnull(failedCount, 0) + 1
		WHERE instanceID = @piInstanceID
			AND elementID = @piElementID;

		UPDATE ASRSysWorkflowInstanceSteps
		SET ASRSysWorkflowInstanceSteps.status = 1,
			ASRSysWorkflowInstanceSteps.activationDateTime = getdate(), 
			ASRSysWorkflowInstanceSteps.completionDateTime = null
		WHERE ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID
			AND ASRSysWorkflowInstanceSteps.elementID IN 
				(SELECT id 
				FROM [dbo].[udfASRGetSucceedingWorkflowElements](@piElementID, 1))
			AND (ASRSysWorkflowInstanceSteps.status = 0
				OR ASRSysWorkflowInstanceSteps.status = 3
				OR ASRSysWorkflowInstanceSteps.status = 4
				OR ASRSysWorkflowInstanceSteps.status = 6
				OR ASRSysWorkflowInstanceSteps.status = 8);
						
		-- Set activated Web Forms to be 'pending' (to be done by the user) 
		UPDATE ASRSysWorkflowInstanceSteps
		SET ASRSysWorkflowInstanceSteps.status = 2
		WHERE ASRSysWorkflowInstanceSteps.id IN (
			SELECT ASRSysWorkflowInstanceSteps.ID
			FROM ASRSysWorkflowInstanceSteps
			INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
			WHERE ASRSysWorkflowInstanceSteps.status = 1
				AND ASRSysWorkflowElements.type = 2);
						
		-- Set activated Terminators to be 'completed'
		UPDATE ASRSysWorkflowInstanceSteps
		SET ASRSysWorkflowInstanceSteps.status = 3,
			ASRSysWorkflowInstanceSteps.completionDateTime = getdate(), 
			ASRSysWorkflowInstanceSteps.completionCount = isnull(ASRSysWorkflowInstanceSteps.completionCount, 0) + 1
		WHERE ASRSysWorkflowInstanceSteps.id IN (
			SELECT ASRSysWorkflowInstanceSteps.ID
			FROM ASRSysWorkflowInstanceSteps
			INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
			WHERE ASRSysWorkflowInstanceSteps.status = 1
				AND ASRSysWorkflowElements.type = 1);
						
		-- Count how many terminators have completed. ie. if the workflow has completed.
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowInstanceSteps
		INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
		WHERE ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID
			AND ASRSysWorkflowInstanceSteps.status = 3
			AND ASRSysWorkflowElements.type = 1;
											
		IF @iCount > 0 
		BEGIN
			UPDATE ASRSysWorkflowInstances
			SET ASRSysWorkflowInstances.completionDateTime = getdate(), 
				ASRSysWorkflowInstances.status = 3
			WHERE ASRSysWorkflowInstances.ID = @piInstanceID;
			
			/* NB. Deletion of records in related tables (eg. ASRSysWorkflowInstanceSteps and ASRSysWorkflowInstanceValues)
			is performed by a DELETE trigger on the ASRSysWorkflowInstances table. */
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRWorkflowRebuild]...';


GO
ALTER PROCEDURE [dbo].[spASRWorkflowRebuild]
AS
BEGIN	
	-- Refresh all scheduled Workflow items in the queue.
	DECLARE @sTableName 	varchar(255),
		@iTableID			int,
		@sSQL				nvarchar(MAX)
	
	-- Get a cursor of the tables in the database.
	DECLARE curTables CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableName, tableID
		FROM ASRSysTables;
	OPEN curTables;

	DELETE FROM ASRSysWorkflowQueue 
	WHERE dateInitiated IS null 
		AND [Immediate] = 0;

	-- Loop through the tables in the database.
	FETCH NEXT FROM curTables INTO @sTableName, @iTableID;
	WHILE @@fetch_status <> -1
	BEGIN
		/* Get a cursor of the records in the current table.  */
		/* Call the Workflow trigger for that table and record  */
		SET @sSQL = '
			DECLARE @iCurrentID	int,
				@sSQL		nvarchar(MAX);
			
			IF EXISTS (SELECT * FROM sysobjects
			WHERE id = object_id(''spASRWorkflowRebuild_' + LTrim(Str(@iTableID)) + ''') 
				AND sysstat & 0xf = 4)
			BEGIN
				DECLARE curRecords CURSOR FOR
				SELECT id
				FROM ' + @sTableName + ';

				OPEN curRecords;

				FETCH NEXT FROM curRecords INTO @iCurrentID;
				WHILE @@fetch_status <> -1
				BEGIN
					SET @sSQL = ''EXEC spASRWorkflowRebuild_' + LTrim(Str(@iTableID)) 
						+ ' '' + convert(varchar(100), @iCurrentID) + '''';
					EXECUTE sp_executeSQL @sSQL;

					FETCH NEXT FROM curRecords INTO @iCurrentID;
				END
				CLOSE curRecords;
				DEALLOCATE curRecords;
			END';

		 EXECUTE sp_executeSQL @sSQL;

		/* Move onto the next table in the database. */ 
		FETCH NEXT FROM curTables INTO @sTableName, @iTableID;
	END

	CLOSE curTables;
	DEALLOCATE curTables;
END
GO
PRINT N'Altering [dbo].[spASRWorkflowUsesInitiator]...';


GO
ALTER PROCEDURE [dbo].[spASRWorkflowUsesInitiator]
(
	@piWorkflowID		integer,			
	@pfUsesInitiator		bit	OUTPUT
)
AS
BEGIN
	/* Return 1 if the given workflow uses the initiator's personnel record; else return 0 */
	DECLARE	@iCount	integer;

	SET @pfUsesInitiator = 0

	/* Initiator's record used by a Stored Data element action? */
	SELECT @iCount = COUNT(*)
	FROM ASRSysWorkflowElements
	WHERE ASRSysWorkflowElements.type = 5 -- 5 = Stored Data element
		AND (ASRSysWorkflowElements.dataRecord = 0 OR ASRSysWorkflowElements.secondaryDataRecord = 0) -- 0 = Initiator's record
		AND ASRSysWorkflowElements.workflowID = @piWorkflowID;

	IF @iCount > 0 SET @pfUsesInitiator = 1;

	IF @pfUsesInitiator = 0
	BEGIN
		/* Initiator's record used by a Stored Data element Database Value item? */
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowElementColumns
		INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowElementColumns.elementID = ASRSysWorkflowElements.ID
		WHERE ASRSysWorkflowElements.type = 5 -- 5 = Stored Data element
			AND ASRSysWorkflowElementColumns.valueType = 2 -- 2 = Database value
			AND ASRSysWorkflowElementColumns.dbRecord = 0 -- 0 = Initiator's record
			AND ASRSysWorkflowElements.workflowID = @piWorkflowID;
	
		IF @iCount > 0 SET @pfUsesInitiator = 1;
	END

	IF @pfUsesInitiator = 0
	BEGIN
		/* Initiator's record used by an Email element address? */
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowElements
		WHERE ASRSysWorkflowElements.type = 3 -- 3 = Email element
			AND ASRSysWorkflowElements.emailRecord = 0 -- 0 = Initiator's record
			AND ASRSysWorkflowElements.workflowID = @piWorkflowID;

		IF @iCount > 0 SET @pfUsesInitiator = 1;
	END

	IF @pfUsesInitiator = 0
	BEGIN
		/* Initiator's record used by an Email element Database Value item? */
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowElementItems
		INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowElementItems.elementID = ASRSysWorkflowElements.ID
		WHERE ASRSysWorkflowElements.type = 3 -- 3 = Email element
			AND ASRSysWorkflowElementItems.itemType = 1 -- 1 = Database value
			AND ASRSysWorkflowElementItems.dbRecord = 0 -- 0 = Initiator's record
			AND ASRSysWorkflowElements.workflowID = @piWorkflowID;

		IF @iCount > 0 SET @pfUsesInitiator = 1;
	END

	IF @pfUsesInitiator = 0
	BEGIN
		/* Initiator's record used by a Web Form element Database Value? */
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowElementItems
		INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowElementItems.elementID = ASRSysWorkflowElements.ID
		WHERE ASRSysWorkflowElements.type = 2 -- 2 = Web Form element
			AND ASRSysWorkflowElementItems.itemType = 1 -- 1 = Database value
			AND ASRSysWorkflowElementItems.dbRecord = 0 -- 0 = Initiator's record
			AND ASRSysWorkflowElements.workflowID = @piWorkflowID;

		IF @iCount > 0 SET @pfUsesInitiator = 1;
	END

	IF @pfUsesInitiator = 0
	BEGIN
		/* Initiator's record used by a Web Form element Record Selector? */
		SELECT @iCount = COUNT(*)
		FROM ASRSysWorkflowElementItems
		INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowElementItems.elementID = ASRSysWorkflowElements.ID
		WHERE ASRSysWorkflowElements.type = 2 -- 2 = Web Form element
			AND ASRSysWorkflowElementItems.itemType = 11 -- 11 = Record Selector
			AND ASRSysWorkflowElementItems.dbRecord = 0 -- 0 = Initiator's record
			AND ASRSysWorkflowElements.workflowID = @piWorkflowID;

		IF @iCount > 0 SET @pfUsesInitiator = 1;
	END

	/* Now Expressions by element */

	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Decision Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElements WHERE TrueFlowExprID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END
	
	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Web form (Descriptions) Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElements WHERE DescriptionExprID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END	
	
	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Web form (Record Filters) Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElementItems WHERE RecordFilterID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END	
		
	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Web form (Label Calculations & Default Calculations & Email) Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElementItems WHERE CalcID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END	
	
	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Web form (Validation Calculations) Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElementValidations WHERE ExprID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END	
	
	IF @pfUsesInitiator = 0
	BEGIN					
		/* Expressions - Web form (Stored Data) Element */
		SELECT @iCount = COUNT(*) FROM ASRSysWorkflowElementColumns WHERE CalcID IN 
			(SELECT ExprID
			FROM ASRSysExprComponents EC
			WHERE EC.exprID in (SELECT E.exprID
					FROM ASRSysExpressions E
					WHERE E.utilityid = 114)
				AND EC.workflowRecord = 0); -- 0 = Initiator's record
				
		IF @iCount > 0 SET @pfUsesInitiator = 1;			
	END	
	
	
	
END
GO
PRINT N'Altering [dbo].[spstat_getaudittrail]...';


GO
ALTER PROCEDURE [dbo].[spstat_getaudittrail] (
	@piAuditType	int,
	@psOrder 		varchar(MAX))
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sSQL			varchar(MAX),
			@sExecString	nvarchar(MAX);

	IF @piAuditType = 1
	BEGIN

		SET @sSQL = 'SELECT userName AS [User], 
			dateTimeStamp AS [Date / Time], 
			tableName AS [Table], 
			columnName AS [Column], 
			oldValue AS [Old Value], 
			newValue AS [New Value], 
			recordDesc AS [Record Description],
			id
			FROM dbo.ASRSysAuditTrail ';

		IF LEN(@psOrder) > 0
			SET @sExecString = @sSQL + @psOrder;
		ELSE
			SET @sExecString = @sSQL;
		
	END
	ELSE IF @piAuditType = 2
	BEGIN

		SET @sSQL =  'SELECT userName AS [User], 
			dateTimeStamp AS [Date / Time],
			groupName AS [User Group],
			viewTableName AS [View / Table],
			columnName AS [Column], 
			action AS [Action],
			permission AS [Permission], 
			id
			FROM dbo.ASRSysAuditPermissions ';

		IF LEN(@psOrder) > 0
			SET @sExecString = @sSQL + @psOrder;
		ELSE
			SET @sExecString = @sSQL;

	END
	ELSE IF @piAuditType = 3
	BEGIN
		SET @sSQL = 'SELECT userName AS [User],
    			dateTimeStamp AS [Date / Time],
			groupName AS [User Group], 
			userLogin AS [User Login],
			[Action], 
			id
			FROM dbo.ASRSysAuditGroup ';

		IF LEN(@psOrder) > 0
			SET @sExecString = @sSQL + @psOrder;
		ELSE
			SET @sExecString = @sSQL;

	END
	ELSE IF @piAuditType = 4
	BEGIN
		SET @sSQL = 'SELECT DateTimeStamp AS [Date / Time],
    			UserGroup AS [User Group],
			UserName AS [User], 
			ComputerName AS [Computer Name],
			HRProModule AS [Module],
			Action AS [Action], 
			id
			FROM dbo.ASRSysAuditAccess ';

		IF LEN(@psOrder) > 0
			SET @sExecString = @sSQL + @psOrder;
		ELSE
			SET @sExecString = @sSQL;

	END

	-- Retreive selected data
	IF LEN(@sExecString) > 0 EXECUTE sp_executeSQL @sExecString;

END
GO
PRINT N'Altering [dbo].[spstat_scriptnewcolumn]...';


GO
ALTER PROCEDURE dbo.spstat_scriptnewcolumn (@columnid integer OUTPUT, @tableid integer, @columnname varchar(255)
	, @datatype integer, @description varchar(255), @size integer, @decimals integer, @islocked bit, @uniquekey varchar(37))
AS
BEGIN

	DECLARE @ssql nvarchar(MAX),
			@tablename varchar(255),
			@datasyntax	varchar(255);

	DECLARE @spinnerMinimum integer,
		@spinnerMaximum integer,
		@spinnerIncrement integer,
		@audit bit,
		@duplicate bit,
		@defaultvalue varchar(max),
		@columntype integer,
		@mandatory bit,
		@uniquecheck bit,
		@convertcase smallint,
		@mask varchar(MAX),
		@lookupTableID integer,
		@lookupColumnID integer,
		@controltype integer,
		@alphaonly bit,
		@blankIfZero bit,
		@multiline bit,
		@alignment smallint,
		@calcExprID integer,
		@gotFocusExprID integer,
		@lostFocusExprID integer,
		@calcTrigger smallint,
		@readOnly bit,
		@statusBarMessage varchar(255),
		@errorMessage varchar(255),
		@linkTableID integer, 
		@Afdenabled bit, 
		@Afdindividual integer,
		@Afdforename integer, 
		@Afdsurname integer,
		@Afdinitial integer, 
		@Afdtelephone integer, 
		@Afdaddress integer,
		@Afdproperty integer, 
		@Afdstreet integer, 
		@Afdlocality integer, 
		@Afdtown integer, 
		@Afdcounty integer,
		@dfltValueExprID integer, 
		@linkOrderID integer, 
		@OleOnServer bit, 
		@childUniqueCheck bit,
		@LinkViewID integer, 
		@DefaultDisplayWidth integer, 
		@UniqueCheckType integer,
		@Trimming integer, 
		@Use1000Separator bit,
		@LookupFilterColumnID integer, 
		@LookupFilterValueID integer, 
		@QAddressEnabled integer, 
		@QAIndividual integer, 
		@QAAddress integer, 
		@QAProperty integer, 
		@QAStreet integer,
		@QALocality integer, 
		@QATown integer, 
		@QACounty integer, 
		@LookupFilterOperator integer, 
		@Embedded bit, 
		@OLEType integer, 
		@MaxOLESizeEnabled bit, 
		@MaxOLESize integer,
		@AutoUpdateLookupValues bit, 
		@CalculateIfEmpty bit;

	-- Can we safely create this column?
	SELECT @columnid = ISNULL(columnid,0) FROM dbo.[ASRSysColumns] WHERE tableid = @tableid AND columnname = @columnname;
	IF @columnid > 0
	BEGIN
		RETURN;
	END

	SELECT @tablename = [tablename] FROM dbo.[ASRSysTables] WHERE tableid = @tableid;
	SELECT @columnid = MAX(columnid) + 1 FROM dbo.[ASRSysColumns];
	
	SET @defaultvalue = '';		
	SET @spinnerMinimum = 0;
	SET @spinnerMaximum = 0;
	SET @spinnerIncrement = 0;
	SET @audit = 0;
	SET @duplicate = 0;
	SET @columntype = 0;
	SET @mandatory = 0;
	SET @uniquecheck = 0;
	SET @convertcase = 0;
	SET @mask = '';
	SET @lookupTableID = 0;
	SET	@lookupColumnID = 0;
	SET	@controltype = 0;	
	SET @alphaonly = 0;
	SET @blankIfZero = 0;
	SET @multiline = 0;
	SET @alignment = 0;
	SET @calcExprID = 0;
	SET @gotFocusExprID = 0;
	SET @lostFocusExprID = 0;
	SET @calcTrigger = 0;
	SET @readOnly = 0;
	SET @statusBarMessage = '';
	SET @errorMessage = '';
	SET @linkTableID = 0; 
	SET @Afdenabled = 0; 
	SET @Afdindividual = 0;
	SET @Afdforename = 0; 
	SET @Afdsurname = 0;
	SET @Afdinitial = 0; 
	SET @Afdtelephone = 0; 
	SET @Afdaddress = 0;
	SET @Afdproperty = 0; 
	SET @Afdstreet = 0; 
	SET @Afdlocality = 0; 
	SET @Afdtown = 0; 
	SET @Afdcounty = 0;
	SET @dfltValueExprID = 0; 
	SET @linkOrderID = 0; 
	SET @OleOnServer = 0; 
	SET @childUniqueCheck = 0;
	SET @LinkViewID = 0; 
	SET @DefaultDisplayWidth = 0; 
	SET @UniqueCheckType = 0;
	SET @Trimming = 0;
	SET @Use1000Separator = 0;
	SET @LookupFilterColumnID = 0; 
	SET @LookupFilterValueID = 0; 
	SET @QAddressEnabled = 0; 
	SET @QAIndividual = 0; 
	SET @QAAddress = 0; 
	SET @QAProperty = 0; 
	SET @QAStreet = 0;
	SET @QALocality = 0; 
	SET @QATown = 0; 
	SET @QACounty = 0; 
	SET @LookupFilterOperator = 0; 
	SET @Embedded = 0; 
	SET @OLEType = 0; 
	SET @MaxOLESizeEnabled = 0; 
	SET @MaxOLESize = 0;
	SET @AutoUpdateLookupValues = 0; 
	SET @CalculateIfEmpty = 0;
	

	-- Logic
	IF @datatype = -7
	BEGIN
		SET @datasyntax = 'bit';
		SET @defaultvalue = 'FALSE';
		SET @controltype = 1;
	END

	-- OLE
	IF @datatype = -4
		SET @controltype = 1;

	-- Photo
	IF @datatype = -3
		SET @controltype = 1024;

	-- Link
	IF @datatype = -2
	BEGIN
		SET @datasyntax = 'varchar(255)';
		SET @controltype = 2048;
	END

	-- Working Pattern
	IF @datatype = -1
	BEGIN
		SET @datasyntax = 'varchar(14)';
		SET @controltype = 4096;
	END
	
	-- Numeric
	IF @datatype = 2
	BEGIN
		SET @datasyntax = 'numeric(' + convert(varchar(10),@size) + ',' + @decimals + ')';
		SET @defaultvalue = 0;	
		SET @controltype = 64;
	END

	-- Integers
	IF @datatype = 4
	BEGIN
		SET @datasyntax = 'integer';
		SET @controltype = 64;
	END
	
	-- Date
	IF @datatype = 11
	BEGIN
		SET @datasyntax = 'datetime';
		SET @controltype = 64;
	END

	-- Character
	IF @datatype = 12
	BEGIN
		SET @datasyntax = 'varchar(' + convert(varchar(10),@size) + ')';
		SET @controltype = 64;
	END

	-- System objects update
	INSERT dbo.[tbsys_scriptedobjects] ([guid], [objecttype], [targetid], [ownerid], [effectivedate], [revision], [locked], [lastupdated])
		SELECT @uniquekey, 2, @columnid, 'AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE', '01/01/1900',1,@islocked, GETDATE();

	-- Update base table								
	INSERT dbo.[tbsys_columns] ([columnID], [tableID], [columnType], [datatype], [defaultValue], [size], [decimals]
			, [lookupTableID], [lookupColumnID], [controltype], [spinnerMinimum], [spinnerMaximum], [spinnerIncrement], [audit]
			, [duplicate], [mandatory], [uniquecheck], [convertcase], [mask], [alphaonly], [blankIfZero], [multiline], [alignment]
			, [calcExprID], [gotFocusExprID], [lostFocusExprID], [calcTrigger], [readOnly], [statusBarMessage], [errorMessage]
			, [linkTableID], [Afdenabled], [Afdindividual], [Afdforename], [Afdsurname], [Afdinitial], [Afdtelephone], [Afdaddress]
			, [Afdproperty], [Afdstreet], [Afdlocality], [Afdtown], [Afdcounty], [dfltValueExprID], [linkOrderID], [OleOnServer]
			, [childUniqueCheck], [LinkViewID], [DefaultDisplayWidth], [ColumnName], [UniqueCheckType], [Trimming], [Use1000Separator]
			, [LookupFilterColumnID], [LookupFilterValueID], [QAddressEnabled], [QAIndividual], [QAAddress], [QAProperty], [QAStreet]
			, [QALocality], [QATown], [QACounty], [LookupFilterOperator], [Embedded], [OLEType], [MaxOLESizeEnabled], [MaxOLESize]
			, [AutoUpdateLookupValues], [CalculateIfEmpty]) 
		VALUES (@columnid, @tableid, @columntype, @datatype, @defaultvalue, @size, @decimals
			, @lookupTableID, @lookupColumnID, @controltype, @spinnerMinimum, @spinnerMaximum, @spinnerIncrement, @audit
			, @duplicate, @mandatory, @uniquecheck, @convertcase, @mask, @alphaonly, @blankIfZero, @multiline, @alignment
			, @calcExprID, @gotFocusExprID, @lostFocusExprID, @calcTrigger, @readOnly, @statusBarMessage, @errorMessage
			, @linkTableID, @Afdenabled, @Afdindividual, @Afdforename, @Afdsurname, @Afdinitial, @Afdtelephone, @Afdaddress
			, @Afdproperty, @Afdstreet, @Afdlocality, @Afdtown, @Afdcounty, @dfltValueExprID, @linkOrderID, @OleOnServer
			, @childUniqueCheck, @LinkViewID, @DefaultDisplayWidth, @ColumnName, @UniqueCheckType, @Trimming, @Use1000Separator
			, @LookupFilterColumnID, @LookupFilterValueID, @QAddressEnabled, @QAIndividual, @QAAddress, @QAProperty, @QAStreet
			, @QALocality, @QATown, @QACounty, @LookupFilterOperator, @Embedded, @OLEType, @MaxOLESizeEnabled, @MaxOLESize
			, @AutoUpdateLookupValues, @CalculateIfEmpty);

		-- Physically create this column (is regenerated by the System Manager save)	
		SET @ssql = N'ALTER TABLE dbo.tbuser_' + @tablename + ' ADD ' + @columnname + ' ' + @datasyntax;
		EXECUTE sp_executesql @ssql;

	RETURN;

END
GO
PRINT N'Creating [dbo].[sp_ASRGetParentTables]...';


GO
CREATE PROCEDURE sp_ASRGetParentTables (
	@piTableID int = 0)
AS
BEGIN
	SELECT tableID, tableName 
	FROM ASRSysTables
	JOIN ASRSysRelations 
		ON ASRSysTables.tableID = ASRSysRelations.parentID
	WHERE ASRSysRelations.childID= @piTableID
END
GO
PRINT N'Creating [dbo].[spASRGetMetadata]...';


GO
CREATE PROCEDURE [dbo].[spASRGetMetadata] (@Username varchar(255))
WITH ENCRYPTION
AS
BEGIN

	DECLARE @licenseKey			varchar(MAX);

	EXEC [dbo].[sp_ASRIntGetSystemSetting] 'Licence', 'Key', 'moduleCode', @licenseKey OUTPUT, 0, 0;


	SELECT TableID, TableName, TableType, DefaultOrderID, RecordDescExprID FROM dbo.ASRSysTables;

	SELECT ColumnID, TableID, ColumnName, DataType, Use1000Separator, Size, Decimals FROM dbo.ASRSysColumns;

	SELECT ParentID, ChildID FROM dbo.ASRSysRelations;

	SELECT ModuleKey, ParameterKey, ISNULL(ParameterValue,'') AS ParameterValue, ParameterType FROM dbo.ASRSysModuleSetup;

	SELECT * FROM dbo.ASRSysUserSettings WHERE Username = @Username;

	SELECT functionID, functionName, returnType FROM dbo.ASRSysFunctions;

	SELECT * FROM dbo.ASRSysFunctionParameters ORDER BY functionID, parameterIndex;

	SELECT * FROM dbo.ASRSysOperators;

	SELECT * FROM dbo.ASRSysOperatorParameters ORDER BY OperatorID, parameterIndex;
	
	-- Which modules are enabled?
	SELECT 'WORKFLOW' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,1024) AS [enabled]
	UNION
	SELECT 'PERSONNEL' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,1) AS [enabled]
	UNION
	SELECT 'ABSENCE' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,4) AS [enabled]
	UNION
	SELECT 'TRAINING' AS [name],  dbo.udfASRNetIsModuleLicensed(@licenseKey,8) AS [enabled]
	UNION
	SELECT  'VERSIONONE' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,2048) AS [enabled];


	-- Selected system settings
	SELECT * FROM ASRSysSystemSettings;


END
GO
PRINT N'Creating [dbo].[spASRIntGetCustomReport]...';


GO
CREATE PROCEDURE dbo.spASRIntGetCustomReport
	(@ReportID integer)
AS
BEGIN

	SET NOCOUNT ON;
	
	-- Base report info
	SELECT c.[ID], c.[Name], c.[Description], c.[BaseTable], c.[AllRecords], c.[Picklist], c.[Filter]
		 , c.[Parent1Table], c.[Parent1Filter], c.[Parent2Table], c.[Parent2Filter], c.[Summary], c.[PrintFilterHeader]
		 , c.[UserName], c.[Timestamp], c.[Parent1AllRecords]
 		 , ISNULL(c.[Parent1Picklist],0) AS [Parent1Picklist]
		 , c.[Parent2AllRecords]
		 , ISNULL(c.[Parent2Picklist],0) AS [Parent2Picklist]
		 , c.[OutputPreview], c.[OutputFormat], c.[OutputScreen], c.[OutputPrinter], c.[OutputPrinterName], c.[OutputSave]
		 , c.[OutputSaveExisting], c.[OutputEmail], c.[OutputEmailAddr], c.[OutputEmailSubject], c.[OutputFilename]
		 , ISNULL(c.[OutputEmailAttachAs],0) AS [OutputEmailAttachAs]
		 , c.[IgnoreZeros]
		, t.tablename AS TableName
		, ISNULL(e.Name, '') AS EmailGroupName
		FROM dbo.ASRSYSCustomReportsName c
			INNER JOIN ASRSysTables t ON t.tableid = c.BaseTable
			LEFT JOIN ASRSysEmailGroupName e ON c.OutputEmailAddr = e.EmailGroupID
		WHERE c.ID = @ReportID;

	-- Child Report info
	SELECT C.ChildTable, C.ChildFilter, C.ChildMaxRecords, T.TableName, C.ChildOrder
		FROM ASRSYSCustomReportsChildDetails C
		      INNER JOIN ASRSysTables T ON T.TableID = C.ChildTable 
		WHERE C.CustomReportID = @ReportID;

END
GO
PRINT N'Creating [dbo].[spASRIntGetCustomReportDetails]...';


GO
CREATE PROCEDURE spASRIntGetCustomReportDetails (@piCustomReportID integer)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT d.*, ISNULL(c.Use1000separator,0) AS Use1000separator
			, ISNULL(c.columnname,'') AS [columnname]
			, ISNULL(t.tableid,0) AS [tableid]
			, ISNULL(t.tablename,'') AS [tablename]
			, CASE c.datatype WHEN 11 THEN 1 ELSE 0 END AS [IsDateColumn]
			, CASE c.datatype WHEN -7 THEN 1 ELSE 0 END AS [IsBooleanColumn]
		FROM ASRSysCustomReportsDetails d
		LEFT JOIN ASRSysColumns c ON c.columnid = d.ColExprID And d.Type = 'C'
		LEFT JOIN ASRSysTables t ON c.tableid = t.tableid
	WHERE CustomReportID = @piCustomReportID ORDER BY [Sequence];

END
GO
PRINT N'Creating [dbo].[spASRIntGetExpressionAndComponents]...';


GO
CREATE PROCEDURE dbo.spASRIntGetExpressionAndComponents
	(@ExpressionID integer, @ExpressionType integer)
AS
BEGIN

	IF @ExpressionType = 14
		SELECT name, 0 AS tableID, returnType, type, parentComponentID, Username,
			access, description, ViewInColour, CONVERT(integer, timestamp) AS intTimestamp, '' AS tableName
			FROM ASRSysExpressions
			WHERE exprID = @ExpressionID;

	ELSE
		SELECT e.name, ISNULL(e.TableID, 0) AS [tableID]
			, ISNULL(e.returnType, 0) AS [returntype]
			, ISNULL(e.type, 0) AS [type]
			, ISNULL(e.parentComponentID, 0) AS [parentComponentID]
			, ISNULL(e.Username, SYSTEM_USER) AS [username]
			, ISNULL(e.access, 'RW') AS [access]
			, ISNULL(e.description,'') AS [description]
			, ISNULL(e.ViewInColour,0) AS [ViewInColour]
			, CONVERT(integer, e.timestamp) AS [intTimestamp]
			, ISNULL(t.tableName,'') AS [tablename]
			FROM ASRSysExpressions e
				LEFT OUTER JOIN ASRSysTables t ON e.TableID = t.tableID
			WHERE exprID = @ExpressionID;

	-- Components for this expression
	SELECT * FROM ASRSysExprComponents WHERE exprID = @ExpressionID ORDER BY componentID;

END
GO
PRINT N'Creating [dbo].[spASRIntGetSessionSettings]...';


GO
CREATE PROCEDURE [dbo].[spASRIntGetSessionSettings]
AS
BEGIN

	SET NOCOUNT ON;

	-- Declarations and their default values.
	DECLARE @BlockSize				integer = 1000,
			@PrimaryStartMode		tinyint = 3,
			@HistoryStartMode		tinyint = 3,
			@LookupStartMode		tinyint = 2,
			@QuickAccessStartMode	tinyint = 1,
			@ExprColourMode			integer	= 1,
			@ExprNodeMode			tinyint	= 1;

	DECLARE @SupportTelNo			varchar(50) = '+44 (0)1582 714820',
			@SupportFax				varchar(50) = '+44 (0)1582 714814',
			@SupportEmail			varchar(50) = 'service.delivery@advancedcomputersoftware.com',
			@SupportWebpage			varchar(50)	= 'http://webfirst.advancedcomputersoftware.com',
			@DesktopColour			varchar(20) = 2147483660;



	SELECT @BlockSize = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'IntranetFindWindow' AND settingKey = 'BlockSize';

	SELECT @PrimaryStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'Primary';

	SELECT @HistoryStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'History';

	SELECT @LookupStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'LookUp';

	SELECT @QuickAccessStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'QuickAccess';

	SELECT @ExprColourMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'ExpressionBuilder' AND settingKey = 'ViewColours';

	SELECT @ExprNodeMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'ExpressionBuilder' AND settingKey = 'NodeSize';
	
	SELECT @SupportTelNo = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Telephone No';

	SELECT @SupportFax = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Fax';

	SELECT @SupportEmail = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Email';
		
	SELECT @SupportWebpage = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'WebPage';

	SELECT @DesktopColour = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'DesktopSetting' AND settingKey = 'BackgroundColour';


	SELECT @BlockSize			AS [BlockSize]
		, @PrimaryStartMode		AS [PrimaryStartMode]
		, @HistoryStartMode		AS [HistoryStartMode]
		, @LookupStartMode		AS [LookupStartMode]
		, @QuickAccessStartMode	AS [QuickAccessStartMode]
		, @ExprColourMode		AS [ExprColourMode]
		, @ExprColourMode		AS [ExprColourMode]
		, @ExprNodeMode			AS [ExprNodeMode]
		, @SupportTelNo			AS [SupportTelNo]
		, @SupportFax			AS [SupportFax]
		, @SupportEmail			AS [SupportEmail]
		, @SupportWebpage		AS [SupportWebpage]
		, @DesktopColour		AS [DesktopColour];


END
GO
PRINT N'Creating [dbo].[spASRIntGetUniqueExpressionID]...';


GO
CREATE PROCEDURE [dbo].[spASRIntGetUniqueExpressionID](
	@settingkey AS varchar(50),
	@settingvalue AS integer OUTPUT)
AS
BEGIN

	SELECT @settingvalue = [SettingValue] FROM [asrsyssystemsettings] WHERE [Section] = 'AUTOID' AND [SettingKey] = @settingkey;

	IF @settingvalue IS NULL
		INSERT ASRSysSystemSettings([Section], [SettingKey], [SettingValue]) VALUES ('AUTOID', @settingkey, 1);	
	ELSE
	BEGIN
		SET @settingvalue = @settingvalue + 1
		UPDATE ASRSysSystemSettings SET [SettingValue] = @settingvalue  WHERE [Section] ='AUTOID' AND [SettingKey] = @settingkey;
	END

END
GO
PRINT N'Creating [dbo].[spASRIntGetUserGroup]...';


GO
CREATE PROCEDURE [dbo].[spASRIntGetUserGroup]
	( 
	@psItemKey				varchar(50),
	@psUserGroup			varchar(250)	OUTPUT,
	@iSelfServiceUserType	integer			OUTPUT,
	@fSelfService			bit				OUTPUT
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sPermissionItemKey varchar(500),
		@iSSIntranetCount AS integer,
		@sIntranet_SelfService AS varchar(255),
		@sIntranet AS varchar(255);
	
	SET @psUserGroup = '';

	/* SET NOCOUNT ON added to prevent extra result sets from interfering with SELECT statements. */
	SET NOCOUNT ON;
	SET @psUserGroup = (SELECT CASE 
		WHEN (usg.uid IS null) THEN null
		ELSE usg.name
	END as groupname
	FROM sysusers usu 
	LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = SYSTEM_USER
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END IN (
				SELECT [groupName]
				FROM [dbo].[ASRSysGroupPermissions]
				WHERE itemID IN (
					SELECT [itemID]
					FROM [dbo].[ASRSysPermissionItems]
					WHERE categoryID = 1
					AND itemKey LIKE '%' + @psItemKey + '%'
				)  
				AND [permitted] = 1))
END

	SET @sIntranet = (SELECT itemKey FROM ASRSysPermissionItems inner join ASRSysGroupPermissions ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	WHERE ASRSysGroupPermissions.groupName = @psUserGroup and permitted = 1 and categoryID = 1
	and ASRSysPermissionItems.itemKey = 'INTRANET');
	
	SET @sIntranet_SelfService = (SELECT itemKey FROM ASRSysPermissionItems inner join ASRSysGroupPermissions ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	WHERE ASRSysGroupPermissions.groupName = @psUserGroup and permitted = 1 and categoryID = 1
	and ASRSysPermissionItems.itemKey = 'INTRANET_SELFSERVICE');
	
	SET @iSSIntranetCount = (SELECT count(*) FROM ASRSysPermissionItems inner join ASRSysGroupPermissions ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	WHERE ASRSysGroupPermissions.groupName = @psUserGroup and permitted = 1 and categoryID = 1
	and ASRSysPermissionItems.itemKey = 'SSINTRANET');
		
	IF (@sIntranet is null) and (@sIntranet_SelfService is null) and (@iSSINTRANETcount = 0)
	/* No permissions at all  */
	BEGIN
		SET @sPermissionItemKey = 'NO PERMS'
		SET @iSelfServiceUserType = 0
		SET @fSelfService = 0
	END
	
	IF @sIntranet = 'INTRANET'
	/* IF DMI Multi automatically*/ 
	BEGIN
		SET @sPermissionItemKey = 'INTRANET'
		SET @iSelfServiceUserType = 1
		SET @fSelfService = 0
	END
	
	IF (@sIntranet_SelfService = 'INTRANET_SELFSERVICE') and (@iSSIntranetCount = 0)
	/* IF DMI Single Only*/ 
	BEGIN
		SET @sPermissionItemKey = 'INTRANET'
		SET @iSelfServiceUserType = 2
		SET @fSelfService = 0
	END	
	
	IF (@sIntranet_SelfService = 'INTRANET_SELFSERVICE') and (@iSSIntranetCount = 1)
	/* IF DMI Single And SSI */ 
	BEGIN
		SET @sPermissionItemKey = 'SSINTRANET'
		SET @iSelfServiceUserType = 3
		SET @fSelfService = 1
	END	
	
	IF  @iSSIntranetCount = 1 and (@sIntranet is null and  @sIntranet_SelfService is null)
	/* IF SSI Only */ 
	BEGIN
		SET @sPermissionItemKey = 'SSINTRANET'
		SET @iSelfServiceUserType = 4
		SET @fSelfService = 1
	END

	IF (@sIntranet = 'INTRANET') and (@iSSIntranetCount = 1)
	/* IF DMI Multi and SSI */
	BEGIN
		SET @sPermissionItemKey = 'INTRANET'
		SET @iSelfServiceUserType = 5
		SET @fSelfService = 0
	END
GO
PRINT N'Creating [dbo].[spASRIntOrgChart]...';


GO
CREATE PROCEDURE [dbo].[spASRIntOrgChart] (@RootID int)
AS
BEGIN
       SET NOCOUNT ON;
       DECLARE @staff_number VARCHAR(MAX);
       DECLARE @today DATETIME = DATEADD(dd, 0, DATEDIFF(dd, 0,  getdate()));
 
       -- Fetch Absences from DB
       DECLARE @ids TABLE (id INT, TYPE VARCHAR(50), reason VARCHAR(50));
 
       INSERT @ids
       SELECT id_1, TYPE, reason FROM absence a WHERE a.Start_Date <= @today AND (End_Date >= @today OR isnull(End_Date, '') = '')
 
       -- Fetch Training bookings from DB
       DECLARE @trainingIDs TABLE (id INT, course_title VARCHAR(50))
       INSERT @trainingIDs
              SELECT id_1, course_title FROM Training_Booking
              WHERE Start_Date <= @today and (End_Date >= @today or ISNULL(End_Date, '') = '') 
 
       SELECT @staff_number = staff_number FROM Personnel_Records WHERE id=@RootID;
       
       WITH Emp_CTE AS (
              SELECT id, forenames, surname AS name, staff_number, line_Manager_staff_number, job_Title, 1 AS HierarchyLevel
                     FROM Personnel_Records
                     WHERE line_manager_staff_number = @staff_number
              UNION ALL
                     SELECT e.id, e.forenames, e.Surname, e.staff_number, e.Line_Manager_Staff_Number, e.Job_Title, ecte.HierarchyLevel + 1 AS HierarchyLevel
                     FROM Personnel_Records e
              INNER JOIN Emp_CTE ecte ON ecte.Staff_Number = e.Line_Manager_Staff_Number
       )
       
       SELECT p.*, a.type, a.reason, t.course_title FROM Emp_CTE p
       LEFT JOIN @ids a ON a.id = p.id
       LEFT JOIN @trainingIDs t ON t.id = p.ID
       ORDER BY hierarchylevel, Job_Title, name
END
GO
PRINT N'Creating [dbo].[spASRPostSystemSave]...';


GO
CREATE PROCEDURE [dbo].[spASRPostSystemSave]
AS
BEGIN

	IF OBJECT_ID('ASRSysProtectsCache') IS NOT NULL 
		DELETE FROM ASRSysProtectsCache;

	INSERT ASRSysProtectsCache 
	SELECT ID, Action, Columns, ProtectType , uid
       FROM sysprotects;

END
GO
PRINT N'Creating [dbo].[spASRSysUpdateFrameworkVersions]...';


GO
CREATE PROCEDURE [dbo].[spASRSysUpdateFrameworkVersions]
AS
BEGIN

	SET NOCOUNT ON

	DECLARE @clrversion varchar(255)

	BEGIN TRAN

	DELETE FROM ASRSysSystemSettings
	WHERE [Section] = '.NET Framework'
	AND [SettingKey] = 'CLR Version'
	
	SELECT @clrversion = dbo.udfASRNetCLRVersion()

	IF @@ERROR <> 0
	BEGIN
		RAISERROR(N'Unable to detect .NET Framework versions', 16, 1)
		ROLLBACK
	END
	ELSE
	BEGIN
		INSERT INTO ASRSysSystemSettings 
		VALUES ('.NET Framework','CLR Version',@clrversion)

		IF @@ERROR <> 0
		BEGIN
			RAISERROR(N'Unable to update .NET Framework versions', 16, 1)
			ROLLBACK
		END
		ELSE COMMIT TRAN
	END
	
	SET NOCOUNT OFF

END
GO
PRINT N'Altering [dbo].[sp_ASR_Bradford_CalculateDurations]...';


GO
ALTER PROCEDURE [dbo].[sp_ASR_Bradford_CalculateDurations]
(
	@pdReportStart	  	datetime,
	@pdReportEnd		datetime,
	@pcReportTableName	char(30)
)
AS
BEGIN

	SET NOCOUNT ON;

	declare @pdStartDate as datetime
	declare @pdEndDate as datetime
	declare @pcStartSession as char(2)
	declare @pcEndSession as char(2)

	declare @pfDuration as float
	declare @piID as integer
	declare @pfIncludedAmount as float
	declare @sSQL as varchar(MAX)
	declare @pbIncludedRecalculate as bit
	declare @pbTodaysDate as datetime

	/* Set an end date in the event of a blank one */
	set @pbTodaysDate = getDate()

	/* Open the passed in table */
	set @sSQL = 'DECLARE BradfordIndexCursor CURSOR FOR SELECT Start_Date, Start_Session, End_Date, End_Session, Personnel_ID,Duration FROM ' + @pcReportTableName + ' FOR UPDATE OF Included_Days, Duration'
	execute(@sSQL)
	open BradfordIndexCursor

	/* Loop through the records in the bradford report table */
	fetch next from BradfordIndexCursor into @pdStartDate, @pcStartSession, @pdEndDate, @pcEndSession, @piID, @pfDuration
	while @@fetch_status = 0
	begin
		/* Calculate start and end dates */
		Set @pbIncludedRecalculate = 0

		/* If empty end date fire off the absence duration calc with system date */
		if isdate(@pdEndDate) = 0
			begin
				execute sp_ASRFn_AbsenceDuration @pfIncludedAmount OUTPUT, @pdStartDate, @pcStartSession, @pbTodaysDate, 'PM', @piID
				set @sSQL = 'UPDATE ' + @pcReportTableName + ' SET Duration = ' + convert(char(10), @pfIncludedAmount) + ' WHERE CURRENT OF BradFordIndexCursor'
				execute(@sSQL)
				set @pdEndDate = @pbTodaysDate
				set @pbIncludedRecalculate = 1
			end

		/* Start date is before reporting period */
		if @pdStartDate < @pdReportStart
			begin
				set @pdStartDate = @pdReportStart
				set @pcStartSession = 'AM'
				set @pbIncludedRecalculate = 1
			end

		/* End date is outside the reporting period */
		if @pdEndDate > @pdReportEnd
			begin
				set @pdEndDate = @pdReportEnd
				set @pcEndSession = 'PM'
				set @pbIncludedRecalculate = 1
			end

		/* If outside of report period, recalculate */
		if @pbIncludedRecalculate = 1
			begin
				execute sp_ASRFn_AbsenceDuration @pfIncludedAmount OUTPUT, @pdStartDate, @pcStartSession, @pdEndDate, @pcEndSession, @piID
				set @sSQL = 'UPDATE ' + @pcReportTableName + ' SET Included_Days = ' + convert(char(10), @pfIncludedAmount) + ' WHERE CURRENT OF BradFordIndexCursor'
				execute(@sSQL)
			end

		/* Get next record */
		fetch next from BradfordIndexCursor into @pdStartDate, @pcStartSession, @pdEndDate, @pcEndSession, @piID, @pfDuration
	end

	close BradfordIndexCursor
	deallocate BradfordIndexCursor

END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateBulkBookings]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateBulkBookings] (
	@piCourseRecordID				integer,
	@psEmployeeRecordIDs			varchar(MAX),
	@psBookingStatus				varchar(MAX),
	@piResultCode					integer			OUTPUT,
	@psErrorMessage					varchar(MAX)	OUTPUT,
	@psWhoFailedPreReqCheck			varchar(MAX)	OUTPUT,
	@psWhoFailedUnavailabilityCheck	varchar(MAX)	OUTPUT,
	@psWhoFailedOverlapCheck		varchar(MAX)	OUTPUT,
	@psWhoFailedOverbookingCheck	varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks
	on booking being made. 
	Return codes are :
		0 - completely valid
		If non-zero then the result code is composed as abcd,
		where a is the result of the OVERBOOKING check
			b is the result of the PRE-REQUISITES check
			c is the result of the AVAILABILITY check
			d is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overbooking or overlapped bookings checks, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 0120.
	*/
	DECLARE	
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount					integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@iIndex					integer,
			@fFailure				bit,
			@sCurrentCode			varchar(1),
			@sCodeString			varchar(10),
			@iEmployeeID			integer,
			@fDoPreReqCheck			bit,
			@iPreReqTableID			integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sTemp					varchar(MAX),
			@piTableID				integer,
			@psRecordDescription	varchar(MAX),
			@psEmployeeName			varchar(MAX);

	SET @piResultCode = 0
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0
	SET @psErrorMessage = ''
	SET @psWhoFailedPreReqCheck = ''
	SET @psWhoFailedUnavailabilityCheck = ''
	SET @psWhoFailedOverlapCheck = ''
	SET @psWhoFailedOverbookingCheck = ''
	
	/* Clean the input string parameters. */
	IF len(@psEmployeeRecordIDs) > 0 SET @psEmployeeRecordIDs = replace(@psEmployeeRecordIDs, '''', '''''')

	/* Check if we need to do the overbooking check. */
	SELECT @sTemp = parameterValue
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseIncludeProvisionals'
	IF @psBookingStatus = 'B' OR @sTemp = 'TRUE'
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1
	END
	
	/* Check if we need to do the pre-requisite check. */
	SELECT @iPreReqTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_PreReqTable'
	IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

	IF @iPreReqTableID > 0 
	BEGIN
		/* Check if the pre-req stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoPreReqCheck = 1
	END

	/* Check if we need to do the unavailibility check. */
	SELECT @iUnavailTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_UnavailTable'
	IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

	IF @iUnavailTableID > 0 
	BEGIN
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckUnavailability')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
	END

	/* Check if we need to do the overlap check. */
	/* Check if the unavailibility stored procedure exists. */
	SELECT @iCount = COUNT(*) 
	FROM sysobjects
	WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
		AND sysstat & 0xf = 4
	
	IF @iCount > 0 SET @fDoOverlapCheck = 1

	/* Loop thourgh the given employee records. */
	SET @fFailure = 0
	SET @piResultCode = 0
	SET @iNumberBooked = 0

	WHILE len(@psEmployeeRecordIDs) > 0
	BEGIN
		/* Rip out the individual employee record ID from the given comma-delimited string of employee IDs. */
		SELECT @iIndex = charindex(',', @psEmployeeRecordIDs)
		IF @iIndex > 0
		BEGIN
			SET  @iEmployeeID = substring(@psEmployeeRecordIDs, 1, @iIndex - 1)
			SELECT @psEmployeeRecordIDs = substring(@psEmployeeRecordIDs, @iIndex + 1, len(@psEmployeeRecordIDs))
		END
		ELSE
		BEGIN
			SET  @iEmployeeID = @psEmployeeRecordIDs
			SET @psEmployeeRecordIDs = ''
		END

		BEGIN
			SET @piTableID = 1 /* Need to derive the Personnel table */
			EXECUTE dbo.spASRRecordDescription 1, @iEmployeeID, @psRecordDescription OUTPUT
			SET  @psEmployeeName = @psRecordDescription
		END

		SET @sCodeString = convert(varchar(10), @piResultCode)

		IF @fDoPreReqCheck = 1
		BEGIN
			IF LEN(@sCodeString) >= 3
			BEGIN
				SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 3), 1)
			END
			ELSE SET @sCurrentCode = 0
			
			IF @sCurrentCode <> '1'
			BEGIN
				/* Return 0 if the given record in the personnel table has satisfied the pre-requisite criteria for the given course record.
				Return 1 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record.
				Return 2 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record but the user can override this failure. */
				exec sp_ASR_TBCheckPreRequisites @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				IF @iResult = 1 
				BEGIN
					SET @psWhoFailedPreReqCheck = @psWhoFailedPreReqCheck 
						+ CASE
							WHEN len(@psWhoFailedPreReqCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END
				IF @iResult = 2 
				BEGIN
					SET @psWhoFailedPreReqCheck = @psWhoFailedPreReqCheck
						+ CASE
							WHEN len(@psWhoFailedPreReqCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END
				SET @piResultCode = @piResultCode - (100 * convert(integer, @sCurrentCode)) + (100 * @iResult)
			END
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
			IF len(@sCodeString) >= 2
			BEGIN 
				SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 2), 1)
			END
			ELSE SET @sCurrentCode = 0
			
			IF @sCurrentCode <> '1'
			BEGIN
				exec sp_ASR_TBCheckUnavailability @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				/* Return 0 if the given record in the personnel table IS available for the given course record.
				Return 1 if the given record in the personnel table is NOT available for the given course record.
				Return 2 if the given record in the personnel table is NOT available for the given course record but the user can override this failure. */
				IF @iResult = 1 
				BEGIN
					SET @psWhoFailedUnavailabilityCheck = @psWhoFailedUnavailabilityCheck
						+ CASE
							WHEN len(@psWhoFailedUnavailabilityCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END	
				IF @iResult = 2 
				BEGIN
					SET @psWhoFailedUnavailabilityCheck = @psWhoFailedUnavailabilityCheck
						+ CASE
							WHEN len(@psWhoFailedUnavailabilityCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END				
				ELSE 
				SET @piResultCode = @piResultCode - (10 * convert(integer, @sCurrentCode)) + (10 * @iResult)
			END
		END

		IF @fDoOverlapCheck = 1
		BEGIN
			IF len(@sCodeString) >= 1
			BEGIN
				SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 1), 1)
			END
			ELSE SET @sCurrentCode = 0

			IF @sCurrentCode <> '1'
			BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecordID,  @iEmployeeID, 0, @iResult OUTPUT
				  /* Return 0 if the given course does NOT overlap with another course that the given delegate is booked on.
				  Return 1 if the given course DOES overlap with another course that the given delegate is booked on.
				  Return 2 if the given course does NOT overlap with another course that the given delegate is booked on, but the user can override this failure. */
				IF @iResult = 1 
				BEGIN
					SET @psWhoFailedOverlapCheck = @psWhoFailedOverlapCheck
						+ CASE
							WHEN len(@psWhoFailedOverlapCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END
				IF @iResult = 2 
				BEGIN
					SET @psWhoFailedOverlapCheck = @psWhoFailedOverlapCheck
						+ CASE
							WHEN len(@psWhoFailedOverlapCheck) > 0 THEN ', '
							ELSE ''
						END 
						+ '"' + @psEmployeeName + '"'
				END
				SET @piResultCode = @piResultCode - convert(integer, @sCurrentCode) + @iResult
			END
		END

		SET @iNumberBooked = @iNumberBooked + 1
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		IF @iResult = 1 /* Course fully booked (error). */
		BEGIN
			SET @piResultCode = @piResultCode + 1000
		END
		IF @iResult = 2 /* Course fully booked (over-rideable by the user). */
		BEGIN
			SET @piResultCode = @piResultCode + 2000
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateTrainingBooking]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateTrainingBooking] (
	@piResultCode		integer OUTPUT,
	@piEmpRecID			integer,
	@piCourseRecID		integer,
	@psBookingStatus	varchar(MAX),
	@piTBRecID			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Perform the Training Booking validation on the given insert/update SQL string.
	Return codes are :
		0 - completely valid
		If non-zero then the result code is composed as abcd,
		where a is the result of the OVERBOOKING check
			b is the result of the PRE-REQUISITES check
			c is the result of the AVAILABILITY check
			d is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overbooking or overlapped bookings checks, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 0120.
	*/
	DECLARE @fOK				bit,
		@fIncludeProvisionals	bit,
		@sIncludeProvisionals	varchar(MAX),
		@iCount					integer,
		@iResult				integer,
		@iTemp					integer;

	SET @fOK = 1
	SET @piResultCode = 0

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'TRAINING', @fOK OUTPUT
		
	IF @fOK = 0
	BEGIN
		/* Do not perform any training Booking checks if the module is not licenced. */
		RETURN
	END

	IF (@piCourseRecID > 0) AND ((@psBookingStatus = 'B') OR (@psBookingStatus = 'P'))
	BEGIN  
		SELECT @sIncludeProvisionals = parameterValue
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseIncludeProvisionals'
		IF @sIncludeProvisionals IS NULL SET @sIncludeProvisionals = 'FALSE'
		IF @sIncludeProvisionals = 'FALSE'
		BEGIN
			SET @sIncludeProvisionals = 0
		END
		ELSE
		BEGIN
			SET @sIncludeProvisionals = 1
		END

		/* Only check that the selected course is not fully booked if the new booking is included in the number booked. */
		IF (@fIncludeProvisionals = 1) OR (@psBookingStatus = 'B') 
		BEGIN
			/* Check if the overbooking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverbooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverbooking @piCourseRecID, @piTBRecID, 1, @iResult OUTPUT

				IF @iResult = 1 /* Course fully booked (error). */
				BEGIN
					SET @piResultCode = @piResultCode + 1000
				END
				IF @iResult = 2 /* Course fully booked (over-rideable by the user). */
				BEGIN
					SET @piResultCode = @piResultCode + 2000
				END
			END
		END
      
		IF @piEmpRecID > 0
		BEGIN
			/* Check that the employee has satisfied the pre-requisite criteria for the selected course. */
			/* First check if the pre-requisite table is configured. If not, we do not need to do the pre-req check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_PreReqTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the pre-req stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckPreRequisites @piCourseRecID, @piEmpRecID, @iResult OUTPUT

					IF @iResult = 1 /* Pre-requisites not satisfied (error). */
					BEGIN
						SET @piResultCode = @piResultCode + 100
					END
					IF @iResult = 2 /* Pre-requisites not satisfied (over-rideable by the user). */
					BEGIN
						SET @piResultCode = @piResultCode + 200
					END 
				END
			END

			/* Check that the employee is available for the selected course. */
			/* First check if the unavailability table is configured. If not, we do not need to do the unavailability check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_UnavailTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the unavailability stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckUnavailability')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckUnavailability @piCourseRecID, @piEmpRecID, @iResult OUTPUT

					IF @iResult = 1 /* Employee unavailable (error). */
					BEGIN
						SET @piResultCode = @piResultCode + 10
					END
					IF @iResult = 2 /* Employee unavailable (over-rideable by the user). */
					BEGIN
						SET @piResultCode = @piResultCode + 20
					END 
				END
			END

			/* Check if the overlapped booking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecID, @piEmpRecID, @piTBRecID, @iResult OUTPUT
				IF @iResult = 1 /* Overlapped booking (error). */
				BEGIN
					SET @piResultCode = @piResultCode + 1
				END
				IF @iResult = 2 /* Overlapped booking (over-rideable by the user). */
				BEGIN
					SET @piResultCode = @piResultCode + 2
				END 
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetExprFunctions]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetExprFunctions] (
	@piTableID 		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimited runtime function definitions ;
	<function id><tab><function name><tab><function category> */
	DECLARE @fEnableUDFFunctions	bit,
		@fNewModuleCode			bit,
		@fAbsenceEnabled		bit,
		@iTemp 					integer,
		@iPersonnelTableID		integer,
		@iHierarchyTableID		integer,
		@iPostAllocationTableID	integer,
		@iIdentifyingColumnID	integer,
		@iReportsToColumnID		integer,
		@iLoginColumnID			integer,
		@iSecondLoginColumnID	integer,
		@fIsPostSubOfOK			bit,
		@fIsPostSubOfUserOK		bit,
		@fIsPersSubOfOK			bit,
		@fIsPersSubOfUserOK		bit,
		@fHasPostSubOK			bit,
		@fHasPostSubUserOK		bit,
		@fHasPersSubOK			bit,
		@fHasPersSubUserOK		bit,
		@fPostBased				bit, 
		@sSQLVersion			integer,
		@fBaseTablePersonnelOK	bit;

	SET @fEnableUDFFunctions = 0;
	SET @fIsPostSubOfOK = 0;
	SET @fIsPostSubOfUserOK = 0;
	SET @fIsPersSubOfOK = 0;
	SET @fIsPersSubOfUserOK = 0;
	SET @fHasPostSubOK = 0;
	SET @fHasPostSubUserOK = 0;
	SET @fHasPersSubOK = 0;
	SET @fHasPersSubUserOK = 0;
	SET @fPostBased = 0;
	SET @fBaseTablePersonnelOK = 0;
	
	SELECT @sSQLVersion = dbo.udfASRSQLVersion();

	IF @sSQLVersion >= 8
	BEGIN  
		SET @fEnableUDFFunctions = 1;
		
		SELECT @iPersonnelTableID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_PERSONNEL' 
			AND parameterKey = 'Param_TablePersonnel';

		SELECT @iHierarchyTableID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_HIERARCHY' 
			AND parameterKey = 'Param_TableHierarchy';

		SELECT @iIdentifyingColumnID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_HIERARCHY' 
			AND parameterKey = 'Param_FieldIdentifier';

		SELECT @iReportsToColumnID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_HIERARCHY' 
			AND parameterKey = 'Param_FieldReportsTo';

		SELECT @iPostAllocationTableID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_HIERARCHY' 
			AND parameterKey = 'Param_TablePostAllocation';

		SELECT @iLoginColumnID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_PERSONNEL' 
			AND parameterKey = 'Param_FieldsLoginName';

		SELECT @iSecondLoginColumnID = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup 
		WHERE moduleKey = 'MODULE_PERSONNEL' 
			AND parameterKey = 'Param_FieldsSecondLoginName';

		IF (@iLoginColumnID = 0) AND (@iSecondLoginColumnID > 0)
		BEGIN
			SET @iLoginColumnID = @iSecondLoginColumnID;
			SET @iSecondLoginColumnID = 0;
		END

		IF @iPersonnelTableID <> @iHierarchyTableID SET @fPostBased = 1;
		IF @iPersonnelTableID = @piTableID 
		BEGIN
			IF (@iIdentifyingColumnID > 0) AND
				(@iReportsToColumnID > 0) AND
				((@fPostBased = 0) OR (@iPersonnelTableID > 0)) AND
				((@fPostBased = 0) OR (@iPostAllocationTableID > 0)) 
			BEGIN
				SET @fIsPersSubOfOK = 1;
				SET @fHasPersSubOK = 1;
			END
			IF (@iIdentifyingColumnID > 0) AND
				(@iReportsToColumnID > 0) AND
				(@iPersonnelTableID > 0) AND
				(@iLoginColumnID > 0) AND
				((@fPostBased = 0) OR (@iPostAllocationTableID > 0)) 
			BEGIN
				SET @fIsPersSubOfUserOK = 1;
				SET @fHasPersSubUserOK = 1;
			END
		END
				
		IF @iHierarchyTableID = @piTableID 
		BEGIN
			IF (@iIdentifyingColumnID > 0) AND
				(@iReportsToColumnID > 0) AND
				(@fPostBased = 1)
			BEGIN
				SET @fIsPostSubOfOK = 1;
				SET @fHasPostSubOK = 1;
			END
			IF (@iIdentifyingColumnID > 0) AND
				(@iReportsToColumnID > 0) AND
				(@iPersonnelTableID > 0) AND
				(@iLoginColumnID > 0) AND
				(@fPostBased = 1) AND
				(@iPostAllocationTableID > 0)
			BEGIN
				SET @fIsPostSubOfUserOK = 1;
				SET @fHasPostSubUserOK = 1;
			END
		END
		IF @iPersonnelTableID = @piTableID 
		BEGIN
			SET @fBaseTablePersonnelOK = 1;
		END
		ELSE
		BEGIN
			SELECT @iTemp = COUNT(*)
			FROM ASRSysRelations
			WHERE parentID = @iPersonnelTableID
				AND childID = @piTableID;
			IF @iTemp > 0
			BEGIN
				SET @fBaseTablePersonnelOK = 1;
			END
		END
	END

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'ABSENCE', @fAbsenceEnabled OUTPUT
	SELECT 
		convert(varchar(255), functionID) + char(9) +
		functionName + 
		CASE 
			WHEN len(shortcutKeys) > 0 THEN ' ' + shortcutKeys
			ELSE ''
		END + char(9) +
		category AS [definitionString]
	FROM ASRSysFunctions
	WHERE ((runtime = 1)	
			OR ((UDF = 1) AND (@fEnableUDFFunctions = 1)))
		AND ((functionID <> 65) OR (@fIsPostSubOfOK = 1))
		AND ((functionID <> 66) OR (@fIsPostSubOfUserOK = 1))
		AND ((functionID <> 67) OR (@fIsPersSubOfOK = 1))
		AND ((functionID <> 68) OR (@fIsPersSubOfUserOK = 1))
		AND ((functionID <> 69) OR (@fHasPostSubOK = 1))
		AND ((functionID <> 70) OR (@fHasPostSubUserOK = 1))
		AND ((functionID <> 71) OR (@fHasPersSubOK = 1))
		AND ((functionID <> 72) OR (@fHasPersSubUserOK = 1))
		AND ((functionID <> 30) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 46) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 47) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 73) OR ((@fBaseTablePersonnelOK = 1) AND (@fAbsenceEnabled = 1)));
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetMinimumPasswordLength]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetMinimumPasswordLength] (
	@piMinPassordLength	integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the minimum password length. */
	DECLARE 
		@sValue				varchar(MAX),
		@fNewSettingFound	bit,
		@fOldSettingFound	bit;

	/* Get the minimum password length. */
	SET @piMinPassordLength = 0;
	exec sp_ASRIntGetSystemSetting 'password', 'minimum length', 'minimumPasswordLength', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT;
	IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
	BEGIN
		SET @piMinPassordLength = convert(integer, @sValue);
	END

	IF @piMinPassordLength IS NULL SET @piMinPassordLength = 0;
END
GO
PRINT N'Altering [dbo].[spASREmailImmediate]...';


GO
ALTER PROCEDURE [dbo].[spASREmailImmediate]
	(@Username varchar(255))
AS
	BEGIN
		DECLARE @QueueID int,
				@LinkID int,
				@RecordID int,
				@sSQL nvarchar(max),
				@DateDue datetime,
				@hResult int,
				@TableID int,
				@tmpUser varchar(255),
				@RecalculateRecordDesc int,
				@AttachmentFolder varchar(max)

		DECLARE @TempText nvarchar(max),
				@To varchar(max),
				@CC varchar(max),
				@BCC varchar(max),
				@Subject varchar(max),
				@MsgText varchar(max),
				@Attachment varchar(max)

		SET @AttachmentFolder = ''
		SELECT @AttachmentFolder = settingvalue
		FROM asrsyssystemsettings
		WHERE [section] = 'email' and [settingkey] = 'attachment path'

		DECLARE emailqueue_cursor
		CURSOR LOCAL FAST_FORWARD FOR 
		  SELECT ASRSysEmailQueue.QueueID
			   , ASRSysEmailQueue.LinkID
			   , ASRSysEmailQueue.RecordID
			   , ASRSysEmailQueue.TableID
			   , ASRSysEmailQueue.DateDue
			   , ASRSysEmailQueue.UserName
			   , ASRSysEmailQueue.RecalculateRecordDesc
			   , ASRSysEmailQueue.RepTo
               , ASRSysEmailQueue.RepCC
               , ASRSysEmailQueue.RepBCC
               , ASRSysEmailQueue.[Subject]
               , ASRSysEmailQueue.MsgText
               , ASRSysEmailQueue.Attachment
          FROM ASRSysEmailQueue
		  LEFT OUTER JOIN
				 ASRSysEmailLinks
			  ON ASRSysEmailLinks.LinkID = ASRSysEmailQueue.LinkID
		  WHERE  DateSent IS Null
			AND  datediff(dd,DateDue,getdate()) >= 0
			AND  (LOWER(substring(@Username,charindex('\',@Username)+1,999)) = LOWER(substring([Username],charindex('\',[Username])+1,999))
				  OR @Username = ''
				  )
		  ORDER BY dateDue

		OPEN emailqueue_cursor
		FETCH NEXT FROM emailqueue_cursor INTO @QueueID, @LinkID, @RecordID, @TableID, @DateDue, @tmpUser, @RecalculateRecordDesc, @To, @CC, @BCC, @Subject, @MsgText, @Attachment

		WHILE (@@fetch_status = 0)
		BEGIN

			SET @hResult = 0
			IF @RecalculateRecordDesc = 1 OR rtrim(isnull(@To,'')) = ''
			BEGIN
				SELECT @sSQL = 'spASREmail_' + convert(varchar,@LinkID)
				IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = @sSQL)
				BEGIN
					EXEC @hResult = @sSQL @queueid, @recordid, @tmpUser, @To OUTPUT, @CC OUTPUT, @BCC OUTPUT, @Subject OUTPUT, @MsgText OUTPUT, @Attachment OUTPUT
				END
			END

			IF @hResult = 0 AND RTrim(@To) <> ''
			BEGIN
				IF @Attachment <> '' SET @Attachment = @AttachmentFolder+@Attachment
				EXEC spASRSendMail @hResult OUTPUT, @To, @CC, @BCC, @Subject, @MsgText, @Attachment
				IF @hResult = 0
					UPDATE ASRSysEmailQueue
					SET DateSent = getdate(), RecalculateRecordDesc = 0
					WHERE QueueID = @QueueID
			END

			FETCH NEXT FROM emailqueue_cursor INTO @QueueID, @LinkID, @RecordID, @TableID, @DateDue, @tmpUser, @RecalculateRecordDesc, @To, @CC, @BCC, @Subject, @MsgText, @Attachment
		END

		CLOSE emailqueue_cursor
		DEALLOCATE emailqueue_cursor

	END
GO
PRINT N'Altering [dbo].[spASREmailRebuild]...';


GO
ALTER PROCEDURE [dbo].[spASREmailRebuild]
AS
BEGIN	
	/* Refresh all calculated columns in the database. */
	DECLARE @sTableName 	varchar(255),
		@iTableID			integer,
		@sSQL				nvarchar(MAX),
		@sColumnName		varchar(255);

	
	/* Get a cursor of the tables in the database. */
	DECLARE curTables CURSOR FOR
		SELECT tableName, tableID
		FROM ASRSysTables
	OPEN curTables;

	DELETE FROM ASRSysEmailQueue WHERE DateSent Is Null AND [Immediate] = 0;

	/* Loop through the tables in the database. */
	FETCH NEXT FROM curTables INTO @sTableName, @iTableID;
	WHILE @@fetch_status <> -1
	BEGIN
		/* Get a cursor of the records in the current table.  */
		/* Call the diary trigger for that table and record  */
		SET @sSQL = 'DECLARE @iCurrentID	int,
						@sSQL		nvarchar(MAX);
					
					IF EXISTS (SELECT * FROM sysobjects
					WHERE id = object_id(''spASREmailRebuild_' + LTrim(Str(@iTableID)) + ''') 
						AND sysstat & 0xf = 4)
					BEGIN
						DECLARE curRecords CURSOR FOR
						SELECT id
						FROM ' + @sTableName + ';
		
						OPEN curRecords;
		
						FETCH NEXT FROM curRecords INTO @iCurrentID;
						WHILE @@fetch_status <> -1
						BEGIN
							PRINT ''ID : '' + Str(@iCurrentID);
							SET @sSQL = ''EXEC spASREmailRebuild_' + LTrim(Str(@iTableID)) 
								+ ' '' + convert(varchar(100), @iCurrentID) + '''';
							EXECUTE sp_executeSQL @sSQL;
		
							FETCH NEXT FROM curRecords INTO @iCurrentID;
						END
						CLOSE curRecords;
						DEALLOCATE curRecords;
					END';
		 EXECUTE sp_executeSQL @sSQL;

		/* Move onto the next table in the database. */ 
		FETCH NEXT FROM curTables INTO @sTableName, @iTableID;
	END

	CLOSE curTables;
	DEALLOCATE curTables;

	EXEC [dbo].spASREmailImmediate '';

END
GO
PRINT N'Altering [dbo].[spASRIntGetActualUserDetails]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetActualUserDetails]
(
		@psUserName sysname OUTPUT,
		@psUserGroup sysname OUTPUT,
		@piUserGroupID integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound				integer,
		@sSQLVersion			integer,
		@sProgramName			varchar(500),
		@sPermissionItemKey		varchar(500),
		@psItemKey				varchar(50),
		@iSelfServiceUserType	integer,
		@fSelfService			bit;

	SET @psUserGroup = '';
	SET @sPermissionItemKey = '';
	SET @sProgramName = '';
	SET @iSelfServiceUserType = 0;
	SET @psItemKey = 'INTRANET';
	
	EXEC	[dbo].[spASRIntGetUserGroup]
			@psItemKey = 'INTRANET',
			@psUserGroup = @psUserGroup OUTPUT,
			@iSelfServiceUserType = @iSelfServiceUserType OUTPUT,
			@fSelfService = @fSelfService OUTPUT

	IF @psUserGroup IS NULL
	BEGIN
		SET @sPermissionItemKey = 'NO PERMS'
	END

	SET @sSQLVersion = convert(int,convert(float,substring(@@version,charindex('-',@@version)+2,2)))

	SELECT @iFound = COUNT(*) 
	FROM sysusers usu 
	LEFT OUTER JOIN	(sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = system_user
		AND CASE
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
		END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'

	IF (@iFound > 0)
	BEGIN
		SELECT	@psUserName = usu.name,
			@psUserGroup = CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND lo.loginname = system_user
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END IN (
					SELECT [groupName]
					FROM [dbo].[ASRSysGroupPermissions]
					WHERE itemID IN (
									SELECT [itemID]
									FROM [dbo].[ASRSysPermissionItems]
									WHERE categoryID = 1
									AND itemKey LIKE @sPermissionItemKey + '%'
								)  
					AND [permitted] = 1
	)			
	END
	ELSE
	BEGIN
		SELECT @psUserName = usu.name, 
			@psUserGroup = CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND is_member(lo.loginname) = 1
			AND CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END IN (
					SELECT [groupName]
					FROM [dbo].[ASRSysGroupPermissions]
					WHERE itemID IN (
														SELECT [itemID]
														FROM [dbo].[ASRSysPermissionItems]
														WHERE categoryID = 1
														AND itemKey LIKE @sPermissionItemKey + '%'
													)  
					AND [permitted] = 1
	)
	END

	IF @psUserGroup <> ''
	BEGIN
		DELETE FROM [ASRSysUserGroups] 
		WHERE [UserName] = SUSER_NAME()

		INSERT INTO [ASRSysUserGroups] 
		VALUES 
		(
			CASE
				WHEN @sSQLVersion <= 8 THEN USER_NAME()
				ELSE SUSER_NAME()
			END,
			@psUserGroup
		)
	END
END
GO
PRINT N'Altering [dbo].[spASRIntGetChartData]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetChartData] (
	--@piHistoryTableID	integer,
	@piParentTableID 	integer,
--	@piParentRecordID	integer,
	@piColumnId integer,
	@piAggregateType integer
)
AS
BEGIN
	SET NOCOUNT ON;
	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sRootTable 		varchar(255),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sTemp				varchar(MAX),
		@sSelectSQL			nvarchar(MAX),
		@sActualUserName	sysname,
		@strTempSepText		varchar(500);
	SET @sSelectSQL = '';
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID;
	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName	sysname);
	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @columnPermissions TABLE (tableViewName	sysname,
				columnName	sysname,
				granted		bit);
	-- Cached view of SysProtects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000));
	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN
		
			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysColumns ac
												WHERE ac.TableID = @piParentTableID);
			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM SysProtects
				WHERE Action = 193;
			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0));
		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sParentRealSource = left(@sParentRealSource, 255);
			END
			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM ASRSysProtectsCache
				WHERE [UID] = @iUserGroupID AND Action = 193;
			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END
	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	
	/*populate the temp table with info from ssi - i.e. chart column details*/
	
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	--SELECT ASRSysColumns.columnId, 
	--	ASRSysColumns.columnName, 
	--	ASRSysColumns.dataType
	--FROM ASRSysSummaryFields 
	--INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	--WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
	--	AND ASRSysColumns.tableID = @piParentTableID 
	--ORDER BY ASRSysSummaryFields.sequence;
	SELECT ASRSysColumns.columnId, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysColumns
	WHERE ASRSysColumns.ColumnID = @piColumnID;
		
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		
		SET @fSelectGranted = 0;
		/* Get the select permission on the column. */
		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @ColumnPermissions
		WHERE tableViewName = @sParentTableName
			AND columnName = @sColumnName;
		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			SET @sTemp = ',';
			IF LEN(@sSelectSQL) > 0
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101) AS [COLUMN]';
				IF @piAggregateType = 0	/* Aggregate = Count */
				BEGIN
					SET @sTemp = @sTemp + ', count(convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101)) as [Aggregate]'
				END
				ELSE	/* Aggregate = Total */
				BEGIN
					SET @sTemp = @sTemp + ', sum(convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101)) as [Aggregate]'
				END
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END 
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sParentTableName + '.' + @sColumnName + ' AS [COLUMN]';
				IF @piAggregateType = 0	/* Aggregate = Count */
				BEGIN
					SET @sTemp = @sTemp + ', count(' + @sParentTableName + '.' + @sColumnName + ') as [Aggregate]'
				END
				ELSE	/* Aggregate = Total */
				BEGIN
					SET @sTemp = @sTemp + ', sum(' + @sParentTableName + '.' + @sColumnName + ') as [Aggregate]'
				END
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END
			/* Add the table to the array of tables/views to join if it has not already been added. */
			SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sParentTableName;
			IF @iTempCount = 0
			BEGIN
				INSERT INTO @joinParents (tableViewName) VALUES(@sParentTableName);
			END
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';
			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @ColumnPermissions
			WHERE tableViewName <> @sParentTableName
				AND columnName = @sColumnName
				AND granted = 1;
			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;
				IF len(@sSelectString) > 0 SET @sSelectString = @sSelectString + ',';
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					SET @sSelectString = @sSelectString + 'convert(varchar(10),' + @sViewName + '.' + @sColumnName + ',101)';
					IF @piAggregateType = 0	/* Aggregate = Count */
					BEGIN
						SET @sSelectString = @sSelectString + ', count(convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)) as [Aggregate]'
					END
					ELSE	/* Aggregate = Total */
					BEGIN
						SET @sSelectString = @sSelectString + ', sum(convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)) as [Aggregate]'
					END
				END
				ELSE
				BEGIN
					SET @sSelectString = @sSelectString + @sViewName + '.' + @sColumnName;
					IF @piAggregateType = 0	/* Aggregate = Count */
					BEGIN
						SET @sSelectString = @sSelectString + ', count(' + @sViewName + '.' + @sColumnName + ') as [Aggregate]'
					END
					ELSE	/* Aggregate = Total */
					BEGIN
						SET @sSelectString = @sSelectString + ', sum(' + @sViewName + '.' + @sColumnName + ') as [Aggregate]'
					END
				END
				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName;
				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);
				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;
			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = 'COALESCE(' + @sSelectString + ', NULL) AS [COLUMN]';
				SET @sTemp = ',';
				IF LEN(@sSelectSQL) > 0
					SET @sSelectSQL = @sSelectSQL + @sTemp;
				SET @sTemp = @sSelectString;
				SET @sSelectSQL = @sSelectSQL + @sTemp;
				
			END
		END
		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;
	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = 'SELECT ' + @sSelectSQL ;
		SELECT @iTempCount = COUNT(tableViewName)
			FROM @joinParents;
		IF @iTempCount = 1 
		BEGIN
			SELECT TOP 1 @sRootTable = tableViewName
			FROM @joinParents;
		END
		ELSE
		BEGIN
			SET @sRootTable = @sParentTableName;
		END
		--SET @sTemp = ', row_number()  over ( order by ' +@sViewName + '.' + @sColumnName + ') as ROW_NUMBER FROM ' + @sRootTable;
		SET @sTemp = ' FROM ' + @sRootTable;
		SET @sSelectSQL = @sSelectSQL + @sTemp;
		/* Add the join code. */
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @joinParents;
		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sTableViewName <> @sRootTable
			BEGIN
				SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRootTable + '.ID' + ' = ' + @sTableViewName + '.ID';
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END
			FETCH NEXT FROM joinCursor INTO @sTableViewName;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;
--		SET @sTemp = ' WHERE ' + @sRootTable + '.id = ' + convert(varchar(255), @piParentRecordID);
--		SET @sSelectSQL = @sSelectSQL + @sTemp;
		
		SET @sTemp = ' GROUP BY ' + @sRootTable + '.' + @sColumnName;
		SET @sSelectSQL = @sSelectSQL + @sTemp;
		
	END
	-- Run the constructed SQL SELECT string.
	EXEC sp_executeSQL @sSelectSQL;
END
GO
PRINT N'Altering [dbo].[spASRIntGetLookupFilterValue]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetLookupFilterValue] (
	@piScreenID			integer,
	@piColumnID			integer,
	@piTableID			integer,
	@piViewID			integer,
	@piRecordID			integer,
	@psFilterValue		varchar(MAX)	OUTPUT,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@pfError 			bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iLookupFilterValueID	integer,
		@sRealSource			sysname,
		@sLookupFilterValueName	sysname,
		@iCount					integer,
		@iTableType				integer,
		@sTableName				sysname,
		@iChildViewID			integer,
		@sUserGroupName			sysname,
		@iUserGroupID			integer,
		@sSQL					nvarchar(MAX),
		@sSQLParam				nvarchar(500),
		@dblResult				float,
		@fResult				bit,
		@dtResult				datetime,
		@sResult				varchar(MAX),
		@iDataType				integer,
		@sActualUserName		sysname,
		@iDfltValueExprID		integer,
		@sDefaultValue			varchar(MAX),
		@lngParentTableID		integer;

	SET @psFilterValue = '';
	SET @pfError = 0;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
					
	SET @psFilterValue = '';

	SELECT @iLookupFilterValueID = lookupFilterValueID
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @piColumnID;

	IF @iLookupFilterValueID IS null SET @iLookupFilterValueID = 0;

	IF @iLookupFilterValueID > 0 
	BEGIN
		/* Check if the looup filter value column is in the screen. If so, we don't need to find it again. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysControls]
		WHERE screenID = @piScreenID
			AND columnId = @iLookupFilterValueID;

		IF @iCount = 0 
		BEGIN
			IF @piRecordID = 0
			BEGIN
				/* New record. */
				SELECT @iDfltValueExprID = dfltValueExprID, 
					@sDefaultValue = defaultValue, 
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;

				IF @iDfltValueExprID IS null SET @iDfltValueExprID = 0;
				IF @sDefaultValue IS null SET @sDefaultValue = '';
				IF @iDataType IS null SET @iDataType = 0;

				IF @iDfltValueExprID > 0
				BEGIN
					/* Calculated value as the default. */
					SELECT @iCount = COUNT(*)
					FROM sysobjects
					WHERE id = object_id(N'sp_ASRDfltExpr_' + convert(sysname, @iDfltValueExprID))
					AND OBJECTPROPERTY(id, N'IsProcedure') = 1;

					IF @iCount > 0
					BEGIN
						SET @sSQL = 'EXEC sp_ASRDfltExpr_' + convert(nvarchar(100), @iDfltValueExprID) + ' @result OUTPUT';

						DECLARE parents_cursor CURSOR LOCAL FAST_FORWARD FOR 
							SELECT parentID
							FROM ASRSysRelations
							WHERE childID = @piTableID
							ORDER BY parentID;

						OPEN parents_cursor;
						FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						WHILE (@@fetch_status = 0)
						BEGIN
						    IF @lngParentTableID = @piParentTableID
							BEGIN
								SET @sSQL = @sSQL + ',' + convert(nvarchar(100), @piParentRecordID);
							END
							ELSE
							BEGIN
								SET @sSQL = @sSQL + ',0' ;
							END

							FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						END
						CLOSE parents_cursor;
						DEALLOCATE parents_cursor;

						IF @iDataType = -7 /* Boolean */
						BEGIN
							SET @sSQLParam = N'@result integer OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

							SET @psFilterValue = 
								CASE 
									WHEN @fResult = 0 THEN 'False'
									ELSE 'True'
								END;
						END

						IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
						BEGIN
							SET @sSQLParam = N'@result float OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

							SET @psFilterValue = convert(varchar(MAX), @dblResult);
						END

						IF (@iDataType = 11) /* Date */
						BEGIN
							SET @sSQLParam = N'@result datetime OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT

							SET @psFilterValue = convert(varchar(MAX), @dtResult, 101);
						END

						IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working pattern, photo*/
						BEGIN
							SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

							SET @psFilterValue = @sResult;
						END
					END
				END
				ELSE
				BEGIN
					SET @psFilterValue = @sDefaultValue;
				END
			END
			ELSE
			BEGIN
				SELECT @sTableName = tableName,
					@iTableType = tableType
				FROM [dbo].[ASRSysTables]
				WHERE tableID = @piTableID;

				IF @iTableType <> 2 /* ie. top-level or lookup */
				BEGIN
					IF @piViewID > 0 
					BEGIN	
						/* RealSource is the view. */	
						SELECT @sRealSource = viewName
						FROM [dbo].[ASRSysViews]
						WHERE viewID = @piViewID;
					END
					ELSE
					BEGIN
						SET @sRealSource = @sTableName;
					END 
				END
				ELSE
				BEGIN
					SELECT @iChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @piTableID
						AND [role] = @sUserGroupName;
						
					IF @iChildViewID IS null SET @iChildViewID = 0;
						
					IF @iChildViewID > 0 
					BEGIN
						SET @sRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iChildViewID) +
							'#' + replace(@sTableName, ' ', '_') +
							'#' + replace(@sUserGroupName, ' ', '_');
						SET @sRealSource = left(@sRealSource, 255);
					END
				END
	
				SELECT @sLookupFilterValueName = columnName,
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;
	
				/* Check the filter column can be read from the given table/view. */
				SELECT @iCount = COUNT(*)
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND ((sysprotects.protectType = 204) OR (sysprotects.protectType = 205))
					AND syscolumns.name = @sLookupFilterValueName
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

				IF @iCount > 0 
				BEGIN
					/* Can read the column from the realSource */
					SET @sSQL = 'SELECT @result = ' + @sLookupFilterValueName 
						+ ' FROM ' + @sRealSource
						+ ' WHERE id = ' + convert(nvarchar(100), @piRecordID);

					IF @iDataType = -7 /* Boolean */
					BEGIN
						SET @sSQLParam = N'@result integer OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

						SET @psFilterValue = 
							CASE 
								WHEN @fResult = 0 or @fResult is null THEN 'False'
								ELSE 'True'
							END;
					END

					IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
					BEGIN
						SET @sSQLParam = N'@result float OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dblResult);
					END

					IF (@iDataType = 11) /* Date */
					BEGIN
						SET @sSQLParam = N'@result datetime OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dtResult, 101);
					END

					IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working patter, photo*/
					BEGIN
						SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

						SET @psFilterValue = @sResult;
					END
				END
				ELSE
				/* Column cannot be read from view */
				SET @pfError = 1;
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRIntGetParentValues]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetParentValues] (
	@piScreenID 		integer,
	@piParentTableID 	integer,
	@piParentRecordID 	integer
)
AS
BEGIN
	
	SET NOCOUNT ON;
	
	/* Return a recordset of the parent record values required for controls in the given screen. */
	DECLARE 
		@iUserGroupID		integer,
		@sRoleName			sysname,
		@iTempCount 		integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iParentChildViewID	integer,
		@sParentRealSource	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@sNewBit			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sParentSelectSQL	nvarchar(MAX),
		@sTemp				varchar(MAX),
		@fColumns			bit,
		@sSQL				nvarchar(MAX),
		@sActualUserName	sysname;

	SET @sParentSelectSQL  = 'SELECT ';
	SET @fColumns = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(tableViewName	sysname,
		columnName	sysname,
		granted		bit);

	SELECT @iTempCount = COUNT(*)
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysControls.columnID = ASRSysColumns.columnId
		AND ASRSysColumns.tableID = @piParentTableID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0;

	IF @iTempCount = 0 RETURN;

	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables
		WHERE tableID = @piParentTableID;

	IF @iParentTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			sysobjects.name,
			syscolumns.name,
			CASE p.protectType
			        	WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		WHERE p.UID = @iUserGroupID
			AND p.action = 193 
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piParentTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piParentTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SET @sParentRealSource = @sParentTableName;
	END
	ELSE
	BEGIN
		/* Get permitted child view on the parent table. */
		SELECT @iParentChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piParentTableID
			AND role = @sRoleName;
				
		IF @iParentChildViewID IS null SET @iParentChildViewID = 0;
				
		IF @iParentChildViewID > 0 
		BEGIN
			SET @sParentRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iParentChildViewID) +
				'#' + replace(@sParentTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sParentRealSource = left(@sParentRealSource, 255);

			INSERT INTO @columnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0
		AND ASRSysColumns.tableID = @piParentTableID;
	
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
	
		/* Get the select permission on the column. */
		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @columnPermissions
		WHERE tableViewName = @sParentRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			IF @fColumns = 1
			BEGIN
				SET @sTemp = ',';
				SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
			END

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sNewBit = 'convert(varchar(10), ' + @sParentRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sNewBit = @sParentRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
			END

			SET @fColumns = 1;
			SET @sParentSelectSQL = @sParentSelectSQL + @sNewBit;
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @columnPermissions
			WHERE tableViewName <> @sParentRealSource
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';

				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
				END

				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);
				END

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = @sSelectString +
					' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

				IF @fColumns = 1
				BEGIN
					SET @sTemp = ',';
					SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
				END

				SET @fColumns = 1;
				SET @sParentSelectSQL = @sParentSelectSQL + @sSelectString;
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF @fColumns = 0 RETURN;

	SET @sTemp = ' FROM ' + @sParentRealSource;
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName
	FROM @joinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sParentRealSource + '.ID = ' + @sTableViewName + '.ID';
		SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

		FETCH NEXT FROM joinCursor INTO @sTableViewName;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SET @sTemp = ' WHERE ' + @sParentRealSource + '.ID = ' + convert(varchar(100), @piParentRecordID);
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	EXECUTE sp_executeSQL @sParentSelectSQL;
	
END
GO
PRINT N'Altering [dbo].[spASRIntGetQuickFindRecord]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetQuickFindRecord] (
	@plngTableID		integer,
	@plngViewID			integer,
	@plngColumnID		integer,
	@psValue			varchar(MAX),
	@psFilterDef		varchar(MAX),
	@plngRecordID		integer			OUTPUT,
	@psDecimalSeparator	varchar(100),
	@psLocaleDateFormat	varchar(100)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@lngTableID			integer,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sRealSource 		varchar(255),
		@sTableName 		varchar(255),
		@iTableType			integer,
		@iChildViewID		integer,
		@sActualUserName	sysname,
		@sColumnName		sysname,
		@iDataType			integer,
		@iResult			integer,
		@sSQL1				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fPermitted			bit,
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sSubFilterSQL		nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psValue) > 0 SET @psValue = replace(@psValue, '''', '''''')

	SET @plngRecordID = 0
	SET @sFilterSQL = ''

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @plngViewID
	END

	/* Get the table-type. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @lngTableID

	/* Get the column name. */
	SELECT @sColumnName = columnName,
		@iDataType = dataType
	FROM ASRSysColumns
	WHERE columnID = @plngColumnID
	
	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'
	END

	/* Get the real source of the given screen's table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @plngViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @plngViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		/* Get appropriate child view if required. */
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @lngTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	/* Check the user has permission to read the column. */
	SET @fPermitted = 1
	IF @fSysSecMgr = 0
	BEGIN
		SELECT @iResult = COUNT(*)
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		WHERE sysprotects.uid = @iUserGroupID
			AND sysprotects.action = 193 
			AND syscolumns.name = @sColumnName
			AND sysobjects.name = @sRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		
		IF @iResult = 0 SET @fPermitted = 0
	END
	
	IF @fPermitted = 1
	BEGIN
		/* Construct the SQL query for getting the record. */
		SET @sSQL1 = 'SELECT @result = id' +
			' FROM ' + @sRealSource +
			' WHERE ' + @sColumnName 
			
		IF (@iDataType = 11) AND len(@psValue) = 0
		BEGIN
			/* Date column - handle nulls */
			SET @sSQL1 = @sSQL1 +
				' IS null'
		END
		ELSE
		BEGIN
			SET @sSQL1 = @sSQL1 +	' = '
			IF ((@iDataType = 11) OR (@iDataType = 12)) SET @sSQL1 = @sSQL1 + ''''
			SET @sSQL1 = @sSQL1 + @psValue
			IF ((@iDataType = 11) OR (@iDataType = 12)) SET @sSQL1 = @sSQL1 + ''''
		END
	
		IF len(@psFilterDef)> 0 
		BEGIN
			WHILE charindex('	', @psFilterDef) > 0
			BEGIN
				SET @sSubFilterSQL = ''

				SET @iIndex1 = charindex('	', @psFilterDef)
				SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1)
				SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1)
				
				SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1))
				SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1))
				SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1)
				
				SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3)

				SELECT @iDataType = dataType,
					@sColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @iColumnID
								
				SET @sColumnName = @sRealSource + '.' + @sColumnName

				IF (@iDataType = -7) 
				BEGIN
					/* Logic column (must be the equals operator).	*/
					SET @sSubFilterSQL = @sColumnName + ' = '
				
					IF UPPER(@sValue) = 'TRUE'
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + '1'
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + '0'
					END
				END

				IF ((@iDataType = 2) OR (@iDataType = 4)) 
				BEGIN
					/* Numeric/Integer column. */
					/* Replace the locale decimal separator with '.' for SQL's benefit. */
					SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.')

					IF (@iOperatorID = 1) 
					BEGIN
						/* Equals. */
						SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
	          END
	        END

					IF (@iOperatorID = 2)
					BEGIN
						/* Not Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL'
						END
					END

					IF (@iOperatorID = 3) 
					BEGIN
						/* Less than or Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
	          END
          END
        
					IF (@iOperatorID = 4) 
					BEGIN
						/* Greater than or Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END

					IF (@iOperatorID = 5) 
					BEGIN
						/* Greater than. */
						SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END

					IF (@iOperatorID = 6) 
					BEGIN
						/* Less than.*/
						SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END
				END

				IF (@iDataType = 11) 
				BEGIN
					/* Date column. */
					IF LEN(@sValue) > 0
					BEGIN
						/* Convert the locale date into the SQL format. */
						/* Note that the locale date has already been validated and formatted to match the locale format. */
						SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat)
						SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat)
						SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat)
						
						SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
							+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
							+ SUBSTRING(@sValue, @iIndex3, 4)
					END

					IF (@iOperatorID = 1) 
					BEGIN
						/* Equal To. */
		        IF LEN(@sValue) > 0
		        BEGIN
							SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL'
						END
			    END

					IF (@iOperatorID = 2)
					BEGIN
						/* Not Equal To. */
						IF LEN(@sValue) > 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL'
						END
	        END

					IF (@iOperatorID = 3) 
					BEGIN
						/* Less than or Equal To. */
			      IF LEN(@sValue) > 0 
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL'
					  END
	        END

					IF (@iOperatorID = 4) 
					BEGIN
						/* Greater than or Equal To. */
			      IF LEN(@sValue) > 0
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL'
						END
					END

					IF (@iOperatorID = 5) 
					BEGIN
						/* Greater than. */
			      IF LEN(@sValue) > 0
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL'
						END
				  END

					IF (@iOperatorID = 6)
					BEGIN
						/* Less than. */
		        IF LEN(@sValue) > 0
		        BEGIN
							SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL'
						END
	        END
				END
			
				IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
				BEGIN
						/* Character/Working Pattern column. */
					IF (@iOperatorID = 1) 
					BEGIN
						/* Equal To. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')
							SET @sValue = replace(@sValue, '*', '%')
							SET @sValue = replace(@sValue, '?', '_')

							SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + ''''
						END
					END

					IF (@iOperatorID = 2) 
					BEGIN
						/* Not Equal To. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')
							SET @sValue = replace(@sValue, '*', '%')
							SET @sValue = replace(@sValue, '?', '_')

							SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + ''''
						END
					END

					IF (@iOperatorID = 7)
					BEGIN
						/* Contains */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')

							SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%'''
						END
					END

					IF (@iOperatorID = 8) 
					BEGIN
						/* Does Not Contain. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')

							SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%'''
						END
					END
				END
			
				IF LEN(@sSubFilterSQL) > 0
				BEGIN
					/* Add the filter code for this grid record into the complete filter code. */
					IF LEN(@sFilterSQL) > 0
					BEGIN
						SET @sFilterSQL = @sFilterSQL + ' AND ('
					END
					ELSE
					BEGIN
						SET @sFilterSQL = @sFilterSQL + '('
					END

					SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')'
				END
			END

			IF LEN(@sFilterSQL) > 0 
			BEGIN
				SET @sSQL1 = @sSQL1 +
					' AND ' + @sFilterSQL
			END
		END

		SET @sParamDefinition = N'@result integer OUTPUT'
		EXEC sp_executesql @sSQL1, @sParamDefinition, @plngRecordID OUTPUT
		
		IF @plngRecordID IS null SET @plngRecordID = 0
	END	
END
GO
PRINT N'Altering [dbo].[spASRIntGetSummaryValues]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetSummaryValues] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sRootTable 		varchar(255),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sTemp				varchar(MAX),
		@sSelectSQL			nvarchar(MAX),
		@sActualUserName	sysname,
		@strTempSepText		varchar(500);

	SET @sSelectSQL = '';
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName	sysname);

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @columnPermissions TABLE (tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	-- Cached view of SysProtects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000));

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID);

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM ASRSysProtectsCache
				WHERE [UID] = @iUserGroupID AND Action = 193;

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sParentRealSource = left(@sParentRealSource, 255);
			END

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM ASRSysProtectsCache
				WHERE [UID] = @iUserGroupID AND Action = 193;

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnId, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;

	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @ColumnPermissions
		WHERE tableViewName = @sParentTableName
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			SET @sTemp = ',';
			IF LEN(@sSelectSQL) > 0
				SET @sSelectSQL = @sSelectSQL + @sTemp;

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END 
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sParentTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END

			/* Add the table to the array of tables/views to join if it has not already been added. */
			SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sParentTableName;

			IF @iTempCount = 0
			BEGIN
				INSERT INTO @joinParents (tableViewName) VALUES(@sParentTableName);
			END
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @ColumnPermissions
			WHERE tableViewName <> @sParentTableName
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) > 0 SET @sSelectString = @sSelectString + ',';

				IF @iColumnDataType = 11 /* Date */
					SET @sSelectString = @sSelectString + 'convert(varchar(10),' + @sViewName + '.' + @sColumnName + ',101)';
				ELSE
					SET @sSelectString = @sSelectString + @sViewName + '.' + @sColumnName;


				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = 'COALESCE(' + @sSelectString + ', NULL) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sTemp = ',';

				IF LEN(@sSelectSQL) > 0
					SET @sSelectSQL = @sSelectSQL + @sTemp;

				SET @sTemp = @sSelectString;
				SET @sSelectSQL = @sSelectSQL + @sTemp;
				
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = 'SELECT ' + @sSelectSQL ;

		SELECT @iTempCount = COUNT(tableViewName)
			FROM @joinParents;

		IF @iTempCount = 1 
		BEGIN
			SELECT TOP 1 @sRootTable = tableViewName
			FROM @joinParents;
		END
		ELSE
		BEGIN
			SET @sRootTable = @sParentTableName;
		END

		SET @sTemp = ' FROM ' + @sRootTable;
		SET @sSelectSQL = @sSelectSQL + @sTemp;

		/* Add the join code. */
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sTableViewName <> @sRootTable
			BEGIN
				SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRootTable + '.ID' + ' = ' + @sTableViewName + '.ID';
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END

			FETCH NEXT FROM joinCursor INTO @sTableViewName;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		SET @sTemp = ' WHERE ' + @sRootTable + '.id = ' + convert(varchar(255), @piParentRecordID);
		SET @sSelectSQL = @sSelectSQL + @sTemp;

	END

	-- Run the constructed SQL SELECT string.
	EXEC sp_executeSQL @sSelectSQL;

END
GO
PRINT N'Altering [dbo].[spASRIntSysSecMgr]...';


GO
ALTER PROCEDURE [dbo].[spASRIntSysSecMgr]
(
		@pfSysSecMgr bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sRoleName			sysname,
		@sActualUserName	sysname,
		@iActualUserGroupID	integer;
		
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	SELECT @pfSysSecMgr = 
		CASE
			WHEN (SELECT count(*)
				FROM ASRSysGroupPermissions
				INNER JOIN ASRSysPermissionItems 
					ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories 
					ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE ASRSysGroupPermissions.groupname = @sRoleName
					AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
			ELSE 0
		END;
END
GO
PRINT N'Altering [dbo].[spASRIntGetSelfServiceRecordID]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetSelfServiceRecordID] (
	@piRecordID		integer 		OUTPUT,
	@piRecordCount	integer 		OUTPUT,
	@piViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iUserGroupID	integer,
		@sUserGroupName			sysname,
		@sActualUserName		sysname,
		@sViewName		sysname,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@iRecordID			integer,
		@iRecordCount		integer, 
		@fSysSecMgr			bit,
		@fAccessGranted		bit;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	SET @iRecordID = 0;
	SET @iRecordCount = 0;

	SELECT @sViewName = viewName
		FROM ASRSysViews
		WHERE viewID = @piViewID;

	IF len(@sViewName) > 0
	BEGIN
		/* Check if the user has permission to read the Self-service view. */
		exec spASRIntSysSecMgr @fSysSecMgr OUTPUT;

		IF @fSysSecMgr = 1
		BEGIN
			SET @fAccessGranted = 1;
		END
		ELSE
		BEGIN
		
			SELECT @fAccessGranted =
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM ASRSysProtectsCache p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.UID = @iUserGroupID
				AND p.action = 193 
				AND syscolumns.name = 'ID'
				AND sysobjects.name = @sViewName
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	
		IF @fAccessGranted = 1
		BEGIN
			SET @sCommand = 'SELECT @iValue = COUNT(ID)' + 
				' FROM ' + @sViewName;
			SET @sParamDefinition = N'@iValue integer OUTPUT';
			EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordCount OUTPUT;

			IF @iRecordCount = 1 
			BEGIN
				SET @sCommand = 'SELECT @iValue = ' + @sViewName + '.ID ' + 
					' FROM ' + @sViewName;
				SET @sParamDefinition = N'@iValue integer OUTPUT';
				EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordID OUTPUT;
			END
		END
	END

	SET @piRecordID = @iRecordID;
	SET @piRecordCount = @iRecordCount;
END
GO
PRINT N'Creating [dbo].[spASRIntGetColumnPermissions]...';


GO
CREATE PROCEDURE [dbo].[spASRIntGetColumnPermissions]
	(@SourceList AS dbo.dataPermissions READONLY)
AS
BEGIN
	
	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
			@sActualUserName	sysname,
			@sRoleName				sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT UPPER(so.name) AS tableViewName, UPPER(syscolumns.name) AS columnName, p.action
		, CASE p.protectType WHEN 205 THEN 1 WHEN 204 THEN 1 ELSE 0 END AS permission, sl.*
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects so ON p.id = so.id
		INNER JOIN @SourceList sl ON sl.name = so.name
		INNER JOIN syscolumns ON p.id = syscolumns.id 
		WHERE p.uid = @iUserGroupID
			AND (p.action = 193 OR p.action = 197)
			AND syscolumns.name <> 'timestamp'
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0) OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		ORDER BY tableViewName;

END
GO
PRINT N'Creating [dbo].[spASRIntSetupTablesCollection]...';


GO
CREATE PROCEDURE dbo.spASRIntSetupTablesCollection
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
			@sActualUserName	sysname,
			@sRoleName			sysname,
			@SysSecPerms		integer = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;
	
	SELECT @SysSecPerms = COUNT(*) 
		FROM ASRSysGroupPermissions
			INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			INNER JOIN sysusers a ON ASRSysGroupPermissions.groupName = a.name AND a.name = @sRoleName
		WHERE (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1 AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	-- Security Info
	SELECT @sActualUserName AS [ActualLogin], @sRoleName AS [UserGroup], SYSTEM_USER AS [UserName]
		, CASE WHEN @SysSecPerms > 0 THEN 1 ELSE 0 END AS [IsSysSecMgr];

		
	-- Individual system permissions		
	SELECT ASRSysPermissionCategories.categoryKey + '_' + ASRSysPermissionItems.itemKey AS [key],
		CASE
			WHEN NOT ASRSysGroupPermissions.permitted IS NULL THEN ASRSysGroupPermissions.permitted
			ELSE 0
		END AS [permitted]
	FROM ASRSysPermissionItems
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	LEFT OUTER JOIN ASRSysGroupPermissions ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
		AND ASRSysGroupPermissions.groupName = @sRoleName;


	-- Views
	SELECT v.viewID, UPPER(v.viewName) AS [viewname], t.tableID
		, UPPER(t.tableName) AS [tablename], t.tableType, t.defaultOrderID, t.recordDescExprID
		FROM ASRSysViews v
			INNER JOIN ASRSysTables t ON v.viewTableID = t.tableID;

END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateTransfers]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateTransfers] (
	@piEmployeeTableID			integer,
	@piCourseTableID			integer,
	@piCourseRecordID			integer,
	@piTransferCourseRecordID	integer,
	@piTrainBookTableID			integer,
	@piTrainBookStatusColumnID	integer,
	@piResultCode				integer			OUTPUT,
	@psErrorMessage				varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks
	on booking being transferred from one course (@piCourseRecordID) to another (@piTransferCourseRecordID). 
	Return codes are :
		0 - completely valid
		If non-zero then the result code is composed as abcd,
		where a is the result of the OVERBOOKING check
			b is the result of the PRE-REQUISITES check
			c is the result of the AVAILABILITY check
			d is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overbooking or overlapped bookings checks, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 0120.
	*/
	DECLARE	@sCommand				nvarchar(MAX),
			@sParamDefinition		nvarchar(500),
			@iUserGroupID			integer,
			@sUserGroupName			sysname,
			@iChildViewID			integer,
			@fTransferProvisionals	bit,
			@sTemp					varchar(MAX),
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount					integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@sTBTableName			sysname,
			@sTrainBookRealSource	sysname,
			@sTrainBookStatusColumnName		sysname,
			@fDoPreReqCheck			bit,
			@iPreReqTableID			integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sActualUserName		sysname;

	SET @piResultCode = 0
	SET @psErrorMessage = ''
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTrainBookRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTrainBookRealSource = left(@sTrainBookRealSource, 255)
	END
	ELSE
	BEGIN
		SET @psErrorMessage = 'Unable to determine the Training Booking child view.'
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		IF @piTrainBookStatusColumnID > 0
		BEGIN
			SELECT @sTrainBookStatusColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @piTrainBookStatusColumnID
			IF @sTrainBookStatusColumnName IS NULL SET @psErrorMessage = 'Unable to find the Training Booking Status column.'
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if we need to transfer provisional bookings. */
		SET @sTemp = ''
		SELECT @sTemp = convert(varchar(MAX), parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTransferProvisionals'
		IF @sTemp IS NULL SET @sTemp = ''
		IF @sTemp = 'TRUE'
		BEGIN
			SET @fTransferProvisionals = 1
		END
		ELSE
		BEGIN
			SET @fTransferProvisionals = 0
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if the overbooking stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1

		/* Check if we need to do the pre-requisite check. */
		SELECT @iPreReqTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_PreReqTable'
		IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

		IF @iPreReqTableID > 0 
		BEGIN
			/* Check if the pre-req stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoPreReqCheck = 1
		END

		/* Check if we need to do the unavailibility check. */
		SELECT @iUnavailTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_UnavailTable'
		IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

		IF @iUnavailTableID > 0 
		BEGIN
			/* Check if the unavailibility stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckUnavailability')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
		END

		/* Check if we need to do the overlap check. */
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoOverlapCheck = 1
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		SET @sCommand = 
			'DECLARE @iEmployeeID	integer,' +
			'	@sStatus		varchar(MAX),' + 
			'	@iResult		integer,' +
			'	@fFailure		bit,' +
			'	@sCodeString		varchar(10),' +
			'	@sCurrentCode		varchar(1)' +
			' SET @piResultCode = 0' +
			' SET @fFailure = 0' +
			' SET @piNumberBooked = 0' +
			' DECLARE transfersCursor CURSOR LOCAL FAST_FORWARD FOR ' + 
			' SELECT id_' + convert(nvarchar(100), @piEmployeeTableID) + 
			', ' + @sTrainBookStatusColumnName +
			' FROM ' + @sTrainBookRealSource +
			' WHERE id_' + convert(nvarchar(100), @piCourseTableID) + ' = ' + convert(nvarchar(100), @piCourseRecordID)

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B'''
		END

		SET @sCommand = @sCommand  + 
			' OPEN transfersCursor' +
			' FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' WHILE (@@fetch_status = 0) AND (@fFailure = 0)' +
			' BEGIN' +
			'	SET @sCodeString = convert(varchar(10), @piResultCode)'

		IF @fDoPreReqCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF LEN(@sCodeString) >= 3' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 3), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckPreRequisites ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Pre-requisites not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (100 * convert(integer, @sCurrentCode)) + (100 * @iResult)' +
				'	END'
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 2' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 2), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckUnavailability ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Unavailability check not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (10 * convert(integer, @sCurrentCode)) + (10 * @iResult)' +
				'	END'
		END

		IF @fDoOverlapCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 1' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 1), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckOverlappedBooking ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, 0, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Overlapped booking (error). */' +
				'		SET @piResultCode = @piResultCode - convert(integer, @sCurrentCode) + @iResult' +
				'	END'
		END

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' SET @piNumberBooked = @piNumberBooked + 1'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' IF @sStatus = ''B'' SET @piNumberBooked = @piNumberBooked + 1'
		END

		SET @sCommand = @sCommand  + 
			'	FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' END' +
			' CLOSE transfersCursor' +
			' DEALLOCATE transfersCursor'

		SET @sParamDefinition = N'@piResultCode integer OUTPUT, @piNumberBooked integer OUTPUT'
		EXEC sp_executesql @sCommand,  @sParamDefinition, @piResultCode OUTPUT, @iNumberBooked OUTPUT
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piTransferCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		IF @iResult = 1 /* Course fully booked (error). */
		BEGIN
			SET @piResultCode = @piResultCode + 1000
		END
		IF @iResult = 2 /* Course fully booked (over-rideable by the user). */
		BEGIN
			SET @piResultCode = @piResultCode + 2000
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntAddFromWaitingList]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntAddFromWaitingList] (
	@piEmpRecordID		integer,
	@piCourseRecordID	integer,
	@psStatus			varchar(MAX)
)
AS
BEGIN
	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@fSysSecMgr				bit,
		@sColumnList			varchar(MAX),
		@sValueList				varchar(MAX),
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sExecString			nvarchar(MAX),
		@iEmpTableID			integer,
		@iCourseTableID			integer,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@sTempTBColumnName		sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(MAX),
		@sTempWLColumnName		sysname,
		@sAddedColumns			varchar(MAX),
		@iSourceColumnID		integer,
		@iDestinationColumnID	integer,
		@iIndex					integer,
		@fGranted				bit,
		@iWLCourseTitleColumnID	integer,
		@sWLCourseTitleColumnName	sysname,
		@sCourseTitle			varchar(MAX),
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@sCourseSource			sysname,
		@sActualUserName		sysname;

	SET NOCOUNT ON;

	/* Clean the input string parameters. */
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
	END

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable';
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable';
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(100), @piCourseRecordID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @sCourseTitle = '';
	END

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus';
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;

	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Initialise the insert strings with the basic values.*/
	SET @sColumnList = 'id_' + convert(varchar(128), @iEmpTableID) + ',' +
		'id_' + convert(varchar(128), @iCourseTableID) + ',' +
		@sTBStatusColumnName;
	SET @sValueList = convert(varchar(128), @piEmpRecordID) + ',' +
		convert(varchar(128), @piCourseRecordID) + ',' +
		'''' + @psStatus + '''';
	SET @sAddedColumns = ',' + convert(varchar(MAX), @iTBStatusColumnID) + ',';

	/* Get the TB and WL column permissions. */
	IF @fSysSecMgr = 0
	BEGIN
		CREATE TABLE #columnPermissions
		(
			columnID	int,
			action		int,		
			granted		bit		
		);

		INSERT INTO #columnPermissions
		SELECT 
			ASRSysColumns.columnId,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END AS [protectType]
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND (ASRSysColumns.tableID = @iTBTableID
				OR ASRSysColumns.tableID = @iWLTableID))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND (sysobjects.name = @sTBRealSource
				OR sysobjects.name = @sWLRealSource)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	END

	/* Get the Waiting List - Training Booking related columns. */
	DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sourceColumnID, destColumnID
	FROM ASRSysModuleRelatedColumns
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TBWLRelatedColumns';
	OPEN relatedColumns_cursor;
	FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iIndex = charindex(',' + convert(varchar(MAX), @iDestinationColumnID) + ',', @sAddedColumns);

		IF @iIndex = 0
		BEGIN
			/* Check that the user has read permission on the WL column, and update permission on the TB column. */
			SET @fGranted = 1;

			IF @fSysSecMgr = 0
			BEGIN
				SELECT @fGranted = granted
				FROM #columnPermissions
				WHERE columnID = @iDestinationColumnID
					AND action = 193;

				IF @fGranted IS null SET @fGranted = 0;

				IF @fGranted = 1
				BEGIN
					SELECT @fGranted = granted
					FROM #columnPermissions
					WHERE columnID = @iSourceColumnID
						AND action = 197;

					IF @fGranted IS null SET @fGranted = 0;
				END
			END

			IF @fGranted = 1
			BEGIN
				SELECT @sTempTBColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @iSourceColumnID;

				SELECT @sTempWLColumnName = columnName
				FROM ASRSysColumns 
				WHERE columnID = @iDestinationColumnID;

				SET @sColumnList = @sColumnList + ',' + @sTempTBColumnName;
				SET @sValueList = @sValueList + ',' + @sTempWLColumnName;
			END
			
			SET @sAddedColumns = @sAddedColumns + convert(varchar(MAX), @iSourceColumnID) + ',';
		END

		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	END
	CLOSE relatedColumns_cursor;
	DEALLOCATE relatedColumns_cursor;

	IF @fSysSecMgr = 0
	BEGIN
		/* Drop temporary tables no longer required. */
		DROP TABLE #columnPermissions;
	END

	/* Create the booking record. */
	SET @sExecString = 'INSERT INTO ' + @sTBRealSource + 
		'(' + @sColumnList + ')' +
		' SELECT TOP 1 ' + @sValueList + 
		' FROM ' + @sWLRealSource + 
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;

	/* Delete the old Waiting List record(s). */
	SET @sExecString = 'DELETE FROM ' + @sWLRealSource +
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntAuditAccess]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntAuditAccess]
(
	@blnLoggingIn bit,
	@strUsername varchar(1000)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@sActualUserName	sysname;
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	IF @sUserGroupName IS NULL
	BEGIN
		SET @sUserGroupName = '<Unknown>';
	END

	/* Put an entry in the Audit Access Log */
	IF @blnLoggingIn <> 0
	BEGIN
		INSERT INTO [dbo].[ASRSysAuditAccess]
			(DateTimeStamp,UserGroup,UserName,ComputerName,HRProModule,Action) 
			VALUES (GetDate(), @sUserGroupName, @strUserName, LOWER(HOST_NAME()), 'Intranet', 'Log In');
	END
	ELSE
	BEGIN
		INSERT INTO [dbo].[ASRSysAuditAccess]
			(DateTimeStamp,UserGroup,UserName,ComputerName,HRProModule,Action) 
			VALUES (GetDate(), @sUserGroupName, @strUserName, LOWER(HOST_NAME()), 'Intranet', 'Log Out');
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntCheckLogin]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntCheckLogin] (
	@piSuccessFlag			integer			OUTPUT,
	@psErrorMessage			varchar(MAX)	OUTPUT,
	@piMinPassordLength		integer			OUTPUT,
	@psIntranetAppVersion	varchar(50),
	@piPasswordLength		integer,
	@piUserType				integer			OUTPUT,
	@psUserGroup			varchar(250)	OUTPUT,
	@iSelfServiceUserType   integer			OUTPUT
)
AS
BEGIN
	/* Check that the current user is okay to login. */
	/* 	@pfLoginOK 	= 0 if the login was NOT okay
				= 1 if the login was okay (without warnings)
				= 2 if the login was okay (but the user's password has expired)
		@psErrorMessage is the description of the login failure if @pfLoginOK = 0
		@piMinPassordLength is the configured minimum password length
		@psIntranetAppVersion is the intranet application version passed into the stored procedure (set as a session variable in the global.asa file. 
		@piPasswordLength is the length of the user's current password. 
		@fDmiNetUserType is te DMI or SSI path 1 for SSi 0 for DMI

	*/
	SET NOCOUNT ON;
	
	DECLARE @iSysAdminRoles				integer,
		@sLockUser						sysname,
		@sHostName						varchar(MAX),
		@sLoginName						varchar(255),
		@sProgramName					varchar(255),
		@sRoleName						sysname,
		@source 						varchar(30),
		@desc 							varchar(200),
		@fIntranetEnabled				bit,
		@sIntranetDBVersion				varchar(50),
		@sIntranetDBMajor				varchar(50),
		@sIntranetDBMinor				varchar(50),
		@sIntranetDBRevision			varchar(50),
		@sIntranetAppMajor				varchar(50),
		@sIntranetAppMinor				varchar(50),
		@sIntranetAppRevision			varchar(50),
		@sMinIntranetVersion			varchar(50),
		@sMinIntranetMajor				varchar(50),
		@sMinIntranetMinor				varchar(50),
		@sMinIntranetRevision			varchar(50),
		@iPosition1 					integer,
		@iPosition2 					integer,
		@fValidIntranetAppVersion		bit,
		@fValidIntranetDBVersion		bit,
		@fValidMinIntranetVersion		bit,
		@iMinPasswordLength				integer,
		@iChangePasswordFrequency		integer,
		@sChangePasswordPeriod			varchar(1),
		@dtPasswordLastChanged			datetime,
		@fPasswordForceChange			bit,
		@sDomain						varchar(MAX),
		@iCount							integer,
		@iPriority						integer,
		@sDescription					varchar(MAX),
		@sLockTime						varchar(255),
		@sValue							varchar(MAX),
		@iValue							integer,
		@iFullUsers						integer,
		@iSSUsers						integer,
		@iSSIUsers						integer,
		@iTemp							integer,
		@fSelfService					bit, 
		@fValidSYSManagerVersion		bit,
		@sSYSManagerMajor				varchar(50),
		@sSYSManagerMinor				varchar(50),
		@sSYSManagerVersion				varchar(50),
		@sActualUserName				sysname, 
		@iActualUserGroupID				integer,
		@iFullIntItemID					integer,
		@iSSIntItemID					integer,
		@iSSIIntItemID					integer,
		@iSID							binary(85),
		@sSQLVersion					int,
		@sLockMessage					varchar(200),
		@fNewSettingFound				bit,
		@iCurrentItemKey				integer,
		@sCurrentItemKey				varchar(50),
		@psItemKey						varchar(50),
		@fOldSettingFound				bit;
		
	SET @piSuccessFlag = 1;
	SET @psErrorMessage = '';
	SET @piMinPassordLength = 0;
	SET @piUserType = 0;
	SET @iFullUsers = 0;
	SET @iSSUsers = 0;
	SET @iSSIUsers = 0;
	SET @fSelfService = 0;
	SET @iSelfServiceUserType = 0;
	SET @psUserGroup = '';
	
	SET @psItemKey = 'INTRANET';
	EXEC	[dbo].[spASRIntGetUserGroup]
			@psItemKey = 'INTRANET',
			@psUserGroup = @psUserGroup OUTPUT,
			@iSelfServiceUserType = @iSelfServiceUserType OUTPUT,
			@fSelfService = @fSelfService OUTPUT				        

	IF @psUserGroup IS NULL
	BEGIN
		SET @piSuccessFlag = 0
		SET @psErrorMessage = 'The user is not a member of any OpenHR user group or has no permissions to use this system.'
	END

	/*' Check if the current user is a SQL Server System Administrator.	We do not allow these users to login to the intranet module. */			
	IF current_user = 'dbo'
	BEGIN
		SET @piSuccessFlag = 0;
		SET @psErrorMessage = 'SQL Server system administrators cannot use the intranet module.';
	END
	ELSE
	BEGIN
		/* Fault 3901 */
		SELECT @iSysAdminRoles = sysAdmin + securityAdmin + serverAdmin + setupAdmin + processAdmin + diskAdmin + dbCreator
		FROM master..syslogins
		WHERE name = system_user
		IF @iSysAdminRoles > 0 
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'Users assigned to fixed SQL Server roles cannot use the intranet module.'
		END
	END
	/* Check if anyone has locked the system. */
	IF @piSuccessFlag = 1
	BEGIN
		DECLARE @tmpSysProcess1 TABLE(
			hostname nvarchar(50), 
			loginname nvarchar(50),
			program_name nvarchar(50),
			hostprocess int, sid binary(86),
			login_time datetime,
			spid smallint,
			uid smallint);
			
		INSERT @tmpSysProcess1 EXEC dbo.spASRGetCurrentUsers;
		
		
		SELECT TOP 1 @iPriority = ASRSysLock.priority,
			@sLockUser = ASRSysLock.username,
			@sLockTime = convert(varchar(255), ASRSysLock.lock_time, 100),
			@sHostName = ASRSysLock.hostname,
			@sDescription = ASRSysLock.description
		FROM ASRSysLock
		LEFT OUTER JOIN @tmpSysProcess1 syspro 
			ON ASRSysLock.spid = syspro.spid AND ASRSysLock.login_time = syspro.login_time
		WHERE priority = 2 
			OR syspro.spid IS not null
		ORDER BY priority
		IF (NOT @iPriority IS NULL) AND (@iPriority <> 3)
		BEGIN
			/* Get the lock message set in the System Manager */
			SET @sLockMessage = ''
			EXEC sp_ASRIntGetSystemSetting 'messaging', 'lockmessage', 'lockmessage', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
			
			IF ((@fNewSettingFound = 1) OR (@fOldSettingFound = 1) ) AND LTRIM(RTRIM(@sValue)) <> ''
			BEGIN
				SET @sLockMessage = @sValue + '<BR><BR>'
			END
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The database has been locked.<P>' + 
				CASE @iPriority
				WHEN 2 THEN
					@sLockMessage 
				ELSE ''
				END
			    + 'User :  ' + @sLockUser + '<BR>' +
				  'Date/Time :  ' + @sLockTime +  '<BR>' +
				  'Machine :  ' + @sHostName +  '<BR>' +
				  'Type :  ' + @sDescription
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
	
		/* Get the current System Manager version */
		SET @sSYSManagerVersion = ''
		exec sp_ASRIntGetSystemSetting 'database', 'version', 'version', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @sSYSManagerVersion = @sValue
		END
		/* Get the intranet version. */
		SET @sIntranetDBVersion = ''
		IF @fSelfService = 0
		BEGIN
			exec dbo.sp_ASRIntGetSystemSetting 'intranet', 'version', 'intranetVersion', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		END
		ELSE
		BEGIN
			exec dbo.sp_ASRIntGetSystemSetting 'ssintranet', 'version', '', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		END
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @sIntranetDBVersion = @sValue
		END
		/* Get the minimum intranet version. */
		SET @sMinIntranetVersion = ''
		IF @fSelfService = 0
		BEGIN
			exec dbo.sp_ASRIntGetSystemSetting 'intranet', 'minimum version', 'minIntranetVersion', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		END
		ELSE
		BEGIN
			exec dbo.sp_ASRIntGetSystemSetting 'ssintranet', 'minimum version', '', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		END
		
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @sMinIntranetVersion = @sValue
		END
		/* Get the minimum password length. */
		SET @iMinPasswordLength = 0
		exec dbo.sp_ASRIntGetSystemSetting 'password', 'minimum length', 'minimumPasswordLength', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @iMinPasswordLength = convert(integer, @sValue)
		END
		SET @piMinPassordLength = @iMinPasswordLength
		/* Get the password change frequency. */
		SET @iChangePasswordFrequency = 0
		exec dbo.sp_ASRIntGetSystemSetting 'password', 'change frequency', 'changePasswordFrequency', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @iChangePasswordFrequency = convert(integer, @sValue)
		END
		/* Get the password change period. */
		SET @sChangePasswordPeriod = ''
		exec dbo.sp_ASRIntGetSystemSetting 'password', 'change period', 'changePasswordFrequency', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
		BEGIN
			SET @sChangePasswordPeriod = UPPER(@sValue)
		END
	END
	/* Check the database version is the right one for the application version. */
	IF @piSuccessFlag = 1
	BEGIN
		/* Extract the Intranet application version parts from the given version string. */	
		SET @fValidIntranetAppVersion = 1
		SET @iPosition1 = charindex('.', @psIntranetAppVersion)
		IF @iPosition1 = 0 SET @fValidIntranetAppVersion = 0
		IF @fValidIntranetAppVersion = 1
		BEGIN
			SET @iPosition2 = charindex('.', @psIntranetAppVersion, @iPosition1 + 1)
			IF @iPosition2 = 0 SET @fValidIntranetAppVersion = 0
		END
		IF @fValidIntranetAppVersion = 1
		BEGIN
			SET @sIntranetAppMajor = left(@psIntranetAppVersion, @iPosition1 - 1)
			SET @sIntranetAppMinor = substring(@psIntranetAppVersion, @iPosition1 + 1, @iPosition2 - @iPosition1 - 1)
			SET @sIntranetAppRevision = substring(@psIntranetAppVersion, @iPosition2 + 1, len(@psIntranetAppVersion) - @iPosition2)
		END
		ELSE
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'Invalid intranet application version.'
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		/* Extract the Intranet database version parts from the version string. */	
		SET @fValidIntranetDBVersion = 1
		SET @iPosition1 = charindex('.', @sIntranetDBVersion)
		IF @iPosition1 = 0 SET @fValidIntranetDBVersion = 0
		IF @fValidIntranetDBVersion = 1
		BEGIN
			SET @iPosition2 = charindex('.', @sIntranetDBVersion, @iPosition1 + 1)
			IF @iPosition2 = 0 SET @fValidIntranetDBVersion = 0
		END
		IF @fValidIntranetDBVersion = 1
		BEGIN
			SET @sIntranetDBMajor = left(@sIntranetDBVersion, @iPosition1 - 1)
			SET @sIntranetDBMinor = substring(@sIntranetDBVersion, @iPosition1 + 1, @iPosition2 - @iPosition1 - 1)
			SET @sIntranetDBRevision = substring(@sIntranetDBVersion, @iPosition2 + 1, len(@sIntranetDBVersion) - @iPosition2)
		END
		ELSE
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'Invalid intranet database version.'
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		/* Extract the Minimum Intranet version parts from the version string. */	
		SET @fValidMinIntranetVersion = 1
		SET @iPosition1 = charindex('.', @sMinIntranetVersion)
		IF @iPosition1 = 0 SET @fValidMinIntranetVersion = 0
		IF @fValidMinIntranetVersion = 1
		BEGIN
			SET @iPosition2 = charindex('.', @sMinIntranetVersion, @iPosition1 + 1)
			IF @iPosition2 = 0 SET @fValidMinIntranetVersion = 0
		END
		IF @fValidMinIntranetVersion = 1
		BEGIN
			SET @sMinIntranetMajor = left(@sMinIntranetVersion, @iPosition1 - 1)
			SET @sMinIntranetMinor = substring(@sMinIntranetVersion, @iPosition1 + 1, @iPosition2 - @iPosition1 - 1)
			SET @sMinIntranetRevision = substring(@sMinIntranetVersion, @iPosition2 + 1, len(@sMinIntranetVersion) - @iPosition2)
		END
	END
	
	/* Check the System Manager database version is the right one for the intranet version. */
	IF @piSuccessFlag = 1
	BEGIN
		/* Extract the System Manager database version parts from the given version string. */	
		SET @fValidSYSManagerVersion = 1
		SET @iPosition1 = charindex('.', @sSYSManagerVersion)
		IF @iPosition1 = 0 SET @fValidSYSManagerVersion = 0
		IF @fValidSYSManagerVersion = 1
		BEGIN
			SET @sSYSManagerMajor = left(@sSYSManagerVersion, @iPosition1 - 1)
			SET @sSYSManagerMinor = substring(@sSYSManagerVersion, @iPosition1 + 1, len(@sSYSManagerVersion) - @iPosition1)
		END
		ELSE
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'Invalid System Manager database version.'
		END
	END
	
	IF @piSuccessFlag = 1
	BEGIN
		/* Check the application version against the one for the current database. */
		IF (convert(integer, @sIntranetAppMajor) < convert(integer, @sIntranetDBMajor)) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sIntranetDBMajor)) AND (convert(integer, @sIntranetAppMinor) < convert(integer, @sIntranetDBMinor))) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sIntranetDBMajor)) AND (convert(integer, @sIntranetAppMinor) = convert(integer, @sIntranetDBMinor)) AND (convert(integer, @sIntranetAppRevision) < convert(integer, @sIntranetDBRevision))) 
		BEGIN
			/* Application is too old for the database. */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The intranet application is out of date.' 
												+ '<BR>Please ask the System Administrator to update the intranet application.'
												+ '<BR><BR>'
												+ 'Database Name : ' + db_name()
												+ '<BR><BR>'
												+ 'OpenHR System Manager Version : ' + @sSYSManagerVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Database Version : ' + @sIntranetDBVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Application Version : ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision				
												
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		/* Check the application version against the one for the current database. */
		IF (convert(integer, @sIntranetAppMajor) > convert(integer, @sIntranetDBMajor)) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sIntranetDBMajor)) AND (convert(integer, @sIntranetAppMinor) > convert(integer, @sIntranetDBMinor))) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sIntranetDBMajor)) AND (convert(integer, @sIntranetAppMinor) = convert(integer, @sIntranetDBMinor)) AND (convert(integer, @sIntranetAppRevision) > convert(integer, @sIntranetDBRevision))) 
		BEGIN
			/* Database is too old for the appplication. */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The database is out of date.' 
												+ '<BR>Please ask the System Administrator to update the database for use with version ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision + ' of the intranet.'
												+ '<BR><BR>'
												+ 'Database Name : ' +  db_name()
												+ '<BR><BR>'
												+ 'OpenHR System Manager Version : ' + @sSYSManagerVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Database Version : ' + @sIntranetDBVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Application Version : ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision				
												
			IF (convert(integer, @sIntranetAppMajor) > convert(integer, @sSYSManagerMajor)) 
					OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sSYSManagerMajor)) AND (convert(integer, @sIntranetAppMinor) > convert(integer, @sSYSManagerMinor))) 
			BEGIN
				SET @psErrorMessage = @psErrorMessage + '<BR><BR>'
																							+ '<FONT COLOR="Red"><B>Please note that the System Manager version also requires updating to version ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.</B></FONT>' 
			END					
												
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		/* Check the application version against the one for the current database. */
		IF (convert(integer, @sIntranetAppMajor) > convert(integer, @sSYSManagerMajor)) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sSYSManagerMajor)) AND (convert(integer, @sIntranetAppMinor) > convert(integer, @sSYSManagerMinor))) 
		BEGIN
			/* Database is too old for the appplication. */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The database is out of date.' 
				+ '<BR>Please ask the System Administrator to update the System Manager version to ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.'
				+ '<BR><BR>'
				+ 'Database Name : ' + db_name()
				+ '<BR><BR>'
				+ 'OpenHR System Manager Version : ' + @sSYSManagerVersion
				+ '<BR><BR>'
				+ 'OpenHR Intranet Database Version : ' + @sIntranetDBVersion
				+ '<BR><BR>'
				+ 'OpenHR Intranet Application Version : ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision				
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		IF (CONVERT(varchar, @@SERVERNAME) <> CONVERT(varchar, SERVERPROPERTY('servername')))
		BEGIN
			/* Microsoft SQL Server has been renamed */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The Microsoft SQL Server has been renamed but the operation is incomplete.' 
				+ '<BR>Please contact your System Administrator.'
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		EXEC sp_ASRIntGetSystemSetting 'platform', 'SQLServerVersion', 'SQLServerVersion', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		
		IF ((@fNewSettingFound = 1) OR (@fOldSettingFound = 1) ) AND SUBSTRING(LTRIM(RTRIM(@sValue)),1,1) <> @sSQLVersion
		BEGIN
			/* Microsoft SQL Version has been upgraded */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The Microsoft SQL Version has been upgraded.' 
				+ '<BR>Please ask the System Administrator to save the update in the System Manager.'
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		EXEC sp_ASRIntGetSystemSetting 'platform', 'DatabaseName', 'DatabaseName', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		IF ((@fNewSettingFound = 1) OR (@fOldSettingFound = 1) ) AND UPPER(LTRIM(RTRIM(@sValue))) <> UPPER(DB_NAME())
		BEGIN
			/* The database name changed */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The database name has changed.' 
				+ '<BR>Please ask the System Administrator to save the update in the System Manager.'
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		EXEC sp_ASRIntGetSystemSetting 'platform', 'ServerName', 'ServerName', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
		
		IF ((@fNewSettingFound = 1) OR (@fOldSettingFound = 1))
		BEGIN
			IF LTRIM(RTRIM(@sValue)) = '.' SELECT @sValue = @@SERVERNAME
			IF UPPER(@sValue) <> UPPER(@@SERVERNAME)
			BEGIN
				/* The database has moved to a different Microsoft SQL Server */
				SET @piSuccessFlag = 0
				SET @psErrorMessage = 'The database has moved to a different Microsoft SQL Server.' 
					+ '<BR>Please ask the System Administrator to save the update in the System Manager.'
			END
		END
	END
	IF @piSuccessFlag = 1
	BEGIN
		EXEC sp_ASRIntGetSystemSetting 'database', 'refreshstoredprocedures', 'refreshstoredprocedures', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT
			
		IF ((@fNewSettingFound = 1) OR (@fOldSettingFound = 1) ) AND LTRIM(RTRIM(@sValue)) = 1
		BEGIN
			/* Database is too old for the appplication. */
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The database is out of date.' 
				+ '<BR>Please ask the System Administrator to save the update in the System Manager.'
				+ '<BR><BR>'
				+ 'Database Name : ' + db_name()
				+ '<BR><BR>'
				+ 'OpenHR System Manager Version : ' + @sSYSManagerVersion
				+ '<BR><BR>'
				+ 'OpenHR Intranet Database Version : ' + @sIntranetDBVersion
				+ '<BR><BR>'
				+ 'OpenHR Intranet Application Version : ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision	
		END
	END
	IF (@piSuccessFlag = 1) AND (@fValidMinIntranetVersion = 1)
	BEGIN
		/* Check the application version against the minimum one for the current database. */
		IF (convert(integer, @sIntranetAppMajor) < convert(integer, @sMinIntranetMajor)) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sMinIntranetMajor)) AND (convert(integer, @sIntranetAppMinor) < convert(integer, @sMinIntranetMinor))) 
			OR ((convert(integer, @sIntranetAppMajor) = convert(integer, @sMinIntranetMajor)) AND (convert(integer, @sIntranetAppMinor) = convert(integer, @sMinIntranetMinor)) AND (convert(integer, @sIntranetAppRevision) < convert(integer, @sMinIntranetRevision))) 
		BEGIN
			/* Application is older than the minimum required */
			SET @piSuccessFlag = 0
			--SET @psErrorMessage = 'The intranet application is out of date. You require version ' + @sMinIntranetVersion + ' or later. Contact your administrator to update it.'
			SET @psErrorMessage = 'The intranet application is out of date.' 
												+ '<BR>Please ask the System Administrator to update the intranet application.'
												+ '<BR><BR>'
												+ 'Database Name : ' + db_name()
												+ '<BR><BR>'
												+ 'OpenHR System Manager Version : ' + @sSYSManagerVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Database Version : ' + @sIntranetDBVersion
												+ '<BR><BR>'
												+ 'OpenHR Intranet Application Version : ' + @sIntranetAppMajor + '.' + @sIntranetAppMinor + '.' + @sIntranetAppRevision				
		END
	END
	-- Get licence details
	IF @piSuccessFlag = 1
	BEGIN
		EXEC dbo.spASRIntGetLicenceInfo @fSelfService, @piSuccessFlag OUTPUT,
					@fIntranetEnabled OUTPUT, @iSSUsers OUTPUT,
					@iFullUsers OUTPUT,	@iSSIUsers OUTPUT,
					@psErrorMessage OUTPUT
	END
	-- Check that the user belongs to a valid role in the selected database.
	IF @piSuccessFlag = 1
	BEGIN
		EXEC dbo.spASRIntGetActualUserDetails
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT					        

		IF @sRoleName IS NULL
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'The  user is not a member of any OpenHR user group.'
		END
	--END
	--IF @piSuccessFlag = 1
	--BEGIN
		/* Check that the user is permitted to use the Intranet module. */
		/* First check that this permission exists in the current version. */
		SELECT @iSSIIntItemID = ASRSysPermissionItems.itemID
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		WHERE ASRSysPermissionItems.itemKey = 'SSINTRANET'
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'
		IF @iSSIIntItemID IS NULL SET @iSSIIntItemID = 0
		IF @fSelfService = 1
		BEGIN
			/* The permission does exist in the current version so check if the user is granted this permission. */
			SELECT @iCount = count(ItemID)
			FROM ASRSysGroupPermissions 
			WHERE ASRSysGroupPermissions.itemID = @iSSIIntItemID
				AND ASRSysGroupPermissions.groupName = @sRoleName
				AND ASRSysGroupPermissions.permitted = 1
			IF @iCount = 0
			BEGIN				
				SET @piSuccessFlag = 0
				SET @psErrorMessage = 'You are not permitted to use the Self-service Intranet module with this user name.'
			END
		END
		ELSE
		BEGIN
			SELECT @iFullIntItemID = ASRSysPermissionItems.itemID
			FROM ASRSysPermissionItems
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			WHERE ASRSysPermissionItems.itemKey = 'INTRANET'
				AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'
			IF @iFullIntItemID IS NULL SET @iFullIntItemID = 0
		
			SELECT @iSSIntItemID = ASRSysPermissionItems.itemID
			FROM ASRSysPermissionItems
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			WHERE ASRSysPermissionItems.itemKey = 'INTRANET_SELFSERVICE'
				AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'
			IF @iSSIntItemID IS NULL SET @iSSIntItemID = 0
		
			IF @iFullIntItemID > 0
			BEGIN
				/* The permission does exist in the current version so check if the user is granted this permission. */
				SELECT @iCount = count(ItemID)
				FROM ASRSysGroupPermissions 
				WHERE ASRSysGroupPermissions.itemID = @iFullIntItemID
					AND ASRSysGroupPermissions.groupName = @sRoleName
					AND ASRSysGroupPermissions.permitted = 1
				
				IF @iCount = 0
				BEGIN
					IF @iSSIntItemID > 0
					BEGIN
						/* The permission does exist in the current version so check if the user is granted this permission. */
						SELECT @iCount = count(ItemID)
						FROM ASRSysGroupPermissions 
						WHERE ASRSysGroupPermissions.itemID = @iSSIntItemID
							AND ASRSysGroupPermissions.groupName = @sRoleName
							AND ASRSysGroupPermissions.permitted = 1
						IF @iCount = 0
						BEGIN				
							SET @piSuccessFlag = 0
							SET @psErrorMessage = 'You are not permitted to use the Data Manager Intranet module with this user name.'
						END
						ELSE
						BEGIN
							SET @piUserType = 1
						END
					END
				END
			END
		END
	END	
	IF @piSuccessFlag = 1
	BEGIN
		IF @fSelfService = 1
		BEGIN
			SET @iTemp = @iSSIUsers
		END
		ELSE
		BEGIN
			IF @piUserType = 1
			BEGIN
				SET @iTemp = @iSSUsers
			END
			ELSE
			BEGIN
				SET @iTemp = @iFullUsers
			END
		END
		SET @iValue = 0
		/* Don't use uid as it sometimes is 0 when youdon't expect it to be. */
		DECLARE @tmpSysProcess2 TABLE (
			hostname		nvarchar(50),
			loginname		nvarchar(50),
			program_name	nvarchar(50),
			hostprocess		int,
			[sid]			binary(86), 
			ogin_time		datetime,
			spid			smallint,
			[uid]			smallint);
			
		INSERT @tmpSysProcess2 EXEC [dbo].[spASRGetCurrentUsers]
		
		DECLARE users_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT sid
			FROM @tmpSysProcess2
			WHERE program_name = APP_NAME();
			
		OPEN users_cursor
		FETCH NEXT FROM users_cursor INTO @iSID
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @fSelfService = 1
			BEGIN
				SET @iValue = @iValue + 1
			END
			ELSE
			BEGIN
				/* Check if the process is run by the same type of user as the current user. */
				/* Get the user's group name. */
				SELECT @sRoleName = usg.name
				FROM sysusers usu
				left outer join
					(sysmembers mem inner join sysusers usg on mem.groupuid = usg.uid) on usu.uid = mem.memberuid
				WHERE (usu.islogin = 1 and usu.isaliased = 0 and usu.hasdbaccess = 1) 
					AND (usg.issqlrole = 1 OR usg.uid is null) 
					AND usu.sid = @iSID 
					AND not (usg.name like 'ASRSys%') 
					AND not (usg.name like 'db_owner')
				IF @piUserType = 1
				BEGIN
					/* Self-service users. */
					IF @iSSIntItemID > 0
					BEGIN
						/* The permission does exist in the current version so check if the user is granted this permission. */
						SELECT @iCount = count(ItemID)
						FROM ASRSysGroupPermissions 
						WHERE ASRSysGroupPermissions.itemID = @iSSIntItemID
							AND ASRSysGroupPermissions.groupName = @sRoleName
							AND ASRSysGroupPermissions.permitted = 1
						IF @iCount > 0 SET @iValue = @iValue + 1
					END
				END
				ELSE
				BEGIN
					/* Full access users. */
					IF @iFullIntItemID > 0
					BEGIN
						/* The permission does exist in the current version so check if the user is granted this permission. */
						SELECT @iCount = count(*)
						FROM ASRSysGroupPermissions 
						WHERE ASRSysGroupPermissions.itemID = @iFullIntItemID
						AND ASRSysGroupPermissions.groupName = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1
						IF @iCount > 0 SET @iValue = @iValue + 1
					END
				END
			END
			FETCH NEXT FROM users_cursor INTO @iSID
		END
		
		CLOSE users_cursor
		DEALLOCATE users_cursor
		IF @iValue > @iTemp
		BEGIN
			SET @piSuccessFlag = 0
			SET @psErrorMessage = 'Unable to logon. You have reached the maximum number of licensed ' + 
				CASE
					WHEN @fSelfService = 1 THEN 'Self-service Intranet'
					WHEN @piUserType = 1 THEN 'Data Manager Intranet (single record)'
					ELSE 'Data Manager Intranet (multiple record)'
				END +
				' users.'
		END
	END
	/* Check if the password has expired */
	SELECT @sSQLVersion = dbo.udfASRSQLVersion()
	IF @piSuccessFlag = 1 AND @sSQLVersion < 9
	BEGIN
		SELECT @dtPasswordLastChanged = lastChanged, 
			@fPasswordForceChange = forceChange
		FROM ASRSysPasswords
		WHERE userName = system_user
		IF @dtPasswordLastChanged IS NULL
		BEGIN
			/* User not in the password table. So add them. */
			SET @dtPasswordLastChanged = GETDATE()
			SET @fPasswordForceChange = 0
			INSERT INTO ASRSysPasswords (username, lastChanged, forceChange)
			VALUES (LOWER(system_user), @dtPasswordLastChanged, @fPasswordForceChange)
		END
		ELSE
		BEGIN
			IF (@iMinPasswordLength <> 0) OR (@iChangePasswordFrequency <> 0) 
			BEGIN
				/* Check for minimum length. */
				IF (@iMinPasswordLength > @piPasswordLength) SET @fPasswordForceChange = 1
    
				/* Check for Date last changed. */
				IF (@iChangePasswordFrequency > 0) AND (@fPasswordForceChange = 0)
				BEGIN
					IF @sChangePasswordPeriod = 'D' 
					BEGIN
						IF DATEADD(day, @iChangePasswordFrequency, @dtPasswordLastChanged) <= GETDATE() SET @fPasswordForceChange = 1						
					END
					IF @sChangePasswordPeriod = 'W' 
					BEGIN
						IF DATEADD(week, @iChangePasswordFrequency, @dtPasswordLastChanged) <= GETDATE() SET @fPasswordForceChange = 1						
					END
					IF @sChangePasswordPeriod = 'M' 
					BEGIN
						IF DATEADD(month, @iChangePasswordFrequency, @dtPasswordLastChanged) <= GETDATE() SET @fPasswordForceChange = 1						
					END
					IF @sChangePasswordPeriod = 'Y' 
					BEGIN
						IF DATEADD(year, @iChangePasswordFrequency, @dtPasswordLastChanged) <= GETDATE() SET @fPasswordForceChange = 1						
					END
				END
			END
		END
		IF @fPasswordForceChange = 1 SET @piSuccessFlag = 2
	END
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetEmpIDFromTBID]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromTBID] (
	@piEmpRecordID	integer		OUTPUT,
	@piTBRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@iEmpTableID			integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(255),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List table. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piEmpRecordID OUTPUT;

	IF @piEmpRecordID IS null SET @piEmpRecordID = 0;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetEmpIDFromWLID]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromWLID] (
	@piEmpRecordID	integer		OUTPUT,
	@piWLRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@iEmpTableID			integer,
		@iWLTableID				integer,
		@sWLRealSource			varchar(255),
		@sWLTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List table. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable'
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;
	
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		' FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piWLRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piEmpRecordID OUTPUT;

	IF @piEmpRecordID IS null SET @piEmpRecordID = 0;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetFilterColumns]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetFilterColumns]
(
	@plngTableID 	integer, 
	@plngViewID 	integer,
	@psRealSource	varchar(8000) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the columns available for the given table/view. */
	DECLARE @lngTableID		integer,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sRealSource 		varchar(255),
		@sTableName 		varchar(255),
		@iTableType			integer,
		@iChildViewID		integer,
		@sActualUserName	sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID;
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM [dbo].[ASRSysViews]
		WHERE ASRSysViews.viewID = @plngViewID;
	END

	/* Get the table-type. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM [dbo].[ASRSysTables]
	WHERE ASRSysTables.tableID = @lngTableID;

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @ColumnInfo TABLE(
		columnID	integer,
		columnName	sysname,
		dataType	integer,
		readGranted	bit,
		size		integer,
		decimals	integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1 )
	BEGIN
		/* Populate the temporary table with information on the order for the given table. */
		IF @plngViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @plngViewID;

	   		INSERT INTO @ColumnInfo (
				columnID, 
				columnName,
				dataType,
				readGranted,
				size,
				decimals)
			(SELECT ASRSysColumns.columnId, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				1,
				ASRSysColumns.size,
				ASRSysColumns.decimals				
			FROM ASRSysColumns
			INNER JOIN ASRSysViewColumns ON ASRSysColumns.columnId = ASRSysViewColumns.columnID
			WHERE ASRSysColumns.tableID = @lngTableID
				AND ASRSysColumns.columnType <> 4
				AND ASRSysColumns.columnType <> 3
				AND ASRSysColumns.dataType <> -3
				AND ASRSysColumns.dataType <> -4
				AND ASRSysViewColumns.viewID = @plngViewID
				AND ASRSysViewColumns.inView=1);
		END
		ELSE
		BEGIN
			IF @iTableType <> 2 /* ie. top-level or lookup */
			BEGIN
				/* RealSource is the table. */	
				SET @sRealSource = @sTableName;
			END 
			ELSE
			BEGIN
				SELECT @iChildViewID = childViewID
				FROM [dbo].[ASRSysChildViews2]
				WHERE tableID = @lngTableID
					AND role = @sUserGroupName;
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_');
					SET @sRealSource = left(@sRealSource, 255);
				END
			END

	   		INSERT INTO @ColumnInfo (
				columnID, 
				columnName,
				dataType,
				readGranted,
				size,
				decimals)
			(SELECT ASRSysColumns.columnId, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				1,
				ASRSysColumns.size,
				ASRSysColumns.decimals				
			FROM ASRSysColumns
			WHERE ASRSysColumns.tableID = @lngTableID
				AND columnType <> 4
				AND columnType <> 3
				AND dataType <> -3
				AND dataType <> -4);
		END
	END
	ELSE
	BEGIN
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @plngViewID > 0 
			BEGIN	
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM [dbo].[ASRSysViews]
				WHERE viewID = @plngViewID;
			END
			ELSE
			BEGIN
				SET @sRealSource = @sTableName;
			END 
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @lngTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sRealSource = left(@sRealSource, 255);
			END
		END

   		 INSERT INTO @ColumnInfo (
			columnID, 
			columnName,
			dataType,
			readGranted,
			size,
			decimals)
		(SELECT 
			ASRSysColumns.columnId,
			syscolumns.name,
			ASRSysColumns.dataType,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END,
			ASRSysColumns.size,
			ASRSysColumns.decimals				
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		INNER JOIN ASRSysColumns ON syscolumns.name = ASRSysColumns.columnName
		WHERE p.action = 193 
			AND p.uid = @iUserGroupID
			AND ASRSysColumns.tableID = @lngTableID
			AND ASRSysColumns.columnType <> 4
			AND ASRSysColumns.columnType <> 3
			AND ASRSysColumns.dataType <> -3
			AND ASRSysColumns.dataType <> -4
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name = @sRealSource
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)));
	END

	SET @psRealSource = @sRealSource;

	/* Return the resultset. */
	SELECT columnID, columnName, dataType, size, decimals
	FROM @ColumnInfo 
	WHERE readGranted = 1
	ORDER BY columnName;
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetFindRecords3]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetFindRecords3] (
	@pfError 				bit 			OUTPUT, 
	@pfSomeSelectable 		bit 			OUTPUT, 
	@pfSomeNotSelectable 	bit 			OUTPUT, 
	@psRealSource			varchar(255)	OUTPUT,
	@pfInsertGranted		bit				OUTPUT,
	@pfDeleteGranted		bit				OUTPUT,
	@piTableID 				integer, 
	@piViewID 				integer, 
	@piOrderID 				integer, 
	@piParentTableID		integer,
	@piParentRecordID		integer,
	@psFilterDef			varchar(MAX),
	@piRecordsRequired		integer,
	@pfFirstPage			bit				OUTPUT,
	@pfLastPage				bit				OUTPUT,
	@psLocateValue			varchar(MAX),
	@piColumnType			integer			OUTPUT,
	@piColumnSize			integer			OUTPUT,
	@piColumnDecimals		integer			OUTPUT,
	@psAction				varchar(255),
	@piTotalRecCount		integer			OUTPUT,
	@piFirstRecPos			integer			OUTPUT,
	@piCurrentRecCount		integer,
	@psDecimalSeparator		varchar(255),
	@psLocaleDateFormat		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the find records for the current user, given the table/view and order IDs.
		@pfError = 1 if errors occured in getting the find records. Else 0.
		@pfSomeSelectable = 1 if some find columns were selectable. Else 0.
		@pfSomeNotSelectable = 1 if some find columns were NOT selectable. Else 0.
		@piTableID = the ID of the table on which the find is based.
		@piViewID = the ID of the view on which the find is based.
		@piOrderID = the ID of the order we are using.
		@piParentTableID = the ID of the parent table.
		@piParentRecordID = the ID of the associated record in the parent table.
	*/
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iDataType 			integer,
		@iTempAction		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(5),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@iCount				integer,
		@iGetCount			integer,
		@iSize				integer,
		@iDecimals			integer,
		@bUse1000Separator	bit,
		@sActualLoginName	varchar(250),
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sTempLocateValue	varchar(MAX),
		@sSubFilterSQL		nvarchar(MAX),
		@bBlankIfZero		bit,
		@sTempFilterString	varchar(MAX),
		@sJoinSQL			nvarchar(max),
		@psOriginalAction		varchar(255),
		@sThousandColumns		varchar(255),
		@sBlankIfZeroColumns	varchar(255);
	
	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''');
	/* Initialise variables. */
	SET @pfError = 0;
	SET @pfSomeSelectable = 0;
	SET @pfSomeNotSelectable = 0;
	SET @sDESCstring = ' DESC';
	SET @fFirstColumnAsc = 1;
	SET @sFirstColCode = '';
	SET @piColumnSize = 0;
	SET @piColumnDecimals = 0;
	SET @bUse1000Separator = 0;
	SET @bBlankIfZero = 0;
	SET @sThousandColumns = '';
	SET @sBlankIfZeroColumns = '';

	SET @sRealSource = '';
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @sReverseOrderSQL = '';
	SET @fSelectDenied = 0;
	SET @sExecString = '';
	SET @sFilterSQL = '';
	SET @sTempLocateValue = '';
	
	SET @psOriginalAction = @psAction;
	
	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000;
	SET @psAction = UPPER(@psAction);
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE') AND 
		(@psAction <> 'LOCATEID')
	BEGIN
		SET @psAction = 'MOVEFIRST';
	END
	
	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualLoginName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	-- Create a temporary view of the sysprotects table
	DECLARE @SysProtects TABLE([ID] int, Columns varbinary(8000)
								, [Action] tinyint
								, ProtectType tinyint);
	INSERT INTO @SysProtects
	SELECT p.[ID], p.[Columns], p.[Action], p.ProtectType FROM ASRSysProtectsCache p WHERE p.UID = @iUserGroupID;
	
	-- Create a temporary table to hold the tables/views that need to be joined.
	DECLARE @JoinParents TABLE(tableViewName sysname, tableID integer);

	-- Create a temporary table of the 'select' column permissions for all tables/views used in the order.
	DECLARE @ColumnPermissions TABLE(tableID integer,
								tableViewName	sysname,
								columnName	sysname,
								selectGranted	bit);
								
	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piTableID;
	
	IF (@sTableName IS NULL) 
	BEGIN 
		SET @pfError = 1;
		RETURN;
	END
	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM [dbo].[ASRSysChildViews2]
		WHERE tableID = @piTableID
			AND role = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END
	SET @psRealSource = @sRealSource;
	
	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	IF len(@psFilterDef)> 0 
	BEGIN
		WHILE charindex('	', @psFilterDef) > 0
		BEGIN
			SET @sSubFilterSQL = '';
			SET @iIndex1 = charindex('	', @psFilterDef);
			SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1);
			SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1);
				
			SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1));
			SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1));
			SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1);
			
			SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3);
			SELECT @iDataType = dataType,
				@sColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iColumnID;
							
			SET @sColumnName = @sRealSource + '.' + @sColumnName;
			IF (@iDataType = -7) 
			BEGIN
				/* Logic column (must be the equals operator).	*/
				SET @sSubFilterSQL = @sColumnName + ' = ';
			
				IF UPPER(@sValue) = 'TRUE'
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '1';
				END
				ELSE
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '0';
				END
			END
			
			IF ((@iDataType = 2) OR (@iDataType = 4)) 
			BEGIN
				/* Numeric/Integer column. */
				/* Replace the locale decimal separator with '.' for SQL's benefit. */
				SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.');
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equals. */
					SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
        
				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
				IF (@iOperatorID = 6) 
				BEGIN
					/* Less than.*/
					SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
			END
			IF (@iDataType = 11) 
			BEGIN
				/* Date column. */
				IF LEN(@sValue) > 0
				BEGIN
					/* Convert the locale date into the SQL format. */
					/* Note that the locale date has already been validated and formatted to match the locale format. */
					SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat);
					SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat);
					SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat);
						
					SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex3, 4);
				END

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					IF LEN(@sValue) > 0 
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 6)
				BEGIN
					/* Less than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
			END
			
			IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
			BEGIN
				/* Character/Working Pattern column. */
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + '''';
					END
				END
				
				IF (@iOperatorID = 2) 
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 7)
				BEGIN
					/* Contains */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%''';
					END
				END
				
				IF (@iOperatorID = 8) 
				BEGIN
					/* Does Not Contain. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%''';
					END
				END
			END
			
			IF LEN(@sSubFilterSQL) > 0
			BEGIN
				/* Add the filter code for this grid record into the complete filter code. */
				IF LEN(@sFilterSQL) > 0
				BEGIN
					SET @sFilterSQL = @sFilterSQL + ' AND (';
				END
				ELSE
				BEGIN
					SET @sFilterSQL = @sFilterSQL + '(';
				END
				SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')';
			END
		END
	END
	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ASRSysColumns.tableID
		FROM [dbo].[ASRSysOrderItems]
		INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnID
		WHERE ASRSysOrderItems.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;
	
	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.tableID,
		ASRSysOrderItems.columnID, 
		ASRSysColumns.columnName,
	    	ASRSysTables.tableName,
		ASRSysOrderItems.ascending,
		ASRSysOrderItems.type,
		ASRSysColumns.dataType,
		ASRSysColumns.size,
		ASRSysColumns.decimals,
		ASRSysColumns.Use1000Separator,
		ASRSysColumns.BlankIfZero
	FROM [dbo].[ASRSysOrderItems]
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnID
	INNER JOIN ASRSysTables ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysOrderItems.orderID = @piOrderID
	ORDER BY ASRSysOrderItems.sequence;
	
	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iSize, @iDecimals, @bUse1000Separator, @bBlankIfZero;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END
	WHILE (@@fetch_status = 0)
	BEGIN

		SET @fSelectGranted = 0;
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName;
				
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName;

					SET @sSelectSQL = @sSelectSQL + @sTempString;
					SET @sThousandColumns = @sThousandColumns + convert(varchar(1),@bUse1000Separator);
					SET @sBlankIfZeroColumns = @sBlankIfZeroColumns + convert(varchar(1),@bBlankIfZero);
					
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @piColumnSize = @iSize;
						SET @piColumnDecimals = @iDecimals;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName;
						IF (@psAction = 'LOCATEID')
						BEGIN
							IF @piColumnType = 11 /* Date column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = isnull(convert(varchar(MAX), ' + @sRealSource + '.' + @sColumnName + ', 101), '''')';
							END
							ELSE
							IF @piColumnType = -7 /* Logic column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = convert(varchar(MAX), isnull(' + @sRealSource + '.' + @sColumnName + ', 0))';
							END
							ELSE IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = convert(varchar(MAX), isnull(' + @sRealSource + '.' + @sColumnName + ', 0))';
							END
							ELSE
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = replace(isnull(' + @sRealSource + '.' + @sColumnName + ', ''''), '''''''', '''''''''''')' ;
							END
							
							SET @sTempExecString = @sTempExecString
								+ ' FROM ' + @sRealSource
								+ ' WHERE ' + @sRealSource + '.ID = ' + @psLocateValue;
							SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
							EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
						END
					END
					
					SET @sOrderSQL = @sOrderSQL + CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1;
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName;
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + @sColumnTableName + '.' + @sColumnName;
					SET @sSelectSQL = @sSelectSQL + @sTempString;
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @piColumnSize = @iSize;
						SET @piColumnDecimals = @iDecimals;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName;
						IF (@psAction = 'LOCATEID')
						BEGIN
							SET @sTempLocateValue = '';
						END
					END
					SET @sOrderSQL = @sOrderSQL + CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;
				END
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @JoinParents
				WHERE tableViewName = @sColumnTableName;
				
				IF @iTempCount = 0
				BEGIN
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = '';
				
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
					SELECT tableViewName
					FROM @ColumnPermissions
					WHERE tableID = @iColumnTableId
						AND tableViewName <> @sColumnTableName
						AND columnName = @sColumnName
						AND selectGranted = 1;
						
				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE';
					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewname = @sViewName;
					
					IF @iTempCount = 0
					BEGIN
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId);
					END
					FETCH NEXT FROM viewCursor INTO @sViewName;
				END

				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +	' ELSE NULL END';
					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END;
						SET @sSelectSQL = @sSelectSQL + @sTempString;
							
						SET @sTempString = ' AS [' + @sColumnName + ']';
						SET @sSelectSQL = @sSelectSQL + @sTempString;
						
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType;
							SET @piColumnSize = @iSize;
							SET @piColumnDecimals = @iDecimals;
							SET @fFirstColumnAsc = @fAscending;
							SET @sFirstColCode = @sSubString;
							IF (@psAction = 'LOCATEID')
							BEGIN
								SET @sTempLocateValue = '';
							END
						END
						SET @sOrderSQL = @sOrderSQL + CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END;
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1;
				END	
			END
		END
		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iSize, @iDecimals, @bUse1000Separator, @bBlankIfZero;
	END

	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	IF @psAction = 'LOCATEID'
	BEGIN
		SET @psAction = 'LOCATE';
		SET @psLocateValue = @sTempLocateValue;
	END
	
	/* Set the flags that show if no order columns could be selected, or if only some of them could be selected. */
	SET @pfSomeSelectable = CASE WHEN (len(@sSelectSQL) > 0) THEN 1 ELSE 0 END;
	SET @pfSomeNotSelectable = @fSelectDenied;

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID';

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL;
		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL);
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', ';
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', ';
			END
			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1);
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex);
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring;
	END
	
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;
	IF @piParentTableID > 0 
	BEGIN
		SET @sTempExecString = @sTempExecString + 
			' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
		IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' AND ' + @sFilterSQL;
	END
	ELSE
	BEGIN
		IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;
	END
	
	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;

	SET @piTotalRecCount = @iCount;
	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID';
		SET @sSelectSQL = @sSelectSQL + @sTempString;

		SET @sExecString = 'SELECT ' 
		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
			SET @sExecString = @sExecString + @sTempString;
		END
	
		SET @sTempString = @sSelectSQL + ' FROM ' + @sRealSource;
		SET @sExecString = @sExecString + @sTempString;

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @JoinParents;
		
		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		
		CLOSE joinCursor;
		DEALLOCATE joinCursor;
		
		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'MOVENEXT') 
		BEGIN
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END
		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1;
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString;

		END
		/* Add the filter code. */
		IF @piParentTableID > 0 
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
			SET @sExecString = @sExecString + @sTempString;
				
			IF len(@sFilterSQL) > 0
			BEGIN
				SET @sTempString = ' AND ' + @sFilterSQL;
				SET @sExecString = @sExecString + @sTempString;
			END
		END
		ELSE
		BEGIN
			IF len(@sFilterSQL) > 0
			BEGIN
				SET @sTempString = ' WHERE ' + @sFilterSQL;
				SET @sExecString = @sExecString + @sTempString;
			END
		END
		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'LOCATE')
		BEGIN
			SET @sLocateCode = '';
			IF (@piParentTableID > 0) OR (len(@sFilterSQL) > 0) 
			BEGIN
				SET @sLocateCode = @sLocateCode + ' AND (' + @sFirstColCode;
			END
			ELSE
			BEGIN
				SET @sLocateCode = @sLocateCode + ' WHERE (' + @sFirstColCode;
			END;
			
			SET @sJoinSQL = '';
			DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName, 
				tableID
			FROM @JoinParents;
			OPEN joinCursor;
			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @sJoinSQL = @sJoinSQL + 
					' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
				FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
			END;
			
			CLOSE joinCursor;
			DEALLOCATE joinCursor;

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = replace(isnull(' + @sFirstColCode + ', ''''), '''''''', '''''''''''')' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL						
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ''' + @sTempLocateValue + '''';
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL';
						
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' <= ''' + @sTempLocateValue + '''';
					END;
				END
			END
			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = isnull(convert(varchar(MAX),' + @sFirstColCode + ', 101), '''')' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL						
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						IF len(@sTempLocateValue) > 0
						BEGIN
							SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ''' + @sTempLocateValue + '''';
						END
					END;
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						IF len(@sTempLocateValue) > 0
						BEGIN
							SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ''' + @sTempLocateValue + '''';
						END
					END;
				END
			END
			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = convert(varchar(MAX), isnull(' + @sFirstColCode + ', 0))' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL	
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL	;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;
				
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ' + 
							CASE
								WHEN @sTempLocateValue = 'True' THEN '1'
								ELSE '0'
							END;
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ' + 
							CASE
								WHEN @sTempLocateValue = 'True' THEN '1'
								ELSE '0'
							END;
					END;
				END
			END
			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = convert(varchar(MAX), isnull(' + @sFirstColCode + ', 0))' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL	
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL	;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue;
					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ' + @sTempLocateValue;
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL';

					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ' + @sTempLocateValue ;
					END;
				END
			END
			SET @sLocateCode = @sLocateCode + ')';
			SET @sTempString = @sLocateCode;
			SET @sExecString = @sExecString + @sTempString;
		END

		--/* Add in the string to include max number of records available in block */				
		--/* Fault HRPRO-382 */
		--IF @psAction = 'LOCATE'
		--BEGIN
		--	SET @sTempString = ' OR '+@sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource
		--	SET @sTempFilterString = ''
			
		--	IF @piParentTableID > 0 SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						

		--	IF LEN(@sFilterSQL) > 0
		--	BEGIN
		--		IF LEN(@sTempFilterString) > 0
		--			SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	
		--		ELSE
		--			SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL	
		--	END
			
		--	--use for 'go to' only:
		--	IF @psOriginalAction = 'LOCATE'
		--	BEGIN
		--		IF LEN(@sLocateCode) > 0 SET @sTempFilterString = @sTempFilterString + @sLocateCode	
		--	END
			
		--	SET @sTempString = @sTempString + @sTempFilterString
		--	SET @sTempString = @sTempString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
		--	SET @sExecString = @sExecString + @sTempString;		
		--END
		
		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL;
		SET @sExecString = @sExecString + @sTempString;
				
	END

	/* Check if the user has insert or delete permission on the table. */
	SET @pfInsertGranted = 0;
	SET @pfDeleteGranted = 0;
	IF LEN(@sRealSource) > 0
	BEGIN
		DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT p.action
		FROM @sysprotects p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		WHERE p.protectType <> 206
			AND ((p.action = 195) OR (p.action = 196))
			AND sysobjects.name = @sRealSource;
			
		OPEN tableInfo_cursor;
		FETCH NEXT FROM tableInfo_cursor INTO @iTempAction;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @iTempAction = 195
			BEGIN
				SET @pfInsertGranted = 1;
			END
			ELSE
			BEGIN
				SET @pfDeleteGranted = 1;
			END
			FETCH NEXT FROM tableInfo_cursor INTO @iTempAction;
		END
		
		CLOSE tableInfo_cursor;
		DEALLOCATE tableInfo_cursor;
		
	END
	
	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1;
		SET @pfFirstPage = 1;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
		SET @pfFirstPage = 0;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 1;
	END
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @JoinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		
		CLOSE joinCursor;
		DEALLOCATE joinCursor;
		
		IF @piParentTableID > 0 
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
			IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' AND ' + @sFilterSQL;
		END
		ELSE
		BEGIN
			IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;
		END
		
		SET @sTempExecString = @sTempExecString + @sLocateCode;
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT;
		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1;
		END
		ELSE
		BEGIN
			--IF @psOriginalAction = 'LOCATEID'	
			--BEGIN				
			--	SET @piFirstRecPos = @piTotalRecCount - CASE WHEN @piRecordsRequired > @piTotalRecCount THEN @piTotalRecCount - 1 ELSE @piRecordsRequired END;
			--END
			--ELSE 
			--BEGIN
				SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1;
			--END
		END
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	
	-- Return a recordset of the required columns in the required order from the given table/view.
	IF (@pfSomeSelectable = 1)
	BEGIN

		SELECT @sBlankIfZeroColumns AS BlankIfZeroColumns
			, @sThousandColumns AS ThousandColumns

		EXECUTE sp_executeSQL @sExecString;
	END


END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetPersonnelParameters]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetPersonnelParameters] (
	@piEmployeeTableID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @fOK			bit,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sActualUserName	sysname;

	/* Personnel information. */
	SET @fOK = 1;
	SET @piEmployeeTableID = 0;

	/* Get the current user's group id. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'PERSONNEL', @fOK OUTPUT;

	/* Get the required training booking module paramaters. */
	IF @fOK = 1
	BEGIN
		/* Get the EMPLOYEE table information. */
		SELECT @piEmployeeTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_PERSONNEL'
			AND parameterKey = 'Param_TablePersonnel';
		IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0;
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetPicklistDefinition]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetPicklistDefinition] (
	@piPicklistID 			integer, 
	@psAction				varchar(255),
	@psErrorMsg				varchar(MAX)	OUTPUT,
	@psPicklistName			varchar(255)	OUTPUT,
	@psPicklistOwner		varchar(255)	OUTPUT,
	@psPicklistDesc			varchar(MAX)	OUTPUT,
	@psAccess				varchar(255)	OUTPUT,
 	@piTimestamp			integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount		integer,
		@sCurrentUser	sysname,
		@fSysSecMgr		bit;

	SET @psErrorMsg = '';
	SET @sCurrentUser = SYSTEM_USER;

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
	/* Check the picklist exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysPicklistName 
	WHERE picklistID = @piPicklistID

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'picklist has been deleted by another user.'
		RETURN
	END

	SELECT @psPicklistName = name,
		@psPicklistOwner = userName,
		@psPicklistDesc = description,
		@psAccess = access,
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysPicklistName 
	WHERE picklistID = @piPicklistID

	/* Check the current user can view the report. */
	IF (@psAccess = 'HD') AND (@psPicklistOwner <> @sCurrentUser) AND (@fSysSecMgr = 0)
	BEGIN
		SET @psErrorMsg = 'picklist has been made hidden by another user.'
		RETURN
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@psAccess = 'RO') AND (@psPicklistOwner <> @sCurrentUser)  AND (@fSysSecMgr = 0)
	BEGIN
		SET @psErrorMsg = 'picklist has been made read only by another user.'
		RETURN
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psPicklistName = left('copy of ' + @psPicklistName, 50)
		SET @psPicklistOwner = @sCurrentUser
	END

	/* Get the picklist records. */
	SELECT recordID
	FROM ASRSysPickListItems
	WHERE pickListID = @piPicklistID
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetScreenControlsString2]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetScreenControlsString2] (
	@piScreenID 	integer,
	@piViewID 		integer,
	@psSelectSQL	varchar(MAX) OUTPUT,
	@psFromDef		varchar(MAX) OUTPUT,
	@piOrderID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@iScreenTableID		integer,
		@iScreenTableType	integer,
		@sScreenTableName	varchar(255),
		@iScreenOrderID 	integer,
		@sRealSource 		varchar(255),
		@iChildViewID 		integer,
		@sJoinCode 			varchar(MAX),
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@fUpdateGranted 	bit,
		@sSelectString 		varchar(MAX),
		@iTempCount 		integer,
		@sViewName 			varchar(255),
		@fAscending 		bit,
		@sTableViewName 	varchar(255),
		@iJoinTableID 		integer,
		@sParentRealSource	varchar(255),
		@iParentChildViewID	integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iColumnType		integer,
		@iLinkTableID		integer,
		@lngPermissionCount	integer,
		@iLinkChildViewID	integer,
		@sLinkRealSource	varchar(255),
		@sLinkTableName		varchar(255),
		@iLinkTableType		integer,
		@sNewBit			varchar(max),
		@iID				integer,
		@iCount				integer,
		@iUserType			integer,
		@sRoleName			sysname,
		@iEmployeeTableID	integer,
		@sActualUserName	sysname,
		@AppName varchar(50),
		@ItemKey varchar(20);

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;


	DECLARE @SysProtects TABLE([ID] int, Columns varbinary(8000)
								, [Action] tinyint
								, ProtectType tinyint)
	INSERT INTO @SysProtects
	SELECT p.[ID], p.[Columns], p.[Action], p.ProtectType FROM ASRSysProtectsCache p
		INNER JOIN SysColumns c ON (c.id = p.id
			AND c.[Name] = 'timestamp'
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) = 0)))
		WHERE p.UID = @iUserGroupID
			AND [ProtectType] IN (204, 205)
			AND [Action] IN (193, 197);


	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @JoinParents TABLE(tableViewName	sysname,
								tableID		integer);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @ColumnPermissions TABLE(tableID		integer,
										tableViewName	sysname,
										columnName	sysname,
										action		int,		
										granted		bit);


	/* Get the table type and name. */
	SELECT @iScreenTableID = ASRSysScreens.tableID,
		@iScreenTableType = ASRSysTables.tableType,
		@sScreenTableName = ASRSysTables.tableName,
		@iScreenOrderID = 
				CASE 
					WHEN ASRSysScreens.orderID > 0 THEN ASRSysScreens.orderID
					ELSE ASRSysTables.defaultOrderID 
				END
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID;

	IF @iScreenOrderID IS NULL SET @iScreenOrderID = 0;

	IF @piOrderID <= 0 SET @piOrderID = @iScreenOrderID;

	/* Get the real source of the given screen's table/view. */
	IF @iScreenTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			/* RealSource is the table. */	
			SET @sRealSource = @sScreenTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iScreenTableID
			AND role = @sRoleName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sScreenTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	/* Initialise the select and order parameters. */
	SET @psSelectSQL = '';
	SET @psFromDef = '';
	SET @sJoinCode = '';

	/* Loop through the tables used in the screen, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID
	FROM ASRSysControls
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0
	UNION
	SELECT DISTINCT ASRSysColumns.tableID 
	FROM ASRSysOrderItems 
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	WHERE ASRSysOrderItems.type = 'O' 
		AND ASRSysOrderItems.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @iScreenTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				p.action,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			SELECT @iParentTableType = tableType,
				@sParentTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @iTempTableID

			IF @iParentTableType <> 2 /* ie. top-level or lookup */
			BEGIN
				INSERT INTO @ColumnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					p.[action],
					CASE p.protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @sysprotects p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				INNER JOIN syscolumns ON p.id = syscolumns.id
				WHERE syscolumns.name <> 'timestamp'
					AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @iTempTableID 
						UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			END
			ELSE
			BEGIN
				/* Get permitted child view on the parent table. */
				SELECT @iParentChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @iTempTableID
					AND role = @sRoleName
					
				IF @iParentChildViewID IS null SET @iParentChildViewID = 0
					
				IF @iParentChildViewID > 0 
				BEGIN
					SET @sParentRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iParentChildViewID) +
						'#' + replace(@sParentTableName, ' ', '_') +
						'#' + replace(@sRoleName, ' ', '_')
					SET @sParentRealSource = left(@sParentRealSource, 255)

					INSERT INTO @ColumnPermissions
					SELECT 
						@iTempTableID,
						@sParentRealSource,
						syscolumns.name,
						p.[action],
						CASE p.protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @sysprotects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					WHERE syscolumns.name <> 'timestamp'
						AND sysobjects.name = @sParentRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				END
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	SET @iUserType = 1

	/*Ascertain application name in order to select by correct item key  */
	SELECT @AppName = APP_NAME()
	IF @AppName = 'OPENHR SELF-SERVICE INTRANET'
	BEGIN
		SET @ItemKey = 'SSINTRANET'
	END
	ELSE
	BEGIN
		SET @ItemKey = 'INTRANET'
	END

	SELECT @iID = ASRSysPermissionItems.itemID
	FROM ASRSysPermissionItems
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	WHERE ASRSysPermissionItems.itemKey = @ItemKey
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	IF @iID IS NULL SET @iID = 0
	IF @iID > 0
	BEGIN
		/* The permission does exist in the current version so check if the user is granted this permission. */
		SELECT @iCount = count(ASRSysGroupPermissions.itemID)
		FROM ASRSysGroupPermissions 
		WHERE ASRSysGroupPermissions.itemID = @iID
			AND ASRSysGroupPermissions.groupName = @sRoleName
			AND ASRSysGroupPermissions.permitted = 1
			
		IF @iCount > 0
		BEGIN
			SET @iUserType = 0
		END
	END

	/* Get the EMPLOYEE table information. */
	SELECT @iEmployeeTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_PERSONNEL'
		AND parameterKey = 'Param_TablePersonnel'
	IF @iEmployeeTableID IS NULL SET @iEmployeeTableID = 0

	/* Create a temporary table of the column info for all columns used in the screen controls. */
	DECLARE @columnInfo TABLE
	(
		columnID	integer,
		selectGranted	bit,
		updateGranted	bit
	)

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID, 
		ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType,
		ASRSysColumns.columnType,
		ASRSysColumns.linkTableID
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE screenID = @piScreenID
	AND ASRSysControls.columnID > 0

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
		SET @fUpdateGranted = 0

		IF @iColumnTableID = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193

			/* Get the update permission on the column. */
			SELECT @fUpdateGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 197

			/* If the column is a link column, ensure that the link table can be seen. */
			IF (@fUpdateGranted = 1) AND (@iColumnType = 4)
			BEGIN
				SELECT @sLinkTableName = tableName,
					@iLinkTableType = tableType
				FROM ASRSysTables
				WHERE tableID = @iLinkTableID

				IF @iLinkTableType = 1
				BEGIN
					/* Top-level table. */
					SELECT @lngPermissionCount = COUNT(sysprotects.uid)
					FROM sysprotects
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.action = 193
						AND sysprotects.protectType <> 206
						AND syscolumns.name <> 'timestamp'
						AND syscolumns.name <> 'ID'
						AND sysobjects.name = @sLinkTableName
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					IF @lngPermissionCount = 0 
					BEGIN
						/* No permission on the table itself check the views. */
						SELECT @lngPermissionCount = COUNT(ASRSysViews.viewTableID)
						FROM ASRSysViews
						INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
						INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
						WHERE ASRSysViews.viewTableID = @iLinkTableID
							AND sysprotects.uid = @iUserGroupID
							AND sysprotects.action = 193
							AND sysprotects.protecttype <> 206

						IF @lngPermissionCount = 0 SET @fUpdateGranted = 0
					END
				END
				ELSE
				BEGIN
					/* Child/history table. */
					SELECT @iLinkChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @iLinkTableID
						AND role = @sRoleName
						
					IF @iLinkChildViewID IS null SET @iLinkChildViewID = 0
						
					IF @iLinkChildViewID > 0 
					BEGIN
						SET @sLinkRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iLinkChildViewID) +
							'#' + replace(@sLinkTableName, ' ', '_') +
							'#' + replace(@sRoleName, ' ', '_')
						SET @sLinkRealSource = left(@sLinkRealSource, 255)
					END

					SELECT @lngPermissionCount = COUNT(sysobjects.name)
					FROM sysprotects 
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.protectType <> 206
						AND sysprotects.action = 193
						AND sysobjects.name = @sLinkRealSource
		
					IF @lngPermissionCount = 0 SET @fUpdateGranted = 0
				END
			END

			IF @fSelectGranted = 1 
			BEGIN
				/* Get the select string for the column. */
				IF len(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';
			
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(255), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				IF len(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';
	
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sColumnTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sColumnTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
			
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewName = @sColumnTableName;

				IF @iTempCount = 0
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
					
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sSelectString = '';

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableID
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND action = 193
					AND granted = 1;

				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)

				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1;

					IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';
	
					IF @iColumnDataType = 11 /* Date */
					BEGIN
						 /* Date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
					END
					ELSE
					BEGIN
						 /* Non-date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
					END

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
						FROM @JoinParents
						WHERE tableViewName = @sViewName;

					IF @iTempCount = 0
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableID);

					FETCH NEXT FROM viewCursor INTO @sViewName;
				END
				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSelectString) > 0
				BEGIN
					SET @sSelectString = @sSelectString +
						' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

					IF len(@psSelectSQL) > 0 
						SET @psSelectSQL = @psSelectSQL + ',';

					SET @psSelectSQL = @psSelectSQL + @sSelectString;
				END
			END

			/* Reset the update permission on the column. */
			SET @fUpdateGranted = 0
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0
		IF @fUpdateGranted IS NULL SET @fUpdateGranted = 0

		IF (@iUserType = 1) 
			AND (@iScreenTableType = 1)
			AND (@iScreenTableID <> @iEmployeeTableID)
		BEGIN
			SET @fUpdateGranted = 0
		END

		INSERT INTO @columnInfo (columnID, selectGranted, updateGranted)
			VALUES (@iColumnId, @fSelectGranted, @fUpdateGranted)

		FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor

	/* Create the order string. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.tableID,
		ASRSysOrderItems.columnID, 
		ASRSysColumns.columnName,
	    	ASRSysTables.tableName,
		ASRSysOrderItems.ascending
	FROM ASRSysOrderItems
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysOrderItems.orderID = @piOrderID
		AND ASRSysOrderItems.type = 'O'
	ORDER BY ASRSysOrderItems.sequence

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @iColumnTableId = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @JoinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND action = 193
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the id and timestamp columns to the select string. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnId, 
		ASRSysColumns.columnName
	FROM ASRSysColumns
	WHERE tableID = @iScreenTableID
		AND columnType = 3

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName
	WHILE (@@fetch_status = 0)
	BEGIN
		IF len(@psSelectSQL) > 0 
			SET @psSelectSQL = @psSelectSQL + ',';

		SET @sNewBit = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
		SET @psSelectSQL = @psSelectSQL + @sNewBit;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	SET @sNewBit = ', CONVERT(integer, ' + @sRealSource + '.TimeStamp) AS timestamp ';
	SET @psSelectSQL = @psSelectSQL + @sNewBit;

	/* Create the FROM code. */
	SET @psFromDef = @sRealSource + '	'
	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName, tableID
		FROM @JoinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psFromDef = @psFromDef + @sTableViewName + '	' + convert(varchar(100), @iJoinTableID) + '	';
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SELECT
		convert(varchar(MAX), case when ASRSysControls.pageNo IS null then '' else ASRSysControls.pageNo end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.tableID IS null then '' else ASRSysControls.tableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.columnID IS null then '' else ASRSysControls.columnID end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.controlType IS null then '' else ASRSysControls.controlType end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.topCoord IS null then '' else ASRSysControls.topCoord end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.leftCoord IS null then '' else ASRSysControls.leftCoord end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.height IS null then '' else ASRSysControls.height end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.width IS null then '' else ASRSysControls.width end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.caption IS null then '' else ASRSysControls.caption end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.backColor IS null then '' else ASRSysControls.backColor end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.foreColor IS null then '' else ASRSysControls.foreColor end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontName IS null then '' else ASRSysControls.fontName end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontSize IS null then '' else ASRSysControls.fontSize end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontBold IS null then '' else ASRSysControls.fontBold end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontItalic IS null then '' else ASRSysControls.fontItalic end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontStrikethru IS null then '' else ASRSysControls.fontStrikethru end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontUnderline IS null then '' else ASRSysControls.fontUnderline end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.displayType IS null then '' else ASRSysControls.displayType end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.tabIndex IS null then '' else ASRSysControls.tabIndex end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.borderStyle IS null then '' else ASRSysControls.borderStyle end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.alignment IS null then '' else ASRSysControls.alignment end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnName IS null then '' else ASRSysColumns.columnName end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnType IS null then '' else ASRSysColumns.columnType end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.datatype IS null then '' else ASRSysColumns.datatype end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.defaultValue IS null then '' else ASRSysColumns.defaultValue end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.size IS null then '' else convert(nvarchar(max),ASRSysColumns.size) end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.decimals IS null then '' else ASRSysColumns.decimals end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.lookupTableID IS null then '' else ASRSysColumns.lookupTableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.lookupColumnID IS null then '' else ASRSysColumns.lookupColumnID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerMinimum IS null then '' else ASRSysColumns.spinnerMinimum end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerMaximum IS null then '' else ASRSysColumns.spinnerMaximum end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerIncrement IS null then '' else ASRSysColumns.spinnerIncrement end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.mandatory IS null then '' else ASRSysColumns.mandatory end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.uniquechecktype IS null then '' when ASRSysColumns.uniquechecktype <> 0 then 1 else 0 end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.convertcase IS null then '' else ASRSysColumns.convertcase end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.mask IS null then '' else rtrim(ASRSysColumns.mask) end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.blankIfZero IS null then '' else ASRSysColumns.blankIfZero end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.multiline IS null then '' else ASRSysColumns.multiline end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.alignment IS null then '' else ASRSysColumns.alignment end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.dfltValueExprID IS null then '' else ASRSysColumns.dfltValueExprID end) + char(9) +
		convert(varchar(MAX), case when isnull(ASRSysColumns.readOnly,0) = 1 then 1 else 0 end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.statusBarMessage IS null then '' else ASRSysColumns.statusBarMessage end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkTableID IS null then '' else ASRSysColumns.linkTableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkOrderID IS null then '' else ASRSysColumns.linkOrderID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkViewID IS null then '' else ASRSysColumns.linkViewID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.Afdenabled IS null then '' else ASRSysColumns.Afdenabled end) + char(9) +
		convert(varchar(MAX), case when ASRSysTables.TableName IS null then '' else ASRSysTables.TableName end) + char(9) +
		convert(varchar(MAX), case when ci.selectGranted IS null then '' else ci.selectGranted end) + char(9) +
		convert(varchar(MAX), case when ci.updateGranted IS null then '' else ci.updateGranted end) + char(9) +
		'' + char(9) +
		convert(varchar(MAX), case when ASRSysControls.pictureID IS null then '' else ASRSysControls.pictureID end)+ char(9) +
		convert(varchar(MAX), case when ASRSysColumns.trimming IS null then '' else ASRSysColumns.trimming end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.Use1000Separator IS null then '' else ASRSysColumns.Use1000Separator end) + char(9) +	
		convert(varchar(MAX), case when ASRSysColumns.lookupFilterColumnID IS null then '' else ASRSysColumns.lookupFilterColumnID end) + char(9) +	
		convert(varchar(MAX), case when ASRSysColumns.LookupFilterValueID IS null then '' else ASRSysColumns.LookupFilterValueID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.OLEType IS null then '' else ASRSysColumns.OLEType end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.MaxOLESizeEnabled IS null then '' else ASRSysColumns.MaxOLESizeEnabled end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.MaxOLESize IS null then '' else ASRSysColumns.MaxOLESize end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateTo IS null then '' else ASRSysControls.NavigateTo end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateIn IS null then '' else ASRSysControls.NavigateIn end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateOnSave IS null then '' else ASRSysControls.NavigateOnSave end) + char(9) +
		convert(varchar(MAX), case when isnull(ASRSysControls.readOnly,0) = 1 then 1 else 0 end)
		AS [controlDefinition],
		ASRSysControls.pageNo AS [pageNo],
		ASRSysControls.controlLevel AS [controlLevel],
		ASRSysControls.tabIndex AS [tabIndex]
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	LEFT OUTER JOIN @columnInfo ci ON ASRSysColumns.columnId = ci.columnID
	WHERE screenID = @piScreenID
	UNION
	SELECT 
		convert(varchar(MAX), -1) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnId IS null then '' else ASRSysColumns.columnId end)  + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnName IS null then '' else ASRSysColumns.columnName end) 
		AS [controlDefinition],
		0 AS [pageNo],
		0 AS [controlLevel],
		0 AS [tabIndex]
	FROM ASRSysColumns
	WHERE tableID = @iScreenTableID
		AND columnType = 3
	ORDER BY [pageNo],
		[controlLevel] DESC, 
		[tabIndex];

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetScreenDefinition]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetScreenDefinition] (
	@piScreenID 		integer,
	@piViewID			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @iTabCount 		integer,
		@sTabCaptions		varchar(MAX),
		@sTabCaption		varchar(MAX),
		@fSysSecMgr			bit,
		@fInsertGranted		bit,
		@fDeleteGranted		bit,
		@sRealSource		sysname,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iTableID			integer,
		@iTableType			integer,
		@sTableName			sysname,
		@iTempAction		integer,
		@iChildViewID 		integer,
		@sActualUserName	varchar(250);

	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT
					
	/* Get the table type and name. */
	SELECT @iTableID = ASRSysScreens.tableID,
		@iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	/* Get the real source and insert/delete permissions for the table. */
	IF @fSysSecMgr = 1 
	BEGIN
		/* Permission must be granted for System or Security mangers. */
		SET @fInsertGranted = 1
		SET @fDeleteGranted = 1	

		/* Get the realSource of the table. */
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @piViewID > 0 
			BEGIN
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM ASRSysViews
				WHERE viewID = @piViewID	
			END
			ELSE
			BEGIN
				/* RealSource is the table. */	
				SET @sRealSource = @sTableName
			END 
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)
			END
		END
	END
	ELSE
	BEGIN

		/* Permission must be read from the database  for Non-System and Non-Security mangers. */
		SET @fInsertGranted = 0
		SET @fDeleteGranted = 0	

		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @piViewID > 0 
			BEGIN	
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM ASRSysViews
				WHERE viewID = @piViewID
			END
			ELSE
			BEGIN
				SET @sRealSource = @sTableName
			END 

			/* Get the insert/delete permissions for the realSource. */
			DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT p.action
				FROM ASRSysProtectsCache p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				WHERE p.UID = @iUserGroupID AND p.action  IN (195, 196)
					AND sysobjects.name = @sRealSource
					AND ProtectType <> 206

			OPEN tableInfo_cursor
			FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
			WHILE (@@fetch_status = 0)
			BEGIN
				IF @iTempAction = 195
				BEGIN
					SET @fInsertGranted = 1
				END
				ELSE
				BEGIN
					SET @fDeleteGranted = 1	
				END
				FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
			END
			CLOSE tableInfo_cursor
			DEALLOCATE tableInfo_cursor
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)

				/* Get appropriate child view if required. */
				DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
					SELECT p.action
					FROM ASRSysProtectsCache p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					WHERE sysobjects.name = @sRealSource
						AND p.UID = @iUserGroupID
						AND p.Action IN(193, 195, 196)
						AND ProtectType <> 206

				OPEN tableInfo_cursor
				FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
				WHILE (@@fetch_status = 0)
				BEGIN
					IF @iTempAction = 195
					BEGIN
						SET @fInsertGranted = 1
					END
					ELSE
					BEGIN
						IF @iTempAction = 196
						BEGIN
							SET @fDeleteGranted = 1	
						END
					END
					FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
				END
				CLOSE tableInfo_cursor
				DEALLOCATE tableInfo_cursor
			END
		END
	END
	
	/* Get the tab page captions info. */
	SET @iTabCount = 0
	SET @sTabCaptions = ''
	
	DECLARE captions_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT caption 
		FROM ASRSysPageCaptions
		WHERE screenID = @piScreenID
		ORDER BY pageIndexID

	OPEN captions_cursor
	FETCH NEXT FROM captions_cursor INTO @sTabCaption
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTabCount > 0 SET @sTabCaptions = @sTabCaptions + char(9) 

		SET @iTabCount = @iTabCount + 1
		SET @sTabCaptions = @sTabCaptions + @sTabCaption
			
		FETCH NEXT FROM captions_cursor INTO @sTabCaption
	END
	CLOSE captions_cursor
	DEALLOCATE captions_cursor

	SELECT @sTableName AS tableName,
		@sRealSource AS realSource,
		@fInsertGranted AS insertGranted,
		@fDeleteGranted AS deleteGranted,
		height,
		width,
		fontName,
		fontSize,
		fontBold,
		fontItalic,
		fontStrikethru,
		fontUnderline,
		@iTabCount AS tabCount,
		@sTabCaptions AS tabCaptions
	FROM ASRSysScreens
	WHERE screenID = @piScreenID
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetSummaryFields]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetSummaryFields] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer,
	@pfCanSelect		bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@sColumnName 		varchar(255),
		@fSelectGranted 	bit,
		@iCount				integer,
		@sActualUserName	sysname;

	SET @pfCanSelect = 0;

	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @ColumnPermissions TABLE(
				tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID)

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM ASRSysProtectsCache p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE p.UID = @iUserGroupID
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0))
					AND p.Action = 193

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sParentRealSource = left(@sParentRealSource, 255)
			END

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM ASRSysProtectsCache p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.UID = @iUserGroupID
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				AND p.Action = 193
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnName
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @sColumnName
	WHILE (@@fetch_status = 0) AND (@pfCanSelect = 0)
	BEGIN
		SET @fSelectGranted = 0

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @iCount = COUNT(*)
		FROM @ColumnPermissions
		WHERE columnName = @sColumnName
			AND granted = 1

		IF @iCount > 0 
		BEGIN
			SET @pfCanSelect = 1
		END

		FETCH NEXT FROM columnsCursor INTO @sColumnName
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor


	SELECT DISTINCT ASRSysSummaryFields.sequence, 
    	ASRSysSummaryFields.startOfGroup, 
		ASRSysColumns.columnName, 
		ASRSysColumns.columnId, 
		ASRSysColumns.dataType, 
		ASRSysColumns.size, 
		ASRSysColumns.decimals, 
		ASRSysColumns.controlType, 
		ASRSysColumns.alignment,
		ASRSysColumns.Use1000Separator
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns 
		ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetTrainingBookingParameters]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetTrainingBookingParameters] (
	@piEmployeeTableID			integer	OUTPUT,
	@piCourseTableID			integer	OUTPUT,
	@piCourseCancelDateColumnID	integer	OUTPUT,
	@piTBTableID				integer	OUTPUT,
	@pfTBTableSelect			bit		OUTPUT,
	@pfTBTableInsert			bit		OUTPUT,
	@pfTBTableUpdate			bit		OUTPUT,
	@piTBStatusColumnID			integer	OUTPUT,
	@pfTBStatusColumnUpdate		bit		OUTPUT,
	@piTBCancelDateColumnID		integer	OUTPUT,
	@pfTBCancelDateColumnUpdate	bit		OUTPUT,
	@pfTBProvisionalStatusExists	bit	OUTPUT,
	@piWaitListTableID			integer	OUTPUT,
	@pfWaitListTableInsert			bit	OUTPUT,
	@pfWaitListTableDelete			bit	OUTPUT,
	@piWaitListCourseTitleColumnID		integer	OUTPUT,
	@pfWaitListCourseTitleColumnUpdate	bit	OUTPUT,
	@pfWaitListCourseTitleColumnSelect	bit	OUTPUT,
	@piBulkBookingDefaultViewID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @fOK			bit,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sTempName			sysname,
		@iTempAction		integer,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRealSource		sysname,
		@iStatusCount		integer,
		@iChildViewID		integer,
		@sTBTableName		sysname,
		@sWLTableName		sysname,
		@sActualUserName	sysname;
		
	/* Training Booking information. */
	SET @fOK = 1

	SET @piEmployeeTableID = 0

	SET @piCourseTableID = 0
	SET @piCourseCancelDateColumnID = 0

	SET @piTBTableID = 0
	SET @pfTBTableSelect = 0
	SET @pfTBTableInsert = 0
	SET @pfTBTableUpdate = 0
	SET @piTBStatusColumnID = 0
	SET @pfTBStatusColumnUpdate = 0
	SET @piTBCancelDateColumnID = 0
	SET @pfTBCancelDateColumnUpdate = 0
	SET @pfTBProvisionalStatusExists = 0

	SET @piWaitListTableID = 0
	SET @pfWaitListTableInsert = 0
	SET @pfWaitListTableDelete = 0
	SET @piWaitListCourseTitleColumnID = 0
	SET @pfWaitListCourseTitleColumnUpdate = 0
	SET @pfWaitListCourseTitleColumnSelect = 0

	SET @piBulkBookingDefaultViewID = 0
	
	/* Get the current user's group id. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'TRAINING', @fOK OUTPUT

	/* Get the required training booking module paramaters. */
	IF @fOK = 1
	BEGIN
		/* Get the EMPLOYEE table information. */
		SELECT @piEmployeeTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_EmployeeTable'
		IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0

		/* Get the COURSE table information. */
		SELECT @piCourseTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTable'
		IF @piCourseTableID IS NULL SET @piCourseTableID = 0

		IF @piCourseTableID > 0
		BEGIN
			SELECT @piCourseCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_CourseCancelDate'
			IF @piCourseCancelDateColumnID IS NULL SET @piCourseCancelDateColumnID = 0
		END

		/* Get the TRAINING BOOKING table information. */
		SELECT @piTBTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_TrainBookTable'
		IF @piTBTableID IS NULL SET @piTBTableID = 0


		-- Cached view of the sysprotects table
		DECLARE @SysProtects TABLE([ID]				int,
								   [columns]		varbinary(8000),
								   [Action]			tinyint,
								   [ProtectType]	tinyint)
		INSERT INTO @SysProtects
		SELECT [ID], [Columns], [Action], [ProtectType] FROM ASRSysProtectsCache
			WHERE [UID] = @iUserGroupID AND [Action] IN (193, 195, 196, 197)

		IF @piTBTableID > 0
		BEGIN
			SELECT @sTBTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piTBTableID

			SELECT @piTBStatusColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookStatus'
			IF @piTBStatusColumnID IS NULL SET @piTBStatusColumnID = 0

			SELECT @piTBCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookCancelDate'
			IF @piTBCancelDateColumnID IS NULL SET @piTBCancelDateColumnID = 0

			SET @sCommand = 'SELECT @iStatusCount = COUNT(*)' +
				' FROM ASRSysColumnControlValues' +
				' WHERE columnID = ' + convert(nvarchar(100), @piTBStatusColumnID) +
				' AND value = ''P'''
			SET @sParamDefinition = N'@iStatusCount integer OUTPUT'
			EXEC sp_executesql @sCommand, @sParamDefinition, @iStatusCount OUTPUT
			IF @iStatusCount > 0 SET @pfTBProvisionalStatusExists = 1

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				/* System/Security managers must have all permissions granted. */
				SET @pfTBTableSelect = 1
				SET @pfTBTableInsert = 1
				SET @pfTBTableUpdate = 1
				SET @pfTBStatusColumnUpdate = 1
				SET @pfTBCancelDateColumnUpdate = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piTBTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN

					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTBTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (193, 195, 197)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN

						IF @iTempAction = 193
						BEGIN
							SET @pfTBTableSelect = 1
						END
						IF @iTempAction = 195
						BEGIN
							SET @pfTBTableInsert = 1
						END
						IF @iTempAction = 197
						BEGIN
							SET @pfTBTableUpdate = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @tbColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @tbColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piTBTableID
						AND (ASRSysColumns.columnId = @piTBStatusColumnID
							OR ASRSysColumns.columnId = @piTBCancelDateColumnID))
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfTBStatusColumnUpdate = granted

					FROM @tbColumnPermissions
					WHERE columnID = @piTBStatusColumnID
						AND action = 197
					IF @pfTBStatusColumnUpdate IS NULL SET @pfTBStatusColumnUpdate = 0

					SELECT @pfTBCancelDateColumnUpdate = granted
					FROM @tbColumnPermissions
					WHERE columnID = @piTBCancelDateColumnID
						AND action = 197
					IF @pfTBCancelDateColumnUpdate IS NULL SET @pfTBCancelDateColumnUpdate = 0

				END
			END
		END

		/* Get the waiting list table information. */
		SELECT @piWaitListTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_WaitListTable'
		IF @piWaitListTableID IS NULL SET @piWaitListTableID = 0

		IF @piWaitListTableID > 0
		BEGIN
			SELECT @sWLTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piWaitListTableID

			SELECT @piWaitListCourseTitleColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_WaitListCourseTitle'
			IF @piWaitListCourseTitleColumnID IS NULL SET @piWaitListCourseTitleColumnID = 0

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				SET @pfWaitListTableInsert = 1
				SET @pfWaitListTableDelete = 1
				SET @pfWaitListCourseTitleColumnUpdate = 1
				SET @pfWaitListCourseTitleColumnSelect = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piWaitListTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sWLTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (195, 196)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN
						IF @iTempAction = 195
						BEGIN
							SET @pfWaitListTableInsert = 1
						END
						IF @iTempAction = 196
						BEGIN
							SET @pfWaitListTableDelete = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction

					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @waitListColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @waitListColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piWaitListTableID
						AND ASRSysColumns.columnId = @piWaitListCourseTitleColumnID)
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfWaitListCourseTitleColumnUpdate = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 197
					IF @pfWaitListCourseTitleColumnUpdate IS NULL SET @pfWaitListCourseTitleColumnUpdate = 0

					SELECT @pfWaitListCourseTitleColumnSelect = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 193
					IF @pfWaitListCourseTitleColumnSelect IS NULL SET @pfWaitListCourseTitleColumnSelect = 0

				END
			END
		END

		/* Get the Bulk Booking default view. */
		SELECT @piBulkBookingDefaultViewID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_BulkBookingDefaultView'
		IF @piBulkBookingDefaultViewID IS NULL SET @piBulkBookingDefaultViewID = 0
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntNewUser]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntNewUser] (
	@psUserName	sysname)
AS
BEGIN

	SET NOCOUNT ON;

	/* Create an user associated with the given SQL login. 
	Put the new user in the current user's role.
	Return 1 if everything is done okay, else 0. */
	DECLARE @hResult 		integer,
		@sRoleName			sysname,
		@sActualUserName	sysname,
		@iUserGroupID		integer;

	/* Create a user in the database for the given login. */
	EXEC @hResult = sp_grantdbaccess @psUsername, @psUserName;
	IF @hResult <> 0 GOTO Done

	/* Determine the current user's role. */
	EXEC dbo.spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Put the new user in the same role as the current user. */
	EXEC @hResult = sp_addrolemember @sRoleName, @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Make the new user a dbo. */
	EXEC @hResult = sp_addrolemember 'db_owner', @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Jump over the error handling code. */
	GOTO Done;

Err:
	/* Remove the user from the database if it was added okay, but not assigned to a role. */
	EXEC sp_revokedbaccess @psUsername;

Done:
	RETURN (@hResult);

END
GO
PRINT N'Altering [dbo].[sp_ASRIntTransferCourse]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntTransferCourse] (
	@piTBRecordID		integer,
	@piCourseRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iEmpTableID			integer,
		@iEmpRecordID			integer,
		@iCourseTableID			integer,
		@iOriginalCourseRecordID	integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@iTBCancelDateColumnID	integer,
		@sTBCancelDateColumnName	sysname,
		@sBookingStatus			varchar(MAX),
		@fTStatusExists			bit,
		@iCount					integer,
		@iChildViewID			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID

	SELECT @iTBCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookCancelDate'
	IF @iTBCancelDateColumnID IS NULL SET @iTBCancelDateColumnID = 0

	SELECT @sTBCancelDateColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBCancelDateColumnID

	/* Check if the 'T' status code exists. */
	SET @fTStatusExists = 0
	SELECT @iCount = count(value)
	FROM ASRSysColumnControlValues
	WHERE columnID = @iTBStatusColumnID
		AND value = 'T'
	IF @iCount > 0 SET @fTStatusExists = 1

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTBRealSource = left(@sTBRealSource, 255)
	END

	SET @sTempExecString = 'SELECT @iEmpRecordID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		', @iOriginalCourseRecordID = ID_' + convert(nvarchar(100), @iCourseTableID) +
		', @sBookingStatus = ' + @sTBStatusColumnName +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)
	SET @sTempParamDefinition = N'@iEmpRecordID integer OUTPUT, @iOriginalCourseRecordID integer OUTPUT, @sBookingStatus varchar(MAX) OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iEmpRecordID OUTPUT, @iOriginalCourseRecordID OUTPUT, @sBookingStatus OUTPUT


	IF @iEmpRecordID IS null SET @iEmpRecordID = 0
	IF @iOriginalCourseRecordID IS null SET @iOriginalCourseRecordID = 0

	/* Create the new booking record. */
	SET @sTempExecString = 'INSERT INTO ' + @sTBRealSource + 
		' (' + @sTBStatusColumnName +
		', id_' + convert(nvarchar(100), @iEmpTableID) +
		', id_' + convert(nvarchar(100), @iCourseTableID) +
		') VALUES (''' + @sBookingStatus + '''' +
		', ' + convert(nvarchar(100), @iEmpRecordID) +
		', ' + convert(nvarchar(100), @piCourseRecordID) + ')'
	EXEC sp_executesql @sTempExecString

	/* Update the old booking record. */     
	SET @sTempExecString = 'UPDATE ' + @sTBRealSource + 
		' SET ' + @sTBStatusColumnName + ' = ' + 
		CASE @fTStatusExists
			WHEN 1 THEN '''T'''
			ELSE '''C'''
		END

	IF len(@sTBCancelDateColumnName) > 0 
	BEGIN
		SET @sTempExecString = @sTempExecString +
			', ' + @sTBCancelDateColumnName + ' = getdate()'
	END

	SET @sTempExecString = @sTempExecString +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)

	EXEC sp_executesql @sTempExecString
END
GO
PRINT N'Altering [dbo].[spASRIntAllTablePermissions]...';


GO
ALTER PROCEDURE [dbo].[spASRIntAllTablePermissions]
(
	@psSQLLogin 		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName				sysname,
		@sActualUserName			sysname;

	-- Cached view of the objects 
	DECLARE @SysObjects TABLE([ID]		integer PRIMARY KEY CLUSTERED,
							  [Name]	sysname);
		
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
							  
	INSERT INTO @SysObjects
		SELECT [ID], [Name] FROM sysobjects
		WHERE [Name] LIKE 'ASRSysCV%' AND [XType] = 'v'
		UNION 
		SELECT OBJECT_ID(tableName), TableName 
		FROM ASRSysTables
		WHERE NOT OBJECT_ID(tableName) IS null
		UNION
		SELECT OBJECT_ID(viewName), ViewName 
		FROM ASRSysViews
		WHERE NOT OBJECT_ID(viewName) IS null;

	-- Cached view of the sysprotects table
	DECLARE @SysProtects TABLE([ID]				integer,
							   [columns]		varbinary(8000),
							   [Action]			tinyint,
							   [ProtectType]	tinyint);
	INSERT INTO @SysProtects
	SELECT p.ID, p.Columns, p.Action, p.ProtectType FROM ASRSysProtectsCache p
		INNER JOIN @SysObjects o ON p.ID = o.ID
		WHERE p.UID = @iUserGroupID AND ((p.ProtectType <> 206 AND p.Action <> 193) OR (p.Action = 193 AND p.ProtectType IN (204,205)));

	SELECT UPPER(o.name) AS [name], p.action, ISNULL(cv.tableID,0) AS [tableid]
		FROM @SysProtects p
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE p.protectType <> 206
			AND p.action <> 193
	UNION
	SELECT UPPER(o.name) AS [name], 193, ISNULL(cv.tableID,0) AS [tableid]
		FROM sys.columns c
		INNER JOIN @SysProtects p ON (c.object_id = p.id
			AND p.action = 193 
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) = 0)))
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE (c.name <> 'timestamp' AND c.name <> 'ID')
			AND p.protectType IN (204, 205) 
		ORDER BY name;

END
GO
PRINT N'Altering [dbo].[spASRIntGetLinks]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetLinks] 
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iCount				integer,
		@iUtilType			integer, 
		@iUtilID			integer,
		@iScreenID			integer,
		@iTableID			integer,
		@sTableName			sysname,
		@iTableType			integer,
		@sRealSource		sysname,
		@iChildViewID		integer,
		@sAccess			varchar(MAX),
		@sGroupName			varchar(255),
		@pfPermitted		bit,
		@sActualUserName	sysname,
		@iActualUserGroupID integer,
		@fBaseTableReadable bit,
		@iBaseTableID		integer,
		@sURL				varchar(MAX), 
		@fUtilOK			bit,
		@fDrillDownHidden bit,
		@iLinkType			integer,		-- 0 = Hypertext, 1 = Button, 2 = Dropdown List
		@iElement_Type		integer;		-- 2 = chart
	
	IF @plngViewID < 1 
	BEGIN 
		SET @plngViewID = -1;
	END
	SET @fBaseTableReadable = 1;
	
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA'
	BEGIN
		EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT;
		
		DECLARE @Phase1 TABLE([ID] INT);
		INSERT INTO @Phase1
			SELECT Object_ID(ASRSysViews.ViewName) 
			FROM ASRSysViews 
			WHERE NOT Object_ID(ASRSysViews.ViewName) IS null
			UNION
			SELECT Object_ID(ASRSysTables.TableName) 
			FROM ASRSysTables 
			WHERE NOT Object_ID(ASRSysTables.TableName) IS null
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null;
		-- Cached view of the sysprotects table
		DECLARE @SysProtects TABLE([ID] int PRIMARY KEY CLUSTERED);
		INSERT INTO @SysProtects
			SELECT p.[ID] 
			FROM ASRSysProtectsCache p
						INNER JOIN SysColumns c ON (c.id = p.id
							AND c.[Name] = 'timestamp'
							AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
							AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) != 0)
							OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
							AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) = 0)))
			WHERE p.UID = @iActualUserGroupID
				AND p.[ProtectType] IN (204, 205)
				AND p.[Action] = 193			
				AND p.id IN (SELECT ID FROM @Phase1);
		-- Readable tables
		DECLARE @ReadableTables TABLE([Name] sysname PRIMARY KEY CLUSTERED);
		INSERT INTO @ReadableTables
			SELECT OBJECT_NAME(p.ID)
			FROM @SysProtects p;
		
		SET @sRealSource = '';
		IF @plngViewID > 0
		BEGIN
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @plngViewID;
		END
		ELSE
		BEGIN
			SELECT @sRealSource = tableName
			FROM ASRSysTables
			WHERE tableID = @plngTableID;
		END
		SET @fBaseTableReadable = 0
		IF len(@sRealSource) > 0
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @ReadableTables
			WHERE name = @sRealSource;
		
			IF @iCount > 0
			BEGIN
				SET @fBaseTableReadable = 1;
			END
		END
	END
	DECLARE @Links TABLE([ID]						integer PRIMARY KEY CLUSTERED,
											 [utilityType]	integer,
											 [utilityID]		integer,
											 [screenID]			integer,
											 [LinkType]			integer,
											 [Element_Type]	integer,
											 [DrillDownHidden]				bit);
	INSERT INTO @Links ([ID],[utilityType],[utilityID],[screenID], [LinkType], [Element_Type], [DrillDownHidden])
	SELECT ASRSysSSIntranetLinks.ID,
					ASRSysSSIntranetLinks.utilityType,
					ASRSysSSIntranetLinks.utilityID,
					ASRSysSSIntranetLinks.screenID,
					ASRSysSSIntranetLinks.LinkType,
					ASRSysSSIntranetLinks.Element_Type,
					0
	FROM ASRSysSSIntranetLinks
	WHERE (viewID = @plngViewID
			AND tableid = @plngTableID)
			AND (id NOT IN (SELECT linkid 
								FROM ASRSysSSIHiddenGroups
								WHERE groupName = @sGroupName));
	/* Remove any utility links from the temp table where the utility has been deleted or hidden from the current user.*/
	/* Or if the user does not permission to run them. */	
	DECLARE utilitiesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysSSIntranetLinks.utilityType,
					ASRSysSSIntranetLinks.utilityID,
					ASRSysSSIntranetLinks.screenID,
					ASRSysSSIntranetLinks.LinkType,
					ASRSysSSIntranetLinks.Element_Type
	FROM ASRSysSSIntranetLinks
	WHERE (viewID = @plngViewID
				AND tableid = @plngTableID)
			AND (utilityID > 0 
				OR screenID > 0);
	OPEN utilitiesCursor;
	FETCH NEXT FROM utilitiesCursor INTO @iUtilType, @iUtilID, @iScreenID, @iLinkType, @iElement_Type;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iUtilID > 0
		BEGIN
			SET @fUtilOK = 1	;			
			/* Check if the utility is deleted or hidden from the user. */
			EXECUTE [dbo].[spASRIntCurrentAccessForRole]
								@sGroupName,
								@iUtilType,
								@iUtilID,
								@sAccess	OUTPUT;
			IF @sAccess = 'HD' 
			BEGIN
				/* Report/utility is hidden from the user. */
				--HERE FOR CHARTs **************************************************************************************************************************************
				IF @iElement_Type = 2
				BEGIN
					SET @fUtilOK = 1;				
					SET @fDrillDownHidden = 1;
				END
				ELSE
				BEGIN
					SET @fUtilOK = 0;
				END
			END
			IF @fUtilOK = 1
			BEGIN
				/* Check if the user has system permission to run this type of report/utility. */
				IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA'
				BEGIN
					SELECT @pfPermitted = ASRSysGroupPermissions.permitted
					FROM ASRSysPermissionItems
					INNER JOIN ASRSysPermissionCategories 
					ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 					
							CASE 
								WHEN @iUtilType = 17 THEN 'CALENDARREPORTS'
								WHEN @iUtilType = 9 THEN 'MAILMERGE'
								WHEN @iUtilType = 2 THEN 'CUSTOMREPORTS'
								WHEN @iUtilType = 25 THEN 'WORKFLOW'
								ELSE ''
							END
					LEFT OUTER JOIN ASRSysGroupPermissions 
					ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
						AND ASRSysGroupPermissions.groupName = @sGroupName
					WHERE ASRSysPermissionItems.itemKey = 'RUN';
					IF (@pfPermitted IS null) OR (@pfPermitted = 0)
					BEGIN
						/* User does not have system permission to run this type of report/utility. */
						--HERE FOR CHARTS**************************************************************************************************************************************
						IF @iElement_Type = 2
						BEGIN
							SET @fUtilOK = 1;
							SET @fDrillDownHidden = 1;
						END
						ELSE
						BEGIN
							SET @fUtilOK = 0;
						END
					END
				END
			END
			IF @fUtilOK = 1
			BEGIN
				/* Check if the user has read permission on the report/utility base table or any views on it. */
				SET @iBaseTableID = 0;
				IF @iUtilType = 17 /* Calendar Reports */
				BEGIN
					SELECT @iBaseTableID = baseTable
					FROM ASRSysCalendarReports
					WHERE id = @iUtilID;
				END
				IF @iUtilType = 2 /* Custom Reports */
				BEGIN
					SELECT @iBaseTableID = baseTable
					FROM ASRSysCustomReportsName
					WHERE id = @iUtilID;
				END
				IF @iUtilType = 9 /* Mail Merge */
				BEGIN
					SELECT @iBaseTableID = TableID
					FROM ASRSysMailMergeName
					WHERE MailMergeID = @iUtilID;
				END
				/* Not check required for reports/utilities without a base table.
				OR reports/utilities based on the top-level table if the user has read permission on the current view. */
				IF (@iBaseTableID > 0)
					AND((@fBaseTableReadable = 0)
						OR (@iBaseTableID <> @plngTableID))
				BEGIN
					IF (@iLinkType <> 0) -- Hypertext link
						AND (@fBaseTableReadable = 0)
						AND (@iBaseTableID = @plngTableID)
					BEGIN
						/* The report/utility is based on the top-level table, and the user does NOT have read permission
						on the current view (on which Button & DropdownList links are scoped). */
						SET @fUtilOK = 0;
					END
					ELSE
					BEGIN
						SELECT @iCount = COUNT(p.ID)
						FROM @SysProtects p
						WHERE OBJECT_NAME(p.ID) IN (SELECT ASRSysTables.tableName
							FROM ASRSysTables
							WHERE ASRSysTables.tableID = @iBaseTableID
						UNION 
							SELECT ASRSysViews.viewName
								FROM ASRSysViews
								WHERE ASRSysViews.viewTableID = @iBaseTableID
						UNION
							SELECT
								left('ASRSysCV' 
									+ convert(varchar(1000), ASRSysChildViews2.childViewID) 
									+ '#'
									+ replace(ASRSysTables.tableName, ' ', '_')
									+ '#'
									+ replace(@sGroupName, ' ', '_'), 255)
								FROM ASRSysChildViews2
								INNER JOIN ASRSysTables ON ASRSysChildViews2.tableID = ASRSysTables.tableID
								WHERE ASRSysChildViews2.role = @sGroupName
									AND ASRSysChildViews2.tableID = @iBaseTableID);
						IF @iCount = 0 
						BEGIN
							SET @fUtilOK = 0;
						END
					END
				END
			END
			/* For some reason the user cannot use this report/utility, so remove it from the temp table of links. */
			IF @fUtilOK = 0 
			BEGIN
				DELETE FROM @Links
				WHERE utilityType = @iUtilType
					AND utilityID = @iUtilID;
			END
			IF @fDrillDownHidden = 1
			BEGIN
				UPDATE @Links
				SET DrillDownHidden = 1 
				WHERE utilityType = @iUtilType
					AND utilityID = @iUtilID;
			END
			
		END
		
		IF (@iScreenID > 0) AND (UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA')
		BEGIN
			/* Do not display the link if the user does not have permission to read the defined view/table for the screen. */
			SELECT @iTableID = ASRSysTables.tableID, 
				@sTableName = ASRSysTables.tableName,
				@iTableType = ASRSysTables.tableType
			FROM ASRSysScreens
						INNER JOIN ASRSysTables 
						ON ASRSysScreens.tableID = ASRSysTables.tableID
			WHERE screenID = @iScreenID;
			SET @sRealSource = '';
			IF @iTableType  = 2
			BEGIN
				SET @iChildViewID = 0;
				/* Child table - check child views. */
				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @iTableID
					AND [role] = @sGroupName;
				
				IF @iChildViewID IS null SET @iChildViewID = 0;
				
				IF (@iChildViewID > 0) AND (@fBaseTableReadable = 1)
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTableName, ' ', '_') +
						'#' + replace(@sGroupName, ' ', '_');
				
					SET @sRealSource = left(@sRealSource, 255);
				END
				ELSE
				BEGIN
					DELETE FROM @Links
					WHERE screenID = @iScreenID;
				END
			END
			ELSE
			BEGIN
				/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
				SET @sRealSource = '';
				IF @plngViewID > 0
				BEGIN
					SELECT @sRealSource = viewName
					FROM ASRSysViews
					WHERE viewID = @plngViewID;
				END
				ELSE
				BEGIN
					SELECT @sRealSource = tableName
					FROM ASRSysTables
					WHERE tableID = @plngTableID;
				END
			END
			IF len(@sRealSource) > 0
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM @ReadableTables
				WHERE name = @sRealSource;
			
				IF @iCount = 0
				BEGIN
					DELETE FROM @Links
					WHERE screenID = @iScreenID;
				END
			END
		END
		FETCH NEXT FROM utilitiesCursor INTO @iUtilType, @iUtilID, @iScreenID, @iLinkType, @iElement_Type;
	END
	CLOSE utilitiesCursor;
	DEALLOCATE utilitiesCursor;
	/* Remove the Workflow links if the URL has not been configured. */
	SELECT @sURL = isnull(settingValue , '')
	FROM ASRSysSystemSettings
	WHERE section = 'MODULE_WORKFLOW'		
		AND settingKey = 'Param_URL';	
	
	
	IF LEN(@sURL) = 0
	BEGIN
		DELETE FROM @Links
		WHERE utilityType = 25;
	END
	SELECT ASRSysSSIntranetLinks.*, 
		CASE 
			WHEN ASRSysSSIntranetLinks.utilityType = 9 THEN ASRSysMailMergeName.TableID
			WHEN ASRSysSSIntranetLinks.utilityType = 2 THEN ASRSysCustomReportsName.baseTable
			WHEN ASRSysSSIntranetLinks.utilityType = 17 THEN ASRSysCalendarReports.baseTable
			WHEN ASRSysSSIntranetLinks.utilityType = 25 THEN 0
			ELSE null
		END AS [baseTable],
		ASRSysColumns.ColumnName as [Chart_ColumnName],
		tvL.DrillDownHidden as [DrillDownHidden]
	FROM ASRSysSSIntranetLinks
			LEFT OUTER JOIN ASRSysMailMergeName 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysMailMergeName.MailMergeID
				AND ASRSysSSIntranetLinks.utilityType = 9
			LEFT OUTER JOIN ASRSysCalendarReports 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysCalendarReports.ID
				AND ASRSysSSIntranetLinks.utilityType = 17
			LEFT OUTER JOIN ASRSysCustomReportsName 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysCustomReportsName.ID
				AND ASRSysSSIntranetLinks.utilityType = 2
			LEFT OUTER JOIN ASRSysColumns
			ON ASRSysSSIntranetLinks.Chart_ColumnID = ASRSysColumns.columnId		
			LEFT OUTER JOIN @Links tvL
			ON ASRSysSSIntranetLinks.ID = tvL.ID
	WHERE ASRSysSSIntranetLinks.ID IN (SELECT ID FROM @Links)
	ORDER BY ASRSysSSIntranetLinks.linkOrder;
	
END
GO
PRINT N'Altering [dbo].[spASRIntGetNavigationLinks]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGetNavigationLinks]
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@iViewID				integer,
		@iUtilType				integer, 
		@iUtilID				integer, 
		@iScreenID				integer, 
		@sURL					varchar(MAX),
		@iTableID				integer,
		@sTableName				sysname,
		@iTableType				integer,
		@sRealSource			sysname,
		@iChildViewID			integer,
		@sAccess				varchar(MAX),
		@fTableViewOK			bit,
		@pfCustomReportsRun		bit,
		@pfCalendarReportsRun	bit,
		@pfMailMergeRun			bit,
		@pfWorkflowRun			bit,
		@sGroupName				varchar(255),
		@sActualUserName		sysname,
		@iActualUserGroupID 	integer, 
		@sViewName				sysname,
		@iLinkType 				integer,			/* 0 = Hypertext, 1 = Button, 2 = Dropdown List */
		@fFindPage				bit

	/* See if the current user can run the defined Reports/Utilties. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER)))  = 'SA'
	BEGIN
		SET @pfCustomReportsRun = 1
		SET @pfCalendarReportsRun = 1
		SET @pfMailMergeRun = 1
		SET @pfWorkflowRun = 1
	END
	ELSE
	BEGIN

		EXEC dbo.spASRIntGetActualUserDetails
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT
			
		DECLARE @unionTable TABLE (ID int PRIMARY KEY CLUSTERED)

		INSERT INTO @unionTable 
			SELECT Object_ID(ViewName) 
			FROM ASRSysViews 
			WHERE viewID IN (SELECT viewID FROM ASRSysSSIViews)
				AND NOT Object_ID(ViewName) IS null
			UNION
			SELECT Object_ID(TableName) 
			FROM ASRSysTables 
			WHERE tableID IN (SELECT tableID FROM ASRSysSSIViews)
				AND NOT Object_ID(TableName) IS null
				AND tableID NOT IN (SELECT tableID 
					FROM ASRSysViewMenuPermissions 
					WHERE ASRSysViewMenuPermissions.groupName = @sGroupName
						AND ASRSysViewMenuPermissions.hideFromMenu = 1)
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null

		DECLARE @readableTables TABLE (name sysname)	
	
		INSERT INTO @readableTables
			SELECT OBJECT_NAME(p.id)
			FROM syscolumns
			INNER JOIN ASRSysProtectsCache p 
				ON (syscolumns.id = p.id
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
			WHERE p.UID = @iActualUserGroupID
				AND syscolumns.name = 'timestamp'
				AND (p.ID IN (SELECT id FROM @unionTable))
				AND p.Action = 193 AND ProtectType IN (204, 205)
				OPTION (KEEPFIXED PLAN)

		SELECT @pfCustomReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CUSTOMREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	
		SELECT @pfCalendarReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CALENDARREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfMailMergeRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'MAILMERGE'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfWorkflowRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'WORKFLOW'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	END

	DECLARE @links TABLE(
		LinkType			integer,
		Text1	 			varchar(200),
		Text2	 			varchar(200),
		SingleRecord		bit,
		LinkToFind			bit,
		TableID				integer,
		ViewID				integer ,
		PrimarySequence		integer,
		SecondarySequence	integer,
		FindPage			integer)

	/* Hypertext links. */
	/* Single Record View UNION Multiple Record Tables/Views UNION Table/View Hypertext Links link */
	INSERT INTO @links
		SELECT 0, linksLinkText, '', 1, 0, tableID, viewID, 0, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 1
			AND LEN(linksLinkText) > 0
		UNION
		SELECT 0, hypertextLinkText, '', 0, 1, tableID, viewID, 2, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND LEN(hypertextLinkText) > 0
		UNION
		SELECT 0, linksLinkText, '', 0, 0, tableID, viewID, 1, sequence, 1
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND tableid = @plngTableID
			AND viewID = @plngViewID

	/* Button links. */
	INSERT INTO @links
	SELECT 1, buttonLinkPromptText, buttonLinkButtonText, 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE buttonLink = 1

	/* DropdownList links. */
	INSERT INTO @links
	SELECT 2, dropdownListLinkText, '', 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE dropdownListLink = 1


	/* Remove linkToFind links for links to views that are not readable by the user, or those that have no valid links defined for them. */
	DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ISNULL(l.viewID, -1) 'viewID', ASRSysViews.viewName, l.tableID, ASRSysTables.tableName
		FROM @links	l
		LEFT OUTER JOIN ASRSysViews	
			ON l.viewID = ASRSysViews.viewID
		INNER JOIN ASRSysTables
			ON l.tableID = ASRSysTables.tableID

	OPEN viewsCursor
	FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fTableViewOK = 0
		
		IF @iViewID > 0 
		BEGIN 
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sViewName
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sTableName
		END 

		IF @iCount > 0
		BEGIN

			DECLARE linksCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysSSIntranetLinks.utilityType,
							ASRSysSSIntranetLinks.utilityID,
							ASRSysSSIntranetLinks.screenID,
							ASRSysSSIntranetLinks.url
			FROM ASRSysSSIntranetLinks
			WHERE tableID = @iTableID 
				AND	viewID = @iViewID
	
			OPEN linksCursor
			FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			WHILE (@@fetch_status = 0) AND (@fTableViewOK = 0)
			BEGIN
				IF LEN(@sURL) > 0 OR (UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA')
				BEGIN
					SET @fTableViewOK = 1
				END
				ELSE
				BEGIN
					IF @iUtilID > 0
					BEGIN
						/* Check if the utility is deleted or hidden from the user. */
						EXECUTE dbo.spASRIntCurrentAccessForRole
												@sGroupName,
												@iUtilType,
												@iUtilID,
												@sAccess	OUTPUT
	
						IF @sAccess <> 'HD' 
						BEGIN
							IF @iUtilType = 2 AND @pfCustomReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 17 AND @pfCalendarReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 9 AND @pfMailMergeRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 25 AND @pfWorkflowRun = 1 SET @fTableViewOK = 1
						END
					END
	
					IF (@iScreenID > 0) 
					BEGIN
						/* Do not display the link if the user does not have permission to read the defined view/tbale for the screen. */
						SELECT @iTableID = ASRSysTables.tableID, 
							@sTableName = ASRSysTables.tableName,
							@iTableType = ASRSysTables.tableType
						FROM ASRSysScreens
										INNER JOIN ASRSysTables 
										ON ASRSysScreens.tableID = ASRSysTables.tableID
						WHERE screenID = @iScreenID
	
						SET @sRealSource = ''
						IF @iTableType  = 2
						BEGIN
							SET @iChildViewID = 0
	
							/* Child table - check child views. */
							SELECT @iChildViewID = childViewID
							FROM ASRSysChildViews2
							WHERE tableID = @iTableID
								AND role = @sGroupName
							
							IF @iChildViewID IS null SET @iChildViewID = 0
							
							IF @iChildViewID > 0 
							BEGIN
								SET @sRealSource = 'ASRSysCV' + 
									convert(varchar(1000), @iChildViewID) +
									'#' + replace(@sTableName, ' ', '_') +
									'#' + replace(@sGroupName, ' ', '_')
							
								SET @sRealSource = left(@sRealSource, 255)
							END
						END
						ELSE
						BEGIN
							/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
							IF @iViewID > 0 
							BEGIN 
								SELECT @sRealSource = viewName
								FROM ASRSysViews
								WHERE viewID = @iViewID
							END
							ELSE
							BEGIN
								SELECT @sRealSource = tableName
								FROM ASRSysTables
								WHERE tableID = @iTableID
							END 
	
							IF @sRealSource IS null SET @sRealSource = ''
						END
	
						IF len(@sRealSource) > 0
						BEGIN
							SELECT @iCount = COUNT(*)
							FROM @readableTables
							WHERE name = @sRealSource
						
							IF @iCount = 1 SET @fTableViewOK = 1
						END
					END
				END
								
				FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			END
			CLOSE linksCursor
			DEALLOCATE linksCursor

		END
		
		IF @fTableViewOK = 0
		BEGIN
			IF @iViewID > 0 
			BEGIN
				DELETE FROM @links
				WHERE viewID = @iViewID
			END
			ELSE
			BEGIN
				DELETE FROM @links
				WHERE tableid = @iTableID AND viewID = @iViewID
			END
		END
	
		FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	END
	CLOSE viewsCursor
	DEALLOCATE viewsCursor

	SELECT *
	FROM @links
	ORDER BY [primarySequence], [secondarySequence]

END
GO
PRINT N'Altering [dbo].[spASRIntCurrentUserAccess]...';


GO
ALTER PROCEDURE [dbo].[spASRIntCurrentUserAccess] (
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRoleName			varchar(255),
		@sActualUserName	sysname,
		@iActualUserGroupID	integer,
		@fEnabled			bit

	SET @sTableName = '';
	SET @psAccess = 'HD';

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @sRoleName + '''';

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END
GO
PRINT N'Altering [dbo].[spASRIntDeleteCheck]...';


GO
ALTER PROCEDURE [dbo].[spASRIntDeleteCheck] (
	@piUtilityType	integer,
	@plngID			integer,
	@pfDeleted		bit				OUTPUT,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fNewAccess			bit,
		@iCount				integer,
		@sAccess			varchar(MAX),
		@fSysSecMgr			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';
	SET @pfDeleted = 0;
	SET @fNewAccess = 0;

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
		SET @fNewAccess = 1;
  END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
		SET @fNewAccess = 1
  END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
		SET @fNewAccess = 1;
  END

	IF (@piUtilityType = 11) OR (@piUtilityType = 12)  /* Filters/Calcs */
	BEGIN
		SET @sTableName = 'ASRSysExpressions';
		SET @sIDColumnName = 'exprID';
  END

	IF (@piUtilityType = 10)  /* Picklists */
	BEGIN
		SET @sTableName = 'ASRSysPicklistName';
		SET @sIDColumnName = 'picklistID';
  END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @iCount = COUNT(*)
				FROM ' + @sTableName + 
				' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0 
		BEGIN
			SET @pfDeleted = 1;
		END
		ELSE
		BEGIN
			IF @fNewAccess = 1
			BEGIN
				exec [dbo].[spASRIntCurrentUserAccess] @piUtilityType,	@plngID, @psAccess OUTPUT;
			END
			ELSE
			BEGIN
				exec [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
				
				IF @fSysSecMgr = 1 
				BEGIN
					SET @psAccess = 'RW';
				END
				ELSE
				BEGIN
					SET @sSQL = 'SELECT @sAccess = CASE 
								WHEN userName = system_user THEN ''RW''
								ELSE access
							END
							FROM ' + @sTableName + 
							' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
					SET @sParamDefinition = N'@sAccess varchar(MAX) OUTPUT';
					EXEC sp_executesql @sSQL,  @sParamDefinition, @sAccess OUTPUT;

					SET @psAccess = @sAccess;
				END
			END
		END
	END
END
GO
PRINT N'Altering [dbo].[spASRIntValidateCalendarReport]...';


GO
ALTER PROCEDURE [dbo].[spASRIntValidateCalendarReport]
	(
	@psUtilName 			varchar(255), 
	@piUtilID 				integer, 
	@piTimestamp 			integer, 
	@piBasePicklistID		integer, 
	@piBaseFilterID			integer,
	@piEmailGroupID			integer,
	@piDescExprID			integer,
	@psEventFilterIDs		varchar(MAX),			/* tab delimited string of event filter ids */ 
	@piCustomStartID		integer,
	@piCustomEndID			integer,
	@psHiddenGroups 		varchar(MAX), 
	@psErrorMsg				varchar(MAX)	OUTPUT,
	@piErrorCode			varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedFilters 		varchar(MAX)	OUTPUT,
	@psHiddenFilters 		varchar(MAX)	OUTPUT,
	@psDeletedCalcs 		varchar(MAX)	OUTPUT,
	@psHiddenCalcs 			varchar(MAX)	OUTPUT,
	@psDeletedPicklists		varchar(MAX)	OUTPUT,
	@psHiddenPicklists 		varchar(MAX)	OUTPUT,
	@psJobIDsToHide			varchar(MAX)	OUTPUT 
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	
			@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(100),
			@sExprName  			varchar(255),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(255),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iActualUserGroupID		integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''
	SET @psDeletedPicklists = ''
	SET @psHiddenPicklists = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT

 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCalendarReports
		WHERE ID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The report has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCalendarReports
			WHERE ID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					17, 
					@piUtilID,
					@sAccess	OUTPUT

				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp) AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the calendar report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSysCalendarReports
			WHERE name = @psUtilName
				AND ID <> @piUtilID
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSysCalendarReports
			WHERE name = @psUtilName
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A report called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBasePicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBasePicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBaseFilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBaseFilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piDescExprID > 0)
	BEGIN
		/* Check that the Base table description calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piDescExprID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table description calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
				CASE
					WHEN LEN(@psDeletedCalcs) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piDescExprID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piDescExprID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table description calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
					CASE
						WHEN LEN(@psHiddenCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piDescExprID)
			END
		END
	END

	/* Check that the selected event filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@psEventFilterIDs) > 0)
	BEGIN
		SET @sTemp = @psEventFilterIDs

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the event filters have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedFilters = @psDeletedFilters +
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @sCurrentID)
					SET @piErrorCode = 1
			 	END
				ELSE
			  	BEGIN
					SELECT @sOwner = userName,
						@sAccess = access
					FROM ASRSysExpressions
					WHERE exprID = convert(integer, @sCurrentID)

					IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @psErrorMsg = 
							@psErrorMsg + 
							CASE
								WHEN LEN(@psHiddenFilters) > 0 THEN ''
								ELSE 
									CASE 
										WHEN LEN(@psErrorMsg) > 0 THEN char(13)
										ELSE ''
									END +
									'One or more of the event filters have been made hidden by another user. They will be automatically removed from the report.'
							END
						SET @psHiddenFilters = @psHiddenFilters +
						CASE
							WHEN LEN(@psHiddenFilters) > 0 THEN ','
							ELSE ''
						END + convert(varchar(100), @sCurrentID)
						
						SET @piErrorCode = 1
					END
			  	END
			END
		END
	END
	
	
	IF (@piErrorCode = 0) AND (@piCustomStartID > 0)
	BEGIN
		/* Check that the start date calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomStartID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The custom start date calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomStartID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piCustomStartID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The custom start date calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
					CASE
						WHEN LEN(@psHiddenCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomStartID)
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piCustomEndID > 0)
	BEGIN
		/* Check that the end date calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomEndID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The custom end date calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomEndID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piCustomEndID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The custom end date calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + convert(varchar(100), @piCustomEndID)
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCalendarReports
		WHERE ID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iActualUserGroupID OUTPUT
					
			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCalendarReports.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCalendarReports.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Calendar Report ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs

END
GO
PRINT N'Altering [dbo].[spASRIntGet1000SeparatorFindColumns]...';


GO
ALTER PROCEDURE [dbo].[spASRIntGet1000SeparatorFindColumns] (
	@pfError 				bit 			OUTPUT, 
	@piTableID 				integer, 
	@piViewID 				integer, 
	@piOrderID 				integer, 
	@ps1000SeparatorCols	varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@sType	 			varchar(10),
		@fSelectGranted 	bit,
		@iCount				integer,
		@bUse1000Separator	bit,
		@sActualLoginName	varchar(250);

	/* Initialise variables. */
	SET @pfError = 0;
	SET @ps1000SeparatorCols = '';
	SET @sRealSource = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualLoginName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID;

	IF (@sTableName IS NULL) 
	BEGIN 
		SET @pfError = 1;
		RETURN;
	END

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND [role] = @sUserGroupName;
		
		IF @iChildViewID IS null SET @iChildViewID = 0;
		
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	-- Cached view of sysprotects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000))
	INSERT INTO @SysProtects
		SELECT ID, ProtectType, [Columns] FROM ASRSysProtectsCache
		WHERE [UID] = @iUserGroupID AND Action = 193;

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @ColumnPermissions TABLE(
				tableID			integer,
				tableViewName	sysname,
				columnName		sysname,
				selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysColumns.tableID
	FROM ASRSysOrderItems 
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	WHERE ASRSysOrderItems.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE p.protectType
				    WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @Sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.tableID,
		ASRSysColumns.columnName,
		ASRSysTables.tableName,
		ASRSysOrderItems.type,
		ASRSysColumns.Use1000Separator
	FROM ASRSysOrderItems
	INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysTables.tableID = ASRSysColumns.tableID
	WHERE ASRSysOrderItems.orderID = @piOrderID
		AND ASRSysOrderItems.type = 'F'
	ORDER BY ASRSysOrderItems.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @sColumnName, @sColumnTableName, @sType, @bUse1000Separator;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END;
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
	
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END;
			END
			ELSE	
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1;

				IF @iCount > 0 
				BEGIN
					SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
						CASE
							WHEN @bUse1000Separator = 1 THEN '1'
							ELSE '0'
						END;
				END
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @sColumnName, @sColumnTableName, @sType, @bUse1000Separator;
	END

	CLOSE orderCursor;
	DEALLOCATE orderCursor;

END
GO
PRINT N'Altering [dbo].[spASRMobileInstantiateWorkflow]...';


GO

ALTER PROCEDURE [dbo].[spASRMobileInstantiateWorkflow]
		(
			@piWorkflowID	integer,			
			@psKeyParameter	varchar(max),			
			@psPWDParameter	varchar(max),			
			@piInstanceID	integer			OUTPUT,
			@psFormElements	varchar(MAX)	OUTPUT,
			@psMessage		varchar(MAX)	OUTPUT
		)
		AS
		BEGIN
			DECLARE
				@iInitiatorID			integer,
				@iStepID				integer,
				@iElementID				integer,
				@iRecordID				integer,
				@iRecordCount			integer,
				@sSQL					nvarchar(MAX),
				@hResult				integer,
				@sActualLoginName		sysname,
				@fUsesInitiator			bit, 
				@iTemp					integer,
				@iStartElementID		integer,
				@iTableID				integer,
				@iParent1TableID		integer,
				@iParent1RecordID		integer,
				@iParent2TableID		integer,
				@iParent2RecordID		integer,
				@sForms					varchar(MAX),
				@iCount					integer,
				@iSQLVersion			integer,
				@fExternallyInitiated	bit,
				@fEnabled				bit,
				@iElementType			integer,
				@fStoredDataOK			bit, 
				@sStoredDataMsg			varchar(MAX), 
				@sStoredDataSQL			varchar(MAX), 
				@iStoredDataTableID		integer,
				@sStoredDataTableName	varchar(255),
				@iStoredDataAction		integer, 
				@iStoredDataRecordID	integer,
				@sStoredDataRecordDesc	varchar(MAX),
				@sSPName				varchar(255),
				@iNewRecordID			integer,
				@sEvalRecDesc			varchar(MAX),
				@iResult				integer,
				@iFailureFlows			integer,
				@fSaveForLater			bit,
				@fResult	bit;
		
			SELECT @iSQLVersion = convert(float,substring(@@version,charindex('-',@@version)+2,2));
		
			DECLARE @succeedingElements table(elementID int);
		
			SET @iInitiatorID = 0;
			SET @psFormElements = '';
			SET @psMessage = '';
			SET @iParent1TableID = 0;
			SET @iParent1RecordID = 0;
			SET @iParent2TableID = 0;
			SET @iParent2RecordID = 0;
		
			SELECT
			-- @fExternallyInitiated = CASE
			--		WHEN initiationType = 2 THEN 1
			--		ELSE 0
			--	END,
				@fEnabled = enabled
			FROM ASRSysWorkflows
			WHERE ID = @piWorkflowID;

			--IF @fExternallyInitiated = 1
			--BEGIN
				IF @fEnabled = 0
				BEGIN
					/* Workflow is disabled. */
					SET @psMessage = 'This link is currently disabled.';
					RETURN
				END
		
				SET @sActualLoginName = @psKeyParameter;
			--END
			--ELSE
			--BEGIN
				--SET @sActualLoginName = SUSER_SNAME();
				
				SET @sSQL = 'spASRSysMobileGetCurrentUserRecordID';
				IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = @sSQL)
				BEGIN
					SET @hResult = 0;
			
					EXEC @hResult = @sSQL 
						@psKeyParameter,			
						@iRecordID OUTPUT,
						@iRecordCount OUTPUT;
				END
			
			print @iRecordID;
			
				IF NOT @iRecordID IS null SET @iInitiatorID = @iRecordID
				IF @iInitiatorID = 0 
				BEGIN
					/* Unable to determine the initiator's record ID. Is it needed anyway? */
					EXEC [dbo].[spASRWorkflowUsesInitiator]
						@piWorkflowID,
						@fUsesInitiator OUTPUT;
				
					IF @fUsesInitiator = 1
					BEGIN
						IF @iRecordCount = 0
						BEGIN
							/* No records for the initiator. */
							SET @psMessage = 'Unable to locate your personnel record.';
						END
						IF @iRecordCount > 1
						BEGIN
							/* More than one record for the initiator. */
							SET @psMessage = 'You have more than one personnel record.';
						END
			
						RETURN
					END	
				END
				ELSE
				BEGIN
					SELECT @iTableID = convert(integer, isnull(parameterValue, 0))
					FROM ASRSysModuleSetup
					WHERE moduleKey = 'MODULE_PERSONNEL'
					AND parameterKey = 'Param_TablePersonnel';
		
					IF @iTableID = 0 
					BEGIN
						SELECT @iTableID = convert(integer, isnull(parameterValue, 0))
						FROM ASRSysModuleSetup
						WHERE moduleKey = 'MODULE_WORKFLOW'
						AND parameterKey = 'Param_TablePersonnel';
					END
		
					exec [dbo].[spASRGetParentDetails]
						@iTableID,
						@iInitiatorID,
						@iParent1TableID	OUTPUT,
						@iParent1RecordID	OUTPUT,
						@iParent2TableID	OUTPUT,
						@iParent2RecordID	OUTPUT;
				END
			--END
		
			/* Create the Workflow Instance record, and remember the ID. */
			INSERT INTO [dbo].[ASRSysWorkflowInstances] (workflowID, 
				[initiatorID], 
				[status], 
				[userName], 
				[parent1TableID],
				[parent1RecordID],
				[parent2TableID],
				[parent2RecordID],
				pageno)
			VALUES (@piWorkflowID, 
				@iInitiatorID, 
				0, 
				@sActualLoginName,
				@iParent1TableID,
				@iParent1RecordID,
				@iParent2TableID,
				@iParent2RecordID,
				0);
						
			SELECT @piInstanceID = MAX(id)
			FROM [dbo].[ASRSysWorkflowInstances];
		
			/* Create the Workflow Instance Steps records. 
			Set the first steps' status to be 1 (pending Workflow Engine action). 
			Set all subsequent steps' status to be 0 (on hold). */
		
			SELECT @iStartElementID = ASRSysWorkflowElements.ID
			FROM ASRSysWorkflowElements
			WHERE ASRSysWorkflowElements.type = 0 -- Start element
				AND ASRSysWorkflowElements.workflowID = @piWorkflowID;
		
			INSERT INTO @succeedingElements 
				SELECT id 
				FROM [dbo].[udfASRGetSucceedingWorkflowElements](@iStartElementID, 0);
		
			INSERT INTO [dbo].[ASRSysWorkflowInstanceSteps] (instanceID, elementID, status, activationDateTime, completionDateTime, completionCount, failedCount, timeoutCount)
			SELECT 
				@piInstanceID, 
				ASRSysWorkflowElements.ID, 
				CASE
					WHEN ASRSysWorkflowElements.type = 0 THEN 3
					WHEN ASRSysWorkflowElements.ID IN (SELECT suc.elementID
						FROM @succeedingElements suc) THEN 1
					ELSE 0
				END, 
				CASE
					WHEN ASRSysWorkflowElements.type = 0 THEN getdate()
					WHEN ASRSysWorkflowElements.ID IN (SELECT suc.elementID
						FROM @succeedingElements suc) THEN getdate()
					ELSE null
				END, 
				CASE
					WHEN ASRSysWorkflowElements.type = 0 THEN getdate()
					ELSE null
				END, 
				CASE
					WHEN ASRSysWorkflowElements.type = 0 THEN 1
					ELSE 0
				END,
				0,
				0
			FROM ASRSysWorkflowElements 
			WHERE ASRSysWorkflowElements.workflowid = @piWorkflowID;
		
			/* Create the Workflow Instance Value records. */
			INSERT INTO ASRSysWorkflowInstanceValues (instanceID, elementID, identifier)
			SELECT @piInstanceID, ASRSysWorkflowElements.ID, 
				ASRSysWorkflowElementItems.identifier
			FROM ASRSysWorkflowElementItems 
			INNER JOIN ASRSysWorkflowElements on ASRSysWorkflowElementItems.elementID = ASRSysWorkflowElements.ID
			WHERE ASRSysWorkflowElements.workflowID = @piWorkflowID
				AND ASRSysWorkflowElements.type = 2
				AND (ASRSysWorkflowElementItems.itemType = 3 
					OR ASRSysWorkflowElementItems.itemType = 5
					OR ASRSysWorkflowElementItems.itemType = 6
					OR ASRSysWorkflowElementItems.itemType = 7
					OR ASRSysWorkflowElementItems.itemType = 11
					OR ASRSysWorkflowElementItems.itemType = 13
					OR ASRSysWorkflowElementItems.itemType = 14
					OR ASRSysWorkflowElementItems.itemType = 15
					OR ASRSysWorkflowElementItems.itemType = 17
					OR ASRSysWorkflowElementItems.itemType = 0)
			UNION
			SELECT  @piInstanceID, ASRSysWorkflowElements.ID, 
				ASRSysWorkflowElements.identifier
			FROM ASRSysWorkflowElements
			WHERE ASRSysWorkflowElements.workflowID = @piWorkflowID
				AND ASRSysWorkflowElements.type = 5;
						
			SELECT @iCount = COUNT(ASRSysWorkflowInstanceSteps.elementID)
				FROM ASRSysWorkflowInstanceSteps
				INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
				WHERE ASRSysWorkflowInstanceSteps.status = 1
					AND (ASRSysWorkflowElements.type = 4 
						OR (@iSQLVersion >= 9 AND ASRSysWorkflowElements.type = 5) 
						OR ASRSysWorkflowElements.type = 7) -- 4=Decision, 5=StoredData, 7=Or
					AND ASRSysWorkflowElements.workflowID = @piWorkflowID
					AND ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID;	
					
			WHILE @iCount > 0 
			BEGIN
				DECLARE immediateSubmitCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysWorkflowInstanceSteps.elementID, 
					ASRSysWorkflowElements.type
				FROM ASRSysWorkflowInstanceSteps
				INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
				WHERE ASRSysWorkflowInstanceSteps.status = 1
					AND (ASRSysWorkflowElements.type = 4 
						OR (@iSQLVersion >= 9 AND ASRSysWorkflowElements.type = 5) 
						OR ASRSysWorkflowElements.type = 7) -- 4=Decision, 5=StoredData, 7=Or
					AND ASRSysWorkflowElements.workflowID = @piWorkflowID
					AND ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID;	
		
				OPEN immediateSubmitCursor;
				FETCH NEXT FROM immediateSubmitCursor INTO @iElementID, @iElementType;
				WHILE (@@fetch_status = 0) 
				BEGIN
					IF (@iElementType = 5) AND (@iSQLVersion >= 9) -- StoredData
					BEGIN
						SET @fStoredDataOK = 1;
						SET @sStoredDataMsg = '';
						SET @sStoredDataRecordDesc = '';
		
						EXEC [spASRGetStoredDataActionDetails]
							@piInstanceID,
							@iElementID,
							@sStoredDataSQL			OUTPUT, 
							@iStoredDataTableID		OUTPUT,
							@sStoredDataTableName	OUTPUT,
							@iStoredDataAction		OUTPUT, 
							@iStoredDataRecordID	OUTPUT,
							@fResult	OUTPUT;
		
						IF @iStoredDataAction = 0 -- Insert
						BEGIN
							SET @sSPName  = 'spASRWorkflowInsertNewRecord';
		
							BEGIN TRY
								EXEC @sSPName
									@iNewRecordID  OUTPUT, 
									@iStoredDataTableID,
									@sStoredDataSQL;
		
								SET @iStoredDataRecordID = @iNewRecordID;
							END TRY
							BEGIN CATCH
								SET @fStoredDataOK = 0;
								SET @sStoredDataMsg = ERROR_MESSAGE();
							END CATCH
						END
						ELSE IF @iStoredDataAction = 1 -- Update
						BEGIN
							SET @sSPName  = 'spASRWorkflowUpdateRecord';
		
							BEGIN TRY
								EXEC @sSPName
									@iResult OUTPUT,
									@iStoredDataTableID,
									@sStoredDataSQL,
									@sStoredDataTableName,
									@iStoredDataRecordID;
							END TRY
							BEGIN CATCH
								SET @fStoredDataOK = 0;
								SET @sStoredDataMsg = ERROR_MESSAGE();
							END CATCH
						END
						ELSE IF @iStoredDataAction = 2 -- Delete
						BEGIN
							EXEC [dbo].[spASRRecordDescription]
								@iStoredDataTableID,
								@iStoredDataRecordID,
								@sStoredDataRecordDesc OUTPUT;
		
							SET @sSPName  = 'spASRWorkflowDeleteRecord';
		
							BEGIN TRY
								EXEC @sSPName
									@iResult OUTPUT,
									@iStoredDataTableID,
									@sStoredDataTableName,
									@iStoredDataRecordID;
							END TRY
							BEGIN CATCH
								SET @fStoredDataOK = 0;
								SET @sStoredDataMsg = ERROR_MESSAGE();
							END CATCH
						END
						ELSE
						BEGIN
							SET @fStoredDataOK = 0;
							SET @sStoredDataMsg = 'Unrecognised data action.';
						END
		
						IF (@fStoredDataOK = 1)
							AND ((@iStoredDataAction = 0)
								OR (@iStoredDataAction = 1))
						BEGIN
		
							EXEC [dbo].[spASRStoredDataFileActions]
								@piInstanceID,
								@iElementID,
								@iStoredDataRecordID;
						END
		
						IF @fStoredDataOK = 1
						BEGIN
							SET @sStoredDataMsg = 'Successfully ' +
								CASE
									WHEN @iStoredDataAction = 0 THEN 'inserted'
									WHEN @iStoredDataAction = 1 THEN 'updated'
									ELSE 'deleted'
								END + ' record';
		
							IF (@iStoredDataAction = 0) OR (@iStoredDataAction = 1) -- Inserted or Updated
							BEGIN
								IF @iStoredDataRecordID > 0 
								BEGIN	
									EXEC [dbo].[spASRRecordDescription] 
										@iStoredDataTableID,
										@iStoredDataRecordID,
										@sEvalRecDesc OUTPUT;
									IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @sStoredDataRecordDesc = @sEvalRecDesc;
								END
							END
		
							IF len(@sStoredDataRecordDesc) > 0 SET @sStoredDataMsg = @sStoredDataMsg + ' (' + @sStoredDataRecordDesc + ')';
		
							UPDATE ASRSysWorkflowInstanceValues
							SET ASRSysWorkflowInstanceValues.value = convert(varchar(MAX), @iStoredDataRecordID), 
								ASRSysWorkflowInstanceValues.valueDescription = @sStoredDataRecordDesc
							WHERE ASRSysWorkflowInstanceValues.instanceID = @piInstanceID
								AND ASRSysWorkflowInstanceValues.elementID = @iElementID
								AND isnull(ASRSysWorkflowInstanceValues.columnID, 0) = 0
								AND isnull(ASRSysWorkflowInstanceValues.emailID, 0) = 0;
		
							UPDATE ASRSysWorkflowInstanceSteps
							SET ASRSysWorkflowInstanceSteps.status = 3,
								ASRSysWorkflowInstanceSteps.completionDateTime = getdate(),
								ASRSysWorkflowInstanceSteps.message = @sStoredDataMsg
							WHERE ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID
								AND ASRSysWorkflowInstanceSteps.elementID = @iElementID;
		
							-- Get this immediate element's succeeding elements
							UPDATE ASRSysWorkflowInstanceSteps
							SET ASRSysWorkflowInstanceSteps.status = 1
							WHERE ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID
								AND ASRSysWorkflowInstanceSteps.elementID IN (SELECT SUCC.id
									FROM [dbo].[udfASRGetSucceedingWorkflowElements](@iElementID, 0) SUCC);
						END
						ELSE
						BEGIN
							-- Check if the failed element has an outbound flow for failures.
							SELECT @iFailureFlows = COUNT(*)
							FROM ASRSysWorkflowElements Es
							INNER JOIN ASRSysWorkflowLinks Ls ON Es.ID = Ls.startElementID
								AND Ls.startOutboundFlowCode = 1
							WHERE Es.ID = @iElementID
								AND Es.type = 5; -- 5 = StoredData
		
							IF @iFailureFlows = 0
							BEGIN
								UPDATE [dbo].[ASRSysWorkflowInstanceSteps]
								SET [Status] = 4,	-- 4 = failed
									[Message] = @sStoredDataMsg,
									[failedCount] = isnull(failedCount, 0) + 1,
									[completionCount] = isnull(completionCount, 0) - 1
								WHERE instanceID = @piInstanceID
									AND elementID = @iElementID;
		
								UPDATE ASRSysWorkflowInstances
								SET status = 2	-- 2 = error
								WHERE ID = @piInstanceID;
		
								SET @psMessage = @sStoredDataMsg;
								RETURN;
							END
							ELSE
							BEGIN
								UPDATE [dbo].[ASRSysWorkflowInstanceSteps]
								SET [Status] = 8,	-- 8 = failed action
									[Message] = @sStoredDataMsg,
									[failedCount] = isnull(failedCount, 0) + 1,
									[completionCount] = isnull(completionCount, 0) - 1
								WHERE [instanceID] = @piInstanceID
									AND [elementID] = @iElementID;
		
								UPDATE [dbo].[ASRSysWorkflowInstanceSteps]
									SET ASRSysWorkflowInstanceSteps.status = 1
									WHERE ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID
										AND ASRSysWorkflowInstanceSteps.elementID IN (SELECT SUCC.id
									FROM [dbo].[udfASRGetSucceedingWorkflowElements](@iElementID, 0) SUCC);
							END
						END
					END
					ELSE
					BEGIN
						EXEC [dbo].[spASRSubmitWorkflowStep] 
							@piInstanceID, 
							@iElementID, 
							'', 
							@sForms OUTPUT, 
							@fSaveForLater OUTPUT,
							0;
					END
		
					FETCH NEXT FROM immediateSubmitCursor INTO @iElementID, @iElementType;
				END
				CLOSE immediateSubmitCursor;
				DEALLOCATE immediateSubmitCursor;
		
				SELECT @iCount = COUNT(ASRSysWorkflowInstanceSteps.elementID)
					FROM [dbo].[ASRSysWorkflowInstanceSteps]
					INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
					WHERE ASRSysWorkflowInstanceSteps.status = 1
						AND (ASRSysWorkflowElements.type = 4 
							OR (@iSQLVersion >= 9 AND ASRSysWorkflowElements.type = 5) 
							OR ASRSysWorkflowElements.type = 7) -- 4=Decision, 5=StoredData, 7=Or
						AND ASRSysWorkflowElements.workflowID = @piWorkflowID
						AND ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID;
			END						
		
			/* Return a list of the workflow form elements that may need to be displayed to the initiator straight away */
			DECLARE @succeedingSteps table(stepID int)
			
			INSERT INTO @succeedingSteps 
				(stepID) VALUES (-1)
		
			DECLARE formsCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysWorkflowInstanceSteps.ID,
				ASRSysWorkflowInstanceSteps.elementID
			FROM [dbo].[ASRSysWorkflowInstanceSteps]
			INNER JOIN ASRSysWorkflowElements ON ASRSysWorkflowInstanceSteps.elementID = ASRSysWorkflowElements.ID
			WHERE (ASRSysWorkflowInstanceSteps.status = 1 OR ASRSysWorkflowInstanceSteps.status = 2)
				AND ASRSysWorkflowElements.type = 2
				AND ASRSysWorkflowElements.workflowID = @piWorkflowID
				AND ASRSysWorkflowInstanceSteps.instanceID = @piInstanceID;	
		
			OPEN formsCursor;
			FETCH NEXT FROM formsCursor INTO @iStepID, @iElementID;
			WHILE (@@fetch_status = 0) 
			BEGIN
				SET @psFormElements = @psFormElements + convert(varchar(MAX), @iElementID) + char(9);
		
				INSERT INTO @succeedingSteps 
				(stepID) VALUES (@iStepID)
		
				FETCH NEXT FROM formsCursor INTO @iStepID, @iElementID;
			END
		
			CLOSE formsCursor;
			DEALLOCATE formsCursor;
		
			UPDATE [dbo].[ASRSysWorkflowInstanceSteps]
			SET ASRSysWorkflowInstanceSteps.status = 2, 
				userName = @sActualLoginName
			WHERE ASRSysWorkflowInstanceSteps.ID IN (SELECT stepID FROM @succeedingSteps)
		
		END
GO
PRINT N'Altering [dbo].[sp_ASRIntCheckCanMakeHidden]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntCheckCanMakeHidden] (
	@piUtilityType		integer,
	@piUtilityID		integer,
	@piResult			integer			OUTPUT,
	@psMessage			varchar(MAX)	OUTPUT
) AS
BEGIN

	SET NOCOUNT ON;

	/* Check if the given picklist/filter/calculation can be made hidden.
	Return 	0 if there's no problem
		1 if it is used only in utilities owned by the current user - we then need to prompt the user if they want to make these utilities hidden too.
		2 if it is used in utilities which are in batch jobs not owned by the current user - Cannot therefore make the utility hidden. 
		3 if it is used in utilities which are not owned by the current user - Cannot therefore make the utility hidden. */
	DECLARE
		@sCurrentUser				sysname,
		@sUtilName					varchar(255),
		@iUtilID					integer,
		@sUtilOwner					varchar(255),
		@sUtilAccess				varchar(MAX),
		@iCount_Owner				integer,
		@sDetails_Owner				varchar(MAX),
		@iCount_NotOwner			integer,
		@sDetails_NotOwner			varchar(MAX),
		@iCount						integer,
		@sJobName					varchar(MAX),
		@sBatchJobDetails_Owner		varchar(255),
		@fBatchJobsOK				bit,
		@sBatchJobDetails_NotOwner	varchar(MAX),
		@iNonHiddenCount			integer,
		@iScheduled					integer, 
		@sRoleToPrompt				sysname,
		@sCurrentUserGroup			sysname,
		@sScheduledUserGroups		varchar(MAX),
		@sScheduledJobDetails		varchar(MAX),
		@superCursor				cursor,
		@iTemp						integer,
		@fSysSecMgr					bit,
		@sActualUserName			sysname,
		@iUserGroupID				integer;

	SET @sCurrentUser = SYSTEM_USER;
	SET @iCount_Owner = 0;
	SET @sDetails_Owner = '';
	SET @iCount_NotOwner = 0;
	SET @sDetails_NotOwner = '';
	SET @sBatchJobDetails_Owner = '';
	SET @sBatchJobDetails_NotOwner = '';
	SET @fBatchJobsOK = 1;
	SET @psMessage = '';
	SET @piResult = 0;
	SET @sScheduledUserGroups = '';
	SET @sScheduledJobDetails = '';

	EXEC spASRIntSysSecMgr @fSysSecMgr OUTPUT;
	
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sCurrentUserGroup OUTPUT,
		@iUserGroupID OUTPUT;

	DECLARE @batchJobIDs TABLE(id integer)
	DECLARE @calendarReportsIDs TABLE(id integer)
	DECLARE @careerIDs TABLE(id integer)
		DECLARE @crossTabIDs TABLE(id integer)
	DECLARE @customReportsIDs TABLE(id integer)
	DECLARE @dataTransferIDs TABLE(id integer)
	DECLARE @exportIDs TABLE(id integer)
	DECLARE @globalAddIDs TABLE(id integer)
		DECLARE @globalUpdateIDs TABLE(id integer)
		DECLARE @globalDeleteIDs TABLE(id integer)
	DECLARE @labelsIDs TABLE(id integer)
		DECLARE @mailMergeIDs TABLE(id integer)
	DECLARE @matchReportIDs TABLE(id integer)
	DECLARE @recordProfileIDs TABLE(id integer)
	DECLARE @successionIDs TABLE(id integer)
	DECLARE @filterIDs TABLE(id integer)
	DECLARE @calculationIDs TABLE(id integer)
	DECLARE @expressionIDs TABLE(id integer)
	DECLARE @superExpressionIDs TABLE(id integer)

	IF (@piUtilityType = 12) OR (@piUtilityType = 11)
	BEGIN
		/* Calculation/Filter. */
		
		/*---------------------------------------------------*/
		/* Check Calculations/Filters For This Expression		*/
		/* NB. This check must be made before checking the reports/utilities	*/
		/*---------------------------------------------------*/
		INSERT INTO @expressionIDs (id) VALUES (@piUtilityID)
		
		exec spASRIntGetAllExprRootIDs @piUtilityID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO @superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		INSERT INTO @expressionIDs (id) SELECT id FROM @superExpressionIDs

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.ExprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.ExprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 10

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calculation whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calculation : ' + @sUtilName + '<BR>'
					INSERT INTO @calculationIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calculation whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calculation : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calculation : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 11

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Filter whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Filter : ' + @sUtilName + '<BR>'
					INSERT INTO @filterIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Filter whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Filter : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Filter : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportEvents ON ASRSysCalendarReports.ID = ASRSYSCalendarReportEvents.calendarReportID
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON ASRSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCalendarReports.DescriptionExpr IN (SELECT id FROM @expressionIDs)
			OR ASRSysCalendarReports.StartDateExpr IN (SELECT id FROM @expressionIDs)
			OR ASRSysCalendarReports.EndDateExpr IN (SELECT id FROM @expressionIDs)
			OR ASRSysCalendarReports.Filter IN (SELECT id FROM @expressionIDs)
			OR ASRSYSCalendarReportEvents.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calendar Report : ' + @sUtilName + '<BR>'
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calendar Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					17,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Calendar Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
			OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Career Progression : ' + @sUtilName + '<BR>'
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Career Progression whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					24,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Career Progression ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Career Progression in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCrossTab.Name,
			ASRSysCrossTab.[CrossTabID] AS [ID],
			ASRSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCrossTab.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysCrossTab.Name,
			ASRSysCrossTab.crossTabID,
			ASRSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Cross Tab : ' + @sUtilName + '<BR>'
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Cross Tab whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					1,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
					
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Cross Tab ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Cross Tab in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
				ASRSysCustomReportsName.Username,
				COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysCustomReportsName
			 LEFT OUTER JOIN ASRSysCustomReportsDetails ON ASRSysCustomReportsName.ID = ASRSysCustomReportsDetails.CustomReportID
			 LEFT OUTER JOIN ASRSYSCustomReportsChildDetails ON ASRSysCustomReportsName.ID = ASRSYSCustomReportsChildDetails.customReportID
LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
				AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysCustomReportsName.Parent1Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysCustomReportsName.Parent2Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSYSCustomReportsChildDetails.ChildFilter IN (SELECT id FROM @expressionIDs)
				OR(ASRSysCustomReportsDetails.Type = 'E' 
					AND ASRSysCustomReportsDetails.ColExprID IN (SELECT id FROM @expressionIDs))
			GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
				ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Custom Report : ' + @sUtilName + '<BR>'
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Custom Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					2,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsname.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Custom Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Custom Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID AS [ID],
				ASRSysDataTransferName.Username,
				COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysDataTransferName
			 LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
				AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.FilterID IN (SELECT id FROM @expressionIDs)
			GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
				ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Data Transfer : ' + @sUtilName + '<BR>'
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Data Transfer whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					3,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Data Transfer ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID AS [ID],
				ASRSysMailMergeName.Username,
				COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
			 LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
				AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysMailMergeName.isLabel = 1
				AND ((ASRSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysMailMergeColumns.Type = 'E' 
					AND ASRSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
			GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
				ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Envelopes & Labels whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					18,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Envelopes & Labels ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
				ASRSysExportName.ID,
				ASRSysExportName.Username,
				COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysExportName
			 LEFT OUTER JOIN ASRSysExportDetails ON ASRSysExportName.ID = ASRSysExportDetails.exportID
			 LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
				AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysExportName.Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysExportName.Parent1Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysExportName.Parent2Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysExportName.ChildFilter IN (SELECT id FROM @expressionIDs)
				OR (ASRSysExportDetails.Type = 'X' 
					AND ASRSysExportDetails.ColExprID IN (SELECT id FROM @expressionIDs))
			GROUP BY ASRSysExportName.Name,
				ASRSysExportName.ID,
				ASRSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Export : ' + @sUtilName + '<BR>'
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Export whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					4,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Export ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Export in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSysGlobalItems ON ASRSysGlobalFunctions.functionID = ASRSysGlobalItems.FunctionID
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ((ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysGlobalItems.ValueType = 4 
					AND ASRSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
				ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Add : ' + @sUtilName + '<BR>'
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Add whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					5,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Add ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Add in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSysGlobalItems ON ASRSysGlobalFunctions.functionID = ASRSysGlobalItems.FunctionID
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ((ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysGlobalItems.ValueType = 4 
					AND ASRSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
				ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Update : ' + @sUtilName + '<BR>'
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Update whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					7,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Update ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Update in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs)
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
				ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Delete : ' + @sUtilName + '<BR>'
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Delete whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					6,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Delete ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Delete in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID AS [ID],
				ASRSysMailMergeName.Username,
				COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
			 LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
				AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysMailMergeName.isLabel = 0
				AND ((ASRSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysMailMergeColumns.Type = 'E' 
					AND ASRSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
			GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
				ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Mail Merge : ' + @sUtilName + '<BR>'
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Mail Merge whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					9,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Mail Merge ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
			OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Match Report : ' + @sUtilName + '<BR>'
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Match Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					14,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Match Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Match Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileTables ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileTables.recordProfileID
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.FilterID IN (SELECT id FROM @expressionIDs)
			OR ASRSYSRecordProfileTables.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Record Profile : ' + @sUtilName + '<BR>'
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Record Profile whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					20,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Record Profile ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Record Profile in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
			OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Succession Planning : ' + @sUtilName + '<BR>'
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Succession Planning whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					23,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Succession Planning ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
		
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/* Ok, all relevant utility definitions have now been checked, so check the counts and act accordingly */
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		IF (@iCount_Owner = 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1) AND
			(len(@sBatchJobDetails_Owner) = 0)
		BEGIN
			SET @piResult = 0
			RETURN
		END
			
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1)
		BEGIN
			/* Can change utils and no utils are contained within batch jobs that cant be changed. */
			SET @psMessage = @sDetails_Owner + @sBatchJobDetails_Owner
			SET @piResult = 1
			RETURN
		END
				
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 0)
		BEGIN
			IF Len(@sScheduledUserGroups) > 0 
			BEGIN
				SET @psMessage = @sScheduledJobDetails
				SET @piResult = 4
			END
			ELSE
			BEGIN
				/* Can change utils but abort cos those utils are in batch jobs which cannot be changed. */
				SET @psMessage = @sBatchJobDetails_NotOwner
				SET @piResult = 2
			END
			
			RETURN
		END

		IF @iCount_NotOwner > 0 
		BEGIN
			/* Cannot change utils */
			SET @psMessage = @sDetails_NotOwner
			SET @piResult = 3
			RETURN
		END
	END

	IF @piUtilityType = 10
	BEGIN
		/* Picklist */
		
		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON ASRSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCalendarReports.Picklist = @piUtilityID
		GROUP BY ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calendar Report : ' + @sUtilName + '<BR>'
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calendar Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					17,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Calendar Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
			OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Career Progression : ' + @sUtilName + '<BR>'
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Career Progression whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					24,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Career Progression ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Career Progression in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCrossTab.Name,
			ASRSysCrossTab.[CrossTabID] AS [ID],
			ASRSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCrossTab.PicklistID = @piUtilityID
		GROUP BY ASRSysCrossTab.Name,
			ASRSysCrossTab.crossTabID,
			ASRSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Cross Tab : ' + @sUtilName + '<BR>'
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Cross Tab whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					1,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
					
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Cross Tab ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Cross Tab in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
				ASRSysCustomReportsName.Username,
				COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysCustomReportsName
			 LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
				AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent1Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent2Picklist = @piUtilityID
			GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
				ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Custom Report : ' + @sUtilName + '<BR>'
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Custom Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					2,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsname.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Custom Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Custom Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID AS [ID],
				ASRSysDataTransferName.Username,
				COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysDataTransferName
			 LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
				AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.PicklistID = @piUtilityID	
			GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
				ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Data Transfer : ' + @sUtilName + '<BR>'
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Data Transfer whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					3,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Data Transfer ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID AS [ID],
				ASRSysMailMergeName.Username,
				COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
				AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysMailMergeName.isLabel = 1
				AND ASRSysMailMergeName.PicklistID = @piUtilityID
			GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
				ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Envelopes & Labels whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					18,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Envelopes & Labels ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
				ASRSysExportName.ID,
				ASRSysExportName.Username,
				COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysExportName
			 LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
				AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysExportName.Picklist = @piUtilityID
				OR ASRSysExportName.Parent1Picklist = @piUtilityID
				OR ASRSysExportName.Parent2Picklist = @piUtilityID
			GROUP BY ASRSysExportName.Name,
				ASRSysExportName.ID,
				ASRSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Export : ' + @sUtilName + '<BR>'
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Export whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					4,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Export ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Export in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
				ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Add : ' + @sUtilName + '<BR>'
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Add whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					5,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Add ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Add in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
				ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Update : ' + @sUtilName + '<BR>'
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Update whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					7,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Update ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Update in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID AS [ID],
				ASRSysGlobalFunctions.Username,
				COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
				AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
			GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
			ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Delete : ' + @sUtilName + '<BR>'
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Delete whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					6,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Delete ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Delete in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID AS [ID],
				ASRSysMailMergeName.Username,
				COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
			 FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
			 LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
				AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysMailMergeName.isLabel = 0
				AND ASRSysMailMergeName.PicklistID = @piUtilityID
			GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
				ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Mail Merge : ' + @sUtilName + '<BR>'
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Mail Merge whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					9,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Mail Merge ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
			OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Match Report : ' + @sUtilName + '<BR>'
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Match Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					14,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Match Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Match Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.PicklistID = @piUtilityID
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Record Profile : ' + @sUtilName + '<BR>'
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Record Profile whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					20,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Record Profile ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Record Profile in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
			OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Succession Planning : ' + @sUtilName + '<BR>'
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Succession Planning whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
					
				exec spASRIntCurrentUserAccess 
					23,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
			
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Succession Planning ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
								
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/* Ok, all relevant utility definitions have now been checked, so check the counts and act accordingly */
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		IF (@iCount_Owner = 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1) AND
			(len(@sBatchJobDetails_Owner) = 0)
		BEGIN
			SET @piResult = 0
								RETURN
		END
					 
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1)
		BEGIN
			/* Can change utils and no utils are contained within batch jobs that cant be changed. */
			SET @psMessage = @sDetails_Owner + @sBatchJobDetails_Owner
			SET @piResult = 1
			RETURN
		END
				
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 0)
		BEGIN
			IF Len(@sScheduledUserGroups) > 0 
			BEGIN
				SET @psMessage = @sScheduledJobDetails
				SET @piResult = 4
			END
			ELSE
			BEGIN
				/* Can change utils but abort cos those utils are in batch jobs which cannot be changed. */
				SET @psMessage = @sBatchJobDetails_NotOwner
				SET @piResult = 2
			END
			
			RETURN
		END

		IF @iCount_NotOwner > 0 
		BEGIN
			/* Cannot change utils */
			SET @psMessage = @sDetails_NotOwner
			SET @piResult = 3
			RETURN
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidatePicklist2]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidatePicklist2] (
	@psUtilName 		varchar(255),
	@piUtilID 			integer,
	@psAccess 			varchar(MAX),
	@piBaseTableID 		integer, 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = error, 
								2 = definition used in utilities owned by the current user. Prompt to make these hidden too. */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount					integer,
			@sCurrentUser			sysname,
			@iHiddenCheckResult 	integer,
			@sHiddenCheckMessage	varchar(MAX);

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	/* Check that the picklist name is unique. */
	IF @piUtilID > 0
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND picklistID <> @piUtilID
			AND tableID = @piBaseTableID;
	END
	ELSE
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND tableID = @piBaseTableID;
	END

	IF @iCount > 0 
	BEGIN
		SET @psErrorMsg = 'A picklist called ''' + @psUtilName + ''' already exists.';
		SET @piErrorCode = 1;
	END

	IF (@piErrorCode = 0) AND (@psAccess = 'HD') AND (@piUtilID > 0)
	BEGIN
		/* Check that the picklist can be made hidden (ie. is not used in any utilities owned by other people. */
		exec [dbo].[sp_ASRIntCheckCanMakeHidden] 10, @piUtilID, @iHiddenCheckResult OUTPUT, @sHiddenCheckMessage OUTPUT;

		IF @iHiddenCheckResult = 1
		BEGIN
			/* picklist used only in utilities owned by the current user - we then need to prompt the user if they want to make these utilities hidden too. */
			SET @psErrorMsg = 'Changing the selected picklist to hidden will automatically make the following definition(s), of which you are the owner, hidden also :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage +
				'<BR><BR>' +
				'Do you wish to continue ?';
			SET @piErrorCode = 2;
		END

		IF @iHiddenCheckResult = 2
		BEGIN
			/* picklist used in utilities which are in batch jobs not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 3
		BEGIN
			/* picklist used in utilities which are not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in the following definition(s), of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 4
		BEGIN
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs which are scheduled to be run by other user groups :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
 				
			SET @piErrorCode = 1;
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetCrossTabDefinition]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetCrossTabDefinition] (
	@piReportID 			integer, 
	@psCurrentUser			varchar(255),
	@psAction				varchar(255),
	@psErrorMsg				varchar(MAX)	OUTPUT,
	@psReportName			varchar(255)	OUTPUT,
	@psReportOwner			varchar(255)	OUTPUT,
	@psReportDesc			varchar(MAX)	OUTPUT,
	@piBaseTableID			integer			OUTPUT,
	@pfAllRecords			bit				OUTPUT,
	@piPicklistID			integer			OUTPUT,
	@psPicklistName			varchar(255)	OUTPUT,
	@pfPicklistHidden		bit				OUTPUT,
	@piFilterID				integer			OUTPUT,
	@psFilterName			varchar(255)	OUTPUT,
	@pfFilterHidden			bit				OUTPUT,
	@pfPrintFilterHeader	bit				OUTPUT,
	@HColID					integer			OUTPUT,
	@HStart					varchar(20)		OUTPUT,
	@HStop					varchar(20)		OUTPUT,
	@HStep					varchar(20)		OUTPUT,
	@VColID					integer			OUTPUT,
	@VStart					varchar(20)		OUTPUT,
	@VStop					varchar(20)		OUTPUT,
	@VStep					varchar(20)		OUTPUT,
	@PColID					integer			OUTPUT,
	@PStart					varchar(20)		OUTPUT,
	@PStop					varchar(20)		OUTPUT,
	@PStep					varchar(20)		OUTPUT,
	@IType					integer			OUTPUT,
	@IColID					integer			OUTPUT,
	@Percentage				bit				OUTPUT,
	@PerPage				bit				OUTPUT,
	@Suppress				bit				OUTPUT,
	@Thousand				bit				OUTPUT,
	@pfOutputPreview		bit				OUTPUT,
	@piOutputFormat			integer			OUTPUT,
	@pfOutputScreen			bit				OUTPUT,
	@pfOutputPrinter		bit				OUTPUT,
	@psOutputPrinterName	varchar(MAX)	OUTPUT,
	@pfOutputSave			bit				OUTPUT,
	@piOutputSaveExisting	integer			OUTPUT,
	@pfOutputEmail			bit				OUTPUT,
	@piOutputEmailAddr		integer			OUTPUT,
	@psOutputEmailName		varchar(MAX)	OUTPUT,
	@psOutputEmailSubject	varchar(MAX)	OUTPUT,
	@psOutputEmailAttachAs	varchar(MAX)	OUTPUT,
	@psOutputFilename		varchar(MAX)	OUTPUT,
 	@piTimestamp			integer			OUTPUT
)

AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount			integer,
			@sTempHidden	varchar(MAX),
			@sAccess 		varchar(MAX);

	SET @psErrorMsg = ''
	--SET @psCurrentUser = ''
	--SET @psAction = ''
	SET @psErrorMsg = ''
	SET @psReportName = ''
	SET @psReportOwner = ''
	SET @psReportDesc = ''
	SET @piBaseTableID = 0
	SET @pfAllRecords = 0
	SET @piPicklistID = 0
	SET @psPicklistName = ''
	SET @pfPicklistHidden = 0
	SET @piFilterID = 0
	SET @psFilterName = ''
	SET @pfFilterHidden = 0
	SET @pfPrintFilterHeader = 0
	SET @HColID = 0
	SET @HStart = ''
	SET @HStop = ''
	SET @HStep = ''
	SET @VColID = 0
	SET @VStart = ''
	SET @VStop = ''
	SET @VStep = ''
	SET @PColID = 0
	SET @PStart = ''
	SET @PStop = ''
	SET @PStep = ''
	SET @IType = 0
	SET @IColID = 0
	SET @Percentage = 0
	SET @PerPage = 0
	SET @Suppress = 0
	SET @Thousand = 0
	SET @pfOutputPreview = 0
	SET @piOutputFormat = 0
	SET @pfOutputScreen = 0
	SET @pfOutputPrinter = 0
	SET @psOutputPrinterName = ''
	SET @pfOutputSave = 0
	SET @piOutputSaveExisting = 0
	SET @pfOutputEmail = 0
	SET @piOutputEmailAddr = 0
	SET @psOutputEmailName = ''
	SET @psOutputEmailSubject = ''
	SET @psOutputEmailAttachAs = ''
	SET @psOutputFilename = ''
 	SET @piTimestamp = 0


	/* Check the report exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'cross tab has been deleted by another user.'
		RETURN
	END

	SELECT @psReportName = name,
		@psReportDesc	 = description,
		@psReportOwner = userName,
		@piBaseTableID = TableID,
		@pfAllRecords = Selection,
		@piPicklistID = PicklistID,
		@piFilterID = FilterID,
		@pfPrintFilterHeader = PrintFilterHeader,
		@psReportOwner = userName,
		@HColID = HorizontalColID,
		@HStart = HorizontalStart,
		@HStop = HorizontalStop,
		@HStep = HorizontalStep,
		@VColID = VerticalColID,
		@VStart = VerticalStart,
		@VStop = VerticalStop,
		@VStep = VerticalStep,
		@PColID = PageBreakColID,
		@PStart = PageBreakStart,
		@PStop = PageBreakStop,
		@PStep = PageBreakStep,
		@IType = IntersectionType,
		@IColID = IntersectionColID,
		@Percentage = Percentage,
		@PerPage = PercentageofPage,
		@Suppress = SuppressZeros,
		@Thousand = ThousandSeparators,
		@pfOutputPreview = OutputPreview,
		@piOutputFormat = OutputFormat,
		@pfOutputScreen = OutputScreen,
		@pfOutputPrinter = OutputPrinter,
		@psOutputPrinterName = OutputPrinterName,
		@pfOutputSave = OutputSave,
		@piOutputSaveExisting = OutputSaveExisting,
		@pfOutputEmail = OutputEmail,
		@piOutputEmailAddr = OutputEmailAddr,
		@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
		@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
		@psOutputFilename = ISNULL(OutputFilename,''),
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID

	/* Check the current user can view the report. */
	exec spASRIntCurrentUserAccess 
		1, 
		@piReportID,
		@sAccess	OUTPUT

	IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'cross tab has been made hidden by another user.'
		RETURN
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'cross tab has been made read only by another user.'
		RETURN
	END

	IF @psAction = 'copy'
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50)
		SET @psReportOwner = @psCurrentUser
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access
		FROM ASRSysPicklistName 
		WHERE picklistID = @piPicklistID

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfPicklistHidden = 1
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piFilterID

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfFilterHidden = 1
		END
	END

	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM ASRSysEmailGroupName
		WHERE EmailGroupID = @piOutputEmailAddr
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0	
		SET @psOutputEmailName = ''
	END

END
GO
PRINT N'Altering [dbo].[sp_ASRIntGetReportDefinition]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntGetReportDefinition] (
	@piReportID 				integer, 
	@psCurrentUser				varchar(255),
	@psAction					varchar(255),
	@psErrorMsg					varchar(MAX)	OUTPUT,
	@psReportName				varchar(255)	OUTPUT,
	@psReportOwner				varchar(255)	OUTPUT,
	@psReportDesc				varchar(MAX)	OUTPUT,
	@piBaseTableID				integer			OUTPUT,
	@pfAllRecords				bit				OUTPUT,
	@piPicklistID				integer			OUTPUT,
	@psPicklistName				varchar(255)	OUTPUT,
	@pfPicklistHidden			bit				OUTPUT,
	@piFilterID					integer			OUTPUT,
	@psFilterName				varchar(255)	OUTPUT,
	@pfFilterHidden				bit				OUTPUT,
	@piParent1TableID			integer			OUTPUT,
	@psParent1Name				varchar(255)	OUTPUT,
	@piParent1FilterID			integer			OUTPUT,
	@psParent1FilterName		varchar(255)	OUTPUT,
	@pfParent1FilterHidden		bit				OUTPUT,
	@piParent2TableID			integer			OUTPUT,
	@psParent2Name				varchar(255)	OUTPUT,
	@piParent2FilterID			integer			OUTPUT,
	@psParent2FilterName		varchar(255)	OUTPUT,
	@pfParent2FilterHidden		bit				OUTPUT,
	@pfSummary					bit				OUTPUT,
	@pfPrintFilterHeader		bit				OUTPUT,
	@pfOutputPreview			bit				OUTPUT,
	@piOutputFormat				integer			OUTPUT,
	@pfOutputScreen				bit				OUTPUT,
	@pfOutputPrinter			bit				OUTPUT,
	@psOutputPrinterName		varchar(MAX)	OUTPUT,
	@pfOutputSave				bit				OUTPUT,
	@piOutputSaveExisting		integer			OUTPUT,
	@pfOutputEmail				bit				OUTPUT,
	@piOutputEmailAddr			integer			OUTPUT,
	@psOutputEmailName			varchar(MAX)	OUTPUT,
	@psOutputEmailSubject		varchar(MAX)	OUTPUT,
	@psOutputEmailAttachAs		varchar(MAX)	OUTPUT,
	@psOutputFilename			varchar(MAX)	OUTPUT,
	@piTimestamp				integer			OUTPUT,
	@pfParent1AllRecords		bit				OUTPUT,
	@piParent1PicklistID		integer			OUTPUT,
	@psParent1PicklistName		varchar(255)	OUTPUT,
	@pfParent1PicklistHidden	bit				OUTPUT,
	@pfParent2AllRecords		bit				OUTPUT,
	@piParent2PicklistID		integer			OUTPUT,
	@psParent2PicklistName		varchar(255)	OUTPUT,
	@pfParent2PicklistHidden	bit				OUTPUT,
	@psInfoMsg					varchar(MAX)	OUTPUT,
	@pfIgnoreZeros				bit				OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount			integer,
			@sTempHidden		varchar(8000),
			@sAccess				varchar(8000),
			@sTempUsername	varchar(8000),
			@fSysSecMgr			bit;

	SET @psErrorMsg = '';
	SET @psPicklistName = '';
	SET @pfPicklistHidden = 0;
	SET @psFilterName = '';
	SET @pfFilterHidden = 0;
	SET @psParent1Name = '';
	SET @psParent1FilterName = '';
	SET @pfParent1FilterHidden = 0;
	SET @psParent2Name = '';
	SET @psParent2FilterName = '';
	SET @pfParent2FilterHidden = 0;
	SET @psParent1PicklistName = '';
	SET @pfParent1PicklistHidden = 0;
	SET @psParent2PicklistName = '';
	SET @pfParent2PicklistHidden = 0;
	SET @psInfoMsg = '';
	SET @psOutputEmailName = '';

	exec [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
	
	/* Check the report exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysCustomReportsName 
	WHERE ID = @piReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report has been deleted by another user.';
		RETURN;
	END

	SELECT @psReportName = name,
		@psReportDesc	 = description,
		@piBaseTableID = baseTable,
		@pfAllRecords = allRecords,
		@piPicklistID = picklist,
		@piFilterID = filter,
		@piParent1TableID = parent1Table,
		@piParent1FilterID = parent1Filter,
		@piParent2TableID = parent2Table,
		@piParent2FilterID = parent2Filter,
		@pfSummary = summary,
		@pfPrintFilterHeader = printFilterHeader,
		@psReportOwner = userName,
		@pfOutputPreview = OutputPreview,
		@piOutputFormat = OutputFormat,
		@pfOutputScreen = OutputScreen,
		@pfOutputPrinter = OutputPrinter,
		@psOutputPrinterName = OutputPrinterName,
		@pfOutputSave = OutputSave,
		@piOutputSaveExisting = OutputSaveExisting,
		@pfOutputEmail = OutputEmail,
		@piOutputEmailAddr = OutputEmailAddr,
		@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
		@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
		@psOutputFilename = ISNULL(OutputFilename,''),
		@piTimestamp = convert(integer, timestamp),
		@pfParent1AllRecords = parent1AllRecords,
		@piParent1PicklistID = parent1Picklist,
		@pfParent2AllRecords = parent2AllRecords,
		@piParent2PicklistID = parent2Picklist,
		@pfIgnoreZeros = IgnoreZeros
	FROM [dbo].[ASRSysCustomReportsName]
	WHERE ID = @piReportID;

	/* Check the current user can view the report. */
	exec [dbo].[spASRIntCurrentUserAccess]
		2, 
		@piReportID,
		@sAccess OUTPUT;

	IF @fSysSecMgr = 0 
	BEGIN
		IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
		BEGIN
			SET @psErrorMsg = 'report has been made hidden by another user.';
			RETURN;
		END

		IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
		BEGIN
			SET @psErrorMsg = 'report has been made read only by another user.';
			RETURN;
		END
	END
	
	/* Check the report has details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCustomReportsDetails]
		WHERE ASRSysCustomReportsDetails.customReportID = @piReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report contains no details.';
		RETURN;
	END

	/* Check the report has sort order details. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCustomReportsDetails]
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'C'
		AND ASRSysCustomReportsDetails.sortOrderSequence > 0

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report contains no sort order details.';
		RETURN;
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50);
		SET @psReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access,
			@sTempUsername = username
		FROM [dbo].[ASRSysPicklistName]
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			IF UPPER(@sTempUsername) = UPPER(system_user)
			BEGIN
				SET @pfPicklistHidden = 1;
			END
			ELSE
			BEGIN
				/* Picklist is hidden by another user. Remove it from the definition. */
				IF @fSysSecMgr = 0
				BEGIN
					SET @piPicklistID = 0;
					SET @psPicklistName = '';
					SET @pfPicklistHidden = 0;

					SET @psInfoMsg = @psInfoMsg +
					CASE
						WHEN LEN(@psInfoMsg) > 0 THEN char(10)
						ELSE ''
					END + 'The base table picklist will be removed from this definition as it has been made hidden by another user.';
				END
			END
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access,
			@sTempUsername = username
		FROM [dbo].[ASRSysExpressions]
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			IF UPPER(@sTempUsername) = UPPER(system_user)
			BEGIN
				SET @pfFilterHidden = 1;
			END
			ELSE
			BEGIN
				/* Filter is hidden by another user. Remove it from the definition. */
				IF @fSysSecMgr = 0
				BEGIN
					SET @piFilterID = 0;
					SET @psFilterName = '';
					SET @pfFilterHidden = 0;

					SET @psInfoMsg = @psInfoMsg +
					CASE
						WHEN LEN(@psInfoMsg) > 0 THEN char(10)
						ELSE ''
					END + 'The base table filter will be removed from this definition as it has been made hidden by another user.';
				END
			END
		END
	END

	IF @piParent1TableID > 0 
	BEGIN
		SELECT @psParent1Name = tableName
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @piParent1TableID;

		IF @piParent1PicklistID > 0 
		BEGIN
			SELECT @psParent1PicklistName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysPicklistName]
			WHERE picklistID = @piParent1PicklistID;
	
			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent1PicklistHidden = 1;
				END
				ELSE
				BEGIN
					/* Picklist is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent1PicklistID = 0;
						SET @psParent1PicklistName = '';
						SET @pfParent1PicklistHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent1Name + ''' table picklist will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END

		IF @piParent1FilterID > 0 
		BEGIN
			SELECT @psParent1FilterName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysExpressions]
			WHERE exprID = @piParent1FilterID;

			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent1FilterHidden = 1;
				END
				ELSE
				BEGIN
					/* Filter is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent1FilterID = 0;
						SET @psParent1FilterName = '';
						SET @pfParent1FilterHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent1Name + ''' table filter will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END	
	END

	IF @piParent2TableID > 0 
	BEGIN
		SELECT @psParent2Name = tableName 
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @piParent2TableID;

		IF @piParent2PicklistID > 0 
		BEGIN
			SELECT @psParent2PicklistName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysPicklistName]
			WHERE picklistID = @piParent2PicklistID;
	
			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent2PicklistHidden = 1;
				END
				ELSE
				BEGIN
					/* Picklist is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent2PicklistID = 0;
						SET @psParent2PicklistName = '';
						SET @pfParent2PicklistHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent2Name + ''' table picklist will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END

		IF @piParent2FilterID > 0 
		BEGIN
			SELECT @psParent2FilterName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysExpressions]
			WHERE exprID = @piParent2FilterID;

			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent2FilterHidden = 1;
				END
				ELSE
				BEGIN
					/* Filter is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent2FilterID = 0;
						SET @psParent2FilterName = '';
						SET @pfParent2FilterHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent2Name + ''' table filter will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END	
	END

	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM [dbo].[ASRSysEmailGroupName]
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;	
		SET @psOutputEmailName = '';
	END

	/* Get the definition recordset. */
	SELECT 'COLUMN' AS [definitionType],
		'N' AS [hidden],
		convert(varchar(255), ASRSysCustomReportsDetails.type) + char(9) +
		convert(varchar(255), ASRSysColumns.tableID) + char(9) +
		convert(varchar(255), ASRSysCustomReportsDetails.colExprID) + char(9) +
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) + char(9) +
		convert(varchar(100), ASRSysCustomReportsDetails.size) + char(9) +
		convert(varchar(100), ASRSysCustomReportsDetails.dp) + char(9) +
		'N' + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.isNumeric = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		convert(varchar(8000), ASRSysCustomReportsDetails.heading) + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.avge = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE
			WHEN ASRSysCustomReportsDetails.cnt = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.tot = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.Hidden = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.GroupWithNextColumn = 0 THEN '0' 
			ELSE '1' 
		END AS [definitionString],
		ASRSysCustomReportsDetails.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails 
	INNER JOIN ASRSysColumns ON ASRSysCustomReportsDetails.colExprID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'C'
	UNION
	SELECT 'COLUMN' AS [definitionType],
		CASE 
			WHEN ASRSysExpressions.access = 'HD' THEN 'Y'
			ELSE 'N'
		END AS [hidden],
		convert(varchar(255), ASRSysCustomReportsDetails.type) + char(9) +
		convert(varchar(255), ASRSysExpressions.tableID) + char(9) +
		convert(varchar(255), ASRSysCustomReportsDetails.colExprID) + char(9) +
		convert(varchar(MAX), '<' + ASRSysTables.TableName  + ' Calc> ' + replace(ASRSysExpressions.name, '_', ' ')) + char(9) +
		convert(varchar(100), ASRSysCustomReportsDetails.size) + char(9) +
		convert(varchar(100), ASRSysCustomReportsDetails.dp) + char(9) +
		CASE
			WHEN ASRSysExpressions.access = 'HD' THEN 'Y'
			ELSE 'N'
		END + char(9) +
		CASE
			WHEN ASRSysCustomReportsDetails.isNumeric = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		convert(varchar(8000), ASRSysCustomReportsDetails.heading) + char(9) +

		CASE
			WHEN ASRSysCustomReportsDetails.avge = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			when ASRSysCustomReportsDetails.cnt = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.tot = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.Hidden = 0 THEN '0' 
			ELSE '1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.GroupWithNextColumn = 0 THEN '0' 
			ELSE '1' 
		END AS [definitionString],
		ASRSysCustomReportsDetails.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails
		INNER JOIN ASRSysExpressions ON ASRSysCustomReportsDetails.colExprID = ASRSysExpressions.exprID
		INNER JOIN ASRSysTables ON ASRSysExpressions.tableID = ASRSysTables.tableID
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type <> 'C'
	UNION
	SELECT 'ORDER' AS [definitionType],
		'N' AS [hidden],
		convert(varchar(255), ASRSysCustomReportsDetails.colExprID) + char(9) +
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) + char(9) +
		convert(varchar(255), ASRSysCustomReportsDetails.sortOrder) + char(9) +
		CASE
			WHEN ASRSysCustomReportsDetails.boc = 0 THEN '' 
			ELSE '-1' 
		END + char(9) +
		CASE
			WHEN ASRSysCustomReportsDetails.poc = 0 THEN '' 
			ELSE '-1' 
		END + char(9) +
		CASE
			WHEN ASRSysCustomReportsDetails.voc = 0 THEN '' 
			ELSE '-1' 
		END + char(9) +
		CASE 
			WHEN ASRSysCustomReportsDetails.srv = 0 THEN '' 
			ELSE '-1' 
		END  + char(9) +
		convert(varchar(255), ASRSysTables.tableID) AS [definitionString],
		ASRSysCustomReportsDetails.sortOrderSequence AS [sequence]
	FROM ASRSysCustomReportsDetails
	INNER JOIN ASRSysColumns ON ASRSysCustomReportsDetails.colExprID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'C'
		AND ASRSysCustomReportsDetails.sortOrderSequence > 0
	UNION
	SELECT 'REPETITION' AS [definitionType],
		'N' AS [hidden],
		'C' + convert(varchar(255), ASRSysCustomReportsDetails.colExprID) + char(9) +
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) + char(9) +
		convert(varchar(MAX), ASRSysCustomReportsDetails.repetition)  + char(9) +
		convert(varchar(255), ASRSysTables.tableID) + char(9) +
		convert(varchar(255), ASRSysCustomReportsDetails.Hidden) AS [definitionString],
		ASRSysCustomReportsDetails.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails
		INNER JOIN ASRSysColumns ON ASRSysCustomReportsDetails.colExprID = ASRSysColumns.columnId
		INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'C'
		AND ASRSysCustomReportsDetails.repetition >= 0
	UNION
	SELECT 'REPETITION' AS [definitionType],
		CASE 
			WHEN ASRSysExpressions.access = 'HD' THEN 'Y'
			ELSE 'N'
		END AS [hidden],
		'E' + convert(varchar(8000), ASRSysCustomReportsDetails.colExprID) + char(9) +
		'<' + ASRSysTables.TableName + ' Calc> ' + convert(varchar(MAX), ASRSysExpressions.Name) + char(9) +
		convert(varchar(100), ASRSysCustomReportsDetails.repetition)  + char(9) +
		convert(varchar(255), ASRSysExpressions.tableID) + char(9) +
		convert(varchar(255), ASRSysCustomReportsDetails.Hidden) AS [definitionString],
		ASRSysCustomReportsDetails.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails
		INNER JOIN ASRSysExpressions ON ASRSysCustomReportsDetails.colExprID = ASRSysExpressions.ExprID
		INNER JOIN ASRSysTables ON ASRSysExpressions.tableID = ASRSysTables.tableID
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'E'
		AND ASRSysCustomReportsDetails.repetition >= 0
	ORDER BY [sequence] ASC;
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntMakeUtilitiesHidden]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntMakeUtilitiesHidden] (
	@piUtilityType		integer,
	@piUtilityID		integer
) AS
BEGIN

	SET NOCOUNT ON;

	/* Hide any utilities the use the given picklist/filter/calculation. */
	DECLARE
		@sCurrentUser		sysname,
		@sUtilName			varchar(255),
		@iUtilID			integer,
		@sUtilOwner			varchar(255),
		@sUtilAccess		varchar(MAX),
		@iCount				integer,
		@sJobName			varchar(255),
		@iNonHiddenCount	integer,
		@iScheduled			integer, 
		@sRoleToPrompt		sysname,
		@sCurrentUserGroup	sysname,
		@superCursor		cursor,
		@iTemp				integer,
		@iUserGroupID		integer,
		@sActualUserName	sysname;

	SET @sCurrentUser = SYSTEM_USER;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sCurrentUserGroup OUTPUT,
		@iUserGroupID OUTPUT;

	DECLARE @batchJobIDs		TABLE(id integer)
	DECLARE @calendarReportsIDs TABLE(id integer)
	DECLARE @careerIDs			TABLE(id integer)
	DECLARE @crossTabIDs		TABLE(id integer)
	DECLARE @customReportsIDs	TABLE(id integer)
	DECLARE @dataTransferIDs	TABLE(id integer)
	DECLARE @exportIDs			TABLE(id integer)
	DECLARE @globalAddIDs		TABLE(id integer)
	DECLARE @globalUpdateIDs	TABLE(id integer)
	DECLARE @globalDeleteIDs	TABLE(id integer)
	DECLARE @labelsIDs			TABLE(id integer)
	DECLARE @mailMergeIDs		TABLE(id integer)
	DECLARE @matchReportIDs		TABLE(id integer)
	DECLARE @recordProfileIDs	TABLE(id integer)
	DECLARE @successionIDs		TABLE(id integer)
	DECLARE @filterIDs			TABLE(id integer)
	DECLARE @calculationIDs		TABLE(id integer)
	DECLARE @expressionIDs		TABLE(id integer)
	DECLARE @superExpressionIDs	TABLE(id integer)

	IF (@piUtilityType = 12) OR (@piUtilityType = 11)
	BEGIN
		/* Calculation/Filter. */

    /*---------------------------------------------------*/
    /* Check Calculations/Filters For This Expression		*/
    /* NB. This check must be made before checking the reports/utilities	*/
    /*---------------------------------------------------*/
		INSERT INTO @expressionIDs (id) VALUES (@piUtilityID)
		
		exec spASRIntGetAllExprRootIDs @piUtilityID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO @superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		INSERT INTO @expressionIDs (id) SELECT id FROM @superExpressionIDs

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 10

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calculation whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					INSERT INTO @calculationIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 11

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Filter whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					INSERT INTO @filterIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportEvents ON ASRSysCalendarReports.ID = ASRSYSCalendarReportEvents.calendarReportID
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON ASRSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysCalendarReports.DescriptionExpr IN (SELECT id FROM @expressionIDs)
			OR ASRSysCalendarReports.StartDateExpr IN (SELECT id FROM @expressionIDs)
      OR ASRSysCalendarReports.EndDateExpr IN (SELECT id FROM @expressionIDs)
      OR ASRSysCalendarReports.Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSYSCalendarReportEvents.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
 			ASRSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCrossTab.Name,
			ASRSysCrossTab.[CrossTabID] AS [ID],
			ASRSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCrossTab.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysCrossTab.Name,
			ASRSysCrossTab.crossTabID,
 			ASRSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSysCustomReportsDetails ON ASRSysCustomReportsName.ID = ASRSysCustomReportsDetails.CustomReportID
       LEFT OUTER JOIN ASRSYSCustomReportsChildDetails ON ASRSysCustomReportsName.ID = ASRSYSCustomReportsChildDetails.customReportID
       LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysCustomReportsName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysCustomReportsName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSYSCustomReportsChildDetails.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR(ASRSysCustomReportsDetails.Type = 'E' 
					AND ASRSysCustomReportsDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsname.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
        ASRSysMailMergeName.MailMergeID AS [ID],
        ASRSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE ASRSysMailMergeName.isLabel = 1
        AND ((ASRSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysMailMergeColumns.Type = 'E' 
					AND ASRSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
        ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
			 LEFT OUTER JOIN ASRSysExportDetails ON ASRSysExportName.ID = ASRSysExportDetails.exportID
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE ASRSysExportName.Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysExportName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysExportName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysExportName.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR (ASRSysExportDetails.Type = 'X' 
					AND ASRSysExportDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY ASRSysExportName.Name,
				ASRSysExportName.ID,
        ASRSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSysGlobalItems ON ASRSysGlobalFunctions.functionID = ASRSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ((ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysGlobalItems.ValueType = 4 
					AND ASRSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) > 0) 
						OR (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN ASRSysGlobalItems ON ASRSysGlobalFunctions.functionID = ASRSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ((ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysGlobalItems.ValueType = 4 
					AND ASRSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
        ASRSysMailMergeName.MailMergeID AS [ID],
        ASRSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE ASRSysMailMergeName.isLabel = 0
        AND ((ASRSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (ASRSysMailMergeColumns.Type = 'E' 
					AND ASRSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
        ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileTables ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileTables.recordProfileID
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.FilterID IN (SELECT id FROM @expressionIDs)
			OR ASRSYSRecordProfileTables.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
	END

	IF @piUtilityType = 10
	BEGIN
    /* Picklist */
    
		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
			ASRSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON ASRSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysCalendarReports.Picklist = @piUtilityID
		GROUP BY ASRSysCalendarReports.Name,
			ASRSysCalendarReports.ID,
 			ASRSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysCrossTab.Name,
			ASRSysCrossTab.[CrossTabID] AS [ID],
			ASRSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM ASRSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysCrossTab.PicklistID = @piUtilityID
		GROUP BY ASRSysCrossTab.Name,
			ASRSysCrossTab.crossTabID,
 			ASRSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent1Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent2Picklist = @piUtilityID
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsname.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.PicklistID = @piUtilityID	
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
        ASRSysMailMergeName.MailMergeID AS [ID],
        ASRSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM ASRSysMailMergeName
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE ASRSysMailMergeName.isLabel = 1
        AND ASRSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
        ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysExportName.Picklist = @piUtilityID
				OR ASRSysExportName.Parent1Picklist = @piUtilityID
				OR ASRSysExportName.Parent2Picklist = @piUtilityID
      GROUP BY ASRSysExportName.Name,
				ASRSysExportName.ID,
        ASRSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysMailMergeName.Name,
        ASRSysMailMergeName.MailMergeID AS [ID],
        ASRSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM ASRSysMailMergeName
			 LEFT OUTER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON ASRSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE ASRSysMailMergeName.isLabel = 0
				AND ASRSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY ASRSysMailMergeName.Name,
				ASRSysMailMergeName.MailMergeID,
        ASRSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.PicklistID = @piUtilityID
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
	END

	/*---------------------------------------------------------*/
	/* Mark all relevent utilities as hidden. */
	/*---------------------------------------------------------*/
	
	/* Calculations */
	UPDATE ASRSysExpressions
	SET access = 'HD'
	WHERE exprID IN (SELECT id FROM @calculationIDs)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @calculationIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 12

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (12, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 12
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor

	/* Filters */
	UPDATE ASRSysExpressions
	SET access = 'HD'
	WHERE exprID IN (SELECT id FROM @filterIDs)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @filterIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 11

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (11, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 11
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor

	/* Batch Jobs */
	DELETE FROM ASRSysBatchJobAccess
	WHERE ID IN (SELECT id FROM @batchJobIDs)

	INSERT INTO ASRSysBatchJobAccess
		(ID, groupName, access)
		(SELECT ASRSysBatchJobName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysBatchJobName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysBatchJobName.ID IN (SELECT id FROM @batchJobIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @batchJobIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 0

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (0, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 0
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Calendar Reports */
	DELETE FROM ASRSysCalendarReportAccess
	WHERE ID IN (SELECT id FROM @calendarReportsIDs)

	INSERT INTO ASRSysCalendarReportAccess
		(ID, groupName, access)
		(SELECT ASRSysCalendarReports.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCalendarReports
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCalendarReports.ID IN (SELECT id FROM @calendarReportsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @calendarReportsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 17

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (17, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 17
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Career Progression */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @careerIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @careerIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @careerIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 24

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (24, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 24
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Cross Tabs */
	DELETE FROM ASRSysCrossTabAccess
	WHERE ID IN (SELECT id FROM @crossTabIDs)

	INSERT INTO ASRSysCrossTabAccess
		(ID, groupName, access)
		(SELECT ASRSysCrossTab.CrossTabID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCrossTab
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCrossTab.CrossTabID IN (SELECT id FROM @crossTabIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @crossTabIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 1

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (1, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 1
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Custom Reports */
	DELETE FROM ASRSysCustomReportAccess
	WHERE ID IN (SELECT id FROM @customReportsIDs)

	INSERT INTO ASRSysCustomReportAccess
		(ID, groupName, access)
		(SELECT ASRSysCustomReportsName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCustomReportsName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCustomReportsName.ID IN (SELECT id FROM @customReportsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @customReportsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 2

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (2, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 2
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Data Transfers */
	DELETE FROM ASRSysDataTransferAccess
	WHERE ID IN (SELECT id FROM @dataTransferIDs)

	INSERT INTO ASRSysDataTransferAccess
		(ID, groupName, access)
		(SELECT ASRSysDataTransferName.DataTransferID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysDataTransferName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysDataTransferName.DataTransferID IN (SELECT id FROM @dataTransferIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @dataTransferIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 3

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (3, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 3
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Exports */
	DELETE FROM ASRSysExportAccess
	WHERE ID IN (SELECT id FROM @exportIDs)

	INSERT INTO ASRSysExportAccess
		(ID, groupName, access)
		(SELECT ASRSysExportName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysExportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysExportName.ID IN (SELECT id FROM @exportIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @exportIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 4

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (4, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 4
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Adds */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalAddIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalAddIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalAddIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 5

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (5, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 5
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Updates */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalUpdateIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalUpdateIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalUpdateIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 7

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (7, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 7
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Deletes */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalDeleteIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalDeleteIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalDeleteIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 6

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (6, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 6
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Labels */
	DELETE FROM ASRSysMailMergeAccess
	WHERE ID IN (SELECT id FROM @labelsIDs)

	INSERT INTO ASRSysMailMergeAccess
		(ID, groupName, access)
		(SELECT ASRSysMailMergeName.mailMergeID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMailMergeName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMailMergeName.mailMergeID IN (SELECT id FROM @labelsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @labelsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 18

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (18, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 18
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Mail Merges */
	DELETE FROM ASRSysMailMergeAccess
	WHERE ID IN (SELECT id FROM @mailMergeIDs)

	INSERT INTO ASRSysMailMergeAccess
		(ID, groupName, access)
		(SELECT ASRSysMailMergeName.mailMergeID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMailMergeName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMailMergeName.mailMergeID IN (SELECT id FROM @mailMergeIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @mailMergeIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 9

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (9, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 9
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Match Reports */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @matchReportIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @matchReportIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @matchReportIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 14

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (14, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 14
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Record Profiles */
	DELETE FROM ASRSysRecordProfileAccess
	WHERE ID IN (SELECT id FROM @recordProfileIDs)

	INSERT INTO ASRSysRecordProfileAccess
		(ID, groupName, access)
		(SELECT ASRSysRecordProfileName.recordProfileID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysRecordProfileName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysRecordProfileName.recordProfileID IN (SELECT id FROM @recordProfileIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @recordProfileIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 20

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (20, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 20
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Succession Planning */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @successionIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @successionIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @successionIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 23

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (23, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 23
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

END
GO
PRINT N'Altering [dbo].[sp_ASRIntSavePicklist]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntSavePicklist] (
	@psName			varchar(255),
	@psDescription	varchar(MAX),
	@psAccess		varchar(MAX),
	@psUserName		varchar(255),
	@psColumns		varchar(MAX),
	@psColumns2		varchar(MAX),
	@piID			integer	OUTPUT,
	@piTableID		integer	
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iIndex		integer,
		@iCount	integer,
		@sSubstring	varchar(MAX)

	/* Clean the input string parameters. */
	IF len(@psColumns) > 0 SET @psColumns = replace(@psColumns, '''', '''''')
	IF len(@psColumns2) > 0 SET @psColumns2 = replace(@psColumns2, '''', '''''')

	IF @piID = 0 
	BEGIN
		/* Saving a new picklist. */
		INSERT INTO ASRSysPickListName
			(name, description, tableID, access, userName)
		VALUES
			(@psName, @psDescription, @piTableID, @psAccess, @psUserName)

		/* Get the ID of the inserted record.
		NB. We do not use @@IDENTITY as the insertion that we have just performed may have triggered
		other insertions (eg. into the Audit Trail table. The @@IDENTITY variable would then be the last IDENTITY value
		entered in the Audit Trail table.*/
		SELECT @piID = MAX(picklistID) 
		FROM ASRSysPickListName

		WHILE len(@psColumns) > 0
		BEGIN
			SET @iIndex = charindex(',', @psColumns)
	
			IF @iIndex > 0
			BEGIN
				SET @sSubstring = left(@psColumns, @iIndex -1)
				SET @psColumns = substring(@psColumns, @iIndex + 1, len(@psColumns) - @iIndex)

				INSERT INTO ASRSysPickListItems (pickListID, recordID)
				VALUES(@piID, convert(integer, @sSubstring))

				IF (len(@psColumns2) > 0) AND (len(@psColumns) < 7000)
				BEGIN
					SET @psColumns = @psColumns + left(@psColumns2, 1000)
					IF len(@psColumns2) > 1000
					BEGIN
						SET @psColumns2 = substring(@psColumns, 1001, len(@psColumns2) - 1000)
					END
					ELSE
					BEGIN
						SET @psColumns2 = ''
					END
				END
			END
			ELSE
			BEGIN
				BREAK
			END
		END

		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (10, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Saving an existing picklist. */

		IF @psAccess = 'HD'
		BEGIN
			/* Hide any utilities that use this picklist. NB. The check to see if we can do this has already been done in sp_ASRIntCheckCanMakeHidden. */
			exec sp_ASRIntMakeUtilitiesHidden 10, @piID
		END
		
		DELETE FROM ASRSysPickListItems
		WHERE pickListID = @piID

		UPDATE ASRSysPickListName SET
			name = @psName, 
			description = @psDescription, 
			tableID = @piTableID,
			access = @psAccess
		WHERE pickListID = @piID

		WHILE len(@psColumns) > 0
		BEGIN
			SET @iIndex = charindex(',', @psColumns)
	
			IF @iIndex > 0
			BEGIN
				SET @sSubstring = left(@psColumns, @iIndex -1)
				SET @psColumns = substring(@psColumns, @iIndex + 1, len(@psColumns) - @iIndex)

				INSERT INTO ASRSysPickListItems (pickListID, recordID)
				VALUES(@piID, convert(integer, @sSubstring))

				IF (len(@psColumns2) > 0) AND (len(@psColumns) < 7000)
				BEGIN
					SET @psColumns = @psColumns + left(@psColumns2, 1000)
					IF len(@psColumns2) > 1000
					BEGIN
						SET @psColumns2 = substring(@psColumns, 1001, len(@psColumns2) - 1000)
					END
					ELSE
					BEGIN
						SET @psColumns2 = ''
					END
				END
			END
			ELSE
			BEGIN
				BREAK
			END
		END

		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 10

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (10, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 10
		END
	END
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateCrossTab]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateCrossTab] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@piEmailGroupID 	integer, 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedFilters 	varchar(MAX)	OUTPUT,
	@psHiddenFilters 	varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sParameter				varchar(MAX),
			@sExprName  			varchar(MAX),
			@sBatchJobName			varchar(MAX),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(MAX),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The cross tab has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCrossTab
			WHERE CrossTabID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					1, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The cross tab has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The cross tab has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the cross tab name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName
				AND CrossTabID <> @piUtilID
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A cross tab called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Cross Tab ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END

			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	
		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs

END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateMailMerge]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateMailMerge] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@psCalculations 	varchar(MAX), 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ?
								4 = saving will cause batch jobs to be made hiiden. Prompt to continue */
	@psDeletedCalcs 	varchar(MAX)	OUTPUT, 
	@psHiddenCalcs 		varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The mail merge has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysMailMergeName
			WHERE MailMergeID = @piUtilID

			IF (@iTimestamp <> @piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					9, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName
				AND MailMergeID <> @piUtilID AND IsLabel = 0
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName AND IsLabel = 0
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A mail merge called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	/* Check that the selected runtime calculations exists. */
	IF (@piErrorCode = 0) AND (LEN(@psCalculations) > 0)
	BEGIN
		SET @sTemp = @psCalculations

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(',', @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(',', @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(',', @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			SELECT @iCount = COUNT(*)
			FROM ASRSysExpressions
			 WHERE exprID = convert(integer, @sCurrentID)

			IF @iCount = 0
			BEGIN
				SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							'One or more runtime calculations have been deleted by another user. They will be automatically removed from the mail merge.'
					END
				SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
				SET @piErrorCode = 1
			END
			ELSE
			BEGIN
				SELECT @sOwner = userName,
					@sAccess = access
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 
						@psErrorMsg + 
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ''
							ELSE 
								CASE 
									WHEN LEN(@psErrorMsg) > 0 THEN char(13)
									ELSE ''
								END +
								'One or more runtime calculations have been made hidden by another user. They will be automatically removed from the mail merge.'
						END
					SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
					SET @piErrorCode = 1
				END
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysMailMergeName.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysMailMergeName.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Mail Merge ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs
	
END
GO
PRINT N'Altering [dbo].[sp_ASRIntValidateReport]...';


GO
ALTER PROCEDURE [dbo].[sp_ASRIntValidateReport] (
	@psUtilName 				varchar(255), 
	@piUtilID 					integer, 
	@piTimestamp 				integer, 
	@piBasePicklistID			integer, 
	@piBaseFilterID 			integer, 
	@piEmailGroupID 			integer, 
	@piParent1PicklistID		integer, 
	@piParent1FilterID 			integer, 
	@piParent2PicklistID		integer, 
	@piParent2FilterID 			integer, 
	@piChildFilterID 			varchar(100),			/* tab delimited string of child filter ids */ 
	@psCalculations 			varchar(MAX), 
	@psHiddenGroups 			varchar(MAX), 
	@psErrorMsg					varchar(MAX)	OUTPUT,
	@piErrorCode				varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedCalcs 			varchar(MAX)	OUTPUT, 
	@psHiddenCalcs 				varchar(MAX)	OUTPUT,
	@psDeletedFilters 			varchar(MAX)	OUTPUT,
	@psHiddenFilters 			varchar(MAX)	OUTPUT,
	@psDeletedOrders			varchar(MAX)	OUTPUT,
	@psJobIDsToHide				varchar(MAX)	OUTPUT,
	@psDeletedPicklists 		varchar(MAX)	OUTPUT,
	@psHiddenPicklists 			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp	integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(100),
			@sParameter				varchar(MAX),
			@sExprName  			varchar(255),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount			integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''
	SET @psDeletedOrders = ''
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''
	SET @psDeletedPicklists = ''
	SET @psHiddenPicklists = ''

	EXEC spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCustomReportsName
		WHERE ID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The report has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCustomReportsName
			WHERE ID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					2, 
					@piUtilID,
					@sAccess	OUTPUT

				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCustomReportsName
			WHERE name = @psUtilName
				AND ID <> @piUtilID
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCustomReportsName
			WHERE name = @psUtilName
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A report called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBasePicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBasePicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBaseFilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBaseFilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piParent1PicklistID > 0)
	BEGIN
		/* Check that the Parent1 table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piParent1PicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The first parent table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent1PicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piParent1PicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The first parent table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent1PicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent1FilterID > 0)
	BEGIN
		/* Check that the Parent 1 table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piParent1FilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The parent 1 filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent1FilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piParent1FilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The parent 1 table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent1FilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent2PicklistID > 0)
	BEGIN
		/* Check that the Parent1 table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piParent2PicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The second parent table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent2PicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piParent2PicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The second parent table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent2PicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent2FilterID > 0)
	BEGIN
		/* Check that the Parent 2 table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piParent2FilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The parent 2 filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent2FilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piParent2FilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The parent 2 table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent2FilterID)
			END
		END
	END

	/* Check that the selected child filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@piChildFilterID) > 0)
	BEGIN
		SET @sTemp = @piChildFilterID

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the child filters have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedFilters = @psDeletedFilters +
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
					SET @piErrorCode = 1
			 	END
				ELSE
			  	BEGIN
					SELECT @sOwner = userName,
						@sAccess = access
					FROM ASRSysExpressions
					WHERE exprID = convert(integer, @sCurrentID)

					IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @psErrorMsg = 
							@psErrorMsg + 
							CASE
								WHEN LEN(@psHiddenFilters) > 0 THEN ''
								ELSE 
									CASE 
										WHEN LEN(@psErrorMsg) > 0 THEN char(13)
										ELSE ''
									END +
									'One or more of the child filters have been made hidden by another user. They will be automatically removed from the report.'
							END
						SET @psHiddenFilters = @psHiddenFilters +
						CASE
							WHEN LEN(@psHiddenFilters) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
						SET @piErrorCode = 1
					END
			  	END
			END
		END
	END

	/* Check that the selected child filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@psDeletedOrders) > 0)
	BEGIN
		SET @sTemp = @psDeletedOrders

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysOrders
				WHERE OrderID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedOrders) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the child orders have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedOrders = @psDeletedOrders +
					CASE
						WHEN LEN(@psDeletedOrders) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
					SET @piErrorCode = 1
			 	END
			END
		END
	END
	
	/* Check that the selected runtime calculations exists. */
	IF (@piErrorCode = 0) AND (LEN(@psCalculations) > 0)
	BEGIN
		SET @sTemp = @psCalculations

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(',', @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(',', @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(',', @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			SELECT @iCount = COUNT(*)
			FROM ASRSysExpressions
			 WHERE exprID = convert(integer, @sCurrentID)

			IF @iCount = 0
			BEGIN
				SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							'One or more runtime calculations have been deleted by another user. They will be automatically removed from the report.'
					END
				SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
				SET @piErrorCode = 1
			END
			ELSE
			BEGIN
				SELECT @sOwner = userName,
					@sAccess = access
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 
						@psErrorMsg + 
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ''
							ELSE 
								CASE 
									WHEN LEN(@psErrorMsg) > 0 THEN char(13)
									ELSE ''
								END +
								'One or more runtime calculations have been made hidden by another user. They will be automatically removed from the report.'
						END
					SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
					SET @piErrorCode = 1
				END
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCustomReportsName
		WHERE ID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCustomReportsName.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsName.ID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCustomReportsName.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Custom Report ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs
	
END
GO
PRINT N'Refreshing [dbo].[udfASRWorkflowColumnsUsed]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[udfASRWorkflowColumnsUsed]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowDelegates]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowDelegates]';


GO
PRINT N'Refreshing [dbo].[spASRDelegateWorkflowEmail]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRDelegateWorkflowEmail]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetFilterPromptedValuesRecordset]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetFilterPromptedValuesRecordset]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetUtilityPromptedValues]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetUtilityPromptedValues]';


GO
PRINT N'Refreshing [dbo].[sp_ASRSendMessage]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRSendMessage]';


GO
PRINT N'Refreshing [dbo].[spASRGetCurrentUsersInGroups]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetCurrentUsersInGroups]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntCheckPolls]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntCheckPolls]';


GO
PRINT N'Refreshing [dbo].[spASRGetCurrentUsersAppName]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetCurrentUsersAppName]';


GO
PRINT N'Refreshing [dbo].[spASRGetCurrentUsersCountInApp]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetCurrentUsersCountInApp]';


GO
PRINT N'Refreshing [dbo].[spASRGetCurrentUsersCountOnServer]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetCurrentUsersCountOnServer]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowItemValues]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowItemValues]';


GO
PRINT N'Refreshing [dbo].[spASRWorkflowStepDescription]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRWorkflowStepDescription]';


GO
PRINT N'Refreshing [dbo].[spASRWorkflowAscendantRecordID]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRWorkflowAscendantRecordID]';


GO
PRINT N'Refreshing [dbo].[spASRWorkflowFileDownload]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRWorkflowFileDownload]';


GO
PRINT N'Refreshing [dbo].[spASRWorkflowStoredDataFile]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRWorkflowStoredDataFile]';


GO
PRINT N'Refreshing [dbo].[spASRGetDomains]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetDomains]';


GO
PRINT N'Refreshing [dbo].[spASRGetWindowsUsers]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWindowsUsers]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowQueryString]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowQueryString]';


GO
PRINT N'Refreshing [dbo].[sp_ASRFn_ConvertCurrency]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRFn_ConvertCurrency]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetControlDetails]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetControlDetails]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetFindOrderItems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetFindOrderItems]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetOrderDefinition]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetOrderDefinition]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetOrderItems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetOrderItems]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetQuickEntry]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetQuickEntry]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntCalcDefaults]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntCalcDefaults]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetCrossTabTablesInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetCrossTabTablesInfo]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetExprLookupValues]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetExprLookupValues]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetReportColumns]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetReportColumns]';


GO
PRINT N'Refreshing [dbo].[spASRGetAllTableAndViewColumns]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetAllTableAndViewColumns]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetLookupFindRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetLookupFindRecords]';


GO
PRINT N'Refreshing [dbo].[spASRIntInsertNewRecord]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntInsertNewRecord]';


GO
PRINT N'Refreshing [dbo].[spASRIntUpdateRecord]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntUpdateRecord]';


GO
PRINT N'Refreshing [dbo].[sp_ASRExprFilter]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRExprFilter]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetQuickEntryTables]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetQuickEntryTables]';


GO
PRINT N'Refreshing [dbo].[sp_ASRGetRelatedTables]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRGetRelatedTables]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetScreenOrder]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetScreenOrder]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetTablesInfo]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetTablesInfo]';


GO
PRINT N'Refreshing [dbo].[spASRGetParentDetails]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetParentDetails]';


GO
PRINT N'Refreshing [dbo].[spASRRecordDescription]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRRecordDescription]';


GO
PRINT N'Refreshing [dbo].[spstat_audittable]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spstat_audittable]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetStandardReportDates]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetStandardReportDates]';


GO
PRINT N'Refreshing [dbo].[spASREmailBatch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASREmailBatch]';


GO
PRINT N'Refreshing [dbo].[spASRGetCurrentUsersInWindowsGroups]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetCurrentUsersInWindowsGroups]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntBookCourse]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntBookCourse]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntCancelBooking]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntCancelBooking]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntCancelCourse]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntCancelCourse]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntCancelCoursePart2]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntCancelCoursePart2]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetAddFromWaitingListRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetAddFromWaitingListRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetBookCourseRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetBookCourseRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetBulkBookingRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetBulkBookingRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetDefaultOrderColumns]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetDefaultOrderColumns]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetLinkParentValues]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetLinkParentValues]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetLinkViews]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetLinkViews]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetOrderSQL]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetOrderSQL]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetSelectedPicklistRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetSelectedPicklistRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetTBEmployeeColumns]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetTBEmployeeColumns]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetTransferBookingRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetTransferBookingRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetTransferCourseRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetTransferCourseRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetUniqueColumns]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetUniqueColumns]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntMakeBulkBookings]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntMakeBulkBookings]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntPopulateDefsel]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntPopulateDefsel]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetLookupFindRecords2]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetLookupFindRecords2]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetLookupViews]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetLookupViews]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetScreenStrings]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetScreenStrings]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetRecordSelection]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetRecordSelection]';


GO
PRINT N'Refreshing [dbo].[spASRGetStoredDataActionDetails]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetStoredDataActionDetails]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowFormItems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowFormItems]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowGridItems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowGridItems]';


GO
PRINT N'Refreshing [dbo].[spASRWorkflowSubmitImmediatesAndGetSucceedingElements]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRWorkflowSubmitImmediatesAndGetSucceedingElements]';


GO
PRINT N'Refreshing [dbo].[spASRGetWorkflowEmailMessage]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRGetWorkflowEmailMessage]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntDefUsage]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntDefUsage]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetExpressionDefinition]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetExpressionDefinition]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetLinkFindRecords]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetLinkFindRecords]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetRecord]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetRecord]';


GO
PRINT N'Refreshing [dbo].[sp_ASRIntGetMailMergeDefinition]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_ASRIntGetMailMergeDefinition]';


GO
PRINT N'Refreshing [dbo].[spASRIntGetCalendarReportDefinition]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRIntGetCalendarReportDefinition]';


GO
PRINT N'Refreshing [dbo].[spASRSubmitWorkflowStep]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRSubmitWorkflowStep]';


GO
PRINT N'Refreshing [dbo].[spASRActionActiveWorkflowSteps]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRActionActiveWorkflowSteps]';


GO
PRINT N'Refreshing [dbo].[spASRInstantiateWorkflow]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[spASRInstantiateWorkflow]';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
							 SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

DECLARE @lockSystemObjects bit = 1,
				@effectivedate datetime = DATEADD(dd, 0, DATEDIFF(dd, 0, GETDATE()));

MERGE INTO ASRSysColours AS Target
USING (VALUES
	('1', '16777215', 'White', '8', '0'),
	('2', '16777164', 'Light Turquoise', '3', '1'),
	('3', '13434828', 'Light Green', '4', '1'),
	('4', '13434879', 'Light Yellow', '7', '1'),
	('5', '16764057', 'Pale Blue', '3', '1'),
	('6', '16751052', 'Lavender', '5', '1'),
	('7', '13408767', 'Rose', '5', '1'),
	('8', '10079487', 'Tan', '7', '1'),
	('9', '12632256', 'Grey 25%', '16', '0'),
	('10', '16776960', 'Turquoise', '3', '1'),
	('11', '16711935', 'Pink', '5', '1'),
	('12', '65535', 'Yellow', '7', '1'),
	('13', '16763904', 'Sky Blue', '3', '1'),
	('14', '13421619', 'Aqua', '3', '1'),
	('15', '52479', 'Gold', '7', '1'),
	('16', '9868950', 'Grey 40%', '15', '0'),
	('17', '16737843', 'Light Blue', '2', '1'),
	('18', '39423', 'Light Orange', '6', '1'),
	('19', '8421504', 'Grey 50%', '15', '0'),
	('20', '13395456', 'Blue Grey', '2', '1'),
	('21', '52377', 'Lime', '11', '1'),
	('22', '26367', 'Orange', '6', '1'),
	('23', '6723891', 'Sea Green', '11', '1'),
	('24', '6697881', 'Plum', '12', '1'),
	('25', '16711680', 'Blue', '2', '1'),
	('26', '8421376', 'Teal', '10', '1'),
	('27', '8388736', 'Violet', '12', '1'),
	('28', '10040115', 'Indigo', '12', '1'),
	('29', '32896', 'Dark Yellow', '14', '1'),
	('30', '65280', 'Bright Green', '4', '1'),
	('31', '255', 'Red', '6', '1'),
	('32', '13209', 'Brown', '1', '1'),
	('33', '6697728', 'Dark Teal', '1', '1'),
	('34', '8388608', 'Dark Blue', '9', '1'),
	('35', '32768', 'Green', '11', '1'),
	('36', '128', 'Dark Red', '13', '1'),
	('37', '0', 'Black', '1', '0'),
	('38', '6697779', 'Midnight Blue', '3', '0'),
	('39', '16248553', 'Dolphin Blue', '3', '0'),
	('41', '15988214', 'Pale Grey', '15', '0'))
AS Source (ColOrder, ColValue, ColDesc, WordColourIndex, CalendarLegendColour)
ON Target.ColOrder = Source.ColOrder
WHEN MATCHED THEN
	UPDATE SET ColValue = source.colValue, ColDesc = source.ColDesc, WordColourIndex = source.WordColourIndex, CalendarLegendColour = source.CalendarLegendColour
WHEN NOT MATCHED BY TARGET THEN
	INSERT (ColOrder, ColValue, ColDesc, WordColourIndex, CalendarLegendColour)
	VALUES (ColOrder, ColValue, ColDesc, WordColourIndex, CalendarLegendColour)
WHEN NOT MATCHED BY SOURCE THEN 
	DELETE;

MERGE INTO ASRSysSystemSettings AS Target 
USING (VALUES 
	('database', N'olestructure','2'), 
	('database', N'ownerid','BB716F9C-B559-4B72-99BE-C5737FC6EE8A'), 
	('database', N'version','5.2')
) 
AS Source (Section, SettingKey, SettingValue) 
ON Target.Section = Source.Section AND Target.SettingKey = Source.SettingKey
-- update matched rows 
WHEN MATCHED THEN 
UPDATE SET SettingValue = Source.SettingValue 
-- insert new rows 
WHEN NOT MATCHED BY TARGET THEN 
INSERT (Section, SettingKey, SettingValue) 
VALUES (Section, SettingKey, SettingValue) 
-- delete rows that are in the target but not the source 
WHEN NOT MATCHED BY SOURCE THEN 
DELETE;

MERGE INTO tbstat_effectivedates AS Target
USING (VALUES
	(1, @effectivedate)
)
AS Source (type, date)
ON target.type = source.type
WHEN NOT MATCHED BY TARGET THEN
	INSERT (type, date)
	VALUES (type, date)
WHEN NOT MATCHED BY SOURCE THEN 
DELETE;



/* --------------------------------------------------------------------------------------
Customisation data
-------------------------------------------------------------------------------------- */

MERGE INTO tbsys_scriptedobjects AS Target
USING (VALUES 
	('3F55669B-FE5C-4CBA-8E3B-741109FCCD56', 1, 1, 'BB716F9C-B559-4B72-99BE-C5737FC6EE8A', 1, @lockSystemObjects),
	('36FEAB19-D98C-436E-A0BA-23F8E122D709', 1, 2, 'BB716F9C-B559-4B72-99BE-C5737FC6EE8A', 1, @lockSystemObjects),
	('CFF78AA3-1986-4E47-8F25-7086AF99A6BE', 1, 3, 'BB716F9C-B559-4B72-99BE-C5737FC6EE8A', 1, @lockSystemObjects)
)
AS Source (guid, objecttype, targetid, ownerid, revision, locked)
ON Target.guid = Source.guid
WHEN MATCHED THEN 
	UPDATE SET objecttype = source.objecttype, targetid = source.targetid, ownerid = source.ownerid, revision = source.revision
WHEN NOT MATCHED BY TARGET THEN 
	INSERT (guid, objecttype, targetid, ownerid, revision, locked, effectivedate)
	VALUES (guid, objecttype, targetid, ownerid, revision, locked, @effectivedate)
WHEN NOT MATCHED BY SOURCE THEN 
DELETE;

MERGE INTO tbsys_tables AS Target 
USING (VALUES 
	('1', '1', 'Personnel_Records'), 
	('2', '2', 'Absence'), 
	('3', '2', 'Salary')
) 
AS Source (tableID, tableType, tableName) 
ON Target.tableID = Source.tableID AND Target.tablename = Source.tablename
WHEN MATCHED THEN 
	UPDATE SET tabletype = Source.tabletype
WHEN NOT MATCHED BY TARGET THEN 
	INSERT (tableID, tableType, tableName, DefaultOrderID, RecordDescExprID, DefaultEmailID, ManualSummaryColumnBreaks, AuditInsert, AuditDelete, IsRemoteView) 
	VALUES (tableID, tableType, tableName, 0, 0, 0, 0, 0, 0, 0) 
WHEN NOT MATCHED BY SOURCE THEN 
	DELETE;
GO

GO
PRINT N'Update complete.';


GO

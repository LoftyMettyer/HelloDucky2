
/* ----------------------------------------------------------------------- */
/* Variable declarations                                                   */
/*                                                                         */
/* NB. Variable with the naming convention @sSPCode_<n> are declared below */
/* ----------------------------------------------------------------------- */
DECLARE @iCount integer,
    @sDBVersion varchar(10),
    @sTemp varchar(10),
    @iTemp integer,
    @iTemp2 integer,
    @iMajor integer,
    @iMinor integer,
    @iRevision integer,
    @NVarCommand nvarchar(4000),
    @JobID BINARY(16),
    @ReturnCode integer,
    @sJobName nvarchar(4000),
    @sDBName nvarchar(4000),
    @sErrMsg nvarchar(4000),
    @sVersion varchar(100),
    @sGroup sysname,
    @sObject sysname,
    @sObjectType char(2),
    @sSQL varchar(8000),
    @iCurrentUserCount integer,
    @iHRProLockCount integer,
    @iSQLVersion integer;

/* -------------------------- */
/* Set the new version number */
/* -------------------------- */
SET @sVersion = '8.1.13'
SET NOCOUNT ON;

/* ------------------------------------ */
/* Get the name of the current database */
/* ------------------------------------ */
SELECT @sDBName = master..sysdatabases.name
FROM master..sysdatabases
INNER JOIN master..sysprocesses ON master..sysdatabases.dbid = master..sysprocesses.dbid
WHERE master..sysprocesses.spid = @@spid

/* -------------------------------------- */
/* Check SQL Server version compatibility */
/* -------------------------------------- */
SELECT @iSQLVersion = convert(int,convert(float,substring(@@version,charindex('-',@@version)+2,2)))
IF (@iSQLVersion < 10)
BEGIN
    Print '+--------------------------------------------------------------------------+'
    Print '|                                                                          |'
    Print '|                            SCRIPT FAILURE                                |'
    Print '|                                                                          |'
    Print '| This version of OpenHR is only compatible with SQL Server 2008 or later. |'
    Print '| Please upgrade SQL Server before upgrading to this version of OpenHR.    |'
    Print '|                                                                          |'
    Print '+--------------------------------------------------------------------------+'
		RETURN
END

IF @sDBName = 'master'
BEGIN
    Print '+-----------------------------------------------------------------------+'
    Print '|                                                                       |'
    Print '|                            SCRIPT FAILURE                             |'
    Print '|                                                                       |'
    Print '|        This script should not be run on the ''master'' database.      |'
    Print '|                                                                       |'
    Print '+-----------------------------------------------------------------------+'
    RETURN
END

IF IS_SRVROLEMEMBER('systemadmin') = 0
BEGIN
    Print '+-----------------------------------------------------------------------+'
    Print '|                                                                       |'
    Print '|                            SCRIPT FAILURE                             |'
    Print '|                                                                       |'
    Print '| This script can only be run by a member of the ''systemadmin'' role.  |'
    Print '|                                                                       |'
    Print '+-----------------------------------------------------------------------+'
    RETURN
END


GO

-- V8.0 Update script


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRDatabaseStatus]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRDatabaseStatus]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetSubExpressionsAndComponents]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetSubExpressionsAndComponents]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetFullAccessChildView]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFullAccessChildView]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSysSecMgr]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntSysSecMgr]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetRootExpressionIDs]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetRootExpressionIDs]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntCopyRecordPostSave]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntCopyRecordPostSave]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetLoginDetails]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetLoginDetails]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntCheckLogin]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntCheckLogin]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetActualUserDetails]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetActualUserDetails]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRWorkflowOutOfOfficeConfigured]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRWorkflowOutOfOfficeConfigured]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetActualUserDetails_DmiNet]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetActualUserDetails_DmiNet]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntCheckLogin_DmiNet]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntCheckLogin_DmiNet]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCustomReport]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCustomReport];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetSummaryFields]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRIntGetSummaryFields]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetColumnPermissions]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetColumnPermissions]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntCreateCacheTables]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntCreateCacheTables]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSetupTablesCollection]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntSetupTablesCollection]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetSessionSettings]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetSessionSettings]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRGetMetadata]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRGetMetadata]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetExpressionAndComponents]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetExpressionAndComponents]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRUniqueObjectName]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRUniqueObjectName]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUniqueExpressionID]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetUniqueExpressionID]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetSSIWelcomeDetails]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetSSIWelcomeDetails];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetTrainingBookingParameters]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTrainingBookingParameters]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetUserGroup]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetUserGroup]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetDocumentManagementTypes]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetDocumentManagementTypes]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetChartData]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetChartData]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetBlankIfZeroFindColumns]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetBlankIfZeroFindColumns]	
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntUpdateRecord]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntUpdateRecord]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntValidateTrainingBooking]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntValidateTrainingBooking]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetLookupFindRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetLookupFindRecords]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetFilterColumns]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFilterColumns]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetCalendarReportColumns]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetCalendarReportColumns]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetLicenceInfo]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetLicenceInfo]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetColumnsFromTablesAndViews]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetColumnsFromTablesAndViews]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntCurrentAccessForRole]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntCurrentAccessForRole]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntActivateModule]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntActivateModule]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntTestFilter]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntTestFilter]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetSummaryFieldsRun]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetSummaryFieldsRun]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetLookupControlValuesString]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetLookupControlValuesString]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetExprAccess]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetExprAccess]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetSystemSetting]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetSystemSetting]
GO



CREATE PROCEDURE dbo.spASRDatabaseStatus (
	@message	nvarchar(MAX) OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @SystemStatus	integer,
			@lockUser		varchar(255),
			@lockhost		varchar(255)

	SET @message = '';

	SELECT TOP 1 @SystemStatus= ISNULL(Priority,0), @lockUser = [username], @lockhost = [hostname]
		FROM ASRSysLock
		ORDER BY [Priority];

	IF @SystemStatus = 1
	BEGIN
		SET @message = 'A database update has been started by user ' + @lockUser + ' on machine ' + @lockhost + CHAR(13) + CHAR(13) 
			+ 'Data may be lost until you log off and the update has completed.' + CHAR(13) + CHAR(13) 
			+ 'Please contact your HR system administrator.'
	END
	ELSE IF @SystemStatus = 2
	BEGIN
		SET @message = 'The user ' + @lockUser + ' has locked the database on machine ' + @lockhost + CHAR(13) + CHAR(13) 
			+ 'You are unable to make any changes at this time.' + CHAR(13) + CHAR(13) 
			+ 'Please contact your HR system administrator.'
	
	END


END
GO



CREATE PROCEDURE [dbo].[spASRIntGetActualUserDetails]
(
		@psUserName sysname OUTPUT,
		@psUserGroup sysname OUTPUT,
		@piUserGroupID integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;
	EXEC dbo.spASRGetActualUserDetails @psUserName OUTPUT, @psUserGroup OUTPUT, @piUserGroupID  OUTPUT, '';

END

GO

CREATE PROCEDURE [dbo].[spASRIntSysSecMgr]
(
		@pfSysSecMgr bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sRoleName			sysname,
		@sActualUserName	sysname,
		@iActualUserGroupID	integer;
		
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	SELECT @pfSysSecMgr = 
		CASE
			WHEN (SELECT count(*)
				FROM ASRSysGroupPermissions
				INNER JOIN ASRSysPermissionItems 
					ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories 
					ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE ASRSysGroupPermissions.groupname = @sRoleName
					AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
			ELSE 0
		END;
END
GO



CREATE PROCEDURE [dbo].[sp_ASRUniqueObjectName](
		  @psUniqueObjectName sysname OUTPUT
		, @Prefix sysname
		, @Type int)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @NewObj 		as sysname
		, @Count 			as integer
		, @sUserName		as sysname
		, @sCommandString	nvarchar(MAX)	
 		, @sParamDefinition	nvarchar(500);

	SET @sUserName = SYSTEM_USER;
	SET @Count = 1;
	SET @NewObj = @Prefix + CONVERT(varchar(100),@Count);

	WHILE (EXISTS (SELECT * FROM sysobjects WHERE id = object_id(@NewObj) AND sysstat & 0xf = @Type))
		OR (EXISTS (SELECT * FROM ASRSysSQLObjects WHERE Name = @NewObj AND Type = @Type))
		BEGIN
			SET @Count = @Count + 1;
			SET @NewObj = @Prefix + CONVERT(varchar(10),@Count);
		END

	INSERT INTO [dbo].[ASRSysSQLObjects] ([Name], [Type], [DateCreated], [Owner])
		VALUES (@NewObj, @Type, GETDATE(), @sUserName);

	SET @sCommandString = 'SELECT @psUniqueObjectName = ''' + @NewObj + '''';
	SET @sParamDefinition = N'@psUniqueObjectName sysname output';
	EXECUTE sp_executesql @sCommandString, @sParamDefinition, @psUniqueObjectName output;

END


GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASR_AbsenceBreakdown_Run]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASR_AbsenceBreakdown_Run];
GO

CREATE PROCEDURE [dbo].[sp_ASR_AbsenceBreakdown_Run]
(
	@pdReportStart      datetime,
	@pdReportEnd		datetime,
	@pcReportTableName  char(30)
) 
AS 
BEGIN

	SET NOCOUNT ON;

	DECLARE @pdStartDate as datetime
		, @pdEndDate as datetime
		, @pcStartSession as char(2)
		, @pcEndSession as char(2)
		, @pcType as char(50)
		, @pcRecordDescription as char(100);

	DECLARE @pfDuration as float
		, @pdblSun as float
		, @pdblMon as float
		, @pdblTue as float
		, @pdblWed as float
		, @pdblThu as float
		, @pdblFri as float
		, @pdblSat as float

	DECLARE @sSQL as nvarchar(MAX)
		, @piParentID as integer
		, @piID as integer
		, @pbProcessed as bit
		, @pdTempStartDate as datetime
		, @pdTempEndDate as datetime
		, @pcTempStartSession as char(2)
		, @pcTempEndSession as char(2)
		, @sTempEndDate as varchar(50)

	DECLARE @pfCount as float
		, @psVer as char(80)

	/* Alter the structure of the temporary table so it can hold the text for the days */
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ALTER COLUMN Hor NVARCHAR(10)'
	EXECUTE sp_executeSQL @sSQL
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ADD Processed bit, DisplayOrder integer, IsSummary bit'
	EXECUTE sp_executeSQL @sSQL
	Set @sSQL = 'ALTER TABLE ' + @pcReportTableName + ' ALTER COLUMN Value decimal(10,5)'
	EXECUTE sp_executeSQL @sSQL

	/* Load the values from the temporary cursor */
	Set @sSQL = 'DECLARE AbsenceBreakdownCursor CURSOR STATIC FOR SELECT ID, Personnel_ID, Start_Date, End_Date, Start_Session, End_Session, Ver, RecDesc, Processed FROM ' + @pcReportTableName
	execute(@sSQL)
	open AbsenceBreakdownCursor

	/* Loop through the records in the absence breakdown report table */
	Fetch Next From AbsenceBreakdownCursor Into @piID, @piParentID, @pdStartDate, @pdEndDate, @pcStartSession, @pcEndSession, @pcType, @pcRecordDescription, @pbProcessed
	while @@FETCH_STATUS = 0
		begin

		Set @pdblSun = 0
		Set @pdblMon = 0
		Set @pdblTue = 0
		Set @pdblWed = 0
		Set @pdblThu = 0
		Set @pdblFri = 0
		Set @pdblSat = 0

		/* The absence should only calculate for absence within the reporting period */
		set @pdTempStartDate = @pdStartDate
		set @pcTempStartSession = @pcStartSession
		set @pdTempEndDate = @pdEndDate
		set @pcTempEndSession = @pcEndSession

		--/* If blank leaving date set it to todays date */
		if @pdTempEndDate is Null set @pdTempEndDate = getdate()

		if @pdStartDate <  @pdReportStart
			begin
			set @pdTempStartDate = @pdReportStart
			set @pcTempStartSession = 'AM'
			end
		if @pdTempEndDate >  @pdReportEnd
			begin
			set @pdTempEndDate = @pdReportEnd
			set @pcTempEndSession = 'PM'
			end

		set @sTempEndDate = case when @pdEndDate is null then 'null' else '''' + convert(varchar(40),@pdEndDate) + '''' end

		/* Calculate the days this absence takes up */
		execute sp_ASR_AbsenceBreakdown_Calculate @pfDuration OUTPUT, @pdblMon OUTPUT, @pdblTue OUTPUT, @pdblWed OUTPUT, @pdblThu OUTPUT, @pdblFri OUTPUT, @pdblSat OUTPUT, @pdblSun OUTPUT, @pdTempStartDate, @pcTempStartSession, @pdTempEndDate, @pcTempEndSession, @piParentID

		/* Strip out dodgy characters */
		set @pcRecordDescription = replace(@pcRecordDescription,'''','''''')
		set @pcType = replace(@pcType,'''','')

		/* Add Mondays records */
		if @pdblMon > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 0) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblMon) + ',''' + convert(varchar(20),@pdStartDate) + ''',1,1,' + @sTempEndDate + ',1)'
			execute(@sSQL)
			end

		/* Add Tuesday records */
		if @pdblTue > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 1) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblTue) +  ',''' + convert(varchar(20),@pdStartDate) + ''',2,1,' + @sTempEndDate +',2)'
			execute(@sSQL)
			end

		/* Add Wednesdays records */
		if @pdblWed > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 2) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblWed) +  ',''' + convert(varchar(20),@pdStartDate) +  ''',3,1,' + @sTempEndDate +',3)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Thursdays were found */
		if @pdblThu > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 3) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblThu) +  ',''' + convert(varchar(20),@pdStartDate) + ''',4,1,' + @sTempEndDate +',4)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Fridays were found */
		if @pdblFri > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 4) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblFri) + ',''' + convert(varchar(20),@pdStartDate) + ''',5,1,' + @sTempEndDate +',5)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Saturdays were found */
		if @pdblSat > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 5) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblSat) + ','''+ convert(varchar(20),@pdStartDate) + ''',6,1,' + @sTempEndDate +',6)'
			execute(@sSQL)
			end

		/* Add new records depending on how many Sundays were found */
		if @pdblSun > 0
			begin
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (0, ' + Convert(varchar(10),@piParentID) + ',''' + DATENAME(weekday, 5) + ''',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pdblSun) + ',''' + convert(varchar(20),@pdStartDate) + ''',7,1,' + @sTempEndDate +',0)'
			execute(@sSQL)
			end

		/* Calculate total duraton of absence */
		set @pfDuration = @pdblMon + @pdblTue + @pdblWed + @pdblThu + @pdblFri + @pdblSat + @pdblSun

		if @pfDuration > 0
			begin
			/* Write records for average, totals and count */
			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (1, ' + Convert(varchar(10),@piParentID) + ',''Total'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pfDuration) + ',''' + convert(varchar(20),@pdStartDate) + ''',9,1,' + @sTempEndDate +',8)'
			execute(@sSQL)

			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (1, ' + Convert(varchar(10),@piParentID) + ',''Count'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),1) + ',''' + convert(varchar(20),@pdStartDate) + ''',10,1,' + @sTempEndDate +',10)'
			execute(@sSQL)

			set @sSQL = 'INSERT INTO ' + @pcReportTableName + ' (IsSummary, Personnel_ID, Hor, Ver, RecDesc, Value, Start_Date,Day_Number, Processed, End_Date, DisplayOrder) VALUES (1, ' + Convert(varchar(10),@piParentID) + ',''Average'',''' + @pcType + ''', ''' + @pcRecordDescription + ''', ' + Convert(varchar(10),@pfDuration) + ',''' + convert(varchar(20),@pdStartDate) + ''',9,1,' + @sTempEndDate +',9)'
			execute(@sSQL)
			end

		/* Process next record */
		Fetch Next From AbsenceBreakdownCursor Into @piID, @piParentID, @pdStartDate, @pdEndDate, @pcStartSession, @pcEndSession, @pcType, @pcRecordDescription, @pbProcessed

		end

	/* Delete this record from our collection as it's now been processed */
	set @sSQL = 'DELETE FROM ' + @pcReportTableName + ' Where Processed IS NULL'
	execute(@sSQL)

	Set @sSQL = 'DECLARE CalculateAverage CURSOR STATIC FOR SELECT Ver,(SUM(Value) / COUNT(Value)) / COUNT(Value) FROM ' + @pcReportTableName + ' WHERE hor = ''Average'' GROUP BY Ver'
	execute(@sSQL)
	open CalculateAverage

	Fetch Next From CalculateAverage Into @psVer, @pfCount
	while @@FETCH_STATUS = 0
		begin
  			Set @sSQL = 'UPDATE ' + @pcReportTableName + ' SET Value = ' + Convert(varchar(10),@pfCount) + ' WHERE Ver =  ''' + @psVer + ''' AND Hor = ''Average'''
		execute(@sSQL)
			Fetch Next From CalculateAverage Into @psVer, @pfCount
		end

	/* Tidy up */
	close AbsenceBreakdownCursor
	close CalculateAverage
	deallocate AbsenceBreakdownCursor
	deallocate CalculateAverage

END
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetUserGroup]
	( 
	@psItemKey				varchar(50),
	@psUserGroup			varchar(250)	OUTPUT
	)
AS
BEGIN
	set @psUserGroup = '';
	/* SET NOCOUNT ON added to prevent extra result sets from interfering with SELECT statements. */
	SET NOCOUNT ON;
	SET @psUserGroup = (SELECT CASE 
		WHEN (usg.uid IS null) THEN null
		ELSE usg.name
	END as groupname
	FROM sysusers usu 
	LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = SYSTEM_USER
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END IN (
				SELECT [groupName]
				FROM [dbo].[ASRSysGroupPermissions]
				WHERE itemID IN (
					SELECT [itemID]
					FROM [dbo].[ASRSysPermissionItems]
					WHERE categoryID = 1
					AND itemKey LIKE '%' + @psItemKey + '%'
				)  
				AND [permitted] = 1))
END
GO




---------------------------------------------------------------
-- Script 8.0.9
---------------------------------------------------------------


/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateTransfers]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidateTransfers]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist2]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidatePicklist2]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidatePicklist]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateBulkBookings]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidateBulkBookings]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntTransferCourse]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntTransferCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntSaveSetting]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntSaveSetting]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntPopulateDefsel]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntPopulateDefsel]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntNewUser]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntNewUser]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenOrder]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenOrder]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlValuesString]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControlValuesString]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControls]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControls]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordEditInfo]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetRecordEditInfo]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordDescription]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetRecordDescription]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetOrders]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetOrders]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetModuleParameter]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetModuleParameter]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLookupValues]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLookupValues]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkViews]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLinkViews]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkParentValues]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLinkParentValues]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowInfo]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetFindWindowInfo]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFilterPromptedValues]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValues]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprTables]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprTables]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprOperators]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprOperators]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprLookupValues]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprLookupValues]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFunctionParameters]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprFunctionParameters]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExpressionDefinition]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprColumns]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprColumns]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromTBID]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromTBID]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetColumns]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetColumns]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAvailableLogins]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetAvailableLogins]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAbsenceTypes]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetAbsenceTypes]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntExpressionHasHiddenComponents]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntExpressionHasHiddenComponents]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntDeleteUtility]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntDeleteUtility]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCoursePart2]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelCoursePart2]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCourse]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelBooking]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelBooking]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCalcDefaults]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCalcDefaults]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntBookCourse]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntBookCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddFromWaitingList]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntAddFromWaitingList]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddEventLogHeader]    Script Date: 23/07/2013 11:18:30 ******/
DROP PROCEDURE [dbo].[sp_ASRIntAddEventLogHeader]
GO



SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetSystemSetting] (
	@psNewSection		varchar(255),			/* Section value in the new ASRSysSystemSettings table. */
	@psNewKey			varchar(255),			/* Key value in the new ASRSysSystemSettings table. */
	@psOldColumnName	varchar(255),			/* Column name in the old ASRSysConfig table. */
	@psResult			varchar(MAX)	OUTPUT,
	@pfNewSettingFound	bit				OUTPUT,
	@pfOldSettingFound	bit				OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sValue					varchar(MAX);

	SET @pfNewSettingFound = 0;
	SET @pfOldSettingFound = 0;
	IF (@psOldColumnName IS NULL) SET @psOldColumnName = '';

	/* Clean the input string parameters. */
	IF len(@psNewSection) > 0 SET @psNewSection = replace(@psNewSection, '''', '''''');
	IF len(@psNewKey) > 0 SET @psNewKey = replace(@psNewKey, '''', '''''');

	/* Check if the 'ASRSysSystemSettings' table exists. */
	SELECT @iCount = count(Name)
	FROM sysobjects 
	WHERE name = 'ASRSysSystemSettings';
		
	IF @iCount = 1
	BEGIN
		/* The ASRSysSystemSettings table exists. See if the required records exists in it. */
		SET @sTempExecString = 'SELECT @sValue = settingValue' +
			' FROM ASRSysSystemSettings' +
			' WHERE section = ''' + @psNewSection + '''' +
			' AND settingKey = ''' + @psNewKey +'''';
		SET @sTempParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sValue OUTPUT;
	
		IF NOT @sValue IS NULL
		BEGIN
			SET @psResult = @sValue;
			SET @pfNewSettingFound = 1;
		END
	END

	IF @pfNewSettingFound = 0
	BEGIN
		SELECT @iCount = count(syscolumns.name)
		FROM syscolumns 
		INNER JOIN sysobjects ON syscolumns.id = sysobjects.id
		WHERE syscolumns.name = @psOldColumnName
			AND sysobjects.name = 'ASRSysConfig';

		IF @iCount = 1
		BEGIN
			/* Clean the input string parameter. */
			IF len(@psOldColumnName) > 0 SET @psOldColumnName = replace(@psOldColumnName, '''', '''''');

			SET @sTempExecString = 'SELECT @sValue = convert(varchar(8000), ' + @psOldColumnName + ') FROM ASRSysConfig';
			SET @sTempParamDefinition = N'@sValue varchar(100) OUTPUT';
			EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sValue OUTPUT;

			IF NOT @sValue IS NULL
			BEGIN
				SET @psResult = @sValue;
				SET @pfOldSettingFound = 1;
			END
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntActivateModule]    Script Date: 13/09/2013 08:57:58 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntActivateModule](
	@sModule	varchar(50),
	@bLicensed	bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iCustomerNo		integer,
			@sModuleCode		varchar(100),
			@sValue				varchar(MAX),
			@fNewModuleCode		bit,
			@fNewSettingFound	bit,
			@fOldSettingFound	bit,
			@iModule			int,
			@iSuccessFlag		smallint,
			@objectToken 		integer,
			@hResult 			integer,
			@iValue				integer,
			@sErrorMessage		varchar(MAX),
			@sSQLVersion		int;

	IF @sModule = 'PERSONNEL' SET @iModule = 1;
	IF @sModule = 'RECRUITMENT' SET @iModule = 2;
	IF @sModule = 'ABSENCE' SET @iModule = 4;
	IF @sModule = 'TRAINING' SET @iModule = 8;
	IF @sModule = 'INTRANET' SET @iModule = 16;
	IF @sModule = 'AFD' SET @iModule = 32;
	IF @sModule = 'FULLSYSTEMMANGER' SET @iModule = 64;
	IF @sModule = 'CMG' SET @iModule = 128;
	IF @sModule = 'QADDRESS' SET @iModule = 256;
	IF @sModule = 'ACCORD' SET @iModule = 512;
	IF @sModule = 'WORKFLOW' SET @iModule = 1024;
	IF @sModule = 'VERSIONONE' SET @iModule = 2048;
	IF @sModule = 'MOBILE' SET @iModule = 4096;

	/* Get the module license code. */
	SET @sModuleCode = '';
	SET @fNewModuleCode = 0;
	EXEC [dbo].[sp_ASRIntGetSystemSetting] 'Licence', 'Key', 'moduleCode', @sValue OUTPUT, @fNewSettingFound OUTPUT, @fOldSettingFound OUTPUT;
	IF (@fNewSettingFound = 1) OR (@fOldSettingFound = 1) 
	BEGIN
		SET @sModuleCode = @sValue;
		SET @fNewModuleCode = @fNewSettingFound;
	END

	SELECT @bLicensed = dbo.udfASRNetIsModuleLicensed(@sModuleCode,@iModule);

END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddEventLogHeader]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntAddEventLogHeader]
(
    @piNewRecordID	integer OUTPUT,   /* Output variable to hold the new record ID. */
    @piType			integer,
    @psName			varchar(150), 
    @psUserName		varchar(50),
    @psBatchName	varchar(50),
    @piBatchRunID	integer,
    @piBatchJobID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLog] (
		[DateTime],	[Type],	[Name], [Status], [Username],
		[Mode], [BatchName], [SuccessCount], [FailCount], [BatchRunID], [BatchJobID])
	VALUES (GETDATE(), @piType, @psName, 0, @psUserName,
		CASE
			WHEN len(@psBatchName) = 0 THEN 0
			ELSE 1
		END,    
		@psBatchName, NULL,NULL,
		CASE
			WHEN @piBatchRunID > 0 THEN @piBatchRunID
			ELSE null
		END,
		CASE 
			WHEN @piBatchJobID > 0 THEN @piBatchJobID
			ELSE null
		END);
                  
    -- Get the ID of the inserted record.
    SELECT @piNewRecordID = MAX(id) FROM [dbo].[ASRSysEventLog];

END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddFromWaitingList]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntAddFromWaitingList] (
	@piEmpRecordID		integer,
	@piCourseRecordID	integer,
	@psStatus			varchar(MAX)
)
AS
BEGIN
	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@fSysSecMgr				bit,
		@sColumnList			varchar(MAX),
		@sValueList				varchar(MAX),
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sExecString			nvarchar(MAX),
		@iEmpTableID			integer,
		@iCourseTableID			integer,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@sTempTBColumnName		sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(MAX),
		@sTempWLColumnName		sysname,
		@sAddedColumns			varchar(MAX),
		@iSourceColumnID		integer,
		@iDestinationColumnID	integer,
		@iIndex					integer,
		@fGranted				bit,
		@iWLCourseTitleColumnID	integer,
		@sWLCourseTitleColumnName	sysname,
		@sCourseTitle			varchar(MAX),
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@sCourseSource			sysname,
		@sActualUserName		sysname;

	SET NOCOUNT ON;

	/* Clean the input string parameters. */
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable';
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable';
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(100), @piCourseRecordID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @sCourseTitle = '';
	END

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus';
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;

	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Initialise the insert strings with the basic values.*/
	SET @sColumnList = 'id_' + convert(varchar(128), @iEmpTableID) + ',' +
		'id_' + convert(varchar(128), @iCourseTableID) + ',' +
		@sTBStatusColumnName;
	SET @sValueList = convert(varchar(128), @piEmpRecordID) + ',' +
		convert(varchar(128), @piCourseRecordID) + ',' +
		'''' + @psStatus + '''';
	SET @sAddedColumns = ',' + convert(varchar(MAX), @iTBStatusColumnID) + ',';

	/* Get the TB and WL column permissions. */
	IF @fSysSecMgr = 0
	BEGIN
		CREATE TABLE #columnPermissions
		(
			columnID	int,
			action		int,		
			granted		bit		
		);

		INSERT INTO #columnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END AS [protectType]
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND (ASRSysColumns.tableID = @iTBTableID
				OR ASRSysColumns.tableID = @iWLTableID))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND (sysobjects.name = @sTBRealSource
				OR sysobjects.name = @sWLRealSource)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	END

	/* Get the Waiting List - Training Booking related columns. */
	DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sourceColumnID, destColumnID
	FROM ASRSysModuleRelatedColumns
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TBWLRelatedColumns';
	OPEN relatedColumns_cursor;
	FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iIndex = charindex(',' + convert(varchar(MAX), @iDestinationColumnID) + ',', @sAddedColumns);

		IF @iIndex = 0
		BEGIN
			/* Check that the user has read permission on the WL column, and update permission on the TB column. */
			SET @fGranted = 1;

			IF @fSysSecMgr = 0
			BEGIN
				SELECT @fGranted = granted
				FROM #columnPermissions
				WHERE columnID = @iDestinationColumnID
					AND action = 193;

				IF @fGranted IS null SET @fGranted = 0;

				IF @fGranted = 1
				BEGIN
					SELECT @fGranted = granted
					FROM #columnPermissions
					WHERE columnID = @iSourceColumnID
						AND action = 197;

					IF @fGranted IS null SET @fGranted = 0;
				END
			END

			IF @fGranted = 1
			BEGIN
				SELECT @sTempTBColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @iSourceColumnID;

				SELECT @sTempWLColumnName = columnName
				FROM ASRSysColumns 
				WHERE columnID = @iDestinationColumnID;

				SET @sColumnList = @sColumnList + ',' + @sTempTBColumnName;
				SET @sValueList = @sValueList + ',' + @sTempWLColumnName;
			END
			
			SET @sAddedColumns = @sAddedColumns + convert(varchar(MAX), @iSourceColumnID) + ',';
		END

		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	END
	CLOSE relatedColumns_cursor;
	DEALLOCATE relatedColumns_cursor;

	IF @fSysSecMgr = 0
	BEGIN
		/* Drop temporary tables no longer required. */
		DROP TABLE #columnPermissions;
	END

	/* Create the booking record. */
	SET @sExecString = 'INSERT INTO ' + @sTBRealSource + 
		'(' + @sColumnList + ')' +
		' SELECT TOP 1 ' + @sValueList + 
		' FROM ' + @sWLRealSource + 
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;

	/* Delete the old Waiting List record(s). */
	SET @sExecString = 'DELETE FROM ' + @sWLRealSource +
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntBookCourse]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntBookCourse] (
	@piWLRecordID	integer,
	@piCourseRecordID	integer,
	@psStatus	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@fSysSecMgr				bit,
		@sColumnList			varchar(MAX),
		@sValueList				varchar(MAX),
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sExecString			nvarchar(MAX),
		@iEmpTableID			integer,
		@iEmpRecordID			integer,
		@iCourseTableID			integer,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(255),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@sTempTBColumnName		sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(255),
		@sTempWLColumnName		sysname,
		@sAddedColumns			varchar(MAX),
		@iSourceColumnID		integer,
		@iDestinationColumnID	integer,
		@iIndex					integer,
		@fGranted				bit,
		@sActualUserName		sysname;

	/* Clean the input string parameters. */
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Get the course title from the given WL record. */
	/* NB. To reach this point we have already checked that the user has 'delete' permission on the Waiting List table,
	'insert' permission on the Training Booking table, 'update' permission on the Training Booking Status column. 
	So, no need to do them again.*/

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iTBTableID;
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @iTBStatusColumnID;

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable'
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iWLTableID;
	
	SELECT @iChildViewID = childViewID
	FROM [dbo].[ASRSysChildViews2]
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM [dbo].[ASRSysChildViews2]
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(255), @iEmpTableID) +
		' FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iEmpRecordID OUTPUT;

	IF @iEmpRecordID IS null SET @iEmpRecordID = 0;

	/* Initialise the insert strings with the basic values.*/
	SET @sColumnList = 'id_' + convert(varchar(255), @iEmpTableID) + ',' +
		'id_' + convert(varchar(255), @iCourseTableID) + ',' +
		@sTBStatusColumnName;
	SET @sValueList = convert(varchar(255), @iEmpRecordID) + ',' +
		convert(varchar(255), @piCourseRecordID) + ',' +
		'''' + @psStatus + '''';
	SET @sAddedColumns = ',' + convert(varchar(MAX), @iTBStatusColumnID) + ',';

	/* Get the TB and WL column permissions. */
	IF @fSysSecMgr = 0
	BEGIN
		DECLARE @columnPermissions TABLE(
			columnID	int,
			[action]		int,		
			granted		bit)

		INSERT INTO @columnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END AS [protectType]
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND (ASRSysColumns.tableID = @iTBTableID
				OR ASRSysColumns.tableID = @iWLTableID))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND (sysobjects.name = @sTBRealSource
				OR sysobjects.name = @sWLRealSource)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
	END

	/* Get the Waiting List - Training Booking related columns. */
	DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sourceColumnID, destColumnID
	FROM ASRSysModuleRelatedColumns
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TBWLRelatedColumns';
		
	OPEN relatedColumns_cursor;
	FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iIndex = charindex(',' + convert(varchar(MAX), @iDestinationColumnID) + ',', @sAddedColumns);

		IF @iIndex = 0
		BEGIN
			/* Check that the user has read permission on the WL column, and update permission on the TB column. */
			SET @fGranted = 1;

			IF @fSysSecMgr = 0
			BEGIN
				SELECT @fGranted = granted
				FROM @columnPermissions
				WHERE columnID = @iDestinationColumnID
					AND action = 193;

				IF @fGranted IS null SET @fGranted = 0;

				IF @fGranted = 1
				BEGIN
					SELECT @fGranted = granted
					FROM @columnPermissions
					WHERE columnID = @iSourceColumnID
						AND action = 197;

					IF @fGranted IS null SET @fGranted = 0;
				END
			END

			IF @fGranted = 1
			BEGIN
				SELECT @sTempTBColumnName = columnName
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iSourceColumnID;

				SELECT @sTempWLColumnName = columnName
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iDestinationColumnID;

				SET @sColumnList = @sColumnList + ',' + @sTempTBColumnName;
				SET @sValueList = @sValueList + ',' + @sTempWLColumnName;
			END
			
			SET @sAddedColumns = @sAddedColumns + convert(varchar(MAX), @iSourceColumnID) + ',';
		END

		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	END
	
	CLOSE relatedColumns_cursor;
	DEALLOCATE relatedColumns_cursor;

	SET @sExecString = 'INSERT INTO ' + @sTBRealSource + 
		'(' + @sColumnList + ')' +
		' SELECT ' + @sValueList + 
		' FROM ' + @sWLRealSource + 
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	EXEC sp_executesql @sExecString;

	SET @sExecString = 'DELETE FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	EXEC sp_executesql @sExecString;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCalcDefaults]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntCalcDefaults] (
	@piRecordCount			integer OUTPUT,
	@psFromDef 				varchar(MAX),
	@psFilterDef 			varchar(MAX),
	@piTableID				integer,
	@piParentTableID		integer,
	@piParentRecordID		integer,
	@psDefaultCalcColumns	varchar(MAX),
	@psDecimalSeparator		varchar(255),
	@psLocaleDateFormat		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iRecordCount 	integer,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sColumns			varchar(MAX),
		@iID				integer,
		@iDataType			integer,
		@iSize				integer,
		@iDecimals			integer,
		@iDfltExprID		integer,
		@fOneColumnDone		bit,
		@iCount				integer,
		@fOK				bit,
		@iTableID			integer,
		@sCharResult 		varchar(MAX),
		@dblNumericResult 	float,
		@iIntegerResult 	integer,
		@dtDateResult 		datetime,
		@fLogicResult 		bit,
		@sTempTableName		sysname,
		@sTemp 				sysname,
		@iLoop 				integer,
		@sTempDate			varchar(10),
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sSubFilterSQL		nvarchar(MAX),
		@sColumnName 		sysname,
		@sFromSQL			nvarchar(MAX),
		@sRealSource		sysname,
		@sRealSourceAlias	varchar(MAX),
		@sTableViewName		sysname,
		@iJoinTableID		integer,
		@sColumnsDone		varchar(MAX);
		
	SET @fOneColumnDone = 0;
	SET @fOK = 1;
	SET @sFilterSQL = '';

	SET @iIndex1 = charindex(char(9), @psFromDef);
	SET @sRealSource = replace(LEFT(@psFromDef, @iIndex1-1), '''', '''''');
	SET @sRealSourceAlias = 'RS';
	SET @sFromSQL = @sRealSource + ' ' + @sRealSourceAlias + ' ';
	SET @psFromDef = SUBSTRING(@psFromDef, @iIndex1+1, LEN(@psFromDef) - @iIndex1);

	WHILE charindex(char(9), @psFromDef) > 0
	BEGIN
		SET @iIndex1 = charindex(char(9), @psFromDef);
		SET @iIndex2 = charindex(char(9), @psFromDef, @iIndex1+1);
				
		SET @sTableViewName = replace(LEFT(@psFromDef, @iIndex1-1), '''', '''''');
		SET @iJoinTableID = convert(integer, SUBSTRING(@psFromDef, @iIndex1+1, @iIndex2-@iIndex1-1));
				
		SET @psFromDef = SUBSTRING(@psFromDef, @iIndex2+1, LEN(@psFromDef) - @iIndex2);

		SET @sFromSQL = @sFromSQL + 
			' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSourceAlias + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
	END

	IF len(@psFilterDef)> 0 
	BEGIN
		WHILE charindex('	', @psFilterDef) > 0
		BEGIN
			SET @sSubFilterSQL = '';

			SET @iIndex1 = charindex('	', @psFilterDef);
			SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1);
			SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1);
				
			SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1));
			SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1));
			SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1);
				
			SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3);

			SELECT @iDataType = dataType,
				@sColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iColumnID;
							
			SET @sColumnName = @sRealSourceAlias + '.' + @sColumnName;

			IF (@iDataType = -7) 
			BEGIN
				/* Logic column (must be the equals operator).	*/
				SET @sSubFilterSQL = @sColumnName + ' = ';
			
				IF UPPER(@sValue) = 'TRUE'
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '1';
				END
				ELSE
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '0';
				END
			END

			IF ((@iDataType = 2) OR (@iDataType = 4)) 
			BEGIN
				/* Numeric/Integer column. */
				/* Replace the locale decimal separator with '.' for SQL's benefit. */
				SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.');

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equals. */
					SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				    END
				END
        
				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 6) 
				BEGIN
					/* Less than.*/
					SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
			END

			IF (@iDataType = 11) 
			BEGIN
				/* Date column. */
				IF LEN(@sValue) > 0
				BEGIN
					/* Convert the locale date into the SQL format. */
					/* Note that the locale date has already been validated and formatted to match the locale format. */
					SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat);
					SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat);
					SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat);
						
					SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex3, 4);
				END

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
		    END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
  				    IF LEN(@sValue) > 0 
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
				    END
				END

				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
				    IF LEN(@sValue) > 0
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
				    IF LEN(@sValue) > 0
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
			  END

				IF (@iOperatorID = 6)
				BEGIN
					/* Less than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
			END
			
			IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
			BEGIN
				/* Character/Working Pattern column. */
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');

						SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 2) 
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');

						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 7)
				BEGIN
					/* Contains */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');

						SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%''';
					END
				END

				IF (@iOperatorID = 8) 
				BEGIN
					/* Does Not Contain. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');

						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%''';
					END
				END
			END
		
			IF LEN(@sSubFilterSQL) > 0
			BEGIN
				/* Add the filter code for this grid record into the complete filter code. */
				IF LEN(@sFilterSQL) > 0
				BEGIN
					SET @sFilterSQL = @sFilterSQL + ' AND (';
				END
				ELSE
				BEGIN
					SET @sFilterSQL = @sFilterSQL + '(';
				END

				SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')';
			END
		END
	END
	
	/* Get the record count of the current recordset. */
	SET @sCommand = 'SELECT @recordCount = COUNT(' + @sRealSourceAlias + '.id)' +
		' FROM ' + @sFromSQL;

	IF @piParentTableID > 0
	BEGIN
		SET @sCommand = @sCommand +
			' WHERE ' + @sRealSourceAlias + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
		
		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sCommand = @sCommand +	' AND ' + @sFilterSQL;
		END
	END
	ELSE
	BEGIN
		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sCommand = @sCommand +	' WHERE ' + @sFilterSQL;
		END
	END

	SET @sParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordCount OUTPUT;
	SET @piRecordCount = @iRecordCount;

	/* Get the default values for the given columns. */
	SET @sColumns = @psDefaultCalcColumns;
	SET @sColumnsDone = ',';
	WHILE len(@sColumns) > 0
	BEGIN
		IF CHARINDEX(',', @sColumns) > 0
		BEGIN
			SET @iID = convert(integer, left(@sColumns, CHARINDEX(',', @sColumns) - 1));
			SET @sColumns = substring(@sColumns, CHARINDEX(',', @sColumns) + 1, len(@sColumns));
		END
		ELSE
		BEGIN
			SET @iID = convert(integer, @sColumns);
			SET @sColumns = '';
		END

		/* Check the column has not already been done. */
		IF CHARINDEX(',' + convert(varchar(MAX), @iID) + ',', @sColumnsDone) > 0
		BEGIN
			/* Column already been done. */
			SET @iID = 0;
		END
		ELSE
		BEGIN
			/* Column NOT already been done. */
			SET @sColumnsDone = @sColumnsDone + convert(varchar(MAX), @iID) + ',';
		END

		IF @iID > 0 			
		BEGIN
			/* Get the data type and size of the column. */
			SELECT @iDataType = dataType, 
				@iSize = size, 
				@iDecimals = decimals,
				@iDfltExprID = dfltValueExprID
			FROM ASRSysColumns
			WHERE columnID = @iID;

			/* Check the default expression stored procedure exists. */
			SET @sCommand = 'SELECT @count = COUNT(*)' +
				' FROM sysobjects' +
				' WHERE id = object_id(N''sp_ASRDfltExpr_' + convert(varchar(100), @iDfltExprID) + ''')' +
				' AND OBJECTPROPERTY(id, N''IsProcedure'') = 1';
			SET @sParamDefinition = N'@count integer OUTPUT';
			EXEC sp_executesql @sCommand,  @sParamDefinition, @iCount OUTPUT;

			IF @iCount > 0 
			BEGIN
				SET @sCommand = 'exec sp_ASRDfltExpr_' + convert(varchar(100), @iDfltExprID) + ' @result output';	
				SET @fOK = 0;

				IF @iDataType = -7 /* Logic columns. */
				BEGIN
					SET @sParamDefinition = N'@result bit OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 2 /* Numeric columns. */
				BEGIN
					SET @sParamDefinition = N'@result float OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 4 /* Integer columns. */
				BEGIN
					SET @sParamDefinition = N'@result integer OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 11 /* Date columns. */
				BEGIN
					SET @sParamDefinition = N'@result datetime OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 12 /* Character columns. */
				BEGIN
					SET @sParamDefinition = N'@result varchar(MAX) OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = -1 /* Working Pattern columns. */
				BEGIN
					SET @sParamDefinition = N'@result varchar(14) OUTPUT';
					SET @fOK = 1;
				END

				IF @fOK = 1
				BEGIN
 					/* Append the parent table ID parameters. */
					DECLARE parentsCursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT parentID

						FROM ASRSysRelations
						WHERE childID = @piTableID
						ORDER BY parentID;
					OPEN parentsCursor;
					FETCH NEXT FROM parentsCursor INTO @iTableID;
					WHILE (@@fetch_status = 0)
					BEGIN
						IF @iTableID = @piParentTableID
						BEGIN
							SET @sCommand = @sCommand + ', ' + convert(varchar(100), @piParentRecordID);
						END
						ELSE
						BEGIN
							SET @sCommand = @sCommand + ', 0';
						END

						FETCH NEXT FROM parentsCursor INTO @iTableID;
					END
					CLOSE parentsCursor;
					DEALLOCATE parentsCursor;

					IF @iDataType = -7 /* Logic columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @fLogicResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] bit NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue bit';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @fLogicResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] bit NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @fLogicResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 2 /* Numeric columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @dblNumericResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] float NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue float';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @dblNumericResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] float NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @dblNumericResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 4 /* Integer columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @iIntegerResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0

							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END


								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] integer NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue integer';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @iIntegerResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] integer NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @iIntegerResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 11 /* Date columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @dtDateResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(10) NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(10)';

							SET @sTempDate = convert(varchar(10), @dtDateResult, 101);
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sTempDate;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(10) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + convert(nvarchar(MAX), @dtDateResult, 101) + '''';
							EXEC sp_executesql @sCommand;
						END
					END
          	
					IF @iDataType = 12 /* Character columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(MAX) NULL)';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(MAX)';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(MAX) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + REPLACE(convert(nvarchar(MAX), @sCharResult), '''', '''''') + '''';
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = -1 /* Working Pattern columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(MAX) NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(MAX)';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(MAX) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + REPLACE(convert(nvarchar(MAX), @sCharResult), '''', '''''') + '''';
							EXEC sp_executesql @sCommand;
						END
					END

					SET @fOneColumnDone = 1;
				END
			END
		END
	END

	IF @fOneColumnDone > 0
	BEGIN
		SET @sCommand = 'SELECT * FROM ' + @sTempTableName;
		EXEC sp_executesql @sCommand;

		SET @sCommand = 'DROP TABLE ' + @sTempTableName;
		EXEC sp_executesql @sCommand;
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelBooking]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntCancelBooking] (
	@pfTransferBookings	bit,
	@piTBRecordID		integer,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	
		@iCount						integer,
		@iUserGroupID				integer,
		@sUserGroupName				sysname,
		@fSysSecMgr					bit,
		@iTBTableID					integer,
		@sTBTableName				sysname,
		@sTBRealSource				sysname,
		@iWLTableID					integer,
		@sWLTableName				sysname,
		@sWLRealSource				sysname,
		@iChildViewID				integer,
		@iTBStatusColumnID			integer,
		@sTBStatusColumnName		sysname,
		@sExecString				nvarchar(MAX),
		@sCommand					nvarchar(MAX),
		@sParamDefinition			nvarchar(500),
		@sTBStatus					varchar(MAX),
		@iEmpID						integer,
		@iCourseID					integer,
		@iEmpTableID				integer,
		@iCourseTableID				integer,
		@iStatusCount				integer,
		@fTBProvisionalStatusExists		bit,
		@iCourseTitleColumnID		integer,
		@sCourseTitleColumnName		sysname,
		@sTempExecString			nvarchar(MAX),
		@sTempParamDefinition		nvarchar(500),
		@sCourseTitle				varchar(MAX),
		@iTBCancelDateColumnID		integer,
		@fTBCancelDateColumnUpdate	bit,
		@sTBCancelDateColumnName	sysname,
		@iWLCourseTitleColumnID		integer,
		@sWLCourseTitleColumnName	sysname,
		@sColumnList				varchar(MAX),
		@sValueList					varchar(MAX),
		@sAddedColumns				varchar(MAX),
		@sCourseSource				sysname,
		@iSourceColumnID			integer, 
		@iDestinationColumnID		integer,
		@iIndex						integer,
		@fGranted					bit,
		@sTempTBColumnName			sysname,
		@sTempWLColumnName			sysname,
		@sActualUserName			sysname;

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	/* Get the training booking status column name. */
	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	SET @fTBProvisionalStatusExists = 0
	SET @sCommand = 'SELECT @iStatusCount = COUNT(*)' +
		' FROM ASRSysColumnControlValues' +
		' WHERE columnID = ' + convert(nvarchar(255), @iTBStatusColumnID) +
		' AND value = ''P''';
	SET @sParamDefinition = N'@iStatusCount integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @iStatusCount OUTPUT;
	IF @iStatusCount > 0 SET @fTBProvisionalStatusExists = 1;

	SELECT @iTBCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookCancelDate';
	IF @iTBCancelDateColumnID IS NULL SET @iTBCancelDateColumnID = 0;

	IF @iTBCancelDateColumnID > 0 
	BEGIN
		SELECT @sTBCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iTBCancelDateColumnID;
	END
	IF @sTBCancelDateColumnName IS NULL SET @sTBCancelDateColumnName = '';

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;
	
	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Get the status, employee ID and course ID from the given TB record. */
	/* NB. If we've reached this point we already know that we have 'read' permision on the Trining Booking 'status' and id columns. */	
	SET @sCommand = 'SELECT @sTBStatus = ' + @sTBStatusColumnName +
		', @iEmpID = id_' + convert(nvarchar(255), @iEmpTableID) +
		', @iCourseID = id_' + convert(nvarchar(255), @iCourseTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(varchar(100), @piTBRecordID);

	SET @sParamDefinition = N'@sTBStatus varchar(MAX) OUTPUT, @iEmpID integer OUTPUT, @iCourseID integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @sTBStatus OUTPUT, @iEmpID OUTPUT, @iCourseID OUTPUT;

	/* Check the employee ID, course ID and status are valid. */
	IF (@sTBStatus <> 'B') AND (@sTBStatus <> 'P') 
	BEGIN
		SET @psErrorMessage = 'Bookings can only be cancelled if they have ''Booked''';

		IF @fTBProvisionalStatusExists = 1
		BEGIN
			SET @psErrorMessage = @psErrorMessage + ' or ''Provisional''';
		END
		SET @psErrorMessage = @psErrorMessage + ' status.';
		RETURN;
	END

	IF NOT (@iEmpID > 0) 
	BEGIN
		SET @psErrorMessage = 'The selected Training Booking record has no associated Employee record.';
		RETURN;
	END

	IF NOT (@iCourseID > 0) 
	BEGIN
		SET @psErrorMessage = 'The selected Training Booking record has no associated Course record.';
		RETURN;
	END

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(255), @iCourseID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @sCourseTitle = '';
	END

	/* Check the current user's column permissions on the current course table/view. */
	SET @fTBCancelDateColumnUpdate = 0;

	IF @fSysSecMgr = 1
	BEGIN
		SET @fTBCancelDateColumnUpdate = 1;
	END
	ELSE
	BEGIN
	
		/* Create a temporary table of the column permissions. */
		DECLARE @tbColumnPermissions TABLE(
			columnID	int,
			action		int,		
			granted		bit);

		INSERT INTO @tbColumnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND ASRSysColumns.tableID = @iTBTableID
			AND ASRSysColumns.columnID = @iTBCancelDateColumnID)
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 197)
			AND sysobjects.name = @sTBRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SELECT @fTBCancelDateColumnUpdate = granted
		FROM @tbColumnPermissions
		WHERE columnID =  @iTBCancelDateColumnID;
		IF @fTBCancelDateColumnUpdate IS NULL SET @fTBCancelDateColumnUpdate = 0;

	END

	/* Update the TrainingBooking record. */
	/* Already checked that we have 'update' permission on the ststaus column. */
	SET @sCommand = 'UPDATE ' + @sTBRealSource +
		' SET ' + @sTBStatusColumnName + ' = ''C''';

	IF (@iTBCancelDateColumnID > 0) AND (@fTBCancelDateColumnUpdate = 1)
	BEGIN
		/* Add the 'cancel date' column to the update string if the user has permission to. */
		SET @sCommand = @sCommand +
			', ' + @sTBCancelDateColumnName + ' = getdate()';
	END

	SET @sCommand = @sCommand +
		' WHERE id = ' + convert(varchar(100), @piTBRecordID);
	SET @sParamDefinition = N'@sTBStatus varchar(MAX) OUTPUT, @iEmpID integer OUTPUT, @iCourseID integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @sTBStatus OUTPUT, @iEmpID OUTPUT, @iCourseID OUTPUT;

	/* Create Waiting List record if required. */
	IF @pfTransferBookings = 1
	BEGIN
		/* Check if there is already a WL record for the course. */
		SET @sCommand = 'SELECT @iCount = COUNT(*)' +
			' FROM ' + @sWLRealSource + 
			' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + '''' + 
			' AND id_' + convert(nvarchar(255), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @iEmpID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sCommand, @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0
		BEGIN
			/* Initialise the insert strings with the basic values.*/
			/* NB. To reach this point we've already checked the user has 'update' permission on the 'courseTitle' column in the Waiting List table. */
			SET @sColumnList = 'id_' + convert(nvarchar(255), @iEmpTableID) + ',' +	@sWLCourseTitleColumnName;
			SET @sValueList = convert(nvarchar(255), @iEmpID) + ',' +	'''' + replace(@sCourseTitle, '''', '''''') + '''';
			SET @sAddedColumns = ',' + convert(varchar(255), @iWLCourseTitleColumnID) + ',';

			/* Get the TB and WL column permissions. */
			IF @fSysSecMgr = 0
			BEGIN
				DECLARE @columnPermissions TABLE(
					columnID	int,
					[action]	int,		
					granted		bit);

				INSERT INTO @columnPermissions
				SELECT 
					ASRSysColumns.columnID,
					sysprotects.action,
					CASE protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END AS [protectType]
					FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
					AND (ASRSysColumns.tableID = @iTBTableID
						OR ASRSysColumns.tableID = @iWLTableID))
				WHERE sysprotects.uid = @iUserGroupID
					AND (sysprotects.action = 193 OR sysprotects.action = 197)
					AND (sysobjects.name = @sTBRealSource
						OR sysobjects.name = @sWLRealSource)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END

			/* Get the Waiting List - Training Booking related columns. */
			DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT sourceColumnID, destColumnID
			FROM ASRSysModuleRelatedColumns
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TBWLRelatedColumns';
				
			OPEN relatedColumns_cursor;
			FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @iIndex = charindex(',' + convert(varchar(255), @iDestinationColumnID) + ',', @sAddedColumns);

				IF @iIndex = 0
				BEGIN
					/* Check that the user has read permission on the WL column, and update permission on the TB column. */
					SET @fGranted = 1;

					IF @fSysSecMgr = 0
					BEGIN
						SELECT @fGranted = granted
						FROM @columnPermissions
						WHERE columnID = @iSourceColumnID
							AND [action] = 193;

						IF @fGranted IS null SET @fGranted = 0

						IF @fGranted = 1
						BEGIN
							SELECT @fGranted = granted
							FROM @columnPermissions
							WHERE columnID = @iDestinationColumnID
								AND [action] = 197;

							IF @fGranted IS null SET @fGranted = 0;
						END
					END

					IF @fGranted = 1

					BEGIN
						SELECT @sTempTBColumnName = columnName
						FROM ASRSysColumns
						WHERE columnID = @iSourceColumnID;

						SELECT @sTempWLColumnName = columnName
						FROM ASRSysColumns 
						WHERE columnID = @iDestinationColumnID;

						SET @sColumnList = @sColumnList + ',' + @sTempWLColumnName;
						SET @sValueList = @sValueList + ',' + @sTempTBColumnName;
					END
			
					SET @sAddedColumns = @sAddedColumns + convert(varchar(255), @iSourceColumnID) + ',';
				END

				FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
			END
			CLOSE relatedColumns_cursor;
			DEALLOCATE relatedColumns_cursor;

			/* Create the WL record. */
			SET @sExecString = 'INSERT INTO ' + @sWLRealSource + 
				'(' + @sColumnList + ')' +
				' SELECT TOP 1 ' + @sValueList + 
				' FROM ' + @sTBRealSource + 
				' WHERE id = ' + convert(nvarchar(255), @piTBRecordID);
			EXEC sp_executesql @sExecString;
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCourse]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntCancelCourse] (
	@piNumberOfBookings			integer	OUTPUT,
	@piCourseRecordID			integer,
	@piTrainBookTableID			integer,
	@piCourseTableID			integer,
	@piTrainBookStatusColumnID	integer,
	@psCourseRealSource			varchar(MAX),
	@psErrorMessage				varchar(MAX) OUTPUT,
	@psCourseTitle				varchar(MAX) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sCommand					nvarchar(MAX),
			@sParamDefinition			nvarchar(500),
			@sRealSource				sysname,
			@iCourseTableID				integer,
			@fTransferProvisionals		bit,
			@sTrainBookStatusColumnName	sysname,
			@iUserGroupID				integer,
			@sUserGroupName				sysname,
			@fSysSecMgr					bit,
			@iChildViewID				integer,
			@sTemp						varchar(MAX),
			@iCourseTitleColumnID			integer,
			@fCourseTitleColumnSelect		bit,
			@iCourseCancelDateColumnID		integer,
			@fCourseCancelDateColumnUpdate	bit,
			@iCourseCancelByColumnID		integer,
			@fCourseCancelByColumnUpdate	bit,
			@sCourseTitleColumnName		sysname,
			@sTBTableName				sysname,
			@sActualUserName			sysname,
			@sCleanCourseRealSource		sysname;

	/* Clean the input string parameters. */
	SET @sCleanCourseRealSource = @psCourseRealSource;
	IF len(@sCleanCourseRealSource) > 0 SET @sCleanCourseRealSource = replace(@sCleanCourseRealSource, '''', '''''');

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID;
	
	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sRealSource = left(@sRealSource, 255);
	END

	/* Check if we need to transfer provisional bookings. */
	SET @sTemp = '';
	SELECT @sTemp = convert(varchar(MAX), parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTransferProvisionals';
		
	IF @sTemp IS NULL SET @sTemp = '';
	IF @sTemp = 'TRUE'
	BEGIN
		SET @fTransferProvisionals = 1;
	END
	ELSE
	BEGIN
		SET @fTransferProvisionals = 0;
	END

	/* Get the training booking status column name. */
	SELECT @sTrainBookStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @piTrainBookStatusColumnID;

	/* Get the number of training booking records for the current course. */
	SET @sCommand = 'SELECT @iValue = COUNT(ID) ' + 
		' FROM ' + @sRealSource +
		' WHERE id_' + convert(varchar(100), @piCourseTableID) + ' = ' + convert(varchar(100), @piCourseRecordID);

	IF @fTransferProvisionals = 1 
	BEGIN
		SET @sCommand = @sCommand +
			' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
			' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
	END
	ELSE
	BEGIN
		SET @sCommand = @sCommand +
			' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
	END

	SET @sParamDefinition = N'@iValue integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @piNumberOfBookings OUTPUT;

	IF @piNumberOfBookings IS NULL SET @piNumberOfBookings = 0;

	/* Check the current user's column permissions on the current course table/view. */
	/* Get the IDs of the required columns. */
	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;

	SELECT @iCourseCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelDate';
	IF @iCourseCancelDateColumnID IS NULL SET @iCourseCancelDateColumnID = 0;

	SELECT @iCourseCancelByColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelledBy';
	IF @iCourseCancelByColumnID IS NULL SET @iCourseCancelByColumnID = 0;

	IF @fSysSecMgr = 1
	BEGIN
		SET @fCourseTitleColumnSelect = 1;
		SET @fCourseCancelDateColumnUpdate = 1;
		SET @fCourseCancelByColumnUpdate = 1;
	END
	ELSE
	BEGIN
		/* Create a temporary table of the column permissions. */
		DECLARE @courseColumnPermissions TABLE(
			columnID	int,
			[action]		int,		
			granted		bit);

		INSERT INTO @courseColumnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND ASRSysColumns.tableID = @piCourseTableID
			AND ((ASRSysColumns.columnID = @iCourseTitleColumnID) 
				OR (ASRSysColumns.columnID = @iCourseCancelDateColumnID)
				OR (ASRSysColumns.columnID = @iCourseCancelByColumnID)))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND sysobjects.name = @psCourseRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SELECT @fCourseTitleColumnSelect = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseTitleColumnID
			AND [action] = 193;
		IF @fCourseTitleColumnSelect IS NULL SET @fCourseTitleColumnSelect = 0;

		SELECT @fCourseCancelDateColumnUpdate = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseCancelDateColumnID
			AND action = 197;
		IF @fCourseCancelDateColumnUpdate IS NULL SET @fCourseCancelDateColumnUpdate = 0;

		SELECT @fCourseCancelByColumnUpdate = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseCancelByColumnID
			AND action = 197;
		IF @fCourseCancelByColumnUpdate IS NULL SET @fCourseCancelByColumnUpdate = 0;

	END

	IF @iCourseTitleColumnID = 0 SET @psErrorMessage = 'Unable to find the Course Title column.';
	IF ((LEN(@psErrorMessage) = 0) AND (@fCourseTitleColumnSelect = 0)) SET @psErrorMessage = 'You do not have ''read'' permission on the Course Title column in the current table/view.';
	IF ((LEN(@psErrorMessage) = 0) AND (@iCourseCancelDateColumnID = 0)) SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
	IF ((LEN(@psErrorMessage) = 0) AND (@fCourseCancelDateColumnUpdate = 0)) SET @psErrorMessage = 'You do not have ''edit'' permission on the Course Cancel Date column in the current table/view.';
	IF ((LEN(@psErrorMessage) = 0) AND (@iCourseCancelByColumnID > 0) AND (@fCourseCancelByColumnUpdate = 0)) SET @psErrorMessage = 'You do not have ''edit'' permission on the Course Cancel By column in the current table/view.';

	SET @psCourseTitle = '';
	IF (@iCourseTitleColumnID > 0) AND (@fCourseTitleColumnSelect = 1)
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM [dbo].[ASRSysColumns]
		WHERE columnID = @iCourseTitleColumnID;

		IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';
		IF LEN(@sCourseTitleColumnName) > 0
		BEGIN
			SET @sCommand = 'SELECT @sValue = ' + @sCourseTitleColumnName +
				' FROM ' + @sCleanCourseRealSource +
				' WHERE id = ' + convert(varchar(100), @piCourseRecordID);

			SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
			EXEC sp_executesql @sCommand, @sParamDefinition, @psCourseTitle OUTPUT;
			IF @psCourseTitle IS NULL SET @psCourseTitle = '';
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCoursePart2]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntCancelCoursePart2] (
	@piEmployeeTableID					integer,
	@piCourseTableID					integer,
	@psCourseRealSource					varchar(MAX),
	@piCourseRecordID					integer,
	@piTransferCourseRecordID			integer,
	@piCourseCancelDateColumnID			integer,
	@psCourseTitle						varchar(MAX),
	@piTrainBookTableID					integer,
	@pfTrainBookTableInsert				bit,
	@piTrainBookStatusColumnID			integer,
	@piTrainBookCancelDateColumnID		integer,
	@piWaitListTableID					integer,
	@pfWaitListTableInsert				bit,
	@piWaitListCourseTitleColumnID		integer,
	@pfWaitListCourseTitleColumnUpdate	bit,
	@pfCreateWaitListRecords			bit,
	@psErrorMessage						varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure actually does the course cancellation, and the associated transferrals, etc. */
	/* Returns an error string if anything went wrong. */
	DECLARE	@sCommand						nvarchar(MAX),
			@sParamDefinition				nvarchar(500),
			@iUserGroupID					integer,
			@sUserGroupName					sysname,
			@iChildViewID					integer,
			@sTemp							varchar(MAX),
			@iCount							integer,
			@fTransferProvisionals			bit,
			@fCStatusExists					bit,
			@fCCStatusExists				bit,
			@sCourseCancelDateColumnName	sysname,
			@iCourseCancelledByColumnID		integer,
			@sCourseCancelledByColumnName	sysname,
			@sWLTableName					sysname,
			@sWaitListRealSource			sysname,
			@sWaitListCourseTitleColumnName	sysname,
			@sTBTableName					sysname,
			@sTrainBookRealSource			sysname,
			@sTrainBookStatusColumnName		sysname,
			@sTrainBookCancelDateColumnName	sysname,
			@sActualUserName				sysname,
			@iSourceColumnID				integer,
			@iDestinationColumnID			integer,
			@sAddedColumns					varchar(MAX),
			@iIndex							integer,
			@fGranted						bit,
			@sTempTBColumnName				sysname,
			@sTempWLColumnName				sysname,
			@sColumnList					varchar(MAX),
			@sValueList						varchar(MAX),
			@fSysSecMgr						bit;

	BEGIN TRANSACTION

	/* Clean the input string parameters. */
	IF len(@psCourseRealSource) > 0 SET @psCourseRealSource = replace(@psCourseRealSource, '''', '''''');
	IF len(@psCourseTitle) > 0 SET @psCourseTitle = replace(@psCourseTitle, '''', '''''');

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID;

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTrainBookRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTrainBookRealSource = left(@sTrainBookRealSource, 255);
	END
	ELSE
	BEGIN
		SET @psErrorMessage = 'Unable to determine the Training Booking child view.';
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if we need to transfer provisional bookings. */
		SET @sTemp = '';
		SELECT @sTemp = convert(varchar(MAX), parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTransferProvisionals';
		IF @sTemp IS NULL SET @sTemp = '';
		IF @sTemp = 'TRUE'
		BEGIN
			SET @fTransferProvisionals = 1;
		END
		ELSE
		BEGIN
			SET @fTransferProvisionals = 0;
		END

		/* Get the Course Cancelled Date column name if there is a column defined. */
		IF @piCourseCancelDateColumnID > 0 
		BEGIN
			SELECT @sCourseCancelDateColumnName = columnName
			FROM ASRSysColumns
			WHERE columnID = @piCourseCancelDateColumnID;
		END

		IF @sCourseCancelDateColumnName IS NULL SET @sCourseCancelDateColumnName = '';
		IF LEN(@sCourseCancelDateColumnName) = 0 SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		/* Get the Course Cancelled By column name if there is a column defined. */
		SELECT @iCourseCancelledByColumnID = convert(integer, parameterValue)
		FROM [dbo].[ASRSysModuleSetup]
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseCancelledBy';
			
		IF @iCourseCancelledByColumnID IS NULL SET @iCourseCancelledByColumnID = 0;
		IF @iCourseCancelledByColumnID > 0
		BEGIN
			SELECT @sCourseCancelledByColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iCourseCancelledByColumnID;
			
			IF @sCourseCancelledByColumnName IS NULL SET @sCourseCancelledByColumnName = '';
			IF LEN(@sCourseCancelledByColumnName) = 0 SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
		END
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Update the current course record. */
		/* NB. The 'sp_ASRIntCancelCourse' stored procedure is run before this one, and checks certain permissions.
			If the user does not have update permission on the Course Cancelled Date column 
			or Course Cancelled By column (if there is one) then this point won't be reached. */
		SET @sCommand = 'UPDATE ' + @psCourseRealSource +
			' SET ' + @sCourseCancelDateColumnName + ' = getdate()';
		IF @iCourseCancelledByColumnID > 0 SET @sCommand = @sCommand + ', ' + @sCourseCancelledByColumnName + ' = SYSTEM_USER';
		SET @sCommand = @sCommand + ' WHERE id = ' + convert(nvarchar(255), @piCourseRecordID);
		EXEC sp_executesql @sCommand;
	END
	
	IF LEN(@psErrorMessage) = 0 		
	BEGIN	
		/* Get the Training Booking Status column name. */
		IF @piTrainBookStatusColumnID > 0
		BEGIN
			SELECT @sTrainBookStatusColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @piTrainBookStatusColumnID;
		END
		IF @sTrainBookStatusColumnName IS NULL SET @psErrorMessage = 'Unable to find the Training Booking Status column.';
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN	
		/* Transfer course records if required. */
		IF @piTransferCourseRecordID > 0 
		BEGIN
			IF @pfTrainBookTableInsert = 0 SET @psErrorMessage = 'You do not have ''new'' permission on the Training Booking table.';
			IF LEN(@psErrorMessage) = 0 		
			BEGIN
				/* Create the transferred booking records. */
				/* NB. Insert permission on the table is checked above.
					The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
					as the user logs into the intranet module, and checks certain permissions. 
					If the user does not have update permission on the Status column 
					then this point won't be reached. 
				The checks for overbooking, unavailability, overlapped bookings and pre-requisites
				are made as the user selects the new course. */
				SET @sCommand = 'INSERT INTO ' + @sTrainBookRealSource +
					' (' + @sTrainBookStatusColumnName + ', ' +
					'id_' + convert(nvarchar(255), @piEmployeeTableID) + ', ' +
					'id_' + convert(nvarchar(255), @piCourseTableID) + ')' +
					' (SELECT ' +
						@sTrainBookStatusColumnName + ', ' +
						'id_' + convert(nvarchar(255), @piEmployeeTableID) + ', ' +
						convert(nvarchar(255), @piTransferCourseRecordID) +
						' FROM ' + @sTrainBookRealSource +
						' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
				IF @fTransferProvisionals = 1
				BEGIN
					SET @sCommand = @sCommand +
						' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
						' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P''))';
				END	
				ELSE
				BEGIN
					SET @sCommand = @sCommand +
						' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
				END
				EXEC sp_executesql @sCommand;
			END
		END
	END

	IF (LEN(@psErrorMessage) = 0)
		AND (@piTrainBookCancelDateColumnID > 0)
	BEGIN
		/* Change the Cancellation Date of the existing bookings. */	
		/* NB. Update permission on the table is checked above.
			The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Status column or Cancel Date column (if there is one)
				then this point won't be reached. */

		SELECT @sTrainBookCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @piTrainBookCancelDateColumnID;
			
		SET @sCommand = 'UPDATE ' + @sTrainBookRealSource +
			' SET '+ @sTrainBookCancelDateColumnName + ' = getdate()' +
			' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
       
		IF @fTransferProvisionals  = 1
		BEGIN
			SET @sCommand = @sCommand +
          				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
          				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
		END
		EXEC sp_executesql @sCommand;
	END

	IF (LEN(@psErrorMessage) = 0) AND (@piTransferCourseRecordID = 0) AND (@pfCreateWaitListRecords = 1)
	BEGIN	
	
		/* Moved from below to get @sWaitListCourseTitleColumnName in time*/
		IF @piWaitListCourseTitleColumnID > 0
		BEGIN
			/* Get the Waiting List Course Title column name. */
			SELECT @sWaitListCourseTitleColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @piWaitListCourseTitleColumnID;
		END
		IF @sWaitListCourseTitleColumnName IS NULL SET @psErrorMessage = 'Unable to find the Waiting List Course Title column.';

		/*-------------------------------------------------------------------------------------------------------------*/
		/*NPG20080422 Faults 13024 and 13025																		   */
		/*-------------------------------------------------------------------------------------------------------------*/
		IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
		BEGIN
			SET @fSysSecMgr = 1;
		END
		ELSE
		BEGIN	
			/* Check if the current user is a System or Security manager. */
			SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
			FROM ASRSysGroupPermissions
			INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
			WHERE sysusers.uid = @iUserGroupID
				AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
				OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
				AND ASRSysGroupPermissions.permitted = 1
				AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
		END	

		/* Initialise the insert strings with the basic values.*/

		SET @sColumnList = @sWaitListCourseTitleColumnName + ',' +
			'id_' + convert(nvarchar(255), @piEmployeeTableID);
		SET @sValueList = '''' + @psCourseTitle  + ''',' +
			'id_' + convert(nvarchar(255), @piEmployeeTableID);
		SET @sAddedColumns = ',' + convert(varchar(255), @piWaitListCourseTitleColumnID) + ',';

		/* Get the TB and WL column permissions. */
		IF @fSysSecMgr = 0
		BEGIN
			DECLARE @columnPermissions TABLE(
				columnID	int,
				[action]		int,		
				granted		bit);
				
			INSERT INTO @columnPermissions
			SELECT 
				ASRSysColumns.columnID,
				sysprotects.action,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END AS [protectType]
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
				AND (ASRSysColumns.tableID = @piTrainBookTableID
					OR ASRSysColumns.tableID = @piWaitListTableID))
			WHERE sysprotects.uid = @iUserGroupID
				AND (sysprotects.action = 193 OR sysprotects.action = 197)
				AND (sysobjects.name = @sTrainBookRealSource
					OR sysobjects.name = @sWaitListRealSource)
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END

		/* Get the Waiting List - Training Booking related columns. */
		DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT sourceColumnID, destColumnID
		FROM ASRSysModuleRelatedColumns
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_TBWLRelatedColumns';
			
		OPEN relatedColumns_cursor;
		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @iIndex = charindex(',' + convert(varchar(255), @iDestinationColumnID) + ',', @sAddedColumns);
			IF @iIndex = 0
			BEGIN
				/* Check that the user has read permission on the WL column, and update permission on the TB column. */
				SET @fGranted = 1;
				IF @fSysSecMgr = 0
				BEGIN
					SELECT @fGranted = granted
					FROM @columnPermissions
					WHERE columnID = @iDestinationColumnID
						AND [action] = 193;
					IF @fGranted IS null SET @fGranted = 0;
					IF @fGranted = 1
					BEGIN
						SELECT @fGranted = granted
						FROM @columnPermissions
						WHERE columnID = @iSourceColumnID
							AND [action] = 197;
						IF @fGranted IS null SET @fGranted = 0;
					END
				END
				IF @fGranted = 1
				BEGIN
					SELECT @sTempTBColumnName = columnName
					FROM [dbo].[ASRSysColumns]
					WHERE columnID = @iSourceColumnID;
					
					SELECT @sTempWLColumnName = columnName
					FROM [dbo].[ASRSysColumns]
					WHERE columnID = @iDestinationColumnID;
					
					SET @sColumnList = @sColumnList + ',' + @sTempWLColumnName;
					SET @sValueList = @sValueList + ',' + @sTempTBColumnName;
				END
				
				SET @sAddedColumns = @sAddedColumns + convert(varchar(255), @iSourceColumnID) + ',';
			END
			FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
		END

		CLOSE relatedColumns_cursor;
		DEALLOCATE relatedColumns_cursor;
		
		/* Create Waiting List records if required. */
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			IF @pfWaitListCourseTitleColumnUpdate = 0 SET @psErrorMessage = 'You do not have ''edit'' permission on the Waiting List Course Title column.';
		END
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			IF @pfWaitListTableInsert = 0 SET @psErrorMessage = 'You do not have ''new'' permission on the Waiting List table.';
		END
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			SELECT @sWLTableName = tableName
			FROM [dbo].[ASRSysTables]
			WHERE tableID = @piWaitListTableID;
			
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @piWaitListTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sWaitListRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sWLTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sWaitListRealSource = left(@sWaitListRealSource, 255);
			END
			ELSE
			BEGIN
				SET @psErrorMessage = 'Unable to determine the Waiting List child view.';
			END
		END

		IF LEN(@psErrorMessage) = 0 		
		BEGIN	

			/* Create Waiting List records if required. */
			/* NB. Insert permission on the table is checked above.
				The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Course Title column 
				then this point won't be reached. */

			SET @sCommand = 'INSERT INTO ' + @sWaitListRealSource + 
				'(' + @sColumnList + ')' +
				' (SELECT ' + @sValueList + 
				' FROM ' + @sTrainBookRealSource + 
				' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID) +  
				' AND id_' + convert(nvarchar(255), @piEmployeeTableID) + ' > 0' +
				' AND ''' + @psCourseTitle + ''' NOT IN (SELECT ' + @sWaitListRealSource + '.'+ @sWaitListCourseTitleColumnName +
				' FROM ' + @sWaitListRealSource + 
				' WHERE ' + @sWaitListRealSource + '.id_' + convert(nvarchar(255), @piEmployeeTableID) + ' = ' + @sTrainBookRealSource + '.id_' + convert(nvarchar(255), @piEmployeeTableID) + ')';

			IF @fTransferProvisionals  = 1
			BEGIN
				SET @sCommand = @sCommand +
					' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
					' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P''))';
			END
			ELSE
			BEGIN
				SET @sCommand = @sCommand +
					' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B'')';
			END
			EXEC sp_executesql @sCommand;
		END
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Check if the 'CC' status code exists. */
		SET @fCCStatusExists = 0;
		
		SELECT @iCount = count(value)
		FROM [dbo].[ASRSysColumnControlValues]
		WHERE columnID = @piTrainBookStatusColumnID
			AND value = 'CC';
			
		IF @iCount > 0 SET @fCCStatusExists = 1;
		/* Check if the 'C' status code exists. */
		SET @fCStatusExists = 0;
		
		SELECT @iCount = count(value)
		FROM [dbo].[ASRSysColumnControlValues]
		WHERE columnID = @piTrainBookStatusColumnID
			AND value = 'C';
			
		IF @iCount > 0 SET @fCStatusExists = 1;
		IF @fCStatusExists = 0 SET @psErrorMessage = 'The Training Booking Status column does not have ''C'' as a valid value.';
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Update the existing training booking records. */	
		/* NB. Update permission on the table is checked above.
			The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Status column or Cancel Date column (if there is one)
				then this point won't be reached. */
		SET @sCommand = 'UPDATE ' + @sTrainBookRealSource +
			' SET ' + @sTrainBookStatusColumnName + ' = ' +
			CASE 
				WHEN @fCCStatusExists = 1 THEN '''CC'''
				ELSE '''C'''
			END;

		SET @sCommand = @sCommand +
			' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
       
		IF @fTransferProvisionals  = 1
		BEGIN
			SET @sCommand = @sCommand +
          				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
          				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
		END
		EXEC sp_executesql @sCommand;
	END

	IF LEN(@psErrorMessage) > 0 		
	BEGIN
		RAISERROR(@psErrorMessage, 16, 1);
		ROLLBACK;
	END
	ELSE COMMIT TRANSACTION;
END
GO




CREATE PROCEDURE [dbo].[sp_ASRIntGetRootExpressionIDs] (
	@piCompID		integer,
	@piRootExprID	varchar(255)	OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iParentCompID	integer;

	SELECT @iParentCompID = ASRSysExpressions.parentComponentID, 
		@piRootExprID = ASRSysExpressions.exprID
	FROM [dbo].[ASRSysExpressions]
	JOIN ASRSysExprComponents ON ASRSysExpressions.exprID = ASRSysExprComponents.exprID
	WHERE ASRSysExprComponents.componentID = @piCompID;

	IF (@iParentCompID > 0)
	BEGIN
		EXECUTE [dbo].[sp_ASRIntGetRootExpressionIDs] @iParentCompID, @piRootExprID OUTPUT;
	END

	IF @piRootExprID IS null SET @piRootExprID = 0;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntDeleteUtility]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntDeleteUtility] (
	@piUtilType	integer,
	@piUtilID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iExprID	integer;

	IF @piUtilType = 0
	BEGIN
		/* Batch Jobs */
		DELETE FROM ASRSysBatchJobName WHERE ID = @piUtilID;
		DELETE FROM AsrSysBatchJobDetails WHERE BatchJobNameID = @piUtilID;
		DELETE FROM ASRSysBatchJobAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 1
	BEGIN
		/* Cross Tabs */
		DELETE FROM ASRSysCrossTab WHERE CrossTabID = @piUtilID;
		DELETE FROM ASRSysCrossTabAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 2
	BEGIN
		/* Custom Reports. */
		DELETE FROM ASRSysCustomReportsName WHERE id = @piUtilID;
		DELETE FROM ASRSysCustomReportsDetails WHERE customReportID= @piUtilID;
		DELETE FROM ASRSysCustomReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 3
	BEGIN
		/* Data Transfer. */
		DELETE FROM ASRSysDataTransferName WHERE DataTransferID = @piUtilID;
		DELETE FROM ASRSysDataTransferAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 4
	BEGIN
		/* Export. */
		DELETE FROM ASRSysExportName WHERE ID = @piUtilID;
		DELETE FROM AsrSysExportDetails WHERE ExportID = @piUtilID;
		DELETE FROM ASRSysExportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 5) OR (@piUtilType = 6) OR (@piUtilType = 7)
	BEGIN
		/* Globals. */
		DELETE FROM ASRSysGlobalFunctions  WHERE FunctionID = @piUtilID;
		DELETE FROM ASRSysGlobalAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 8
	BEGIN
		/* Import. */
		DELETE FROM ASRSysImportName  WHERE ID = @piUtilID;
		DELETE FROM ASRSysImportDetails WHERE ImportID = @piUtilID;
		DELETE FROM ASRSysImportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 9) OR (@piUtilType = 18)
	BEGIN
		/* Mail Merge/ Envelopes & Labels. */
		DELETE FROM AsrSysMailMergeName  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeColumns  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 10
	BEGIN
		/* Picklists. */
		DELETE FROM ASRSysPickListName WHERE picklistID = @piUtilID;
		DELETE FROM ASRSysPickListItems WHERE picklistID = @piUtilID;
	END
	
	IF @piUtilType = 11 OR @piUtilType = 12
	BEGIN
		/* Filters and Calculations. */
		DECLARE subExpressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.exprID
			FROM ASRSysExpressions
			INNER JOIN ASRSysExprComponents ON ASRSysExpressions.parentComponentID = ASRSysExprComponents.componentID
			AND ASRSysExprComponents.exprID = @piUtilID;
		OPEN subExpressions_cursor;
		FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		WHILE (@@fetch_status = 0)
		BEGIN
			exec [dbo].[sp_ASRIntDeleteUtility] @piUtilType, @iExprID;
			
			FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		END
		CLOSE subExpressions_cursor;
		DEALLOCATE subExpressions_cursor;

		DELETE FROM ASRSysExprComponents
		WHERE exprID = @piUtilID;

		DELETE FROM ASRSysExpressions WHERE exprID = @piUtilID;
	END	

	IF (@piUtilType = 14) OR (@piUtilType = 23) OR (@piUtilType = 24)
	BEGIN
		/* Match Reports/Succession Planning/Career Progression. */
		DELETE FROM ASRSysMatchReportName WHERE MatchReportID = @piUtilID;
		DELETE FROM ASRSysMatchReportAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 17 
	BEGIN
		/*Calendar Reports*/
		DELETE FROM ASRSysCalendarReports WHERE ID = @piUtilID;
		DELETE FROM ASRSysCalendarReportEvents WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportOrder WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 20 
	BEGIN
		/*Record Profile*/
		DELETE FROM ASRSysRecordProfileName WHERE recordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileDetails WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileTables WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileAccess WHERE ID = @piUtilID;
	END
	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntExpressionHasHiddenComponents]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntExpressionHasHiddenComponents] (
	@piExprID 			integer, 
	@pfHasHiddenComponents	bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Check if the given expression has any hidden componeonts. */
	DECLARE @iExprID	integer,
		@sAccess		varchar(MAX),
		@fTemp			bit;

	SET @pfHasHiddenComponents = 0

	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		CASE
			WHEN ASRSysExprComponents.type = 10 THEN	ASRSysExprComponents.filterID
			WHEN ASRSysExprComponents.type = 3 THEN	ASRSysExprComponents.calculationID
			ELSE ASRSysExprComponents.fieldSelectionFilter
		END AS [exprID]
	FROM ASRSysExprComponents
	WHERE exprID = @piExprID
		AND ((type = 3) 
			OR (type = 10) 
			OR ((type = 1) AND (fieldSelectionFilter > 0)))
	OPEN components_cursor
	FETCH NEXT FROM components_cursor INTO @iExprID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @sAccess = access
		FROM ASRSysExpressions
		WHERE exprID = @iExprID	

		IF @sAccess = 'HD'
		BEGIN
			/* The filter/calc is hidden. */
			SET @pfHasHiddenComponents = 1
			RETURN
		END
		ELSE
		BEGIN
			/* The filter/calc is NOT hidden. Check the sub-components. */
			execute sp_ASRIntExpressionHasHiddenComponents @iExprID, @fTemp OUTPUT

			IF @fTemp = 1
			BEGIN
				SET @pfHasHiddenComponents = 1
				RETURN
			END	
		END

		FETCH NEXT FROM components_cursor INTO @iExprID
	END
	CLOSE components_cursor
	DEALLOCATE components_cursor	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAbsenceTypes]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetAbsenceTypes]
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sExecString	nvarchar(MAX),
		@sTableName			varchar(255),
		@sColumnName		varchar(255),
		@iTableID			integer,
		@iColumnID			integer,
		@sParameterValue	varchar(MAX);

	SET @sTableName = '';
	SET @sColumnName = '';
	SET @sParameterValue = '';

	/* Get the Absence Type table name. */
	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_TableAbsenceType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iTableID = convert(integer, @sParameterValue);

		SELECT @sTableName = tableName 
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @iTableID;
		
 	END

	/* Get the Absence Type Column name. */
	SET @sParameterValue = '';

	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_FieldTypeType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iColumnID = convert(integer, @sParameterValue);

		SELECT @sColumnName = columnName 
		FROM [dbo].[ASRSysColumns]
		WHERE columnID = @iColumnID;
		
 	END

	/* Get the Absence Types if everything is ok. */
	IF len(@sTableName) > 0
		AND len(@sColumnName) > 0
	BEGIN
		SET @sExecString = 'SELECT ' + @sColumnName + 
			' FROM ' + @sTableName +
			' ORDER BY ' + @sColumnName;

		/* Return a recordset of the absence types */
		EXECUTE sp_executeSQL @sExecString;
		
	END
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAvailableLogins]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetAvailableLogins] 
AS
BEGIN

	SET NOCOUNT ON;

	SELECT name FROM sys.server_principals
	WHERE NOT EXISTS (SELECT sysusers.sid
						FROM sysusers
						WHERE sysusers.sid = sys.server_principals.sid)
	AND TYPE IN ('S', 'U')
	AND name != 'NT AUTHORITY\SYSTEM'
	AND is_disabled = 0;

END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetColumns]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetColumns] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ColumnID, ColumnName, OLEType
		FROM [dbo].[ASRSysColumns]
		WHERE tableID = @piTableID AND NOT(ColumnName = 'ID')
		ORDER BY ColumnName;
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromTBID]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromTBID] (
	@piEmpRecordID	integer		OUTPUT,
	@piTBRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@iEmpTableID			integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(255),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List table. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piEmpRecordID OUTPUT;

	IF @piEmpRecordID IS null SET @piEmpRecordID = 0;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprColumns]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprColumns] (
	@piTableID			integer,
	@piComponentType	integer,
	@piNumericsOnly		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted column definitions ;
	<column id><tab><column name><tab><data type> */
	DECLARE @iDataType	integer;

	IF @piComponentType = 1
	BEGIN
		SET @iDataType = -3;
	END
	ELSE
	BEGIN
		SET @iDataType = -7;
		SET @piNumericsOnly = 0;
	END

	SELECT 
		convert(varchar(255), columnID) + char(9) +
		columnName + char(9) +
		convert(varchar(255), dataType) AS [definitionString]
	FROM [dbo].[ASRSysColumns]
	WHERE tableID = @piTableID
		AND dataType <> -4
		AND dataType <> -3
		AND dataType <> @iDataType
		AND columnType <> 4
		AND columnType <> 3
		AND ((@piNumericsOnly = 0) OR (dataType = 2) OR (dataType = 4))
	ORDER BY columnName;
END
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetSubExpressionsAndComponents] (
	@piExprID				integer, 
	@psTempExprIDs 			varchar(MAX)	OUTPUT, 
	@psTempComponentIDs		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iComponentID		integer,
		@iExpressionID		integer,
		@sSubExprIDs 		varchar(MAX), 
		@sSubComponentIDs	varchar(MAX);	

	SET @psTempExprIDs = '';
	SET @psTempComponentIDs = '';

	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysExprComponents.componentID
		FROM ASRSysExprComponents
		WHERE ASRSysExprComponents.exprID = @piExprID;
	OPEN components_cursor;
	FETCH NEXT FROM components_cursor INTO @iComponentID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psTempComponentIDs = @psTempComponentIDs +
			CASE
				WHEN len(@psTempComponentIDs) > 0 THEN ','
				ELSE ''
			END +
			convert(varchar(100), @iComponentID);
			
		FETCH NEXT FROM components_cursor INTO @iComponentID;
	END
	CLOSE components_cursor;
	DEALLOCATE components_cursor;

	DECLARE expressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysExpressions.exprID
		FROM ASRSysExpressions
		WHERE ASRSysExpressions.parentComponentID IN
			(SELECT ASRSysExprComponents.componentID
			FROM ASRSysExprComponents
			WHERE ASRSysExprComponents.exprID = @piExprID);
	OPEN expressions_cursor;
	FETCH NEXT FROM expressions_cursor INTO @iExpressionID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psTempExprIDs = @psTempExprIDs +
			CASE
				WHEN len(@psTempExprIDs) > 0 THEN ','
				ELSE ''
			END +
			convert(varchar(100), @iExpressionID);
		
		exec [dbo].[sp_ASRIntGetSubExpressionsAndComponents] @iExpressionID, @sSubExprIDs OUTPUT, @sSubComponentIDs OUTPUT;
		
		IF len(@sSubExprIDs) > 0
		BEGIN
			SET @psTempExprIDs = @psTempExprIDs +
				CASE
					WHEN len(@psTempExprIDs) > 0 THEN ','
					ELSE ''
				END +
				@sSubExprIDs;
		END

		IF len(@sSubComponentIDs) > 0
		BEGIN
			SET @psTempComponentIDs = @psTempComponentIDs +
				CASE
					WHEN len(@psTempComponentIDs) > 0 THEN ','
					ELSE ''
				END +
				@sSubComponentIDs;
		END

		FETCH NEXT FROM expressions_cursor INTO @iExpressionID;
	END
	CLOSE expressions_cursor;
	DEALLOCATE expressions_cursor;
END
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition] (
	@piExprID		integer,
	@psAction		varchar(100),
	@psErrMsg		varchar(MAX)	OUTPUT,
 	@piTimestamp	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the defintions of each component and expression in the given expression. */
	DECLARE @sExprIDs		varchar(MAX),
		@sComponentIDs		varchar(MAX),
		@sTempExprIDs		varchar(MAX),
		@sTempComponentIDs	varchar(MAX),
		@sCurrentUser		sysname,
		@iCount				integer,
		@sOwner				varchar(255),
		@sAccess			varchar(MAX),
		@iBaseTableID		integer,
		@sBaseTableID		varchar(100),
		@fSysSecMgr			bit,
		@sExecString		nvarchar(MAX);
	
	SET @psErrMsg = '';
	SET @sCurrentUser = SYSTEM_USER;

	/* Check the expressions exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @iCount = 0
	BEGIN
		SET @psErrMsg = 'expression has been deleted by another user.';
		RETURN;
	END

	SELECT @sOwner = userName,
		@sAccess = access,
		@iBaseTableID = tableID,
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @sAccess <> 'RW'
	BEGIN
		exec spASRIntSysSecMgr @fSysSecMgr OUTPUT;
	
		IF @fSysSecMgr = 1 SET @sAccess = 'RW';
	END
	
	IF @iBaseTableID IS null 
	BEGIN
		SET @sBaseTableID = '0';
	END
	ELSE
	BEGIN
		SET @sBaseTableID = convert(varchar(100), @iBaseTableID);
	END

	/* Check the current user can view the expression. */
	IF (@sAccess = 'HD') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made hidden by another user.';
		RETURN;
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made read only by another user.';
		RETURN;
	END

	SET @sExprIDs = convert(varchar(MAX), @piExprID);
	SET @sComponentIDs = '0';

	/* Get a list of the components and sub-expressions in the given expression. */
	exec sp_ASRIntGetSubExpressionsAndComponents @piExprID, @sTempExprIDs OUTPUT, @sTempComponentIDs OUTPUT;

	IF len(@sTempExprIDs) > 0 SET @sExprIDs = @sExprIDs + ',' + @sTempExprIDs;
	IF len(@sTempComponentIDs) > 0 SET @sComponentIDs = @sComponentIDs + ',' + @sTempComponentIDs;

	SET @sExecString = 'SELECT
		''C'' as [type],
		ASRSysExprComponents.componentID AS [id],
		convert(varchar(100), ASRSysExprComponents.componentID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.exprID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.type)+ char(9) +
		CASE WHEN ASRSysExprComponents.fieldColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldPassBy IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldPassBy) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionRecord IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionRecord) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionLine IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionLine) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionOrderID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionOrderID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionFilter IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionFilter) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionID) END + char(9) +
		CASE WHEN ASRSysExprComponents.calculationID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.calculationID) END + char(9) +
		CASE WHEN ASRSysExprComponents.operatorID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.operatorID) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueType) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueCharacter IS null THEN '''' ELSE ASRSysExprComponents.valueCharacter END + char(9) +
		CASE WHEN ASRSysExprComponents.valueNumeric IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueNumeric) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueLogic IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueLogic) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueDate IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueDate, 101) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDescription IS null THEN '''' ELSE ASRSysExprComponents.promptDescription END + char(9) +
		CASE WHEN ASRSysExprComponents.promptMask IS null THEN '''' ELSE ASRSysExprComponents.promptMask END + char(9) +
		CASE WHEN ASRSysExprComponents.promptSize IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptSize) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDecimals IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDecimals) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionReturnType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionReturnType) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.filterID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.filterID) END + char(9) +
		CASE WHEN ASRSysExprComponents.expandedNode IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.expandedNode) END + char(9) + 
		CASE WHEN ASRSysExprComponents.promptDateType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDateType) END + char(9) + 
		CASE 
			WHEN ASRSysExprComponents.type = 1 THEN fldtabs.tablename + 
				CASE 
					WHEN (ASRSysExprComponents.fieldPassBy = 2) OR (ASRSysExprComponents.fieldSelectionRecord <> 5) then '' : '' + fldcols.columnname
					ELSE ''''
				END +
				CASE 
					WHEN ASRSysExprComponents.fieldPassBy = 2 then ''''
					ELSE
						CASE 
							WHEN fldrelations.parentID IS null THEN ''''
							ELSE
								CASE 
									WHEN ASRSysExprComponents.fieldSelectionRecord = 1 THEN '' (first record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 2 THEN '' (last record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 3 THEN '' (line '' + convert(varchar(100), ASRSysExprComponents.fieldSelectionLine)
									WHEN ASRSysExprComponents.fieldSelectionRecord = 4 THEN '' (total''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 5 THEN '' (record count''
									ELSE '' (''
								END +
								CASE 
									WHEN fldorders.name IS null THEN ''''
									ELSE '', order by '''''' + fldorders.name + ''''''''
								END  +
								CASE 
									WHEN fldfilters.name IS null then ''''
									ELSE '', filter by '''''' + fldfilters.name + ''''''''
								END + 
								'')''
						END
				END
			WHEN ASRSysExprComponents.type = 2 THEN ASRSysFunctions.functionName
			WHEN ASRSysExprComponents.type = 3 THEN calcexprs.name
			WHEN ASRSysExprComponents.type = 5 THEN ASRSysOperators.name
			WHEN ASRSysExprComponents.type = 10 THEN filtexprs.name
			ELSE ''''
		END + char(9) +
		CASE WHEN fldcols.tableID IS null THEN '''' ELSE convert(varchar(100), fldcols.tableID) END + char(9) + 
		CASE WHEN fldorders.name IS null THEN '''' ELSE fldorders.name END + char(9) + 
		CASE WHEN fldfilters.name IS null THEN '''' ELSE fldfilters.name END
		AS [definition]
	FROM ASRSysExprComponents
	LEFT OUTER JOIN ASRSysExpressions calcexprs ON ASRSysExprComponents.calculationID = calcexprs.exprID
	LEFT OUTER JOIN ASRSysExpressions filtexprs ON ASRSysExprcomponents.filterID = filtexprs.exprID
	LEFT OUTER JOIN ASRSysColumns fldcols ON ASRSysExprComponents.FieldColumnID = fldcols.columnID
	LEFT OUTER JOIN ASRSysTables fldtabs ON fldcols.tableID = fldtabs.tableID
	LEFT OUTER JOIN ASRSysFunctions ON ASRSysExprComponents.functionID = asrsysfunctions.functionID 
	LEFT OUTER JOIN ASRSysOperators ON ASRSysExprComponents.operatorID = asrsysoperators.operatorID 
	LEFT OUTER JOIN ASRSysRelations fldrelations ON (ASRSysExprComponents.fieldTableID = fldrelations.childID and fldrelations.parentID = ' + @sBaseTableID + ')
	LEFT OUTER JOIN ASRSysOrders fldorders ON ASRSysExprComponents.fieldSelectionOrderID = fldorders.orderID
	LEFT OUTER JOIN ASRSysExpressions fldfilters ON ASRSysExprComponents.fieldSelectionFilter = fldfilters.exprID	
	WHERE ASRSysExprComponents.componentID IN (' + @sComponentIDs + ')
	UNION
	SELECT 	
		''E'' as [type],
		ASRSysExpressions.exprID AS [id],
		convert(varchar(100), ASRSysExpressions.exprID)+ char(9) +
		ASRSysExpressions.name + char(9) +
		convert(varchar(100), ASRSysExpressions.tableID) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnType) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnSize) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnDecimals) + char(9) +
		convert(varchar(100), ASRSysExpressions.type) + char(9) +
		convert(varchar(100), ASRSysExpressions.parentComponentID) + char(9) +
		ASRSysExpressions.userName + char(9) +
		ASRSysExpressions.access + char(9) +
		CASE WHEN ASRSysExpressions.description IS null THEN '''' ELSE ASRSysExpressions.description END + char(9) +
		convert(varchar(100), convert(integer, ASRSysExpressions.timestamp)) + char(9) + 
		convert(varchar(100), isnull(ASRSysExpressions.viewInColour, 0)) + char(9) +
		convert(varchar(100), isnull(ASRSysExpressions.expandedNode, 0)) AS [definition]
	FROM ASRSysExpressions
	WHERE ASRSysExpressions.exprID IN (' + @sExprIDs + ')
	ORDER BY [id]';
	
	EXECUTE sp_EXecuteSQL @sExecString;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFunctionParameters]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprFunctionParameters] 
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the runtiume function partameter definitions. */
	DECLARE @fEnableUDFFunctions	bit,
			@sSQLVersion int

	SET @fEnableUDFFunctions = 0
	SELECT @sSQLVersion = dbo.udfASRSQLVersion()

	IF @sSQLVersion >= 8
	BEGIN  
		SET @fEnableUDFFunctions = 1
	END
	SELECT ASRSysFunctions.functionID, 
		ASRSysFunctionParameters.parameterName
	FROM ASRSysFunctions
	LEFT OUTER JOIN ASRSysFunctionParameters ON ASRSysFunctions.functionID = ASRSysFunctionParameters.functionID
	WHERE (ASRSysFunctions.runtime = 1)
		OR ((ASRSysFunctions.UDF = 1) AND (@fEnableUDFFunctions = 1))
	ORDER BY ASRSysFunctions.functionID, ASRSysFunctionParameters.parameterIndex
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprLookupValues]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprLookupValues]
(	@piColumnID		integer,
	@piDataType		integer		OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of values for the given lookup column. */
	DECLARE @sColumnName	sysname,
			@sTableName		sysname,
			@sExecString	nvarchar(MAX);

	SELECT @sColumnName = ASRSysColumns.columnName, 
		@sTableName = ASRSysTables.tableName,
		@piDataType = ASRSysColumns.dataType
	FROM ASRSysColumns
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysColumns.columnID = @piColumnID

	IF @piDataType = 11
	BEGIN
		SET @sExecString = 'SELECT DISTINCT convert(varchar(10), ' + @sColumnName + ', 101) AS lookUpValue' +
			' FROM ' + @sTableName +
			' ORDER BY lookUpValue;';
	END
	ELSE
	BEGIN
		SET @sExecString = 'SELECT DISTINCT ' + @sColumnName + ' AS lookUpValue' +
			' FROM ' + @sTableName +
			' ORDER BY lookUpValue;';
	END
	
	-- Get the data
	EXECUTE sp_executeSQL @sExecString;
	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprOperators]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprOperators]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted operator definitions ;
	<operator id><tab><operator name><tab><operator category> */
	SELECT 
		convert(varchar(100), operatorID) + char(9) +
		name + 
		CASE 
			WHEN len(shortcutKeys) > 0 THEN ' (' + shortcutKeys + ')'
			ELSE ''
		END + char(9) +
		category AS [definitionString]
	FROM [dbo].[ASRSysOperators];
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprTables]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprTables] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted table definitions ;
	<table id><tab><table name><tab><table type><tab><related to base table ?><tab><is child of base table ?> */
	SELECT 
		convert(varchar(255), tableID) + char(9) +
		tableName + char(9) +
		convert(varchar(255), tableType) + char(9) +
		CASE 
			WHEN (tableID = @piTableID) OR (children.childID IS NOT null) OR (parents.parentID IS NOT null) THEN '1'
			ELSE '0'
		END + char(9) +
		CASE 
			WHEN (children.childID IS NOT null) THEN '1'
			ELSE '0'
		END AS [definitionString]
	FROM [dbo].[ASRSysTables]
	LEFT OUTER JOIN ASRSysRelations children ON	(ASRSysTables.tableid = children.childID AND children.parentID = @piTableID)
	LEFT OUTER JOIN ASRSysRelations parents ON	(ASRSysTables.tableid = parents.parentID AND parents.childID = @piTableID)
	ORDER BY tableName;
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFilterPromptedValues]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValues] (
	@piFilterID 		integer,
	@psComponents		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a list of the prompted values in the given filter (and sub-filters). */
	DECLARE	@iComponentID	integer, 
			@iType			integer,
			@sComponents	varchar(MAX),
			@iExprID		integer,
			@iFieldFilterID	integer;

	SET @psComponents = '';

	/* Get the prompted value components, and also the subexpressions (sub-filters and function parameters). */
	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID, 
			type, 
			CASE 
				WHEN type = 3 THEN calculationID
				ELSE filterID
			END AS filterID, 
			fieldSelectionFilter
		FROM [dbo].[ASRSysExprComponents]
		WHERE exprID = @piFilterID
			AND ((type = 7) 
				OR ((type = 1) AND (fieldSelectionFilter > 0)) 
				OR (type = 2) 
				OR (type = 3) 
				OR (type = 10))
		ORDER BY componentID;
		
	OPEN components_cursor;
	FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iType = 1
		BEGIN
			/* Field value with filter. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFieldFilterID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END

		IF @iType = 7
		BEGIN
			/* Prompted value. */
			SET @psComponents = @psComponents + 
				CASE
					WHEN LEN(@psComponents) > 0 THEN ','
					ELSE ''
				END +
				convert(varchar(255), @iComponentID);
		END

		IF (@iType = 10) OR (@iType = 3)
		BEGIN
			/* Sub-filter or calculation. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END
	
		IF @iType = 2
		BEGIN
			/* Function. Check if there are any prompted values in the parameter expressions.. */
			DECLARE function_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT exprID 
				FROM [dbo].[ASRSysExpressions]
				WHERE parentComponentID = @iComponentID;
				
			OPEN function_cursor;
			FETCH NEXT FROM function_cursor INTO @iExprID;
			WHILE (@@fetch_status = 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

				IF LEN(@sComponents) > 0
				BEGIN
					SET @psComponents = @psComponents + 
						CASE
							WHEN LEN(@psComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents;
				END

				FETCH NEXT FROM function_cursor INTO @iExprID;
			END
			CLOSE function_cursor;
			DEALLOCATE function_cursor;
		END
	
		FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	END
	
	CLOSE components_cursor;
	DEALLOCATE components_cursor;

END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowInfo]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetFindWindowInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry 	bit 			OUTPUT, 
	@plngScreenID	integer,
	@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the find window title for the given screen. 	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* Get the screen name. */
	IF @plngScreenID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @psTitle = name,
			@pfQuickEntry = quickEntry
		FROM [dbo].[ASRSysScreens]
		WHERE screenID = @plngScreenID;

		IF @psTitle IS NULL 
		BEGIN
			SET @psTitle = '<unknown screen>';
		END
		IF @pfQuickEntry IS NULL 
		BEGIN
			SET @pfQuickEntry = 0;
		END
	END
	ELSE
	BEGIN
		SET @psTitle = '<unknown screen>';
	END	

	/* Get the view name. */
	IF @plngViewID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @sViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @plngViewID;

		IF @sViewName IS NULL 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkParentValues]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetLinkParentValues] (
	@piChildScreenID 	integer,
	@piTableID 			integer,
	@piRecordID			integer	
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of values from the given record in the given table that in the given child screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iScreenTableID 	integer,
		@iTableType			integer,
		@sTableName			varchar(255),
		@sRealSource 		varchar(1000),
		@iChildViewID 		integer,
		@sViewName 			varchar(255),
		@sSelectSQL 		varchar(MAX),
		@sFromSQL 			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sExecString		nvarchar(MAX),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sTemp				varchar(MAX),
		@sTempSPName		sysname,
		@iLoop				integer,
		@sActualUserName	sysname;

	/* Initialise variables. */
	SET @sSelectSQL = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the screen's table ID. */
	SELECT @iScreenTableID = tableID
	FROM ASRSysScreens
	WHERE screenID = @piChildScreenID

	/* Check if the current user is System or Security Manager. 
	If so we don't need to do so much work figuring out what permissions they have. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	
		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	END

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sRealSource = @sTableName
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	/* Create a temporary table to hold the views that need to be joined. */
	DECLARE @joinViews TABLE(viewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(
		tableViewName	sysname,
		columnName		sysname,
		granted			bit);

	IF @fSysSecMgr = 1
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			@sRealSource,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns
		INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
		WHERE ASRSysTables.tableID = @piTableID

	END
	ELSE
	BEGIN
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piTableID)
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID 
		AND ASRSysColumns.columnID = ASRSysControls.columnID
	WHERE screenID = @piChildScreenID
	AND ASRSysControls.columnID > 0
	AND ASRSysControls.tableID = @piTableID

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @fSysSecMgr = 1 
		BEGIN
			SET @fSelectGranted = 1
		END
		ELSE
		BEGIN

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
		END

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the table. */
			IF len(@sSelectSQL) > 0 SET @sSelectSQL = @sSelectSQL + ', '
			
			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']'
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']'
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END			
		END
		ELSE	
		BEGIN
			IF @iTableType = 1 /* Top-level. */
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sSelectString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableViewName <> @sRealSource
					AND columnName = @sColumnName
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1 

					IF len(@sSelectString) = 0 SET @sSelectString = 'CASE'
	
					IF @iColumnDataType = 11 /* Date */
					BEGIN
						 /* Date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)'
					END
					ELSE
					BEGIN
						 /* Non-date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
					END

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(viewName)
					FROM @joinViews
					WHERE viewName = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinViews (viewName) VALUES(@sViewName)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSelectString) > 0
				BEGIN
					SET @sSelectString = @sSelectString +
						' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']'
					IF LEN(@sSelectSQL) > 0 SET @sSelectSQL = @sSelectSQL + ', '
					SET @sSelectSQL = @sSelectSQL + @sSelectString		
				END
			END

		END

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor

	/* Add the id column to the select string. */
	SELECT @iColumnID = columnID
		FROM ASRSysColumns
		WHERE columnName = 'ID_' + convert(varchar(255), @piTableID)
		AND tableID = @iScreenTableID

	SET @sTemp = 	CASE
			WHEN LEN(@sSelectSQL) > 0 THEN ', '
			ELSE ''
		END + 
		@sRealSource + '.ID AS [' + convert(varchar(100), @iColumnID) + ']'

	SET @sSelectSQL = @sSelectSQL + @sTemp


	/* Create the FROM code. */
	SET @sFromSQL = @sRealSource;
	SELECT @sFromSQL = @sFromSQL
		+ ' LEFT OUTER JOIN ' + ViewName + ' ON ' + @sRealSource
		+ '.ID = ' + ViewName + '.ID'
	FROM @joinViews;


	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF LEN(@sSelectSQL) > 0 
	BEGIN

		/* Create the temp stored procedure name. */
		SET @sTempSPName = ''
		SET @iLoop = 1
		WHILE len(@sTempSPName) = 0
		BEGIN
			SET @sTemp = 'tmpsp_ASRIntGetLinkParentValues' + convert(varchar(100), @iLoop)

			SELECT @iTempCount = COUNT(*)
			FROM sysobjects
			WHERE name = @sTemp

			IF @iTempCount = 0
			BEGIN
				SET @sTempSPName = @sTemp
			END
			ELSE
			BEGIN
				SET @iLoop = @iLoop + 1
			END
		END

		SET @sTemp = convert(varchar(255), @piRecordID)
	
		SET @sExecString = 'CREATE PROCEDURE ' + @sTempSPName + ' AS' +
			' BEGIN' +
			' SELECT ' + @sSelectSQL + 
			' FROM ' + @sFromSQL + 
			' WHERE ' + @sRealSource + '.ID = ' + @sTemp +
			' END'

		-- Create the temporary stored procedure
		EXECUTE sp_executeSQL @sExecString;

		-- Execute the temporary stored procedure
		EXECUTE sp_executeSQL @sTempSPName;

		SET @sExecString = 'DROP PROCEDURE ' + @sTempSPName
		exec sp_executeSQL @sExecString;
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkViews]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetLinkViews]
(
	@plngTableID 		integer,
	@plngDfltOrderID 	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the views of the given table for use in the link find page. */
	DECLARE @sTableName 	varchar(255),
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iChildViewID 		integer,
		@iTableType			integer,
		@lngPermissionCount	integer,
		@sActualUserName	sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table-type. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iTableType = ASRSysTables.tableType,
		@plngDfltOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @plngTableID;

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @viewInfo TABLE(
		viewID		integer,
		viewName	sysname,
		orderTag	integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1)
	BEGIN
		/* Populate the temporary table. */
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		VALUES (
			0,
			@sTableName,
			0);
		
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		(SELECT viewID, 
			viewName,
			1
		FROM [dbo].[ASRSysViews]
		WHERE viewTableID = @plngTableID);
		
	END
	ELSE
	BEGIN
		IF @iTableType <> 2
		BEGIN
			/* Table is a top-level or lookup table. */
			SELECT @lngPermissionCount = COUNT(*)
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protectType <> 206
				AND syscolumns.name <> 'timestamp'
				AND syscolumns.name <> 'ID'
				AND sysobjects.name = @sTableName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

			IF @lngPermissionCount > 0 
			BEGIN
				INSERT INTO @viewInfo (
					viewID, 
					viewName,
					orderTag)
				VALUES (
					0,
					@sTableName,
					0);
			END

			/* Now check on the views on this table. */
			INSERT INTO @viewInfo (
				viewID, 
				viewName,
				orderTag)
			(SELECT ASRSysViews.viewID, 
				ASRSysViews.viewName, 
				1
			FROM [dbo].[ASRSysViews]
			INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
			INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
			WHERE ASRSysViews.viewTableID = @plngTableID
				AND sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protecttype <> 206);
		END
		ELSE
		BEGIN
			/* Get appropriate child view if required. */
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @plngTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				INSERT INTO @viewInfo (
					viewID, 
					viewName,
					orderTag)
				VALUES (
					0,
					@sTableName,
					0);
			END

		END
	END

	/* Return the resultset. */
	SELECT viewID, viewName
		FROM @viewInfo
		ORDER BY orderTag, viewName;
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLookupValues]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetLookupValues] (
	@piColumnID 	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the lookup values for the given lookup column. */
	DECLARE	@sColumnName	sysname,
			@sTableName		sysname,
			@sExecString	nvarchar(MAX);

	SELECT @sTableName = ASRSysTables.tableName,
		@sColumnName = ASRSysColumns.columnName
	FROM ASRSysColumns
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE columnID = @piColumnID;

	SET @sExecString = 'SELECT ' + @sColumnName + 
		' FROM ' + @sTableName +
		' ORDER BY ' + @sColumnName;

	/* Return a recordset of the required columns in the required order from the given table/view. */
	EXECUTE sp_executeSQL @sExecString;
	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetModuleParameter]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetModuleParameter]
(
	@psModuleKey 		varchar(255), 
	@psParameterKey 	varchar(255),
	@psParameter		varchar(1000) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psParameter = parameterValue 
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = @psModuleKey 
		AND parameterKey = @psParameterKey;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetOrders]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetOrders] (@plngTableID int, @plngViewID int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the orders available for the given table/view. */
	DECLARE @lngTableID		int,
		@lngDefaultOrderID	int

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @plngViewID
	END

	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #orderInfo
	(
		orderID			int,
		orderName		sysname,
		defaultOrder		bit
	)

	/* Populate the temporary table with information on the order for the given table. */
   	 INSERT INTO #orderInfo (
		orderID, 
		orderName,
		defaultOrder)	
	(SELECT ASRSysOrders.orderID, 
		ASRSysOrders.name,
		0
	FROM ASRSysOrders
	WHERE ASRSysOrders.tableID = @lngTableID)

	/* Get the table's default order. */
	SELECT @lngDefaultOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @lngTableID

	IF @lngDefaultOrderID > 0 
	BEGIN
		UPDATE #orderInfo
		SET defaultOrder = 1 
		WHERE orderID = @lngDefaultOrderID
	END

	/* Return the resultset. */
	SELECT *
	FROM #orderInfo 
	ORDER BY orderName
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordDescription]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetRecordDescription] (
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@sEvalRecDesc		varchar(8000),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500);

	SET @psRecDesc = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM  [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piTableID;
	END

	/* Get the record description. */
	IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
	BEGIN
		SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(255), @iRecDescID) + ' @recDesc OUTPUT, @recID';
		SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
		EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;

		IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordEditInfo]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetRecordEditInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry	bit				OUTPUT, 
	@piScreenID 	integer, 
	@piViewID 		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the Record Edit window title for the given screen/view . 
	    The title is in the format <screen name>[ - <view name> view)]	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* The title always starts with the screen name. */
	SELECT @psTitle = ASRSysScreens.name,
		@pfQuickEntry = ASRSysScreens.quickEntry
	FROM ASRSysScreens
	WHERE ASRSysScreens.screenID = @piScreenID;

	IF @psTitle IS NULL 
	BEGIN
		SET @psTitle = '<unknown screen>';
	END
	IF @pfQuickEntry IS NULL 
	BEGIN
		SET @pfQuickEntry = 0;
	END

	IF @piViewID > 0
	BEGIN
		/* Find title is the table name with the view name in brackets. */
		SELECT @sViewName = ASRSysViews.viewName
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @piViewID;

		IF (@sViewName IS NULL) 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControls]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControls] (
	@plngScreenID 	int,
	@plngViewId	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the controls in the given screen. */
	SELECT tableID, columnID, controlType,
		topCoord, leftCoord, height, width,	caption
	FROM [dbo].[ASRSysControls]
	WHERE screenID = @plngScreenID;
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlValuesString]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControlValuesString] (
	@plngScreenID 	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the column control values in the given screen. */
	DECLARE @lngColumnID	integer,
		@sValue				varchar(MAX),
		@lngLastColumnID	integer,
		@sDefinition		varchar(MAX);

	DECLARE @valuesInfo TABLE (valueDefinition varchar(MAX));

	SET @lngLastColumnID = 0;
	SET @sDefinition = '';

	DECLARE values_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.value
		FROM ASRSysColumnControlValues
		WHERE ASRSysColumnControlValues.columnID IN (
			SELECT ASRSysControls.columnID
			FROM ASRSysControls
			WHERE ASRSysControls.screenID = @plngScreenID)
		ORDER BY ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.sequence;
				
	OPEN values_cursor;
	FETCH NEXT FROM values_cursor INTO @lngColumnID, @sValue;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @lngLastColumnID <> @lngColumnID
		BEGIN
			IF @lngLastColumnID <> 0
			BEGIN
				INSERT INTO @valuesInfo (valueDefinition) VALUES(@sDefinition);
			END

			SET @sDefinition = convert(varchar(MAX), @lngColumnID) + char(9) + case when @sValue IS null then '' else @sValue end;
		END
		ELSE
		BEGIN
			SET @sDefinition = @sDefinition + char(9) + case when @sValue IS null then '' else @sValue end;
		END

		SET @lngLastColumnID = @lngColumnID;
		FETCH NEXT FROM values_cursor INTO @lngColumnID, @sValue;
	END
	
	CLOSE values_cursor;
	DEALLOCATE values_cursor;

	/* Do the last row. */
	IF @lngLastColumnID <> 0
	BEGIN
		INSERT INTO @valuesInfo (valueDefinition) VALUES(@sDefinition);
	END

	SELECT * FROM @valuesInfo;
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenOrder]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenOrder] (
	@plngOrderID 	int OUTPUT, 
	@plngScreenID	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the order ID of the given screen in the @plngOrderID parameter. */
	DECLARE @lngDefaultOrderID	integer;

	/* Get the order ID, and associated tbale id of the given screen. */
	SELECT @plngOrderID = ASRSysScreens.orderID,
		@lngDefaultOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysScreens
	INNER JOIN ASRSysTables 
		ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.screenID = @plngScreenID;

	/* If no order is defined then use the associated table's default order. */
	IF (@plngOrderID IS NULL) OR (@plngOrderID <= 0)
	BEGIN
		SET @plngOrderID = @lngDefaultOrderID;
	END
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntNewUser]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntNewUser] (
	@psUserName	sysname)
AS
BEGIN

	SET NOCOUNT ON;

	/* Create an user associated with the given SQL login. 
	Put the new user in the current user's role.
	Return 1 if everything is done okay, else 0. */
	DECLARE @hResult 		integer,
		@sRoleName			sysname,
		@sActualUserName	sysname,
		@iUserGroupID		integer;

	/* Create a user in the database for the given login. */
	EXEC @hResult = sp_grantdbaccess @psUsername, @psUserName;
	IF @hResult <> 0 GOTO Done

	/* Determine the current user's role. */
	EXEC dbo.spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Put the new user in the same role as the current user. */
	EXEC @hResult = sp_addrolemember @sRoleName, @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Make the new user a dbo. */
	EXEC @hResult = sp_addrolemember 'db_owner', @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Jump over the error handling code. */
	GOTO Done;

Err:
	/* Remove the user from the database if it was added okay, but not assigned to a role. */
	EXEC sp_revokedbaccess @psUsername;

Done:
	RETURN (@hResult);

END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntPopulateDefsel]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntPopulateDefsel] (
	@intType int, 
	@blnOnlyMine bit,
	@intTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the details with which to populate the intranet defsel grid. */
	DECLARE 
		@strSQL 			nvarchar(MAX),
		@strExplicitSQL 	varchar(MAX),
		@strTableName		varchar(255),
		@strIDName 			varchar(255),
		@sExtraWhereSQL		varchar(MAX),
		@fNewAccess			bit,
		@sRecordSourceWhere	varchar(MAX),
		@sAccessTableName	varchar(255),
		@sRoleName			varchar(255),
		@fSysSecMgr			bit,
		@fDoneWhere			bit,
		@sActualUserName	varchar(250),
		@iActualUserGroupID	integer

	SET @fNewAccess = 0;
	SET @sExtraWhereSQL = '';
	SET @fDoneWhere = 0;
	SET @strExplicitSQL = '';
	
	IF ((@intTableID <=0) OR (@intTableID IS null)) AND (@intType <> 17) AND (@intType <> 9)
	BEGIN
		/* No table ID passed in, so use the first table alphabetically. */
		SELECT TOP 1 @intTableID = tableID
		FROM [dbo].[ASRSysTables]
		ORDER BY tableName;
	END

	IF @intType = 1 /*'crosstabs'*/
	BEGIN
		SET @strTableName = 'AsrSysCrossTab';
		SET @strIDName = 'CrossTabID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCrossTabAccess';
	END

	IF @intType = 2 /*'customreports'*/
	BEGIN
		SET @strTableName = 'AsrSysCustomReportsName';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCustomReportAccess';
	END

	IF @intType = 9 /*'mailmerge'*/
	BEGIN
		SET @strTableName = 'AsrSysMailMergeName';
		SET @strIDName = 'MailMergeID';
		SET @fNewAccess = 1;
		SET @sRecordSourceWhere = 'ASRSysMailMergeName.IsLabel = 0';
		SET @sAccessTableName= 'ASRSysMailMergeAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysMailMergeName.TableID = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 10 /*'picklists'*/
	BEGIN
		SET @strTableName = 'ASRSysPickListName';
		SET @strIDName = 'picklistID';
		SET @sExtraWhereSQL = ' TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 11 /*'filters'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 11 AND (returnType = 3 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 12 /*'calculations'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 10 AND (returnType = 0 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END
	
	IF @intType = 17 /*'calendarreports'*/
	BEGIN
		SET @strTableName = 'ASRSysCalendarReports';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCalendarReportAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysCalendarReports.BaseTable = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 25 /*'workflow'*/
	BEGIN
		SET @strExplicitSQL = 'SELECT 
			Name, 
			replace(ASRSysWorkflows.description, char(9), '''') AS [description],
			'''' AS [Username],
			''rw'' AS [Access],
			ID
			FROM ASRSysWorkflows
			WHERE ASRSysWorkflows.enabled = 1
				AND ISNULL(ASRSysWorkflows.initiationType, 0) = 0
			ORDER BY ASRSysWorkflows.name';
	END
	
	IF len(@strExplicitSQL) > 0 
	BEGIN
		SET @strSQL = @strExplicitSQL;
	END
	ELSE
	BEGIN
		EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT;

		SELECT @fSysSecMgr = 
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE ASRSysGroupPermissions.groupname = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
				ELSE 0
			END;
			
		IF @fNewAccess = 1
		BEGIN
			SET @strSQL = 'SELECT ' + @strTableName + '.Name, ' +
				'replace(' + @strTableName + '.Description, char(9), '''') AS [description], ' +
				'lower(' +@strTableName + '.Username) as ''Username'', ';
				
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(' + @sAccessTableName + '.Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
								
			SET @strSQL = @strSQL +
				@strTableName + '.' + @strIDName + '  as ''ID'' 
				FROM ' + @strTableName + 
				' INNER JOIN ' + @sAccessTableName + ' ON ' + @strTableName + '.' + @strIDName +  ' = ' + @sAccessTableName + '.ID
				AND ' + @sAccessTableName + '.groupname = ''' + @sRoleName + '''';

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END

			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END
			
			SET @strSQL = @strSQL + ' ORDER BY ' + @strTableName + '.Name';
		END
		ELSE
		BEGIN
			SET @strSQL = 'SELECT Name, replace(Description, char(9), '''') AS [description], lower(Username) as ''Username'', ';
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
			SET @strSQL = @strSQL +
				@strIDName + '  as ''ID'' FROM ' + @strTableName;

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END
			
			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END

			SET @strSQL = @strSQL + ' ORDER BY Name';
		END
	END
	
	/* Return the resultset. */
	EXECUTE sp_executeSQL @strSQL;
	
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntSaveSetting]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntSaveSetting] (
	@psSection		varchar(255),
	@psKey			varchar(255),
	@pfUserSetting	bit,
	@psValue		varchar(MAX)	
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Save the given user or system setting. */
	IF @pfUserSetting = 1
	BEGIN
		DELETE FROM [dbo].[ASRSysUserSettings]
		WHERE section = @psSection
			AND settingKey = @psKey
			AND userName = SYSTEM_USER;

		INSERT INTO [dbo].[ASRSysUserSettings]
			(section, settingKey, settingValue, userName)
		VALUES (@psSection, @psKey, @psValue, SYSTEM_USER);
	END
	ELSE
	BEGIN
		DELETE FROM [dbo].[ASRSysSystemSettings]
		WHERE section = @psSection
			AND settingKey = @psKey;

		INSERT INTO [dbo].[ASRSysSystemSettings]
			(section, settingKey, settingValue)
		VALUES (@psSection, @psKey, @psValue);
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntTransferCourse]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntTransferCourse] (
	@piTBRecordID		integer,
	@piCourseRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iEmpTableID			integer,
		@iEmpRecordID			integer,
		@iCourseTableID			integer,
		@iOriginalCourseRecordID	integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@iTBCancelDateColumnID	integer,
		@sTBCancelDateColumnName	sysname,
		@sBookingStatus			varchar(MAX),
		@fTStatusExists			bit,
		@iCount					integer,
		@iChildViewID			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID

	SELECT @iTBCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookCancelDate'
	IF @iTBCancelDateColumnID IS NULL SET @iTBCancelDateColumnID = 0

	SELECT @sTBCancelDateColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBCancelDateColumnID

	/* Check if the 'T' status code exists. */
	SET @fTStatusExists = 0
	SELECT @iCount = count(value)
	FROM ASRSysColumnControlValues
	WHERE columnID = @iTBStatusColumnID
		AND value = 'T'
	IF @iCount > 0 SET @fTStatusExists = 1

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTBRealSource = left(@sTBRealSource, 255)
	END

	SET @sTempExecString = 'SELECT @iEmpRecordID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		', @iOriginalCourseRecordID = ID_' + convert(nvarchar(100), @iCourseTableID) +
		', @sBookingStatus = ' + @sTBStatusColumnName +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)
	SET @sTempParamDefinition = N'@iEmpRecordID integer OUTPUT, @iOriginalCourseRecordID integer OUTPUT, @sBookingStatus varchar(MAX) OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iEmpRecordID OUTPUT, @iOriginalCourseRecordID OUTPUT, @sBookingStatus OUTPUT


	IF @iEmpRecordID IS null SET @iEmpRecordID = 0
	IF @iOriginalCourseRecordID IS null SET @iOriginalCourseRecordID = 0

	/* Create the new booking record. */
	SET @sTempExecString = 'INSERT INTO ' + @sTBRealSource + 
		' (' + @sTBStatusColumnName +
		', id_' + convert(nvarchar(100), @iEmpTableID) +
		', id_' + convert(nvarchar(100), @iCourseTableID) +
		') VALUES (''' + @sBookingStatus + '''' +
		', ' + convert(nvarchar(100), @iEmpRecordID) +
		', ' + convert(nvarchar(100), @piCourseRecordID) + ')'
	EXEC sp_executesql @sTempExecString

	/* Update the old booking record. */     
	SET @sTempExecString = 'UPDATE ' + @sTBRealSource + 
		' SET ' + @sTBStatusColumnName + ' = ' + 
		CASE @fTStatusExists
			WHEN 1 THEN '''T'''
			ELSE '''C'''
		END

	IF len(@sTBCancelDateColumnName) > 0 
	BEGIN
		SET @sTempExecString = @sTempExecString +
			', ' + @sTBCancelDateColumnName + ' = getdate()'
	END

	SET @sTempExecString = @sTempExecString +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)

	EXEC sp_executesql @sTempExecString
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateBulkBookings]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntValidateBulkBookings] (
	@piCourseRecordID				integer,
	@psEmployeeRecordIDs			varchar(MAX),
	@psBookingStatus				varchar(MAX),
	@psErrorMessage				varchar(MAX)	OUTPUT,
	@psPreReqCheckFailsCount			integer	  	OUTPUT,
	@psUnavailabilityCheckFailCount	integer		OUTPUT,
	@psOverlapCheckFailCount			integer		OUTPUT,
	@psCourseOverbooked				integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks on booking being made. 
	Return codes are:
		000 - completely valid
		If non-zero then the result code is composed as abc,
		where a is the result of the OVERBOOKING check
			a is the result of the PRE-REQUISITES check
			b is the result of the AVAILABILITY check
			c is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overlapped bookings check, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 012.

		The SP returns a table indicating the result code for each Employee record (see below) plus a parameter that indicates if the course is overbooked

		EmployeeID  ResultCode
		----------- ----------
		1094        020		--> ResultCode is codified as described above
		961         000	     --> ResultCode is codified as described above

		The output @psCourseOverbooked parameter will be set to one of the following values:
		  0 - No overbooking
		  1 - Course fully booked
		  2 - Course fully booked (over-rideable by the user).
	*/

	DECLARE	
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount				integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@iIndex				integer,
			@fFailure				bit,
			@iEmployeeID			integer,
			@fDoPreReqCheck		bit,
			@iPreReqTableID		integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sTemp				varchar(MAX),
			@piTableID			integer,
			@psRecordDescription	varchar(MAX),
			@psEmployeeName		varchar(MAX),
			@piResultCode			varchar(10)


	SET @piResultCode = ''
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0
	SET @psErrorMessage = ''
	SET @psPreReqCheckFailsCount = 0
	SET @psUnavailabilityCheckFailCount = 0
	SET @psOverlapCheckFailCount = 0
	SET @psCourseOverbooked = 0
	
	DECLARE @TempTable TABLE (EmployeeID INTEGER, EmployeeName VARCHAR(MAX), ResultCode VARCHAR(5))

	/* Clean the input string parameters. */
	IF len(@psEmployeeRecordIDs) > 0 SET @psEmployeeRecordIDs = replace(@psEmployeeRecordIDs, '''', '''''')

	/* Check if we need to do the overbooking check. */
	SELECT @sTemp = parameterValue
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseIncludeProvisionals'
	IF @psBookingStatus = 'B' OR @sTemp = 'TRUE'
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1
	END
	
	/* Check if we need to do the pre-requisite check. */
	SELECT @iPreReqTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_PreReqTable'
	IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

	IF @iPreReqTableID > 0 
	BEGIN
		/* Check if the pre-req stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoPreReqCheck = 1
	END

	/* Check if we need to do the unavailibility check. */
	SELECT @iUnavailTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_UnavailTable'
	IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

	IF @iUnavailTableID > 0 
	BEGIN
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckUnavailability')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
	END

	/* Check if we need to do the overlap check. */
	/* Check if the unavailibility stored procedure exists. */
	SELECT @iCount = COUNT(*) 
	FROM sysobjects
	WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
		AND sysstat & 0xf = 4
	
	IF @iCount > 0 SET @fDoOverlapCheck = 1

	/* Loop thourgh the given employee records. */
	SET @fFailure = 0
	SET @piResultCode = ''
	SET @iNumberBooked = 0

	WHILE len(@psEmployeeRecordIDs) > 0
	BEGIN
		/* Rip out the individual employee record ID from the given comma-delimited string of employee IDs. */
		SELECT @iIndex = charindex(',', @psEmployeeRecordIDs)
		IF @iIndex > 0
		BEGIN
			SET  @iEmployeeID = substring(@psEmployeeRecordIDs, 1, @iIndex - 1)
			SELECT @psEmployeeRecordIDs = substring(@psEmployeeRecordIDs, @iIndex + 1, len(@psEmployeeRecordIDs))
		END
		ELSE
		BEGIN
			SET  @iEmployeeID = @psEmployeeRecordIDs
			SET @psEmployeeRecordIDs = ''
		END

		BEGIN
			SET @piTableID = 1 /* Need to derive the Personnel table */
			EXECUTE dbo.spASRRecordDescription 1, @iEmployeeID, @psRecordDescription OUTPUT
			SET  @psEmployeeName = @psRecordDescription
		END

		IF @fDoPreReqCheck = 1
		BEGIN
				/* Return 0 if the given record in the personnel table has satisfied the pre-requisite criteria for the given course record.
				Return 1 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record.
				Return 2 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record but the user can override this failure. */
				exec sp_ASR_TBCheckPreRequisites @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				IF @iResult = 1 OR @iResult = 2
				BEGIN
	   				SET @psPreReqCheckFailsCount = @psPreReqCheckFailsCount + 1
				END
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
				exec sp_ASR_TBCheckUnavailability @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				/* Return 0 if the given record in the personnel table IS available for the given course record.
				Return 1 if the given record in the personnel table is NOT available for the given course record.
				Return 2 if the given record in the personnel table is NOT available for the given course record but the user can override this failure. */
				IF @iResult = 1  OR @iResult = 2
				BEGIN
					SET @psUnavailabilityCheckFailCount = @psUnavailabilityCheckFailCount + 1
				END				
				 
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		IF @fDoOverlapCheck = 1
		BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecordID,  @iEmployeeID, 0, @iResult OUTPUT
				  /* Return 0 if the given course does NOT overlap with another course that the given delegate is booked on.
				  Return 1 if the given course DOES overlap with another course that the given delegate is booked on.
				  Return 2 if the given course does NOT overlap with another course that the given delegate is booked on, but the user can override this failure. */
				IF @iResult = 1  OR @iResult = 2
				BEGIN
					SET @psOverlapCheckFailCount = @psOverlapCheckFailCount + 1
				END
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		INSERT INTO @TempTable VALUES (@iEmployeeID, @psEmployeeName, @piResultCode)

		SET @iNumberBooked = @iNumberBooked + 1

		SET @piResultCode = ''
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		SET @psCourseOverbooked = @iResult
	END

	SELECT EmployeeID, EmployeeName, ResultCode FROM @TempTable
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntValidatePicklist] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@psAccess 			varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								2 = definition changed by someone else, overwrite ? */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp			integer,
			@sAccess			varchar(MAX),
			@sOwner				varchar(255),
			@iCount				integer,
			@sCurrentUser		sysname;

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysPickListName]
		WHERE picklistID = @piUtilID;

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The picklist has been deleted by another user.<BR>Save as a new definition ?';
			SET @piErrorCode = 1;
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sAccess = access, 
				@sOwner = userName
			FROM [dbo].[ASRSysPickListName]
			WHERE picklistID = @piUtilID;

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user and is now Read Only.<BR>Save as a new definition ?';
					SET @piErrorCode = 1;
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user.<BR>Would you like to overwrite this definition ?';
					SET @piErrorCode = 2;
				END
			END
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist2]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntValidatePicklist2] (
	@psUtilName 		varchar(255),
	@piUtilID 			integer,
	@psAccess 			varchar(MAX),
	@piBaseTableID 		integer, 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = error, 
								2 = definition used in utilities owned by the current user. Prompt to make these hidden too. */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount					integer,
			@sCurrentUser			sysname,
			@iHiddenCheckResult 	integer,
			@sHiddenCheckMessage	varchar(MAX);

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	/* Check that the picklist name is unique. */
	IF @piUtilID > 0
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND picklistID <> @piUtilID
			AND tableID = @piBaseTableID;
	END
	ELSE
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND tableID = @piBaseTableID;
	END

	IF @iCount > 0 
	BEGIN
		SET @psErrorMsg = 'A picklist called ''' + @psUtilName + ''' already exists.';
		SET @piErrorCode = 1;
	END

	IF (@piErrorCode = 0) AND (@psAccess = 'HD') AND (@piUtilID > 0)
	BEGIN
		/* Check that the picklist can be made hidden (ie. is not used in any utilities owned by other people. */
		exec [dbo].[sp_ASRIntCheckCanMakeHidden] 10, @piUtilID, @iHiddenCheckResult OUTPUT, @sHiddenCheckMessage OUTPUT;

		IF @iHiddenCheckResult = 1
		BEGIN
			/* picklist used only in utilities owned by the current user - we then need to prompt the user if they want to make these utilities hidden too. */
			SET @psErrorMsg = 'Changing the selected picklist to hidden will automatically make the following definition(s), of which you are the owner, hidden also :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage +
				'<BR><BR>' +
				'Do you wish to continue ?';
			SET @piErrorCode = 2;
		END

		IF @iHiddenCheckResult = 2
		BEGIN
			/* picklist used in utilities which are in batch jobs not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 3
		BEGIN
			/* picklist used in utilities which are not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in the following definition(s), of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 4
		BEGIN
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs which are scheduled to be run by other user groups :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
 				
			SET @piErrorCode = 1;
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateTransfers]    Script Date: 23/07/2013 11:18:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntValidateTransfers] (
	@piEmployeeTableID			integer,
	@piCourseTableID			integer,
	@piCourseRecordID			integer,
	@piTransferCourseRecordID	integer,
	@piTrainBookTableID			integer,
	@piTrainBookStatusColumnID	integer,
	@piResultCode				integer			OUTPUT,
	@psErrorMessage				varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks
	on booking being transferred from one course (@piCourseRecordID) to another (@piTransferCourseRecordID). 
	Return codes are :
		0 - completely valid
		If non-zero then the result code is composed as abcd,
		where a is the result of the OVERBOOKING check
			b is the result of the PRE-REQUISITES check
			c is the result of the AVAILABILITY check
			d is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overbooking or overlapped bookings checks, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 0120.
	*/
	DECLARE	@sCommand				nvarchar(MAX),
			@sParamDefinition		nvarchar(500),
			@iUserGroupID			integer,
			@sUserGroupName			sysname,
			@iChildViewID			integer,
			@fTransferProvisionals	bit,
			@sTemp					varchar(MAX),
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount					integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@sTBTableName			sysname,
			@sTrainBookRealSource	sysname,
			@sTrainBookStatusColumnName		sysname,
			@fDoPreReqCheck			bit,
			@iPreReqTableID			integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sActualUserName		sysname;

	SET @piResultCode = 0
	SET @psErrorMessage = ''
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTrainBookRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTrainBookRealSource = left(@sTrainBookRealSource, 255)
	END
	ELSE
	BEGIN
		SET @psErrorMessage = 'Unable to determine the Training Booking child view.'
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		IF @piTrainBookStatusColumnID > 0
		BEGIN
			SELECT @sTrainBookStatusColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @piTrainBookStatusColumnID
			IF @sTrainBookStatusColumnName IS NULL SET @psErrorMessage = 'Unable to find the Training Booking Status column.'
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if we need to transfer provisional bookings. */
		SET @sTemp = ''
		SELECT @sTemp = convert(varchar(MAX), parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTransferProvisionals'
		IF @sTemp IS NULL SET @sTemp = ''
		IF @sTemp = 'TRUE'
		BEGIN
			SET @fTransferProvisionals = 1
		END
		ELSE
		BEGIN
			SET @fTransferProvisionals = 0
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if the overbooking stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1

		/* Check if we need to do the pre-requisite check. */
		SELECT @iPreReqTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_PreReqTable'
		IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

		IF @iPreReqTableID > 0 
		BEGIN
			/* Check if the pre-req stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoPreReqCheck = 1
		END

		/* Check if we need to do the unavailibility check. */
		SELECT @iUnavailTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_UnavailTable'
		IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

		IF @iUnavailTableID > 0 
		BEGIN
			/* Check if the unavailibility stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckUnavailability')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
		END

		/* Check if we need to do the overlap check. */
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoOverlapCheck = 1
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		SET @sCommand = 
			'DECLARE @iEmployeeID	integer,' +
			'	@sStatus		varchar(MAX),' + 
			'	@iResult		integer,' +
			'	@fFailure		bit,' +
			'	@sCodeString		varchar(10),' +
			'	@sCurrentCode		varchar(1)' +
			' SET @piResultCode = 0' +
			' SET @fFailure = 0' +
			' SET @piNumberBooked = 0' +
			' DECLARE transfersCursor CURSOR LOCAL FAST_FORWARD FOR ' + 
			' SELECT id_' + convert(nvarchar(100), @piEmployeeTableID) + 
			', ' + @sTrainBookStatusColumnName +
			' FROM ' + @sTrainBookRealSource +
			' WHERE id_' + convert(nvarchar(100), @piCourseTableID) + ' = ' + convert(nvarchar(100), @piCourseRecordID)

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B'''
		END

		SET @sCommand = @sCommand  + 
			' OPEN transfersCursor' +
			' FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' WHILE (@@fetch_status = 0) AND (@fFailure = 0)' +
			' BEGIN' +
			'	SET @sCodeString = convert(varchar(10), @piResultCode)'

		IF @fDoPreReqCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF LEN(@sCodeString) >= 3' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 3), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckPreRequisites ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Pre-requisites not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (100 * convert(integer, @sCurrentCode)) + (100 * @iResult)' +
				'	END'
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 2' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 2), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckUnavailability ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Unavailability check not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (10 * convert(integer, @sCurrentCode)) + (10 * @iResult)' +
				'	END'
		END

		IF @fDoOverlapCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 1' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 1), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckOverlappedBooking ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, 0, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Overlapped booking (error). */' +
				'		SET @piResultCode = @piResultCode - convert(integer, @sCurrentCode) + @iResult' +
				'	END'
		END

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' SET @piNumberBooked = @piNumberBooked + 1'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' IF @sStatus = ''B'' SET @piNumberBooked = @piNumberBooked + 1'
		END

		SET @sCommand = @sCommand  + 
			'	FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' END' +
			' CLOSE transfersCursor' +
			' DEALLOCATE transfersCursor'

		SET @sParamDefinition = N'@piResultCode integer OUTPUT, @piNumberBooked integer OUTPUT'
		EXEC sp_executesql @sCommand,  @sParamDefinition, @piResultCode OUTPUT, @iNumberBooked OUTPUT
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piTransferCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		IF @iResult = 1 /* Course fully booked (error). */
		BEGIN
			SET @piResultCode = @piResultCode + 1000
		END
		IF @iResult = 2 /* Course fully booked (over-rideable by the user). */
		BEGIN
			SET @piResultCode = @piResultCode + 2000
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntSetEventLogPurge]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntSetEventLogPurge]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetViewName]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetViewName]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityName]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetUtilityName]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityAccessRecords]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetTimestamp]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetTimestamp]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetSummaryValues]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetSummaryValues]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetSingleRecordViewID]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetSingleRecordViewID]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordSelection]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetRecordSelection]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordDescriptionInView]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetRecordDescriptionInView]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParentValues]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetParentValues]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPageTitle]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetPageTitle]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetOpFuncShortcuts]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetOpFuncShortcuts]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetNavigationLinks]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetNavigationLinks]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupViews]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetLookupViews]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupFilterValue]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetLookupFilterValue]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLinkInfo]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetLinkInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogRecords]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogRecords]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogPurgeDetails]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogPurgeDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmails]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogEmails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmailInfo]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogDetails]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogBatchDetails]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEmailGroupAddresses]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetEmailGroupAddresses]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetDefaultOrder]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetDefaultOrder]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarColours]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetCalendarColours]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailablePicklists]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailablePicklists]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableOrdersInfo]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableOrdersInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFiltersInfo]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableFiltersInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFilters]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableFilters]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAllExprRootIDs]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetAllExprRootIDs]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualUserDetailsForLogin]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetActualUserDetailsForLogin]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualLogin]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntGetActualLogin]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGet1000SeparatorFindColumns]    Script Date: 23/07/2013 11:19:27 ******/
IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGet1000SeparatorFindColumns]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGet1000SeparatorFindColumns]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteEventLogRecords]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntDeleteEventLogRecords]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteCheck]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntDeleteCheck]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCurrentUserAccess]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntCurrentUserAccess]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntClearEventLogPurge]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntClearEventLogPurge]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCheckSPExists]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntCheckSPExists]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntAllTablePermissions]    Script Date: 23/07/2013 11:19:27 ******/
DROP PROCEDURE [dbo].[spASRIntAllTablePermissions]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntAllTablePermissions]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntAllTablePermissions]
(
	@psSQLLogin 		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	-- Cached view of the objects 
	DECLARE @SysObjects TABLE([ID]		integer PRIMARY KEY CLUSTERED,
							  [Name]	sysname);
							  
	INSERT INTO @SysObjects
		SELECT [ID], [Name] FROM sysobjects
		WHERE [Name] LIKE 'ASRSysCV%' AND [XType] = 'v'
		UNION 
		SELECT OBJECT_ID(tableName), TableName 
		FROM ASRSysTables
		WHERE NOT OBJECT_ID(tableName) IS null
		UNION
		SELECT OBJECT_ID(viewName), ViewName 
		FROM ASRSysViews
		WHERE NOT OBJECT_ID(viewName) IS null;

	-- Cached view of the sysprotects table
	DECLARE @SysProtects TABLE([ID]				integer,
							   [columns]		varbinary(8000),
							   [Action]			tinyint,
							   [ProtectType]	tinyint);
	INSERT INTO @SysProtects
	SELECT p.ID, p.Columns, p.Action, p.ProtectType FROM #SysProtects p
		INNER JOIN @SysObjects o ON p.ID = o.ID
		WHERE ((p.ProtectType <> 206 AND p.Action <> 193) OR (p.Action = 193 AND p.ProtectType IN (204,205)));

	SELECT o.name, p.action, ISNULL(cv.tableID,0) AS [tableid]
		FROM @SysProtects p
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE p.protectType <> 206
			AND p.action <> 193
	UNION
	SELECT o.name, 193, ISNULL(cv.tableID,0) AS [tableid]
		FROM sys.columns c
		INNER JOIN @SysProtects p ON (c.object_id = p.id
			AND p.action = 193 
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) = 0)))
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE (c.name <> 'timestamp' AND c.name <> 'ID')
			AND p.protectType IN (204, 205) 
		ORDER BY o.name;


END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCheckSPExists]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntCheckSPExists]
(
	@psPrefix			varchar(255),
	@plngTableID		integer,
	@pfExists			bit		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSPName	varchar(MAX),
			@iCount		integer;

	SET @pfExists = 0;
	SET @sSPName = @psPrefix + convert(varchar(255), @plngTableID);

	IF NOT @sSPName IS null
	BEGIN
		SELECT @iCount = COUNT([Name])
		FROM sysobjects
		WHERE type = 'P'
			AND name = @sSPName;

		IF @iCount > 0 
		BEGIN
			SET @pfExists = 1;
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntClearEventLogPurge]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntClearEventLogPurge]
AS
BEGIN

	SET NOCOUNT ON;

	DELETE FROM [dbo].[ASRSysEventLogPurge];
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCurrentUserAccess]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntCurrentUserAccess] (
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRoleName			varchar(255),
		@sActualUserName	sysname,
		@iActualUserGroupID	integer,
		@fEnabled			bit

	SET @sTableName = '';
	SET @psAccess = 'HD';

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @sRoleName + '''';

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteCheck]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntDeleteCheck] (
	@piUtilityType	integer,
	@plngID			integer,
	@pfDeleted		bit				OUTPUT,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fNewAccess			bit,
		@iCount				integer,
		@sAccess			varchar(MAX),
		@fSysSecMgr			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';
	SET @pfDeleted = 0;
	SET @fNewAccess = 0;

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
		SET @fNewAccess = 1;
  END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
		SET @fNewAccess = 1
  END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
		SET @fNewAccess = 1;
  END

	IF (@piUtilityType = 11) OR (@piUtilityType = 12)  /* Filters/Calcs */
	BEGIN
		SET @sTableName = 'ASRSysExpressions';
		SET @sIDColumnName = 'exprID';
  END

	IF (@piUtilityType = 10)  /* Picklists */
	BEGIN
		SET @sTableName = 'ASRSysPicklistName';
		SET @sIDColumnName = 'picklistID';
  END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @iCount = COUNT(*)
				FROM ' + @sTableName + 
				' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0 
		BEGIN
			SET @pfDeleted = 1;
		END
		ELSE
		BEGIN
			IF @fNewAccess = 1
			BEGIN
				exec [dbo].[spASRIntCurrentUserAccess] @piUtilityType,	@plngID, @psAccess OUTPUT;
			END
			ELSE
			BEGIN
				exec [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
				
				IF @fSysSecMgr = 1 
				BEGIN
					SET @psAccess = 'RW';
				END
				ELSE
				BEGIN
					SET @sSQL = 'SELECT @sAccess = CASE 
								WHEN userName = system_user THEN ''RW''
								ELSE access
							END
							FROM ' + @sTableName + 
							' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
					SET @sParamDefinition = N'@sAccess varchar(MAX) OUTPUT';
					EXEC sp_executesql @sSQL,  @sParamDefinition, @sAccess OUTPUT;

					SET @psAccess = @sAccess;
				END
			END
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteEventLogRecords]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntDeleteEventLogRecords]
(
		@piDeleteType			integer,
		@psSelectedEventIDs		varchar(MAX),
		@pfCanViewAll			bit
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sSQL	nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psSelectedEventIDs) > 0 SET @psSelectedEventIDs = replace(@psSelectedEventIDs, '''', '''''');

	IF (@piDeleteType = 0) OR (@piDeleteType = 1)
	BEGIN
		/* 0 = Delete all the selected rows */
		/* 1 = Delete all the rows shown */
		SET @sSQL = 'DELETE FROM ASRSysEventLog' +
			' WHERE ID IN (' + @psSelectedEventIDs + ')';
		EXEC sp_executesql @sSQL;
	END
	
	IF @piDeleteType = 2
	BEGIN
		/* Delete all the records the user has permission to see */
		IF @pfCanViewAll = 1
		BEGIN
			DELETE FROM [dbo].[ASRSysEventLog];
		END
		ELSE
		BEGIN
			DELETE FROM [dbo].[ASRSysEventLog] 
			WHERE username = SYSTEM_USER;
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualLogin]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetActualLogin]
(
	@psActualLogin		nvarchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound	integer;

	/* Is this user logged in under a specific login, or as part of a Windows Group login */
	SELECT @iFound = Count(*) FROM sysusers WHERE name = SYSTEM_USER;
	IF (@iFound > 0)
		SET @psActualLogin = SYSTEM_USER;
	ELSE
		SELECT TOP 1 @psActualLogin = name FROM sysusers
			WHERE is_member(Name) & IsNTGroup = 1;

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetActualUserDetailsForLogin]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE Procedure [dbo].[spASRIntGetActualUserDetailsForLogin]
(
		@psLogin sysname,
		@psUserName sysname OUTPUT,
		@psUserGroup sysname OUTPUT,
		@piUserGroupID integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound		int

	SELECT @iFound = COUNT(*) 
	FROM sysusers usu 
	LEFT OUTER JOIN	(sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = @psLogin
		AND CASE
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
		END NOT LIKE 'ASRSys%'

	IF (@iFound > 0)
	BEGIN
		SELECT	@psUserName = usu.name,
			@psUserGroup = CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND lo.loginname = @psLogin
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END NOT LIKE 'ASRSys%'
	END
	ELSE
	BEGIN
		SELECT @psUserName = usu.name, 
			@psUserGroup = CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND is_member(lo.loginname) = 1
			AND CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END NOT LIKE 'ASRSys%'
	END
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAllExprRootIDs]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetAllExprRootIDs]
(
		@iExprID integer,
		@superExpressions cursor varying output
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a cursor of the expressions that use the given expression. */
	DECLARE	@iComponentID	integer,
					@iRootExprID	integer,
					@superCursor	cursor,
					@iTemp				integer

	CREATE TABLE #superExpressionIDs (id integer)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID
		FROM ASRSysExprComponents
		WHERE (calculationID = @iExprID)
			OR (filterID = @iExprID)
			OR ((fieldSelectionFilter = @iExprID) AND (type = 1))

	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iComponentID
	WHILE (@@fetch_status = 0)
	BEGIN
		exec sp_ASRIntGetRootExpressionIDs @iComponentID, @iRootExprID	OUTPUT

		INSERT INTO #superExpressionIDs (id) VALUES (@iRootExprID)
		
		exec spASRIntGetAllExprRootIDs @iRootExprID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO #superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		FETCH NEXT FROM check_cursor INTO @iComponentID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor
	
	SET @superExpressions = CURSOR FORWARD_ONLY STATIC FOR
		SELECT id FROM #superExpressionIDs
	OPEN @superExpressions
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFilters]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetAvailableFilters] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFiltersInfo]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetAvailableFiltersInfo] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name, 
		username, 
		access 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableOrdersInfo]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetAvailableOrdersInfo] (
	@plngTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT orderid AS [ID], 
		name, 
		'' AS username, 
		'' AS access 
	FROM ASRSysOrders 
	WHERE tableid = @plngTableID  
		AND type = 1 
		ORDER BY [name];
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailablePicklists]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetAvailablePicklists] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT picklistid AS [ID], 
		name 
	FROM [dbo].[ASRSysPicklistName]
	WHERE tableid = @plngTableID 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarColours]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetCalendarColours]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ASRSysColours.ColOrder, 
		ASRSysColours.ColValue,
		ASRSysColours.ColDesc, 
		ASRSysColours.WordColourIndex,
		ASRSysColours.CalendarLegendColour
	FROM ASRSysColours
	WHERE (ASRSysColours.CalendarLegendColour = 1)
		AND (ASRSysColours.ColValue NOT IN (13434879))
	ORDER BY ASRSysColours.ColOrder;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetDefaultOrder]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetDefaultOrder] (
	@piTableID	integer,
	@piOrderID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piOrderID = defaultOrderID
	FROM ASRSysTables
	WHERE tableID = @piTableID;
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetEmailGroupAddresses]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEmailGroupAddresses]
	(@EmailGroupID int)
AS
BEGIN

	SET NOCOUNT ON;

	select Fixed from ASRSysEmailAddress
	where EmailID in
	(select EmailDefID from ASRSysEmailGroupItems where EmailGroupID = @EmailGroupID)
	order by [Name];

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogBatchDetails]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails] (
	@piBatchRunID 	integer,
	@piEventID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sExecString		nvarchar(MAX),
			@sSelectString 		varchar(MAX),
			@sFromString		varchar(MAX),
			@sWhereString		varchar(MAX),
			@sOrderString 		varchar(MAX);

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 
		 ID, 
		 DateTime,
		 EndTime,
		 IsNull(Duration,-1) AS Duration,
		 Username,
		 CASE Type 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
		 END AS Type,
		 Name,
		 CASE Mode 
			WHEN 1 THEN ''Batch''
			WHEN 0 THEN ''Manual''
			ELSE ''Unknown''
		 END AS Mode, 
		 CASE Status 
				WHEN 0 THEN ''Pending''
		   	WHEN 1 THEN ''Cancelled'' 
				WHEN 2 THEN ''Failed'' 
				WHEN 3 THEN ''Successful'' 
				WHEN 4 THEN ''Skipped'' 
				WHEN 5 THEN ''Error''
				ELSE ''Unknown'' 
		 END AS Status,
		 IsNull(BatchName,'''') AS BatchName,
		 IsNull(convert(varchar,SuccessCount), ''N/A'') AS SuccessCount,
		 IsNull(convert(varchar,FailCount), ''N/A'') AS FailCount,
		 IsNull(convert(varchar,BatchJobID), ''N/A'') AS BatchJobID,
		 IsNull(convert(varchar,BatchRunID), ''N/A'') AS BatchRunID';

	SET @sFromString = ' FROM ASRSysEventLog ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE BatchRunID = ' + convert(varchar, @piBatchRunID);
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE ID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY DateTime ASC ';

	SET @sExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;

	-- Run generated statement
	EXEC sp_executeSQL @sExecString;
	
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogDetails]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogDetails] (
	@piBatchRunID	integer,
	@piEventID		integer,
	@piExists		integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sSelectString			varchar(MAX),
			@sFromString			varchar(255),
			@sWhereString			varchar(MAX),
			@sOrderString 			varchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer;

	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(*) FROM ASRSysEventLog WHERE ID = ' + convert(varchar,@piEventID);

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piExists = @iCount;
	/****************************************************************************************************************************************/

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT [ID], [EventLogID], IsNull([Notes],'''') AS ''Notes'' ';

	SET @sFromString = ' FROM AsrSysEventLogDetails ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE AsrSysEventLogDetails.EventLogID IN (SELECT ID FROM ASRSysEventLog WHERE BatchRunID = ' + convert(varchar, @piBatchRunID) + ')';
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE AsrSysEventLogDetails.EventLogID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY AsrSysEventLogDetails.[ID] ';
	
	SET @sTempExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;
	EXEC sp_executesql @sTempExecString;
	
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmailInfo]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo] (
	@psSelectedIDs	varchar(MAX),
	@psSubject		varchar(MAX) OUTPUT,
	@psOrderColumn	varchar(MAX),
	@psOrderOrder	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSelectString 	nvarchar(MAX),
			@sOrderSQL		varchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	SELECT @psSubject = IsNull(SettingValue,'<<Unknown Customer>>') + ' - Event Log' 
	FROM ASRSysSystemSettings 
	WHERE Lower(Section) = 'licence' 
		AND Lower(SettingKey) = 'customer name';

	SET @sSelectString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 	A.ID, 
		A.Name, 
		A.DateTime,
		A.EndTime,
		IsNull(A.Duration,-1) AS Duration, 
		A.Username, 
		CASE A.Mode 
			WHEN 1 THEN ''Batch'' 
			ELSE ''Manual'' 
		END AS ''Mode'', 
		CASE A.Status 
			WHEN 0 THEN ''Pending''
		  WHEN 1 THEN ''Cancelled'' 
			WHEN 2 THEN ''Failed'' 
			WHEN 3 THEN ''Successful'' 
			WHEN 4 THEN ''Skipped'' 
			WHEN 5 THEN ''Error''
			ELSE ''Unknown'' 
		END AS Status, 
		CASE A.Type 
			WHEN 0 THEN ''Unknown''
			WHEN 1 THEN ''Cross Tab'' 
			WHEN 2 THEN ''Custom Report'' 
			WHEN 3 THEN ''Data Transfer'' 
			WHEN 4 THEN ''Export'' 
			WHEN 5 THEN ''Global Add'' 
			WHEN 6 THEN ''Global Delete'' 
			WHEN 7 THEN ''Global Update'' 
			WHEN 8 THEN ''Import'' 
			WHEN 9 THEN ''Mail Merge'' 
			WHEN 10 THEN ''Diary Delete'' 
			WHEN 11 THEN ''Diary Rebuild''
			WHEN 12 THEN ''Email Rebuild''
			WHEN 13 THEN ''Standard Report''
			WHEN 14 THEN ''Record Editing''
			WHEN 15 THEN ''System Error''
			WHEN 16 THEN ''Match Report''
			WHEN 17 THEN ''Calendar Report''
			WHEN 18 THEN ''Envelopes & Labels''
			WHEN 19 THEN ''Label Definition''
			WHEN 20 THEN ''Record Profile''
			WHEN 21	THEN ''Succession Planning''
			WHEN 22 THEN ''Career Progression''
			WHEN 25 THEN ''Workflow Rebuild''
			ELSE ''Unknown''  
		END AS Type,
		CASE 
			WHEN A.SuccessCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.SuccessCount)
		END AS SuccessCount,
		CASE
			WHEN A.FailCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.FailCount)
		END AS FailCount,
		A.BatchName AS BatchName,
		A.BatchJobID AS BatchJobID,
		A.BatchRunID AS BatchRunID,
		B.Notes, 
		B.ID AS ''DetailsID'' ,
		(SELECT count(ID) 
			FROM ASRSysEventLogDetails C 
			WHERE C.EventLogID = A.ID) as ''count''
		FROM ASRSysEventLog A
		LEFT OUTER JOIN ASRSysEventLogDetails B
			ON A.ID = B.EventLogID
		WHERE A.ID IN (' + @psSelectedIDs + ')';

	SET @sOrderSQL = '';
	
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
				WHEN 1 THEN ''Cross Tab''
				WHEN 2 THEN ''Custom Report''
				WHEN 3 THEN ''Data Transfer''
				WHEN 4 THEN ''Export''
				WHEN 5 THEN ''Global Add''
				WHEN 6 THEN ''Global Delete''
				WHEN 7 THEN ''Global Update''
				WHEN 8 THEN ''Import''
				WHEN 9 THEN ''Mail Merge''
				WHEN 10 THEN ''Diary Delete''
				WHEN 11 THEN ''Diary Rebuild''
				WHEN 12 THEN ''Email Rebuild''
				WHEN 13 THEN ''Standard Report''
				WHEN 14 THEN ''Record Editing''
				WHEN 15 THEN ''System Error''
				WHEN 16 THEN ''Match Report''
				WHEN 17 THEN ''Calendar Report''
				WHEN 18 THEN ''Envelopes & Labels''
				WHEN 19 THEN ''Label Definition''
				WHEN 20 THEN ''Record Profile''
				WHEN 21 THEN ''Succession Planning''
				WHEN 22 THEN ''Career Progression''
				WHEN 25 THEN ''Workflow Rebuild''
				ELSE ''Unknown''
			END ';
	END

	IF @psOrderColumn = 'Mode'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Mode] 
				WHEN 1 THEN ''Batch''
				WHEN 0 THEN ''Manual''
				ELSE ''Unknown''
			END ';
	END
	
	IF @psOrderColumn = 'Status'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Status] 
				WHEN 0 THEN ''Pending''
				WHEN 1 THEN ''Cancelled''
				WHEN 2 THEN ''Failed''
				WHEN 3 THEN ''Successful''
				WHEN 4 THEN ''Skipped''
				WHEN 5 THEN ''Error''
				ELSE ''Unknown''
			END ';
	END
	
	IF len(@sOrderSQL) = 0
	BEGIN
		SET @sOrderSQL = @psOrderColumn;
	END
	
	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder;

	IF LEN(LTRIM(RTRIM(@sOrderSQL))) > 0 
	BEGIN
		SET @sSelectString = @sSelectString + ' ORDER BY ' + @sOrderSQL;
	END

	EXEC sp_executeSQL @sSelectString;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmails]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogEmails]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT [ASRSysEmailGroupName].[EmailGroupID] AS 'EmailGroupID', 
					[ASRSysEmailGroupName].[Name] AS 'Name'
	FROM [ASRSysEmailGroupName]
	UNION
	SELECT -1  AS 'EmailGroupID',
				(SELECT [ASRSysSystemSettings].[SettingValue]
			FROM [ASRSysSystemSettings]
			WHERE ([ASRSysSystemSettings].[Section] = 'Support')
				AND ([ASRSysSystemSettings].[SettingKey] = 'Email')
			) AS 'Name'
	ORDER BY 'Name';

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogPurgeDetails]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE Procedure [dbo].[spASRIntGetEventLogPurgeDetails]
AS
BEGIN
	SET NOCOUNT ON;

	SELECT * FROM ASRSysEventLogPurge;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogRecords]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogRecords] (
	@pfError 						bit 				OUTPUT, 
	@psFilterUser					varchar(MAX),
	@piFilterType					integer,
	@piFilterStatus					integer,
	@piFilterMode					integer,
	@psOrderColumn					varchar(MAX),
	@psOrderOrder					varchar(MAX),
	@piRecordsRequired				integer,
	@pfFirstPage					bit					OUTPUT,
	@pfLastPage						bit					OUTPUT,
	@psAction						varchar(100),
	@piTotalRecCount				integer				OUTPUT,
	@piFirstRecPos					integer				OUTPUT,
	@piCurrentRecCount				integer
)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE	@sRealSource 			sysname,
			@sSelectSQL				varchar(MAX),
			@iTempCount 			integer,
			@sExecString			nvarchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer,
			@iGetCount				integer,
			@sFilterSQL				varchar(MAX),
			@sOrderSQL				varchar(MAX),
			@sReverseOrderSQL		varchar(MAX);
			
	/* Clean the input string parameters. */
	IF len(@psAction) > 0 SET @psAction = replace(@psAction, '''', '''''');
	IF len(@psFilterUser) > 0 SET @psFilterUser = replace(@psFilterUser, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sExecString = '';
	SET @sRealSource = 'ASRSysEventLog';
	SET @psAction = UPPER(@psAction);

	IF (@psAction <> 'MOVEPREVIOUS') AND (@psAction <> 'MOVENEXT') AND (@psAction <> 'MOVELAST') 
		BEGIN
			SET @psAction = 'MOVEFIRST';
		END

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 50;

	/* Construct the filter SQL from ther input parameters. */
	SET @sFilterSQL = '';
	
	SET @sFilterSQL = @sFilterSQL + ' Type NOT IN (23, 24) ';

	IF @psFilterUser <> '-1' 
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' LOWER(username) = ''' + lower(@psFilterUser) + '''';
	END
	IF @piFilterType <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Type = ' + convert(varchar(MAX), @piFilterType) + ' ';
	END
	IF @piFilterStatus <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Status = ' + convert(varchar(MAX), @piFilterStatus) + ' ';
	END
	IF @piFilterMode <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Mode = ' + convert(varchar(MAX), @piFilterMode) + ' ';
	END
	
	/* Construct the order SQL from ther input parameters. */
	SET @sOrderSQL = '';
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
					WHEN 1 THEN ''Cross Tab''
					WHEN 2 THEN ''Custom Report''
					WHEN 3 THEN ''Data Transfer''
					WHEN 4 THEN ''Export''
					WHEN 5 THEN ''Global Add''
					WHEN 6 THEN ''Global Delete''
					WHEN 7 THEN ''Global Update''
					WHEN 8 THEN ''Import''
					WHEN 9 THEN ''Mail Merge''
					WHEN 10 THEN ''Diary Delete''
					WHEN 11 THEN ''Diary Rebuild''
					WHEN 12 THEN ''Email Rebuild''
					WHEN 13 THEN ''Standard Report''
					WHEN 14 THEN ''Record Editing''
					WHEN 15 THEN ''System Error''
					WHEN 16 THEN ''Match Report''
					WHEN 17 THEN ''Calendar Report''
					WHEN 18 THEN ''Envelopes & Labels''
					WHEN 19 THEN ''Label Definition''
					WHEN 20 THEN ''Record Profile''
					WHEN 21 THEN ''Succession Planning''
					WHEN 22 THEN ''Career Progression''
					WHEN 25 THEN ''Workflow Rebuild''
					ELSE ''Unknown''
				END ';
	END
	ELSE
	BEGIN
		IF @psOrderColumn = 'Mode'
		BEGIN
			SET @sOrderSQL =	
				' CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
					END ';
		END
		ELSE 
		BEGIN
			IF @psOrderColumn = 'Status'
			BEGIN
				SET @sOrderSQL =	
					' CASE [Status]
							WHEN 0 THEN ''Pending''
							WHEN 1 THEN ''Cancelled''
							WHEN 2 THEN ''Failed''
							WHEN 3 THEN ''Successful''
							WHEN 4 THEN ''Skipped''
							WHEN 5 THEN ''Error''
							ELSE ''Unknown''
						END ';
			END
			ELSE
			BEGIN
				SET @sOrderSQL = @psOrderColumn;
			END
		END
	END
	
	SET @sReverseOrderSQL = @sOrderSQL;
	if @psOrderOrder = 'DESC'
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' ASC ';
	END
	ELSE
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' DESC ';
	END

	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder + ' ';


	SET @sSelectSQL = '[DateTime],
					[EndTime],
					IsNull([Duration],-1) AS ''Duration'', 
		 			CASE [Type] 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
					END + char(9) + 
				 	[Name] + char(9) + 
		 			CASE Status 
						WHEN 0 THEN ''Pending''
					  WHEN 1 THEN ''Cancelled'' 
						WHEN 2 THEN ''Failed'' 
						WHEN 3 THEN ''Successful'' 
						WHEN 4 THEN ''Skipped'' 
						WHEN 5 THEN ''Error''
						ELSE ''Unknown'' 
					END + char(9) +
					CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
				 	END + char(9) + 
					[Username] + char(9) + 
					IsNull(convert(varchar, [BatchJobID]), ''0'') + char(9) +
					IsNull(convert(varchar, [BatchRunID]), ''0'') + char(9) +
					IsNull([BatchName],'''') + char(9) +
					IsNull(convert(varchar, [SuccessCount]),''0'') + char(9) +
					IsNull(convert(varchar, [FailCount]), ''0'') AS EventInfo ';

		
	
	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.ID) FROM ' + @sRealSource;

	IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;
	/****************************************************************************************************************************************/
	
	IF len(@sSelectSQL) > 0 
		BEGIN
			SET @sSelectSQL = @sRealSource + '.ID, ' + @sSelectSQL;
			SET @sExecString = 'SELECT ' ;

			IF @psAction = 'MOVEFIRST'
				BEGIN
					SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
					
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource ;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = 1;
					SET @pfFirstPage = 1;
					SET @pfLastPage = 
					CASE 
						WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
						ELSE 0
					END;
				END
		
			IF (@psAction = 'MOVELAST')
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
					
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')'

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
					IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
					SET @pfFirstPage = 	CASE 
									WHEN @piFirstRecPos = 1 THEN 1
									ELSE 0
								END;
					SET @pfLastPage = 1;

				END

			IF (@psAction = 'MOVENEXT') 
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
						BEGIN
							SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')';

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
					SET @pfFirstPage = 0
					SET @pfLastPage = 	CASE 
									WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
									ELSE 0
								END;
				END

			IF @psAction = 'MOVEPREVIOUS'
				BEGIN	
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF @piFirstRecPos <= @piRecordsRequired
						BEGIN
							SET @iGetCount = @piFirstRecPos - 1;
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END
		
					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
				
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')';
						END
					
					SET @sExecString = @sExecString

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
		
					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
					IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
					SET @pfFirstPage = CASE WHEN @piFirstRecPos = 1 
															THEN 1
															ELSE 0
														 END;
					SET @pfLastPage = CASE WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount 
															THEN 1
															ELSE 0
														END;
				END

		END

	EXECUTE sp_executeSQL @sExecString;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLinkInfo]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetLinkInfo]
(
	@piLinkID 		integer,
	@piScreenID		integer			OUTPUT,
	@piTableID		integer			OUTPUT,
	@psTitle		varchar(MAX)	OUTPUT,
	@piStartMode	integer			OUTPUT, 
	@piTableType	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT 
		@piScreenID = ASRSysSSIntranetLinks.screenID,
		@piTableID = ASRSysScreens.tableID,
		@psTitle = ASRSysSSIntranetLinks.pageTitle,
		@piStartMode = ASRSysSSIntranetLinks.startMode,
		@piTableType = ASRSysTables.TableType
	FROM ASRSysSSIntranetLinks
			INNER JOIN ASRSysScreens 
			ON ASRSysSSIntranetLinks.screenID = ASRSysScreens.screenID
				INNER JOIN ASRSysTables
				ON ASRSysScreens.TableID = ASRSysTables.TableID
	WHERE ID = @piLinkID;
END
GO



SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntCurrentAccessForRole] (
	@psRoleName		sysname,
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(2)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fEnabled			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @psRoleName + ''''

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupFilterValue]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupFilterValue] (
	@piScreenID			integer,
	@piColumnID			integer,
	@piTableID			integer,
	@piViewID			integer,
	@piRecordID			integer,
	@psFilterValue		varchar(MAX)	OUTPUT,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@pfError 			bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iLookupFilterValueID	integer,
		@sRealSource			sysname,
		@sLookupFilterValueName	sysname,
		@iCount					integer,
		@iTableType				integer,
		@sTableName				sysname,
		@iChildViewID			integer,
		@sUserGroupName			sysname,
		@iUserGroupID			integer,
		@sSQL					nvarchar(MAX),
		@sSQLParam				nvarchar(500),
		@dblResult				float,
		@fResult				bit,
		@dtResult				datetime,
		@sResult				varchar(MAX),
		@iDataType				integer,
		@sActualUserName		sysname,
		@iDfltValueExprID		integer,
		@sDefaultValue			varchar(MAX),
		@lngParentTableID		integer;

	SET @psFilterValue = '';
	SET @pfError = 0;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
					
	SET @psFilterValue = '';

	SELECT @iLookupFilterValueID = lookupFilterValueID
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @piColumnID;

	IF @iLookupFilterValueID IS null SET @iLookupFilterValueID = 0;

	IF @iLookupFilterValueID > 0 
	BEGIN
		/* Check if the looup filter value column is in the screen. If so, we don't need to find it again. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysControls]
		WHERE screenID = @piScreenID
			AND columnId = @iLookupFilterValueID;

		IF @iCount = 0 
		BEGIN
			IF @piRecordID = 0
			BEGIN
				/* New record. */
				SELECT @iDfltValueExprID = dfltValueExprID, 
					@sDefaultValue = defaultValue, 
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;

				IF @iDfltValueExprID IS null SET @iDfltValueExprID = 0;
				IF @sDefaultValue IS null SET @sDefaultValue = '';
				IF @iDataType IS null SET @iDataType = 0;

				IF @iDfltValueExprID > 0
				BEGIN
					/* Calculated value as the default. */
					SELECT @iCount = COUNT(*)
					FROM sysobjects
					WHERE id = object_id(N'sp_ASRDfltExpr_' + convert(sysname, @iDfltValueExprID))
					AND OBJECTPROPERTY(id, N'IsProcedure') = 1;

					IF @iCount > 0
					BEGIN
						SET @sSQL = 'EXEC sp_ASRDfltExpr_' + convert(nvarchar(100), @iDfltValueExprID) + ' @result OUTPUT';

						DECLARE parents_cursor CURSOR LOCAL FAST_FORWARD FOR 
							SELECT parentID
							FROM ASRSysRelations
							WHERE childID = @piTableID
							ORDER BY parentID;

						OPEN parents_cursor;
						FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						WHILE (@@fetch_status = 0)
						BEGIN
						    IF @lngParentTableID = @piParentTableID
							BEGIN
								SET @sSQL = @sSQL + ',' + convert(nvarchar(100), @piParentRecordID);
							END
							ELSE
							BEGIN
								SET @sSQL = @sSQL + ',0' ;
							END

							FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						END
						CLOSE parents_cursor;
						DEALLOCATE parents_cursor;

						IF @iDataType = -7 /* Boolean */
						BEGIN
							SET @sSQLParam = N'@result integer OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

							SET @psFilterValue = 
								CASE 
									WHEN @fResult = 0 THEN 'False'
									ELSE 'True'
								END;
						END

						IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
						BEGIN
							SET @sSQLParam = N'@result float OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

							SET @psFilterValue = convert(varchar(MAX), @dblResult);
						END

						IF (@iDataType = 11) /* Date */
						BEGIN
							SET @sSQLParam = N'@result datetime OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT

							SET @psFilterValue = convert(varchar(MAX), @dtResult, 101);
						END

						IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working pattern, photo*/
						BEGIN
							SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

							SET @psFilterValue = @sResult;
						END
					END
				END
				ELSE
				BEGIN
					SET @psFilterValue = @sDefaultValue;
				END
			END
			ELSE
			BEGIN
				SELECT @sTableName = tableName,
					@iTableType = tableType
				FROM [dbo].[ASRSysTables]
				WHERE tableID = @piTableID;

				IF @iTableType <> 2 /* ie. top-level or lookup */
				BEGIN
					IF @piViewID > 0 
					BEGIN	
						/* RealSource is the view. */	
						SELECT @sRealSource = viewName
						FROM [dbo].[ASRSysViews]
						WHERE viewID = @piViewID;
					END
					ELSE
					BEGIN
						SET @sRealSource = @sTableName;
					END 
				END
				ELSE
				BEGIN
					SELECT @iChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @piTableID
						AND [role] = @sUserGroupName;
						
					IF @iChildViewID IS null SET @iChildViewID = 0;
						
					IF @iChildViewID > 0 
					BEGIN
						SET @sRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iChildViewID) +
							'#' + replace(@sTableName, ' ', '_') +
							'#' + replace(@sUserGroupName, ' ', '_');
						SET @sRealSource = left(@sRealSource, 255);
					END
				END
	
				SELECT @sLookupFilterValueName = columnName,
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;
	
				/* Check the filter column can be read from the given table/view. */
				SELECT @iCount = COUNT(*)
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND ((sysprotects.protectType = 204) OR (sysprotects.protectType = 205))
					AND syscolumns.name = @sLookupFilterValueName
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

				IF @iCount > 0 
				BEGIN
					/* Can read the column from the realSource */
					SET @sSQL = 'SELECT @result = ' + @sLookupFilterValueName 
						+ ' FROM ' + @sRealSource
						+ ' WHERE id = ' + convert(nvarchar(100), @piRecordID);

					IF @iDataType = -7 /* Boolean */
					BEGIN
						SET @sSQLParam = N'@result integer OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

						SET @psFilterValue = 
							CASE 
								WHEN @fResult = 0 or @fResult is null THEN 'False'
								ELSE 'True'
							END;
					END

					IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
					BEGIN
						SET @sSQLParam = N'@result float OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dblResult);
					END

					IF (@iDataType = 11) /* Date */
					BEGIN
						SET @sSQLParam = N'@result datetime OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dtResult, 101);
					END

					IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working patter, photo*/
					BEGIN
						SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

						SET @psFilterValue = @sResult;
					END
				END
				ELSE
				/* Column cannot be read from view */
				SET @pfError = 1;
			END
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupViews]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupViews]
(
	@plngTableID 		integer,
	@plngDfltOrderID 	integer	OUTPUT,
	@plngColumnID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	/* Return a recordset of the IDs and names of the views of the given table for use in the link find page. */
	DECLARE @sTableName 	varchar(255),
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iChildViewID 		integer,
		@iTableType			integer,
		@lngPermissionCount	integer,
		@sLookupColumnName	sysname,
		@sFilterColumnName	sysname,
		@sRealSource 		varchar(MAX),
		@sActualUserName	sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	/* Get the table-type. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iTableType = ASRSysTables.tableType,
		@plngDfltOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @plngTableID

	SELECT @sLookupColumnName = a.columnName,
		@sFilterColumnName = b.columnName
	FROM ASRSysColumns
	LEFT OUTER JOIN ASRSysColumns a ON ASRSysColumns.lookupColumnID = a.columnID
	LEFT OUTER JOIN ASRSysColumns b ON ASRSysColumns.lookupFilterColumnID = b.columnID
	WHERE ASRSysColumns.columnID = @plngColumnID

	IF @sLookupColumnName IS null SET @sLookupColumnName = ''
	IF @sFilterColumnName IS null SET @sFilterColumnName = ''

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	

		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @viewInfo TABLE(
		viewID			integer,
		viewName		sysname,
		orderTag		integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1)
	BEGIN
		/* Populate the temporary table. */
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		VALUES (
			0,
			@sTableName,
			0	
		)
		
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		(SELECT viewID, 
			viewName,
			1
		FROM ASRSysViews
		WHERE viewTableID = @plngTableID
		)
	END
	ELSE
	BEGIN
		IF @iTableType <> 2
		BEGIN
			/* Table is a top-level or lookup table. */
			SELECT @lngPermissionCount = COUNT(*)
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protectType <> 206
				AND syscolumns.name = @sLookupColumnName
				AND sysobjects.name = @sTableName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

			IF @lngPermissionCount > 0 
			BEGIN
				IF len(@sFilterColumnName) > 0
				BEGIN
					SELECT @lngPermissionCount = COUNT(*)
					FROM sysprotects
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.action = 193
						AND sysprotects.protectType <> 206
						AND syscolumns.name = @sFilterColumnName
						AND sysobjects.name = @sTableName
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				END

				IF @lngPermissionCount > 0 
				BEGIN
					INSERT INTO @viewInfo (
						viewID, 
						viewName,
						orderTag)
					VALUES (
						0,
						@sTableName,
						0	
					)
				END
			END

			/* Now check on the views on this table. */
			INSERT INTO @viewInfo (
				viewID, 
				viewName,
				orderTag)
			(SELECT ASRSysViews.viewID, 
				ASRSysViews.viewName, 
				1
			FROM ASRSysViews
			INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
			INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE ASRSysViews.viewTableID = @plngTableID
				AND sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protecttype <> 206
				AND syscolumns.name = @sLookupColumnName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			)

			IF len(@sFilterColumnName) > 0
			BEGIN
				DELETE FROM @viewInfo 
				WHERE viewID <> 0
					AND viewID NOT IN
				(SELECT ASRSysViews.viewID
				FROM ASRSysViews
				INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
				INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE ASRSysViews.viewTableID = @plngTableID
					AND sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193
					AND sysprotects.protecttype <> 206
					AND syscolumns.name = @sFilterColumnName
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				)
			END
		END
		ELSE
		BEGIN
			/* Get appropriate child view if required. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @plngTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)

				SELECT @lngPermissionCount = COUNT(*)
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193
					AND sysprotects.protectType <> 206
					AND syscolumns.name = @sLookupColumnName
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
	
				IF @lngPermissionCount > 0 
				BEGIN
					IF len(@sFilterColumnName) > 0
					BEGIN
						SELECT @lngPermissionCount = COUNT(*)
						FROM sysprotects
						INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
						INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
						WHERE sysprotects.uid = @iUserGroupID
							AND sysprotects.action = 193
							AND sysprotects.protectType <> 206
							AND syscolumns.name = @sFilterColumnName
							AND sysobjects.name = @sRealSource
							AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
							OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
					END
	
					IF @lngPermissionCount > 0 
					BEGIN
						INSERT INTO @viewInfo (
							viewID, 
							viewName,
							orderTag)
						VALUES (
							0,
							@sTableName,
							0	
						)
					END
				END
			END
		END
	END

	/* Return the resultset. */
	SELECT viewID, viewName
	FROM @viewInfo
	ORDER BY orderTag, viewName
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetNavigationLinks]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetNavigationLinks]
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@iViewID				integer,
		@iUtilType				integer, 
		@iUtilID				integer, 
		@iScreenID				integer, 
		@sURL					varchar(MAX),
		@iTableID				integer,
		@sTableName				sysname,
		@iTableType				integer,
		@sRealSource			sysname,
		@iChildViewID			integer,
		@sAccess				varchar(MAX),
		@fTableViewOK			bit,
		@pfCustomReportsRun		bit,
		@pfCalendarReportsRun	bit,
		@pfMailMergeRun			bit,
		@pfWorkflowRun			bit,
		@sGroupName				varchar(255),
		@sActualUserName		sysname,
		@iActualUserGroupID 	integer, 
		@sViewName				sysname,
		@iLinkType 				integer,			/* 0 = Hypertext, 1 = Button, 2 = Dropdown List */
		@fFindPage				bit

	/* See if the current user can run the defined Reports/Utilties. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER)))  = 'SA'
	BEGIN
		SET @pfCustomReportsRun = 1
		SET @pfCalendarReportsRun = 1
		SET @pfMailMergeRun = 1
		SET @pfWorkflowRun = 1
	END
	ELSE
	BEGIN
		EXEC dbo.spASRIntGetActualUserDetails
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT
			
		DECLARE @unionTable TABLE (ID int PRIMARY KEY CLUSTERED)

		INSERT INTO @unionTable 
			SELECT Object_ID(ViewName) 
			FROM ASRSysViews 
			WHERE viewID IN (SELECT viewID FROM ASRSysSSIViews)
				AND NOT Object_ID(ViewName) IS null
			UNION
			SELECT Object_ID(TableName) 
			FROM ASRSysTables 
			WHERE tableID IN (SELECT tableID FROM ASRSysSSIViews)
				AND NOT Object_ID(TableName) IS null
				AND tableID NOT IN (SELECT tableID 
					FROM ASRSysViewMenuPermissions 
					WHERE ASRSysViewMenuPermissions.groupName = @sGroupName
						AND ASRSysViewMenuPermissions.hideFromMenu = 1)
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null

		DECLARE @readableTables TABLE (name sysname)	
	
		INSERT INTO @readableTables
			SELECT OBJECT_NAME(p.id)
			FROM syscolumns
			INNER JOIN #SysProtects p 
				ON (syscolumns.id = p.id
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
			WHERE syscolumns.name = 'timestamp'
				AND (p.ID IN (SELECT id FROM @unionTable))
				AND p.Action = 193 AND ProtectType IN (204, 205)
				OPTION (KEEPFIXED PLAN)

		SELECT @pfCustomReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CUSTOMREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	
		SELECT @pfCalendarReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CALENDARREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfMailMergeRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'MAILMERGE'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfWorkflowRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'WORKFLOW'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	END

	DECLARE @links TABLE(
		LinkType			integer,
		Text1	 			varchar(200),
		Text2	 			varchar(200),
		SingleRecord		bit,
		LinkToFind			bit,
		TableID				integer,
		ViewID				integer ,
		PrimarySequence		integer,
		SecondarySequence	integer,
		FindPage			integer)

	/* Hypertext links. */
	/* Single Record View UNION Multiple Record Tables/Views UNION Table/View Hypertext Links link */
	INSERT INTO @links
		SELECT 0, linksLinkText, '', 1, 0, tableID, viewID, 0, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 1
			AND LEN(linksLinkText) > 0
		UNION
		SELECT 0, hypertextLinkText, '', 0, 1, tableID, viewID, 2, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND LEN(hypertextLinkText) > 0
		UNION
		SELECT 0, linksLinkText, '', 0, 0, tableID, viewID, 1, sequence, 1
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND tableid = @plngTableID
			AND viewID = @plngViewID

	/* Button links. */
	INSERT INTO @links
	SELECT 1, buttonLinkPromptText, buttonLinkButtonText, 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE buttonLink = 1

	/* DropdownList links. */
	INSERT INTO @links
	SELECT 2, dropdownListLinkText, '', 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE dropdownListLink = 1


	/* Remove linkToFind links for links to views that are not readable by the user, or those that have no valid links defined for them. */
	DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ISNULL(l.viewID, -1) 'viewID', ASRSysViews.viewName, l.tableID, ASRSysTables.tableName
		FROM @links	l
		LEFT OUTER JOIN ASRSysViews	
			ON l.viewID = ASRSysViews.viewID
		INNER JOIN ASRSysTables
			ON l.tableID = ASRSysTables.tableID

	OPEN viewsCursor
	FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fTableViewOK = 0
		
		IF @iViewID > 0 
		BEGIN 
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sViewName
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sTableName
		END 

		IF @iCount > 0
		BEGIN

			DECLARE linksCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysSSIntranetLinks.utilityType,
							ASRSysSSIntranetLinks.utilityID,
							ASRSysSSIntranetLinks.screenID,
							ASRSysSSIntranetLinks.url
			FROM ASRSysSSIntranetLinks
			WHERE tableID = @iTableID 
				AND	viewID = @iViewID
	
			OPEN linksCursor
			FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			WHILE (@@fetch_status = 0) AND (@fTableViewOK = 0)
			BEGIN
				IF LEN(@sURL) > 0 OR (UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA')
				BEGIN
					SET @fTableViewOK = 1
				END
				ELSE
				BEGIN
					IF @iUtilID > 0
					BEGIN
						/* Check if the utility is deleted or hidden from the user. */
						EXECUTE dbo.spASRIntCurrentAccessForRole
												@sGroupName,
												@iUtilType,
												@iUtilID,
												@sAccess	OUTPUT
	
						IF @sAccess <> 'HD' 
						BEGIN
							IF @iUtilType = 2 AND @pfCustomReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 17 AND @pfCalendarReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 9 AND @pfMailMergeRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 25 AND @pfWorkflowRun = 1 SET @fTableViewOK = 1
						END
					END
	
					IF (@iScreenID > 0) 
					BEGIN
						/* Do not display the link if the user does not have permission to read the defined view/tbale for the screen. */
						SELECT @iTableID = ASRSysTables.tableID, 
							@sTableName = ASRSysTables.tableName,
							@iTableType = ASRSysTables.tableType
						FROM ASRSysScreens
										INNER JOIN ASRSysTables 
										ON ASRSysScreens.tableID = ASRSysTables.tableID
						WHERE screenID = @iScreenID
	
						SET @sRealSource = ''
						IF @iTableType  = 2
						BEGIN
							SET @iChildViewID = 0
	
							/* Child table - check child views. */
							SELECT @iChildViewID = childViewID
							FROM ASRSysChildViews2
							WHERE tableID = @iTableID
								AND role = @sGroupName
							
							IF @iChildViewID IS null SET @iChildViewID = 0
							
							IF @iChildViewID > 0 
							BEGIN
								SET @sRealSource = 'ASRSysCV' + 
									convert(varchar(1000), @iChildViewID) +
									'#' + replace(@sTableName, ' ', '_') +
									'#' + replace(@sGroupName, ' ', '_')
							
								SET @sRealSource = left(@sRealSource, 255)
							END
						END
						ELSE
						BEGIN
							/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
							IF @iViewID > 0 
							BEGIN 
								SELECT @sRealSource = viewName
								FROM ASRSysViews
								WHERE viewID = @iViewID
							END
							ELSE
							BEGIN
								SELECT @sRealSource = tableName
								FROM ASRSysTables
								WHERE tableID = @iTableID
							END 
	
							IF @sRealSource IS null SET @sRealSource = ''
						END
	
						IF len(@sRealSource) > 0
						BEGIN
							SELECT @iCount = COUNT(*)
							FROM @readableTables
							WHERE name = @sRealSource
						
							IF @iCount = 1 SET @fTableViewOK = 1
						END
					END
				END
								
				FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			END
			CLOSE linksCursor
			DEALLOCATE linksCursor

		END
		
		IF @fTableViewOK = 0
		BEGIN
			IF @iViewID > 0 
			BEGIN
				DELETE FROM @links
				WHERE viewID = @iViewID
			END
			ELSE
			BEGIN
				DELETE FROM @links
				WHERE tableid = @iTableID AND viewID = @iViewID
			END
		END
	
		FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	END
	CLOSE viewsCursor
	DEALLOCATE viewsCursor

	SELECT *
	FROM @links
	ORDER BY [primarySequence], [secondarySequence]

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetOpFuncShortcuts]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetOpFuncShortcuts]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the operators and functions that have shortcut keys. */
	DECLARE	@iFunctionID		integer, 
			@sParameter			varchar(MAX),
			@iLastFunctionID	integer,
			@sParameters		varchar(MAX);

	SET @iLastFunctionID = 0;
	SET @sParameters = '';

	DECLARE @tempParams TABLE(
		[functionID]	integer,
		[parameters]	varchar(MAX));

	DECLARE paramsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysFunctionParameters.functionID, 
			ASRSysFunctionParameters.parameterName
		FROM ASRSysFunctionParameters
		INNER JOIN ASRSysFunctions ON ASRSysFunctionParameters.functionID = ASRSysFunctions.functionID
			AND LEN(ASRSysFunctions.shortcutKeys) > 0
		ORDER BY ASRSysFunctionParameters.functionID, ASRSysFunctionParameters.parameterIndex;

	OPEN paramsCursor;
	FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iFunctionID <> @iLastFunctionID
		BEGIN
			IF LEN(@sParameters) >0 
			BEGIN
				INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
			END

			SET @iLastFunctionID = @iFunctionID;
			SET @sParameters = @sParameter;
		END
		ELSE
		BEGIN
			SET @sParameters = @sParameters + char(9) + @sParameter;
		END

		FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	END

	IF LEN(@sParameters) >0 
	BEGIN
		INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
	END

	SET @iLastFunctionID = @iFunctionID;
	SET @sParameters = @sParameter;

	CLOSE paramsCursor;
	DEALLOCATE paramsCursor;
	
	SELECT 5 AS [componentType], 
		ASRSysOperators.operatorID AS [ID], 
		ASRSysOperators.shortcutKeys, 
		'' AS [params],
		name AS [name]
	FROM ASRSysOperators
	WHERE len(shortcutKeys) > 0 
	UNION
	SELECT 2 AS [componentType], 
		ASRSysFunctions.functionID AS [ID], 
		ASRSysFunctions.shortcutKeys, 
		tmp.[parameters] AS [params],
		functionName AS [name]
	FROM ASRSysFunctions
	INNER JOIN @tempParams tmp ON ASRSysFunctions.functionID = tmp.functionID
	WHERE len(shortcutKeys) > 0;

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPageTitle]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetPageTitle] (
	@piTableID		integer,
	@piViewID		integer,
	@psPageTitle	varchar(200) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psPageTitle = PageTitle
	FROM ASRSysSSIViews
	WHERE (TableID = @piTableID) AND  (ViewID = @piViewID);

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParentValues]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetParentValues] (
	@piScreenID 		integer,
	@piParentTableID 	integer,
	@piParentRecordID 	integer
)
AS
BEGIN
	
	SET NOCOUNT ON;
	
	/* Return a recordset of the parent record values required for controls in the given screen. */
	DECLARE 
		@iUserGroupID		integer,
		@sRoleName			sysname,
		@iTempCount 		integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iParentChildViewID	integer,
		@sParentRealSource	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@sNewBit			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sParentSelectSQL	nvarchar(MAX),
		@sTemp				varchar(MAX),
		@fColumns			bit,
		@sSQL				nvarchar(MAX),
		@sActualUserName	sysname;

	SET @sParentSelectSQL  = 'SELECT ';
	SET @fColumns = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(tableViewName	sysname,
		columnName	sysname,
		granted		bit);

	SELECT @iTempCount = COUNT(*)
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysControls.columnID = ASRSysColumns.columnID
		AND ASRSysColumns.tableID = @piParentTableID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0;

	IF @iTempCount = 0 RETURN;

	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables
		WHERE tableID = @piParentTableID;

	IF @iParentTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			sysobjects.name,
			syscolumns.name,
			CASE p.protectType
			        	WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM #sysprotects p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		WHERE p.action = 193 
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piParentTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piParentTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SET @sParentRealSource = @sParentTableName;
	END
	ELSE
	BEGIN
		/* Get permitted child view on the parent table. */
		SELECT @iParentChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piParentTableID
			AND role = @sRoleName;
				
		IF @iParentChildViewID IS null SET @iParentChildViewID = 0;
				
		IF @iParentChildViewID > 0 
		BEGIN
			SET @sParentRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iParentChildViewID) +
				'#' + replace(@sParentTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sParentRealSource = left(@sParentRealSource, 255);

			INSERT INTO @columnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysColumns.columnID = ASRSysControls.columnID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0
		AND ASRSysColumns.tableID = @piParentTableID;
	
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
	
		/* Get the select permission on the column. */
		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @columnPermissions
		WHERE tableViewName = @sParentRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			IF @fColumns = 1
			BEGIN
				SET @sTemp = ',';
				SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
			END

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sNewBit = 'convert(varchar(10), ' + @sParentRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sNewBit = @sParentRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
			END

			SET @fColumns = 1;
			SET @sParentSelectSQL = @sParentSelectSQL + @sNewBit;
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @columnPermissions
			WHERE tableViewName <> @sParentRealSource
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';

				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
				END

				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);
				END

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = @sSelectString +
					' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

				IF @fColumns = 1
				BEGIN
					SET @sTemp = ',';
					SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
				END

				SET @fColumns = 1;
				SET @sParentSelectSQL = @sParentSelectSQL + @sSelectString;
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF @fColumns = 0 RETURN;

	SET @sTemp = ' FROM ' + @sParentRealSource;
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName
	FROM @joinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sParentRealSource + '.ID = ' + @sTableViewName + '.ID';
		SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

		FETCH NEXT FROM joinCursor INTO @sTableViewName;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SET @sTemp = ' WHERE ' + @sParentRealSource + '.ID = ' + convert(varchar(100), @piParentRecordID);
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	EXECUTE sp_executeSQL @sParentSelectSQL;
	
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordDescriptionInView]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetRecordDescriptionInView] (
	@piViewID 			integer,
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@iCount				integer,
			@sEvalRecDesc		varchar(MAX),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500),
			@sViewName			sysname;

	SET @psRecDesc = '';
	SET @psErrorMessage = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables 
		WHERE ASRSysTables.tableID = @piTableID;
	END

	IF @iRecordID > 0 
	BEGIN
		/* Check that the given record is still in the given view */
		SELECT @sViewName = viewName
		FROM ASRSysViews
		WHERE viewID = @piViewID;
	
		SET @sExecString = 'SELECT @iCount = COUNT(*) FROM [' + @sViewName + '] WHERE ID = ' + convert(nvarchar(100), @iRecordID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sExecString, @sParamDefinition, @iCount OUTPUT;
		
		IF @iCount = 0 
		BEGIN
			SET @psErrorMessage = 'The requested record is not in the current view.';
		END
		ELSE
		BEGIN
			/* Get the record description. */
			IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
			BEGIN
				SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(100), @iRecDescID) + ' @recDesc OUTPUT, @recID';
				SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
				EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;
		
				IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
			END
		END
	END
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordSelection]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetRecordSelection]
(
	@psType		varchar(255),
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @fSysSecMgr	bit;

	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT
	
	IF UPPER(@psType) = 'PICKLIST'
	BEGIN
		SELECT picklistid, 
			name, 
			username, 
			access 
		FROM [dbo].[ASRSysPicklistName]
		WHERE (tableid = @piTableID)
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END

	IF UPPER(@psType) = 'FILTER'
	BEGIN
		SELECT exprid, 
			name, 
			username, 
			access 
		FROM [dbo].[ASRSysExpressions]
		WHERE tableid = @piTableID 
			AND type = 11 
			AND (returnType = 3 OR type = 10) 
			AND parentComponentID = 0 
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END
	
	IF UPPER(@psType) = 'CALC'
	BEGIN
		IF @piTableID > 0
		BEGIN
			SELECT exprid, 
				name, 
				username, 
				access 
			FROM [dbo].[ASRSysExpressions]
			WHERE (tableid = @piTableID)
				AND  type = 10 
				AND (returnType = 0 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
		ELSE
		BEGIN
			SELECT exprid, 
				name, 
				username, 
				access 
			FROM [dbo].[ASRSysExpressions] 
			WHERE  type = 18 
				AND (returnType = 4 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetSingleRecordViewID]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetSingleRecordViewID] 
(
		@piTableID		integer OUTPUT,
		@piViewID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piTableID = TableID, @piViewID = ViewID
	FROM ASRSysSSIViews
	WHERE SingleRecordView = 1;

	IF @piTableID IS NULL SET @piTableID = 0;
	IF @piViewID IS NULL SET @piViewID = 0;

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetSummaryValues]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetSummaryValues] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sRootTable 		varchar(255),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sTemp				varchar(MAX),
		@sSelectSQL			nvarchar(MAX),
		@sActualUserName	sysname,
		@strTempSepText		varchar(500);

	SET @sSelectSQL = '';
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName	sysname);

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @columnPermissions TABLE (tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	-- Cached view of SysProtects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000));

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID);

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM #SysProtects
				WHERE Action = 193;

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sParentRealSource = left(@sParentRealSource, 255);
			END

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM #SysProtects
				WHERE Action = 193;

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnID
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;

	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @ColumnPermissions
		WHERE tableViewName = @sParentTableName
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			SET @sTemp = ',';
			IF LEN(@sSelectSQL) > 0
				SET @sSelectSQL = @sSelectSQL + @sTemp;

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END 
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sParentTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END

			/* Add the table to the array of tables/views to join if it has not already been added. */
			SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sParentTableName;

			IF @iTempCount = 0
			BEGIN
				INSERT INTO @joinParents (tableViewName) VALUES(@sParentTableName);
			END
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @ColumnPermissions
			WHERE tableViewName <> @sParentTableName
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) > 0 SET @sSelectString = @sSelectString + ',';

				IF @iColumnDataType = 11 /* Date */
					SET @sSelectString = @sSelectString + 'convert(varchar(10),' + @sViewName + '.' + @sColumnName + ',101)';
				ELSE
					SET @sSelectString = @sSelectString + @sViewName + '.' + @sColumnName;


				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = 'COALESCE(' + @sSelectString + ', NULL) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sTemp = ',';

				IF LEN(@sSelectSQL) > 0
					SET @sSelectSQL = @sSelectSQL + @sTemp;

				SET @sTemp = @sSelectString;
				SET @sSelectSQL = @sSelectSQL + @sTemp;
				
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = 'SELECT ' + @sSelectSQL ;

		SELECT @iTempCount = COUNT(tableViewName)
			FROM @joinParents;

		IF @iTempCount = 1 
		BEGIN
			SELECT TOP 1 @sRootTable = tableViewName
			FROM @joinParents;
		END
		ELSE
		BEGIN
			SET @sRootTable = @sParentTableName;
		END

		SET @sTemp = ' FROM ' + @sRootTable;
		SET @sSelectSQL = @sSelectSQL + @sTemp;

		/* Add the join code. */
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sTableViewName <> @sRootTable
			BEGIN
				SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRootTable + '.ID' + ' = ' + @sTableViewName + '.ID';
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END

			FETCH NEXT FROM joinCursor INTO @sTableViewName;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		SET @sTemp = ' WHERE ' + @sRootTable + '.id = ' + convert(varchar(255), @piParentRecordID);
		SET @sSelectSQL = @sSelectSQL + @sTemp;

	END

	-- Run the constructed SQL SELECT string.
	EXEC sp_executeSQL @sSelectSQL;

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetTimestamp]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetTimestamp] (
	@piTimestamp 	int 		OUTPUT, 
	@piRecordID		integer,
	@psRealsource	varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500);

	/* Clean the input string parameters. */
	IF len(@psRealsource) > 0 SET @psRealsource = replace(@psRealsource, '''', '''''');
	
	SET @sTempExecString = 'SELECT @iTimestamp = convert(integer, timestamp) FROM ' + convert(nvarchar(255), @psRealsource) + ' where ID = ' + convert(nvarchar(100), @piRecordID);
	SET @sTempParamDefinition = N'@iTimestamp integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piTimestamp OUTPUT;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityAccessRecords]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords] (
	@piUtilityType		integer,
	@piID				integer,
	@piFromCopy			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sDefaultAccess	varchar(2),
		@sAccessTable	sysname,
		@sKey			varchar(255),
		@sSQL			nvarchar(MAX);

	SET @sAccessTable = '';

	IF @piUtilityType = 17
	BEGIN
		/* Calendar Reports */
		SET @sAccessTable = 'ASRSysCalendarReportAccess';
		SET @sKey = 'dfltaccess CalendarReports';
	END

	IF @piUtilityType = 1
	BEGIN
		/* Cross Tabs */
		SET @sAccessTable = 'ASRSysCrossTabAccess';
		SET @sKey = 'dfltaccess CrossTabs';
	END

	IF @piUtilityType = 2
	BEGIN
		/* Custom Reports */
		SET @sAccessTable = 'ASRSysCustomReportAccess';
		SET @sKey = 'dfltaccess CustomReports';
	END

	IF @piUtilityType = 9
	BEGIN
		/* Mail Merge */
		SET @sAccessTable = 'ASRSysMailMergeAccess';
		SET @sKey = 'dfltaccess MailMerge';
	END

	IF LEN(@sAccessTable) > 0
	BEGIN
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SELECT @sDefaultAccess = SettingValue 
			FROM ASRSysUserSettings
			WHERE UserName = system_user
				AND Section = 'utils&reports'
				AND SettingKey = @sKey;
	
			IF (@sDefaultAccess IS null)
			BEGIN
				SET @sDefaultAccess = 'RW';
			END
		END
		ELSE
		BEGIN
			SET @sDefaultAccess = 'HD';
		END
		
		SET @sSQL = 'SELECT sysusers.name + char(9) +
				CASE WHEN	
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE sysusers.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						ELSE ';
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RW'' THEN ''Read / Write''
			 WHEN	CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
			ELSE '
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RO'' THEN ''Read Only''
			ELSE ''Hidden'' 
			END + char(9) +
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
 						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''1''
				ELSE
					''0''
			END AS [accessDefinition]
			FROM sysusers
			LEFT OUTER JOIN ' + @sAccessTable + ' ON (sysusers.name = ' + @sAccessTable + '.groupName
				AND ' + @sAccessTable + '.id = ' + convert(nvarchar(100), @piID) + ')
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0 AND NOT (sysusers.name LIKE ''ASRSys%'') AND NOT (sysusers.name LIKE ''db_%'')
			ORDER BY sysusers.name';

			EXEC sp_executesql @sSQL;
	END

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityName]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetUtilityName] (
	@piUtilityType	integer,
	@plngID			integer,
	@psName			varchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500);

	SET @sTableName = '';
	SET @psName = '<unknown>';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
    END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sIDColumnName = 'ID';
    END
        
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sIDColumnName = 'DataTransferID';
    END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sIDColumnName = 'functionID';
    END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sIDColumnName = 'mailMergeID';
    END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sIDColumnName = 'recordProfileID';
    END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sIDColumnName = 'matchReportID';
    END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SET @sTableName = 'ASRSysWorkflows';
		SET @sIDColumnName = 'ID';
	END
      	
	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sName = [' + @sTableName + '].[name]
				FROM [' + @sTableName + ']
				WHERE [' + @sTableName + '].[' + @sIDColumnName + '] = ' + convert(nvarchar(255), @plngID);

		SET @sParamDefinition = N'@sName varchar(255) OUTPUT';
		EXEC sp_executesql @sSQL, @sParamDefinition, @psName OUTPUT;
	END

	IF @psName IS null SET @psName = '<unknown>';
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetViewName]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetViewName] (
	@piViewID	integer,
	@psViewName	varchar(255) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @piViewID;

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntSetEventLogPurge]    Script Date: 23/07/2013 11:19:27 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntSetEventLogPurge]
(
		@psPeriod		varchar(2),
		@piFrequency	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLogPurge] (Period,Frequency)
	VALUES (@psPeriod, @piFrequency);

END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntValidateCalendarReport]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntValidateCalendarReport]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntUDFFunctionsEnabled]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntUDFFunctionsEnabled]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntShowOutOfOfficeHyperlink]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntShowOutOfOfficeHyperlink]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntSetEventLogPurge]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntSetEventLogPurge]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntSaveCalendarReport]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntSaveCalendarReport]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetViewName]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetViewName]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityName]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetUtilityName]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityAccessRecords]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords]
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetTimestamp]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetTimestamp]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetSummaryValues]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetSummaryValues]
GO

DROP PROCEDURE [dbo].[spASRIntGetSortOrderColumns]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetSingleRecordViewID]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetSingleRecordViewID]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordSelection]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetRecordSelection]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordDescriptionInView]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetRecordDescriptionInView]
GO

DROP PROCEDURE [dbo].[spASRIntGetQuickFindRecord]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPicture]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetPicture]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParentValues]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetParentValues]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParameterPassByType]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetParameterPassByType]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPageTitle]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetPageTitle]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetOpFuncShortcuts]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetOpFuncShortcuts]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetNavigationLinks]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetNavigationLinks]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupViews]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetLookupViews]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupTables]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetLookupTables]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupFilterValue]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetLookupFilterValue]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLinkInfo]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetLinkInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogUsers]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogUsers]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogRecords]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogRecords]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogPurgeDetails]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogPurgeDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmails]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogEmails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmailInfo]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogDetails]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogBatchDetails]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEmailGroupAddresses]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetEmailGroupAddresses]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetDefaultOrder]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetDefaultOrder]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarReportDefinition]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetCalendarReportDefinition]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarColours]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetCalendarColours]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailablePicklists]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailablePicklists]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableOrdersInfo]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableOrdersInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableLoginsFromAssembly]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableLoginsFromAssembly]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFiltersInfo]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableFiltersInfo]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFilters]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAvailableFilters]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAllExprRootIDs]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetAllExprRootIDs]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualUserDetailsForLogin]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetActualUserDetailsForLogin]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualLogin]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntGetActualLogin]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteEventLogRecords]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntDeleteEventLogRecords]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteCheck]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntDeleteCheck]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCurrentUserAccess]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntCurrentUserAccess]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntClearEventLogPurge]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntClearEventLogPurge]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCheckSPExists]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntCheckSPExists]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntCanReadView]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntCanReadView]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntAllTablePermissions]    Script Date: 13/09/2013 08:57:58 ******/
DROP PROCEDURE [dbo].[spASRIntAllTablePermissions]
GO


/****** Object:  StoredProcedure [dbo].[spASRIntAllTablePermissions]    Script Date: 13/09/2013 08:57:58 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntAllTablePermissions]
(
	@psSQLLogin 		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	-- Cached view of the objects 
	DECLARE @SysObjects TABLE([ID]		integer PRIMARY KEY CLUSTERED,
							  [Name]	sysname);
							  
	INSERT INTO @SysObjects
		SELECT [ID], [Name] FROM sysobjects
		WHERE [Name] LIKE 'ASRSysCV%' AND [XType] = 'v'
		UNION 
		SELECT OBJECT_ID(tableName), TableName 
		FROM ASRSysTables
		WHERE NOT OBJECT_ID(tableName) IS null
		UNION
		SELECT OBJECT_ID(viewName), ViewName 
		FROM ASRSysViews
		WHERE NOT OBJECT_ID(viewName) IS null;

	-- Cached view of the sysprotects table
	DECLARE @SysProtects TABLE([ID]				integer,
							   [columns]		varbinary(8000),
							   [Action]			tinyint,
							   [ProtectType]	tinyint);
	INSERT INTO @SysProtects
	SELECT p.ID, p.Columns, p.Action, p.ProtectType FROM #SysProtects p
		INNER JOIN @SysObjects o ON p.ID = o.ID
		WHERE ((p.ProtectType <> 206 AND p.Action <> 193) OR (p.Action = 193 AND p.ProtectType IN (204,205)));

	SELECT o.name, p.action, ISNULL(cv.tableID,0) AS [tableid]
		FROM @SysProtects p
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE p.protectType <> 206
			AND p.action <> 193
	UNION
	SELECT o.name, 193, ISNULL(cv.tableID,0) AS [tableid]
		FROM sys.columns c
		INNER JOIN @SysProtects p ON (c.object_id = p.id
			AND p.action = 193 
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) = 0)))
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE (c.name <> 'timestamp' AND c.name <> 'ID')
			AND p.protectType IN (204, 205) 
		ORDER BY o.name;


END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntCanReadView]    Script Date: 13/09/2013 08:57:58 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE Procedure [dbo].[spASRIntCanReadView]
	@piViewID		integer
AS
BEGIN
	/* This sp will error if the current user cannot read the given view.
	THe calling code needs to handle this error. */
	DECLARE 
		@sSQL				nvarchar(4000),
		@sViewName	nvarchar(4000)
	
	SELECT @sViewName = viewName
	FROM ASRSysViews
	WHERE viewID = @piViewID
	
	IF LEN(@sViewName) > 0 
	BEGIN
		SET @sSQL = ' SELECT COUNT(id)
			FROM ' + @sViewName
			
		EXEC sp_executesql @sSQL
	END
END

GO


CREATE PROCEDURE [dbo].[spASRIntCheckSPExists]
(
	@psPrefix			varchar(255),
	@plngTableID		integer,
	@pfExists			bit		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSPName	varchar(MAX),
			@iCount		integer;

	SET @pfExists = 0;
	SET @sSPName = @psPrefix + convert(varchar(255), @plngTableID);

	IF NOT @sSPName IS null
	BEGIN
		SELECT @iCount = COUNT([Name])
		FROM sysobjects
		WHERE type = 'P'
			AND name = @sSPName;

		IF @iCount > 0 
		BEGIN
			SET @pfExists = 1;
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntClearEventLogPurge]    Script Date: 13/09/2013 08:57:58 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntClearEventLogPurge]
AS
BEGIN

	SET NOCOUNT ON;

	DELETE FROM [dbo].[ASRSysEventLogPurge];
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntCurrentUserAccess]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntCurrentUserAccess] (
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRoleName			varchar(255),
		@sActualUserName	sysname,
		@iActualUserGroupID	integer,
		@fEnabled			bit

	SET @sTableName = '';
	SET @psAccess = 'HD';

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @sRoleName + '''';

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteCheck]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntDeleteCheck] (
	@piUtilityType	integer,
	@plngID			integer,
	@pfDeleted		bit				OUTPUT,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fNewAccess			bit,
		@iCount				integer,
		@sAccess			varchar(MAX),
		@fSysSecMgr			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';
	SET @pfDeleted = 0;
	SET @fNewAccess = 0;

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
		SET @fNewAccess = 1;
  END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
		SET @fNewAccess = 1
  END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
		SET @fNewAccess = 1;
  END

	IF (@piUtilityType = 11) OR (@piUtilityType = 12)  /* Filters/Calcs */
	BEGIN
		SET @sTableName = 'ASRSysExpressions';
		SET @sIDColumnName = 'exprID';
  END

	IF (@piUtilityType = 10)  /* Picklists */
	BEGIN
		SET @sTableName = 'ASRSysPicklistName';
		SET @sIDColumnName = 'picklistID';
  END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @iCount = COUNT(*)
				FROM ' + @sTableName + 
				' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0 
		BEGIN
			SET @pfDeleted = 1;
		END
		ELSE
		BEGIN
			IF @fNewAccess = 1
			BEGIN
				exec [dbo].[spASRIntCurrentUserAccess] @piUtilityType,	@plngID, @psAccess OUTPUT;
			END
			ELSE
			BEGIN
				exec [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
				
				IF @fSysSecMgr = 1 
				BEGIN
					SET @psAccess = 'RW';
				END
				ELSE
				BEGIN
					SET @sSQL = 'SELECT @sAccess = CASE 
								WHEN userName = system_user THEN ''RW''
								ELSE access
							END
							FROM ' + @sTableName + 
							' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
					SET @sParamDefinition = N'@sAccess varchar(MAX) OUTPUT';
					EXEC sp_executesql @sSQL,  @sParamDefinition, @sAccess OUTPUT;

					SET @psAccess = @sAccess;
				END
			END
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntDeleteEventLogRecords]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntDeleteEventLogRecords]
(
		@piDeleteType			integer,
		@psSelectedEventIDs		varchar(MAX),
		@pfCanViewAll			bit
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sSQL	nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psSelectedEventIDs) > 0 SET @psSelectedEventIDs = replace(@psSelectedEventIDs, '''', '''''');

	IF (@piDeleteType = 0) OR (@piDeleteType = 1)
	BEGIN
		/* 0 = Delete all the selected rows */
		/* 1 = Delete all the rows shown */
		SET @sSQL = 'DELETE FROM ASRSysEventLog' +
			' WHERE ID IN (' + @psSelectedEventIDs + ')';
		EXEC sp_executesql @sSQL;
	END
	
	IF @piDeleteType = 2
	BEGIN
		/* Delete all the records the user has permission to see */
		IF @pfCanViewAll = 1
		BEGIN
			DELETE FROM [dbo].[ASRSysEventLog];
		END
		ELSE
		BEGIN
			DELETE FROM [dbo].[ASRSysEventLog] 
			WHERE username = SYSTEM_USER;
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualLogin]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetActualLogin]
(
	@psActualLogin		nvarchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound	integer;

	/* Is this user logged in under a specific login, or as part of a Windows Group login */
	SELECT @iFound = Count(*) FROM sysusers WHERE name = SYSTEM_USER;
	IF (@iFound > 0)
		SET @psActualLogin = SYSTEM_USER;
	ELSE
		SELECT TOP 1 @psActualLogin = name FROM sysusers
			WHERE is_member(Name) & IsNTGroup = 1;

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetActualUserDetailsForLogin]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE Procedure [dbo].[spASRIntGetActualUserDetailsForLogin]
(
		@psLogin sysname,
		@psUserName sysname OUTPUT,
		@psUserGroup sysname OUTPUT,
		@piUserGroupID integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iFound		int

	SELECT @iFound = COUNT(*) 
	FROM sysusers usu 
	LEFT OUTER JOIN	(sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = @psLogin
		AND CASE
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
		END NOT LIKE 'ASRSys%'

	IF (@iFound > 0)
	BEGIN
		SELECT	@psUserName = usu.name,
			@psUserGroup = CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND lo.loginname = @psLogin
			AND CASE 
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
				END NOT LIKE 'ASRSys%'
	END
	ELSE
	BEGIN
		SELECT @psUserName = usu.name, 
			@psUserGroup = CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END,
			@piUserGroupID = usg.gid
		FROM sysusers usu 
		LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
		LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
		WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
			AND (usg.issqlrole = 1 OR usg.uid IS null)
			AND is_member(lo.loginname) = 1
			AND CASE
				WHEN (usg.uid IS null) THEN null
				ELSE usg.name
			END NOT LIKE 'ASRSys%'
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAllExprRootIDs]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetAllExprRootIDs]
(
		@iExprID integer,
		@superExpressions cursor varying output
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a cursor of the expressions that use the given expression. */
	DECLARE	@iComponentID	integer,
					@iRootExprID	integer,
					@superCursor	cursor,
					@iTemp				integer

	CREATE TABLE #superExpressionIDs (id integer)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID
		FROM ASRSysExprComponents
		WHERE (calculationID = @iExprID)
			OR (filterID = @iExprID)
			OR ((fieldSelectionFilter = @iExprID) AND (type = 1))

	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iComponentID
	WHILE (@@fetch_status = 0)
	BEGIN
		exec sp_ASRIntGetRootExpressionIDs @iComponentID, @iRootExprID	OUTPUT

		INSERT INTO #superExpressionIDs (id) VALUES (@iRootExprID)
		
		exec spASRIntGetAllExprRootIDs @iRootExprID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO #superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		FETCH NEXT FROM check_cursor INTO @iComponentID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor
	
	SET @superExpressions = CURSOR FORWARD_ONLY STATIC FOR
		SELECT id FROM #superExpressionIDs
	OPEN @superExpressions
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFilters]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetAvailableFilters] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableFiltersInfo]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetAvailableFiltersInfo] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT exprid AS [ID], 
		name, 
		username, 
		access 
	FROM [dbo].[ASRSysExpressions]
	WHERE tableid = @plngTableID 
		AND type = 11 
		AND (returnType = 3 OR type = 10) 
		AND parentComponentID = 0 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableLoginsFromAssembly]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS OFF
GO

SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[spASRIntGetAvailableLoginsFromAssembly]
WITH EXECUTE AS CALLER
AS
EXTERNAL NAME [Advanced.Framework].[Assembly.SQLFunctions].[GetAvailableLogins]
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailableOrdersInfo]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetAvailableOrdersInfo] (
	@plngTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT orderid AS [ID], 
		name, 
		'' AS username, 
		'' AS access 
	FROM ASRSysOrders 
	WHERE tableid = @plngTableID  
		AND type = 1 
		ORDER BY [name];
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetAvailablePicklists]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetAvailablePicklists] (
	@plngTableID	integer,
	@psUserName		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT picklistid AS [ID], 
		name 
	FROM [dbo].[ASRSysPicklistName]
	WHERE tableid = @plngTableID 
		AND (username = @psUserName 
			OR Access <> 'HD') 
	ORDER BY [name];
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarColours]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetCalendarColours]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ASRSysColours.ColOrder, 
		ASRSysColours.ColValue,
		ASRSysColours.ColDesc, 
		ASRSysColours.WordColourIndex,
		ASRSysColours.CalendarLegendColour
	FROM ASRSysColours
	WHERE (ASRSysColours.CalendarLegendColour = 1)
		AND (ASRSysColours.ColValue NOT IN (13434879))
	ORDER BY ASRSysColours.ColOrder;
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetCalendarReportDefinition]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetCalendarReportDefinition] 
	(
	@piCalendarReportID 		integer, 
	@psCurrentUser				varchar(255),
	@psAction					varchar(255),
	@psErrorMsg					varchar(MAX)	OUTPUT,
	@psCalendarReportName		varchar(255)	OUTPUT,
	@psCalendarReportOwner		varchar(255)	OUTPUT,
	@psCalendarReportDesc		varchar(MAX)	OUTPUT,
	@piBaseTableID				integer			OUTPUT,
	@pfAllRecords				bit				OUTPUT,
	@piPicklistID				integer			OUTPUT,
	@psPicklistName				varchar(255)	OUTPUT,
	@pfPicklistHidden			bit				OUTPUT,
	@piFilterID					integer			OUTPUT,
	@psFilterName				varchar(255)	OUTPUT,
	@pfFilterHidden				bit				OUTPUT,
	@pfPrintFilterHeader		bit				OUTPUT,
	@piDesc1ID					integer			OUTPUT,
	@piDesc2ID					integer			OUTPUT,
	@piDescExprID				integer			OUTPUT,
	@psDescExprName				varchar(255)	OUTPUT,
	@pfDescCalcHidden			bit				OUTPUT,
	@piRegionID					integer			OUTPUT,
	@pfGroupByDesc				bit				OUTPUT,
	@pfDescSeparator			varchar(255)	OUTPUT,	
	@piStartType				integer			OUTPUT,
	@pdFixedStart				datetime		OUTPUT,
	@piStartFrequency			integer			OUTPUT,
	@piStartPeriod				integer			OUTPUT,
	@piCustomStartID			integer			OUTPUT,
	@psCustomStartName			varchar(MAX)	OUTPUT,
	@pfStartDateCalcHidden		bit				OUTPUT,
	@piEndType					integer			OUTPUT,
	@pdFixedEnd					datetime		OUTPUT,
	@piEndFrequency				integer			OUTPUT,
	@piEndPeriod				integer			OUTPUT,
	@piCustomEndID				integer			OUTPUT,
	@psCustomEndName			varchar(MAX)	OUTPUT,
	@pfEndDateCalcHidden		bit				OUTPUT,
	@pfShadeBHols				bit				OUTPUT,
	@pfShowCaptions				bit				OUTPUT,
	@pfShadeWeekends			bit				OUTPUT,
	@pfStartOnCurrentMonth		bit				OUTPUT,
	@pfIncludeWorkingDaysOnly	bit				OUTPUT,
	@pfIncludeBHols				bit				OUTPUT,
	@pfOutputPreview			bit				OUTPUT,
	@piOutputFormat				integer			OUTPUT,
	@pfOutputScreen				bit				OUTPUT,
	@pfOutputPrinter			bit				OUTPUT,
	@psOutputPrinterName		varchar(MAX)	OUTPUT,
	@pfOutputSave				bit				OUTPUT,
	@piOutputSaveExisting		integer			OUTPUT,
	@pfOutputEmail				bit				OUTPUT,
	@piOutputEmailAddr			integer			OUTPUT,
	@psOutputEmailName			varchar(MAX)	OUTPUT,
	@psOutputEmailSubject		varchar(MAX)	OUTPUT,
	@psOutputEmailAttachAs		varchar(MAX)	OUTPUT,
	@psOutputFilename			varchar(MAX)	OUTPUT,	
 	@piTimestamp				integer			OUTPUT
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount			integer,
			@sTempHidden	varchar(10),
			@sAccess 		varchar(10);

	SET @psErrorMsg = '';
	SET @psPicklistName = '';
	SET @pfPicklistHidden = 0;
	SET @psFilterName = '';
	SET @pfFilterHidden = 0;
	SET @pfDescCalcHidden = 0;
	SET @pfStartDateCalcHidden = 0;
	SET @pfEndDateCalcHidden = 0;
	
	/* Check the calendar report exists. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCalendarReports]
	WHERE ID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report has been deleted by another user.';
		RETURN;
	END

	SELECT	@psCalendarReportName = name,
					@psCalendarReportOwner = userName,
					@psCalendarReportDesc = description,
					@piBaseTableID = baseTable,
					@pfAllRecords = allRecords,
					@piPicklistID = picklist,
					@piFilterID = filter,
					@pfPrintFilterHeader = PrintFilterHeader,
					@piDesc1ID = Description1,
					@piDesc2ID = Description2,
					@piDescExprID = DescriptionExpr,
					@piRegionID = Region,
					@pfGroupByDesc = GroupByDesc,
					@pfDescSeparator = DescriptionSeparator,
					@piStartType = StartType,
					@pdFixedStart = FixedStart,
					@piStartFrequency = StartFrequency,
					@piStartPeriod = StartPeriod,
					@piCustomStartID = StartDateExpr,
					@piEndType = EndType,
					@pdFixedEnd = FixedEnd,
					@piEndFrequency = EndFrequency,
					@piEndPeriod = EndPeriod,
					@piCustomEndID = EndDateExpr,
					@pfShadeBHols = ShowBankHolidays,
					@pfShowCaptions = ShowCaptions,
					@pfShadeWeekends = ShowWeekends,
					@pfStartOnCurrentMonth = StartOnCurrentMonth,
					@pfIncludeWorkingDaysOnly	= IncludeWorkingDaysOnly,
					@pfIncludeBHols = IncludeBankHolidays,
					@pfOutputPreview = OutputPreview,
					@piOutputFormat = OutputFormat,
					@pfOutputScreen = OutputScreen,
					@pfOutputPrinter = OutputPrinter,
					@psOutputPrinterName = OutputPrinterName,
					@pfOutputSave = OutputSave,
					@piOutputSaveExisting = OutputSaveExisting,
					@pfOutputEmail = OutputEmail,
					@piOutputEmailAddr = OutputEmailAddr,
					@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
					@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
					@psOutputFilename = ISNULL(OutputFilename,''),
					@piTimestamp = convert(integer, timestamp)
	FROM [dbo].[ASRSysCalendarReports]
	WHERE ID = @piCalendarReportID;

	/* Check the current user can view the calendar report. */
	exec [dbo].[spASRIntCurrentUserAccess]
		17, 
		@piCalendarReportID,
		@sAccess OUTPUT;

	IF (@sAccess = 'HD') AND (@psCalendarReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'calendar report has been made hidden by another user.';
		RETURN;
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psCalendarReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'calendar report has been made read only by another user.';
		RETURN;
	END

	/* Check the calendar report has details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCalendarReportEvents]
		WHERE ASRSysCalendarReportEvents.calendarReportID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report contains no details.';
		RETURN;
	END

	/* Check the calendar report has sort order details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCalendarReportOrder]
		WHERE ASRSysCalendarReportOrder.calendarReportID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report contains no sort order details.';
		RETURN;
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psCalendarReportName = left('copy of ' + @psCalendarReportName, 50);
		SET @psCalendarReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access
		FROM ASRSysPicklistName 
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfPicklistHidden = 1;
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfFilterHidden = 1;
		END
	END
	
	IF @piDescExprID > 0 
	BEGIN
		SELECT @psDescExprName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piDescExprID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfDescCalcHidden = 1;
		END
	END
	
	IF @piCustomStartID > 0 
	BEGIN
		SELECT @psCustomStartName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomStartID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfStartDateCalcHidden = 1;
		END
	END
	
	IF @piCustomEndID > 0 
	BEGIN
		SELECT @psCustomEndName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomEndID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfEndDateCalcHidden = 1;
		END
	END


	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM ASRSysEmailGroupName
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;
		SET @psOutputEmailName = '';
	END

	/* Get the calendar events definition recordset. */
	SELECT 
			ASRSysCalendarReportEvents.Name + char(9) + 
			CONVERT(varchar,ASRSysCalendarReportEvents.TableID) + char(9) +
			(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ASRSysCalendarReportEvents.TableID) + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.FilterID) + char(9) +
			CASE 
				WHEN ASRSysCalendarReportEvents.FilterID > 0 THEN
					(SELECT ISNULL(ASRSysExpressions.Name,'') FROM ASRSysExpressions WHERE ASRSysExpressions.ExprID = ASRSysCalendarReportEvents.FilterID) 
				ELSE
					''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventStartDateID) + char(9) +
			(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventStartDateID) + char(9) +
			
			CONVERT(varchar,ASRSysCalendarReportEvents.EventStartSessionID) + char(9) + 
			CASE 
				WHEN ASRSysCalendarReportEvents.EventStartSessionID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventStartSessionID)
				ELSE
					''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventEndDateID) + char(9) +
			CASE 
				WHEN ASRSysCalendarReportEvents.EventEndDateID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventEndDateID)
				ELSE ''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventEndSessionID) + char(9) + 
			CASE 
				WHEN ASRSysCalendarReportEvents.EventEndSessionID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventEndSessionID)
				ELSE
					''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventDurationID) + char(9) + 
			CASE 
				WHEN ASRSysCalendarReportEvents.EventDurationID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDurationID)
				ELSE 
					''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.LegendType) + char(9) +
			CASE 
				WHEN ASRSysCalendarReportEvents.LegendType = 1 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ASRSysCalendarReportEvents.LegendLookupTableID) + 
					'.' +
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.LegendLookupCodeID)
				ELSE
					ASRSysCalendarReportEvents.LegendCharacter
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.LegendLookupTableID) + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.LegendLookupColumnID) + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.LegendLookupCodeID) + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.LegendEventColumnID) + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventDesc1ColumnID) + char(9) +
			CASE 
				WHEN ASRSysCalendarReportEvents.EventDesc1ColumnID > 0 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ((SELECT ISNULL(ASRSysColumns.TableID,0) FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc1ColumnID))) + 
					'.' + 
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc1ColumnID)
				ELSE
					''
			END + char(9) +
			CONVERT(varchar,ASRSysCalendarReportEvents.EventDesc2ColumnID) + char(9) +
			CASE
				WHEN ASRSysCalendarReportEvents.EventDesc2ColumnID > 0 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID IN ((SELECT ISNULL(ASRSysColumns.TableID,0) FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc2ColumnID))) + 
					'.' + 
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc2ColumnID)
				ELSE
					''
	 		END + char(9) +
			ASRSysCalendarReportEvents.EventKey	 + char(9) +
			CASE 
				WHEN ASRSysCalendarReportEvents.FilterID > 0 THEN
			  		(SELECT CASE WHEN ASRSysExpressions.Access = 'HD' THEN 'Y' ELSE 'N' END FROM ASRSysExpressions WHERE ASRSysExpressions.ExprID = ASRSysCalendarReportEvents.FilterID) 
				ELSE
					'N'
			END	
			AS [DefinitionString],
		
			CASE 
				WHEN ASRSysCalendarReportEvents.FilterID > 0 THEN
			  		(SELECT CASE WHEN ASRSysExpressions.Access = 'HD' THEN 'Y' ELSE 'N' END FROM ASRSysExpressions WHERE ASRSysExpressions.ExprID = ASRSysCalendarReportEvents.FilterID) 
				ELSE
					'N'
			END AS [FilterHidden]
	FROM ASRSysCalendarReportEvents
	WHERE ASRSysCalendarReportEvents.CalendarReportID = @piCalendarReportID
	ORDER BY ASRSysCalendarReportEvents.ID;
END

GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetColumnsFromTablesAndViews]
AS
BEGIN

	SET NOCOUNT ON;
	
	SELECT c.columnName, c.columnType, c.dataType
		, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
		, t.tableName AS tableViewName
	FROM dbo.tbsys_columns c
	INNER JOIN tbsys_tables t ON c.tableID = t.tableID
	UNION 
	SELECT c.columnName, c.columnType, c.dataType
		, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
		, v.viewName AS tableViewName 
	FROM dbo.tbsys_columns c
	INNER JOIN ASRSysViews v ON c.tableID = v.viewTableID 
	LEFT OUTER JOIN ASRSysViewColumns vc ON (v.viewID = vc.viewID 
			AND c.columnID = vc.columnID)
	WHERE vc.inView = 1 OR c.columnType = 3 
	ORDER BY tableViewName;


	-- Version 2 (runs better looking at the execution plan, but does in fact incur more reads!)
	--DECLARE @columns TABLE (columnName varchar(255), columnType int, datatype integer, columnID integer, TableID integer, uniquechecktype bit);

	--INSERT @columns
	--	SELECT c.columnName, c.columnType, c.dataType
	--		, c.columnID, c.TableID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
	--		FROM dbo.ASRSysColumns c;

	--SELECT c.columnName, c.columnType, c.dataType
	--	, c.columnID, c.uniqueCheckType
	--	, t.tableName AS tableViewName
	--FROM @columns c
	--INNER JOIN ASRSysTables t ON c.tableID = t.tableID
	--UNION 
	--SELECT c.columnName, c.columnType, c.dataType
	--	, c.columnID, c.uniqueCheckType
	--	, v.viewName AS tableViewName 
	--FROM @columns c
	--INNER JOIN ASRSysViews v ON c.tableID = v.viewTableID 
	--LEFT OUTER JOIN ASRSysViewColumns vc ON (v.viewID = vc.viewID AND c.columnID = vc.columnID)
	--WHERE vc.inView = 1 OR c.columnType = 3 
	--ORDER BY tableViewName;


	-- Version 1. Looking as column and table views, but is quite slow.
	--SELECT c.columnName, c.columnType, c.dataType
	--	, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
	--	, t.tableName AS tableViewName
	--FROM dbo.ASRSysColumns c
	--INNER JOIN ASRSysTables t ON c.tableID = t.tableID
	--UNION 
	--SELECT c.columnName, c.columnType, c.dataType
	--	, c.columnID, ISNULL(c.uniqueCheckType,0) AS uniqueCheckType
	--	, v.viewName AS tableViewName 
	--FROM dbo.ASRSysColumns c
	--INNER JOIN ASRSysViews v ON c.tableID = v.viewTableID 
	--LEFT OUTER JOIN ASRSysViewColumns vc ON (v.viewID = vc.viewID 
	--		AND c.columnID = vc.columnID)
	--WHERE vc.inView = 1 OR c.columnType = 3 
	--ORDER BY tableViewName;



END



GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetDefaultOrder]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetDefaultOrder] (
	@piTableID	integer,
	@piOrderID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piOrderID = defaultOrderID
	FROM ASRSysTables
	WHERE tableID = @piTableID;
END

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetDocumentManagementTypes]	
	AS
	BEGIN
		SET NOCOUNT ON
		SELECT [DocumentMapID], 
			[Name], 
			[Username], 
			[Access] 
		FROM [ASRSysDocumentManagementTypes] 
		ORDER BY [Name]
	END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEmailGroupAddresses]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEmailGroupAddresses]
	(@EmailGroupID int)
AS
BEGIN

	SET NOCOUNT ON;

	select Fixed from ASRSysEmailAddress
	where EmailID in
	(select EmailDefID from ASRSysEmailGroupItems where EmailGroupID = @EmailGroupID)
	order by [Name];

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogBatchDetails]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails] (
	@piBatchRunID 	integer,
	@piEventID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sExecString		nvarchar(MAX),
			@sSelectString 		varchar(MAX),
			@sFromString		varchar(MAX),
			@sWhereString		varchar(MAX),
			@sOrderString 		varchar(MAX);

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 
		 ID, 
		 DateTime,
		 EndTime,
		 IsNull(Duration,-1) AS Duration,
		 Username,
		 CASE Type 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
		 END AS Type,
		 Name,
		 CASE Mode 
			WHEN 1 THEN ''Batch''
			WHEN 0 THEN ''Manual''
			ELSE ''Unknown''
		 END AS Mode, 
		 CASE Status 
				WHEN 0 THEN ''Pending''
		   	WHEN 1 THEN ''Cancelled'' 
				WHEN 2 THEN ''Failed'' 
				WHEN 3 THEN ''Successful'' 
				WHEN 4 THEN ''Skipped'' 
				WHEN 5 THEN ''Error''
				ELSE ''Unknown'' 
		 END AS Status,
		 IsNull(BatchName,'''') AS BatchName,
		 IsNull(convert(varchar,SuccessCount), ''N/A'') AS SuccessCount,
		 IsNull(convert(varchar,FailCount), ''N/A'') AS FailCount,
		 IsNull(convert(varchar,BatchJobID), ''N/A'') AS BatchJobID,
		 IsNull(convert(varchar,BatchRunID), ''N/A'') AS BatchRunID';

	SET @sFromString = ' FROM ASRSysEventLog ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE BatchRunID = ' + convert(varchar, @piBatchRunID);
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE ID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY DateTime ASC ';

	SET @sExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;

	-- Run generated statement
	EXEC sp_executeSQL @sExecString;
	
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogDetails]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEventLogDetails] (
	@piBatchRunID	integer,
	@piEventID		integer,
	@piExists		integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sSelectString			varchar(MAX),
			@sFromString			varchar(255),
			@sWhereString			varchar(MAX),
			@sOrderString 			varchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer;

	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(*) FROM ASRSysEventLog WHERE ID = ' + convert(varchar,@piEventID);

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piExists = @iCount;
	/****************************************************************************************************************************************/

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT [ID], [EventLogID], IsNull([Notes],'''') AS ''Notes'' ';

	SET @sFromString = ' FROM AsrSysEventLogDetails ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE AsrSysEventLogDetails.EventLogID IN (SELECT ID FROM ASRSysEventLog WHERE BatchRunID = ' + convert(varchar, @piBatchRunID) + ')';
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE AsrSysEventLogDetails.EventLogID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY AsrSysEventLogDetails.[ID] ';
	
	SET @sTempExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;
	EXEC sp_executesql @sTempExecString;
	
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmailInfo]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo] (
	@psSelectedIDs	varchar(MAX),
	@psSubject		varchar(MAX) OUTPUT,
	@psOrderColumn	varchar(MAX),
	@psOrderOrder	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSelectString 	nvarchar(MAX),
			@sOrderSQL		varchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	SELECT @psSubject = IsNull(SettingValue,'<<Unknown Customer>>') + ' - Event Log' 
	FROM ASRSysSystemSettings 
	WHERE Lower(Section) = 'licence' 
		AND Lower(SettingKey) = 'customer name';

	SET @sSelectString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 	A.ID, 
		A.Name, 
		A.DateTime,
		A.EndTime,
		IsNull(A.Duration,-1) AS Duration, 
		A.Username, 
		CASE A.Mode 
			WHEN 1 THEN ''Batch'' 
			ELSE ''Manual'' 
		END AS ''Mode'', 
		CASE A.Status 
			WHEN 0 THEN ''Pending''
		  WHEN 1 THEN ''Cancelled'' 
			WHEN 2 THEN ''Failed'' 
			WHEN 3 THEN ''Successful'' 
			WHEN 4 THEN ''Skipped'' 
			WHEN 5 THEN ''Error''
			ELSE ''Unknown'' 
		END AS Status, 
		CASE A.Type 
			WHEN 0 THEN ''Unknown''
			WHEN 1 THEN ''Cross Tab'' 
			WHEN 2 THEN ''Custom Report'' 
			WHEN 3 THEN ''Data Transfer'' 
			WHEN 4 THEN ''Export'' 
			WHEN 5 THEN ''Global Add'' 
			WHEN 6 THEN ''Global Delete'' 
			WHEN 7 THEN ''Global Update'' 
			WHEN 8 THEN ''Import'' 
			WHEN 9 THEN ''Mail Merge'' 
			WHEN 10 THEN ''Diary Delete'' 
			WHEN 11 THEN ''Diary Rebuild''
			WHEN 12 THEN ''Email Rebuild''
			WHEN 13 THEN ''Standard Report''
			WHEN 14 THEN ''Record Editing''
			WHEN 15 THEN ''System Error''
			WHEN 16 THEN ''Match Report''
			WHEN 17 THEN ''Calendar Report''
			WHEN 18 THEN ''Envelopes & Labels''
			WHEN 19 THEN ''Label Definition''
			WHEN 20 THEN ''Record Profile''
			WHEN 21	THEN ''Succession Planning''
			WHEN 22 THEN ''Career Progression''
			WHEN 25 THEN ''Workflow Rebuild''
			ELSE ''Unknown''  
		END AS Type,
		CASE 
			WHEN A.SuccessCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.SuccessCount)
		END AS SuccessCount,
		CASE
			WHEN A.FailCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.FailCount)
		END AS FailCount,
		A.BatchName AS BatchName,
		A.BatchJobID AS BatchJobID,
		A.BatchRunID AS BatchRunID,
		B.Notes, 
		B.ID AS ''DetailsID'' ,
		(SELECT count(ID) 
			FROM ASRSysEventLogDetails C 
			WHERE C.EventLogID = A.ID) as ''count''
		FROM ASRSysEventLog A
		LEFT OUTER JOIN ASRSysEventLogDetails B
			ON A.ID = B.EventLogID
		WHERE A.ID IN (' + @psSelectedIDs + ')';

	SET @sOrderSQL = '';
	
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
				WHEN 1 THEN ''Cross Tab''
				WHEN 2 THEN ''Custom Report''
				WHEN 3 THEN ''Data Transfer''
				WHEN 4 THEN ''Export''
				WHEN 5 THEN ''Global Add''
				WHEN 6 THEN ''Global Delete''
				WHEN 7 THEN ''Global Update''
				WHEN 8 THEN ''Import''
				WHEN 9 THEN ''Mail Merge''
				WHEN 10 THEN ''Diary Delete''
				WHEN 11 THEN ''Diary Rebuild''
				WHEN 12 THEN ''Email Rebuild''
				WHEN 13 THEN ''Standard Report''
				WHEN 14 THEN ''Record Editing''
				WHEN 15 THEN ''System Error''
				WHEN 16 THEN ''Match Report''
				WHEN 17 THEN ''Calendar Report''
				WHEN 18 THEN ''Envelopes & Labels''
				WHEN 19 THEN ''Label Definition''
				WHEN 20 THEN ''Record Profile''
				WHEN 21 THEN ''Succession Planning''
				WHEN 22 THEN ''Career Progression''
				WHEN 25 THEN ''Workflow Rebuild''
				ELSE ''Unknown''
			END ';
	END

	IF @psOrderColumn = 'Mode'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Mode] 
				WHEN 1 THEN ''Batch''
				WHEN 0 THEN ''Manual''
				ELSE ''Unknown''
			END ';
	END
	
	IF @psOrderColumn = 'Status'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Status] 
				WHEN 0 THEN ''Pending''
				WHEN 1 THEN ''Cancelled''
				WHEN 2 THEN ''Failed''
				WHEN 3 THEN ''Successful''
				WHEN 4 THEN ''Skipped''
				WHEN 5 THEN ''Error''
				ELSE ''Unknown''
			END ';
	END
	
	IF len(@sOrderSQL) = 0
	BEGIN
		SET @sOrderSQL = @psOrderColumn;
	END
	
	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder;

	IF LEN(LTRIM(RTRIM(@sOrderSQL))) > 0 
	BEGIN
		SET @sSelectString = @sSelectString + ' ORDER BY ' + @sOrderSQL;
	END

	EXEC sp_executeSQL @sSelectString;
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogEmails]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEventLogEmails]
AS
BEGIN

	SET NOCOUNT ON;

	SELECT [ASRSysEmailGroupName].[EmailGroupID] AS 'EmailGroupID', 
					[ASRSysEmailGroupName].[Name] AS 'Name'
	FROM [ASRSysEmailGroupName]
	UNION
	SELECT -1  AS 'EmailGroupID',
				(SELECT [ASRSysSystemSettings].[SettingValue]
			FROM [ASRSysSystemSettings]
			WHERE ([ASRSysSystemSettings].[Section] = 'Support')
				AND ([ASRSysSystemSettings].[SettingKey] = 'Email')
			) AS 'Name'
	ORDER BY 'Name';

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogPurgeDetails]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE Procedure [dbo].[spASRIntGetEventLogPurgeDetails]
AS
BEGIN
	SET NOCOUNT ON;

	SELECT * FROM ASRSysEventLogPurge;
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogRecords]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetEventLogRecords] (
	@pfError 						bit 				OUTPUT, 
	@psFilterUser					varchar(MAX),
	@piFilterType					integer,
	@piFilterStatus					integer,
	@piFilterMode					integer,
	@psOrderColumn					varchar(MAX),
	@psOrderOrder					varchar(MAX),
	@piRecordsRequired				integer,
	@pfFirstPage					bit					OUTPUT,
	@pfLastPage						bit					OUTPUT,
	@psAction						varchar(100),
	@piTotalRecCount				integer				OUTPUT,
	@piFirstRecPos					integer				OUTPUT,
	@piCurrentRecCount				integer
)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE	@sRealSource 			sysname,
			@sSelectSQL				varchar(MAX),
			@iTempCount 			integer,
			@sExecString			nvarchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer,
			@iGetCount				integer,
			@sFilterSQL				varchar(MAX),
			@sOrderSQL				varchar(MAX),
			@sReverseOrderSQL		varchar(MAX);
			
	/* Clean the input string parameters. */
	IF len(@psAction) > 0 SET @psAction = replace(@psAction, '''', '''''');
	IF len(@psFilterUser) > 0 SET @psFilterUser = replace(@psFilterUser, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sExecString = '';
	SET @sRealSource = 'ASRSysEventLog';
	SET @psAction = UPPER(@psAction);

	IF (@psAction <> 'MOVEPREVIOUS') AND (@psAction <> 'MOVENEXT') AND (@psAction <> 'MOVELAST') 
		BEGIN
			SET @psAction = 'MOVEFIRST';
		END

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 50;

	/* Construct the filter SQL from ther input parameters. */
	SET @sFilterSQL = '';
	
	SET @sFilterSQL = @sFilterSQL + ' Type NOT IN (23, 24) ';

	IF @psFilterUser <> '-1' 
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' LOWER(username) = ''' + lower(@psFilterUser) + '''';
	END
	IF @piFilterType <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Type = ' + convert(varchar(MAX), @piFilterType) + ' ';
	END
	IF @piFilterStatus <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Status = ' + convert(varchar(MAX), @piFilterStatus) + ' ';
	END
	IF @piFilterMode <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Mode = ' + convert(varchar(MAX), @piFilterMode) + ' ';
	END
	
	/* Construct the order SQL from ther input parameters. */
	SET @sOrderSQL = '';
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
					WHEN 1 THEN ''Cross Tab''
					WHEN 2 THEN ''Custom Report''
					WHEN 3 THEN ''Data Transfer''
					WHEN 4 THEN ''Export''
					WHEN 5 THEN ''Global Add''
					WHEN 6 THEN ''Global Delete''
					WHEN 7 THEN ''Global Update''
					WHEN 8 THEN ''Import''
					WHEN 9 THEN ''Mail Merge''
					WHEN 10 THEN ''Diary Delete''
					WHEN 11 THEN ''Diary Rebuild''
					WHEN 12 THEN ''Email Rebuild''
					WHEN 13 THEN ''Standard Report''
					WHEN 14 THEN ''Record Editing''
					WHEN 15 THEN ''System Error''
					WHEN 16 THEN ''Match Report''
					WHEN 17 THEN ''Calendar Report''
					WHEN 18 THEN ''Envelopes & Labels''
					WHEN 19 THEN ''Label Definition''
					WHEN 20 THEN ''Record Profile''
					WHEN 21 THEN ''Succession Planning''
					WHEN 22 THEN ''Career Progression''
					WHEN 25 THEN ''Workflow Rebuild''
					ELSE ''Unknown''
				END ';
	END
	ELSE
	BEGIN
		IF @psOrderColumn = 'Mode'
		BEGIN
			SET @sOrderSQL =	
				' CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
					END ';
		END
		ELSE 
		BEGIN
			IF @psOrderColumn = 'Status'
			BEGIN
				SET @sOrderSQL =	
					' CASE [Status]
							WHEN 0 THEN ''Pending''
							WHEN 1 THEN ''Cancelled''
							WHEN 2 THEN ''Failed''
							WHEN 3 THEN ''Successful''
							WHEN 4 THEN ''Skipped''
							WHEN 5 THEN ''Error''
							ELSE ''Unknown''
						END ';
			END
			ELSE
			BEGIN
				SET @sOrderSQL = @psOrderColumn;
			END
		END
	END
	
	SET @sReverseOrderSQL = @sOrderSQL;
	if @psOrderOrder = 'DESC'
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' ASC ';
	END
	ELSE
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' DESC ';
	END

	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder + ' ';


	SET @sSelectSQL = '[DateTime],
					[EndTime],
					IsNull([Duration],-1) AS ''Duration'', 
		 			CASE [Type] 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						ELSE ''Unknown''  
					END + char(9) + 
				 	[Name] + char(9) + 
		 			CASE Status 
						WHEN 0 THEN ''Pending''
					  WHEN 1 THEN ''Cancelled'' 
						WHEN 2 THEN ''Failed'' 
						WHEN 3 THEN ''Successful'' 
						WHEN 4 THEN ''Skipped'' 
						WHEN 5 THEN ''Error''
						ELSE ''Unknown'' 
					END + char(9) +
					CASE [Mode] 
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						ELSE ''Unknown''
				 	END + char(9) + 
					[Username] + char(9) + 
					IsNull(convert(varchar, [BatchJobID]), ''0'') + char(9) +
					IsNull(convert(varchar, [BatchRunID]), ''0'') + char(9) +
					IsNull([BatchName],'''') + char(9) +
					IsNull(convert(varchar, [SuccessCount]),''0'') + char(9) +
					IsNull(convert(varchar, [FailCount]), ''0'') AS EventInfo ';

		
	
	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.ID) FROM ' + @sRealSource;

	IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;
	/****************************************************************************************************************************************/
	
	IF len(@sSelectSQL) > 0 
		BEGIN
			SET @sSelectSQL = @sRealSource + '.ID, ' + @sSelectSQL;
			SET @sExecString = 'SELECT ' ;

			IF @psAction = 'MOVEFIRST'
				BEGIN
					SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
					
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource ;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = 1;
					SET @pfFirstPage = 1;
					SET @pfLastPage = 
					CASE 
						WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
						ELSE 0
					END;
				END
		
			IF (@psAction = 'MOVELAST')
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
					
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')'

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
					IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
					SET @pfFirstPage = 	CASE 
									WHEN @piFirstRecPos = 1 THEN 1
									ELSE 0
								END;
					SET @pfLastPage = 1;

				END

			IF (@psAction = 'MOVENEXT') 
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
						BEGIN
							SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')';

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
					SET @pfFirstPage = 0
					SET @pfLastPage = 	CASE 
									WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
									ELSE 0
								END;
				END

			IF @psAction = 'MOVEPREVIOUS'
				BEGIN	
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF @piFirstRecPos <= @piRecordsRequired
						BEGIN
							SET @iGetCount = @piFirstRecPos - 1;
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END
		
					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
				
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')';
						END
					
					SET @sExecString = @sExecString

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
		
					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
					IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
					SET @pfFirstPage = CASE WHEN @piFirstRecPos = 1 
															THEN 1
															ELSE 0
														 END;
					SET @pfLastPage = CASE WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount 
															THEN 1
															ELSE 0
														END;
				END

		END

	EXECUTE sp_executeSQL @sExecString;
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetEventLogUsers]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogUsers]
AS
BEGIN
	SELECT DISTINCT Username FROM ASRSysEventLog ORDER BY Username
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetLinkInfo]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetLinkInfo]
(
	@piLinkID 		integer,
	@piScreenID		integer			OUTPUT,
	@piTableID		integer			OUTPUT,
	@psTitle		varchar(MAX)	OUTPUT,
	@piStartMode	integer			OUTPUT, 
	@piTableType	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT 
		@piScreenID = ASRSysSSIntranetLinks.screenID,
		@piTableID = ASRSysScreens.tableID,
		@psTitle = ASRSysSSIntranetLinks.pageTitle,
		@piStartMode = ASRSysSSIntranetLinks.startMode,
		@piTableType = ASRSysTables.TableType
	FROM ASRSysSSIntranetLinks
			INNER JOIN ASRSysScreens 
			ON ASRSysSSIntranetLinks.screenID = ASRSysScreens.screenID
				INNER JOIN ASRSysTables
				ON ASRSysScreens.TableID = ASRSysTables.TableID
	WHERE ID = @piLinkID;
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupFilterValue]    Script Date: 13/09/2013 08:57:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetLookupFilterValue] (
	@piScreenID			integer,
	@piColumnID			integer,
	@piTableID			integer,
	@piViewID			integer,
	@piRecordID			integer,
	@psFilterValue		varchar(MAX)	OUTPUT,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@pfError 			bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iLookupFilterValueID	integer,
		@sRealSource			sysname,
		@sLookupFilterValueName	sysname,
		@iCount					integer,
		@iTableType				integer,
		@sTableName				sysname,
		@iChildViewID			integer,
		@sUserGroupName			sysname,
		@iUserGroupID			integer,
		@sSQL					nvarchar(MAX),
		@sSQLParam				nvarchar(500),
		@dblResult				float,
		@fResult				bit,
		@dtResult				datetime,
		@sResult				varchar(MAX),
		@iDataType				integer,
		@sActualUserName		sysname,
		@iDfltValueExprID		integer,
		@sDefaultValue			varchar(MAX),
		@lngParentTableID		integer;

	SET @psFilterValue = '';
	SET @pfError = 0;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
					
	SET @psFilterValue = '';

	SELECT @iLookupFilterValueID = lookupFilterValueID
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @piColumnID;

	IF @iLookupFilterValueID IS null SET @iLookupFilterValueID = 0;

	IF @iLookupFilterValueID > 0 
	BEGIN
		/* Check if the looup filter value column is in the screen. If so, we don't need to find it again. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysControls]
		WHERE screenID = @piScreenID
			AND columnId = @iLookupFilterValueID;

		IF @iCount = 0 
		BEGIN
			IF @piRecordID = 0
			BEGIN
				/* New record. */
				SELECT @iDfltValueExprID = dfltValueExprID, 
					@sDefaultValue = defaultValue, 
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;

				IF @iDfltValueExprID IS null SET @iDfltValueExprID = 0;
				IF @sDefaultValue IS null SET @sDefaultValue = '';
				IF @iDataType IS null SET @iDataType = 0;

				IF @iDfltValueExprID > 0
				BEGIN
					/* Calculated value as the default. */
					SELECT @iCount = COUNT(*)
					FROM sysobjects
					WHERE id = object_id(N'sp_ASRDfltExpr_' + convert(sysname, @iDfltValueExprID))
					AND OBJECTPROPERTY(id, N'IsProcedure') = 1;

					IF @iCount > 0
					BEGIN
						SET @sSQL = 'EXEC sp_ASRDfltExpr_' + convert(nvarchar(100), @iDfltValueExprID) + ' @result OUTPUT';

						DECLARE parents_cursor CURSOR LOCAL FAST_FORWARD FOR 
							SELECT parentID
							FROM ASRSysRelations
							WHERE childID = @piTableID
							ORDER BY parentID;

						OPEN parents_cursor;
						FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						WHILE (@@fetch_status = 0)
						BEGIN
						    IF @lngParentTableID = @piParentTableID
							BEGIN
								SET @sSQL = @sSQL + ',' + convert(nvarchar(100), @piParentRecordID);
							END
							ELSE
							BEGIN
								SET @sSQL = @sSQL + ',0' ;
							END

							FETCH NEXT FROM parents_cursor INTO @lngParentTableID;
						END
						CLOSE parents_cursor;
						DEALLOCATE parents_cursor;

						IF @iDataType = -7 /* Boolean */
						BEGIN
							SET @sSQLParam = N'@result integer OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

							SET @psFilterValue = 
								CASE 
									WHEN @fResult = 0 THEN 'False'
									ELSE 'True'
								END;
						END

						IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
						BEGIN
							SET @sSQLParam = N'@result float OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

							SET @psFilterValue = convert(varchar(MAX), @dblResult);
						END

						IF (@iDataType = 11) /* Date */
						BEGIN
							SET @sSQLParam = N'@result datetime OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT

							SET @psFilterValue = convert(varchar(MAX), @dtResult, 101);
						END

						IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working pattern, photo*/
						BEGIN
							SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
							EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

							SET @psFilterValue = @sResult;
						END
					END
				END
				ELSE
				BEGIN
					SET @psFilterValue = @sDefaultValue;
				END
			END
			ELSE
			BEGIN
				SELECT @sTableName = tableName,
					@iTableType = tableType
				FROM [dbo].[ASRSysTables]
				WHERE tableID = @piTableID;

				IF @iTableType <> 2 /* ie. top-level or lookup */
				BEGIN
					IF @piViewID > 0 
					BEGIN	
						/* RealSource is the view. */	
						SELECT @sRealSource = viewName
						FROM [dbo].[ASRSysViews]
						WHERE viewID = @piViewID;
					END
					ELSE
					BEGIN
						SET @sRealSource = @sTableName;
					END 
				END
				ELSE
				BEGIN
					SELECT @iChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @piTableID
						AND [role] = @sUserGroupName;
						
					IF @iChildViewID IS null SET @iChildViewID = 0;
						
					IF @iChildViewID > 0 
					BEGIN
						SET @sRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iChildViewID) +
							'#' + replace(@sTableName, ' ', '_') +
							'#' + replace(@sUserGroupName, ' ', '_');
						SET @sRealSource = left(@sRealSource, 255);
					END
				END
	
				SELECT @sLookupFilterValueName = columnName,
					@iDataType = dataType
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iLookupFilterValueID;
	
				/* Check the filter column can be read from the given table/view. */
				SELECT @iCount = COUNT(*)
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND ((sysprotects.protectType = 204) OR (sysprotects.protectType = 205))
					AND syscolumns.name = @sLookupFilterValueName
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

				IF @iCount > 0 
				BEGIN
					/* Can read the column from the realSource */
					SET @sSQL = 'SELECT @result = ' + @sLookupFilterValueName 
						+ ' FROM ' + @sRealSource
						+ ' WHERE id = ' + convert(nvarchar(100), @piRecordID);

					IF @iDataType = -7 /* Boolean */
					BEGIN
						SET @sSQLParam = N'@result integer OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @fResult OUTPUT;

						SET @psFilterValue = 
							CASE 
								WHEN @fResult = 0 or @fResult is null THEN 'False'
								ELSE 'True'
							END;
					END

					IF (@iDataType = 2) OR (@iDataType = 4) /* Numeric, Integer */
					BEGIN
						SET @sSQLParam = N'@result float OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dblResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dblResult);
					END

					IF (@iDataType = 11) /* Date */
					BEGIN
						SET @sSQLParam = N'@result datetime OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @dtResult OUTPUT;

						SET @psFilterValue = convert(varchar(8000), @dtResult, 101);
					END

					IF (@iDataType = 12) OR (@iDataType = -3) OR (@iDataType = -1) /* varchar, working patter, photo*/
					BEGIN
						SET @sSQLParam = N'@result varchar(MAX) OUTPUT';
						EXEC sp_executesql @sSQL, @sSQLParam, @sResult OUTPUT;

						SET @psFilterValue = @sResult;
					END
				END
				ELSE
				/* Column cannot be read from view */
				SET @pfError = 1;
			END
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupTables]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupTables]
AS
BEGIN
	/* return a recordset of all the lookup tables. */
	SELECT ASRSysTables.TableName, ASRSysTables.TableID 
    FROM ASRSysTables
    WHERE ASRSysTables.TableType = 3
    ORDER BY ASRSysTables.TableName;
END	

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetLookupViews]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetLookupViews]
(
	@plngTableID 		integer,
	@plngDfltOrderID 	integer	OUTPUT,
	@plngColumnID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	/* Return a recordset of the IDs and names of the views of the given table for use in the link find page. */
	DECLARE @sTableName 	varchar(255),
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iChildViewID 		integer,
		@iTableType			integer,
		@lngPermissionCount	integer,
		@sLookupColumnName	sysname,
		@sFilterColumnName	sysname,
		@sRealSource 		varchar(MAX),
		@sActualUserName	sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	/* Get the table-type. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iTableType = ASRSysTables.tableType,
		@plngDfltOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @plngTableID

	SELECT @sLookupColumnName = a.columnName,
		@sFilterColumnName = b.columnName
	FROM ASRSysColumns
	LEFT OUTER JOIN ASRSysColumns a ON ASRSysColumns.lookupColumnID = a.columnID
	LEFT OUTER JOIN ASRSysColumns b ON ASRSysColumns.lookupFilterColumnID = b.columnID
	WHERE ASRSysColumns.columnID = @plngColumnID

	IF @sLookupColumnName IS null SET @sLookupColumnName = ''
	IF @sFilterColumnName IS null SET @sFilterColumnName = ''

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	

		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @viewInfo TABLE(
		viewID			integer,
		viewName		sysname,
		orderTag		integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1)
	BEGIN
		/* Populate the temporary table. */
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		VALUES (
			0,
			@sTableName,
			0	
		)
		
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		(SELECT viewID, 
			viewName,
			1
		FROM ASRSysViews
		WHERE viewTableID = @plngTableID
		)
	END
	ELSE
	BEGIN
		IF @iTableType <> 2
		BEGIN
			/* Table is a top-level or lookup table. */
			SELECT @lngPermissionCount = COUNT(*)
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protectType <> 206
				AND syscolumns.name = @sLookupColumnName
				AND sysobjects.name = @sTableName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

			IF @lngPermissionCount > 0 
			BEGIN
				IF len(@sFilterColumnName) > 0
				BEGIN
					SELECT @lngPermissionCount = COUNT(*)
					FROM sysprotects
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.action = 193
						AND sysprotects.protectType <> 206
						AND syscolumns.name = @sFilterColumnName
						AND sysobjects.name = @sTableName
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				END

				IF @lngPermissionCount > 0 
				BEGIN
					INSERT INTO @viewInfo (
						viewID, 
						viewName,
						orderTag)
					VALUES (
						0,
						@sTableName,
						0	
					)
				END
			END

			/* Now check on the views on this table. */
			INSERT INTO @viewInfo (
				viewID, 
				viewName,
				orderTag)
			(SELECT ASRSysViews.viewID, 
				ASRSysViews.viewName, 
				1
			FROM ASRSysViews
			INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
			INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE ASRSysViews.viewTableID = @plngTableID
				AND sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protecttype <> 206
				AND syscolumns.name = @sLookupColumnName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			)

			IF len(@sFilterColumnName) > 0
			BEGIN
				DELETE FROM @viewInfo 
				WHERE viewID <> 0
					AND viewID NOT IN
				(SELECT ASRSysViews.viewID
				FROM ASRSysViews
				INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
				INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE ASRSysViews.viewTableID = @plngTableID
					AND sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193
					AND sysprotects.protecttype <> 206
					AND syscolumns.name = @sFilterColumnName
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				)
			END
		END
		ELSE
		BEGIN
			/* Get appropriate child view if required. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @plngTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)

				SELECT @lngPermissionCount = COUNT(*)
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193
					AND sysprotects.protectType <> 206
					AND syscolumns.name = @sLookupColumnName
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
	
				IF @lngPermissionCount > 0 
				BEGIN
					IF len(@sFilterColumnName) > 0
					BEGIN
						SELECT @lngPermissionCount = COUNT(*)
						FROM sysprotects
						INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
						INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
						WHERE sysprotects.uid = @iUserGroupID
							AND sysprotects.action = 193
							AND sysprotects.protectType <> 206
							AND syscolumns.name = @sFilterColumnName
							AND sysobjects.name = @sRealSource
							AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
							OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
					END
	
					IF @lngPermissionCount > 0 
					BEGIN
						INSERT INTO @viewInfo (
							viewID, 
							viewName,
							orderTag)
						VALUES (
							0,
							@sTableName,
							0	
						)
					END
				END
			END
		END
	END

	/* Return the resultset. */
	SELECT viewID, viewName
	FROM @viewInfo
	ORDER BY orderTag, viewName
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetNavigationLinks]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetNavigationLinks]
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@iViewID				integer,
		@iUtilType				integer, 
		@iUtilID				integer, 
		@iScreenID				integer, 
		@sURL					varchar(MAX),
		@iTableID				integer,
		@sTableName				sysname,
		@iTableType				integer,
		@sRealSource			sysname,
		@iChildViewID			integer,
		@sAccess				varchar(MAX),
		@fTableViewOK			bit,
		@pfCustomReportsRun		bit,
		@pfCalendarReportsRun	bit,
		@pfMailMergeRun			bit,
		@pfWorkflowRun			bit,
		@sGroupName				varchar(255),
		@sActualUserName		sysname,
		@iActualUserGroupID 	integer, 
		@sViewName				sysname,
		@iLinkType 				integer,			/* 0 = Hypertext, 1 = Button, 2 = Dropdown List */
		@fFindPage				bit

	/* See if the current user can run the defined Reports/Utilties. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER)))  = 'SA'
	BEGIN
		SET @pfCustomReportsRun = 1
		SET @pfCalendarReportsRun = 1
		SET @pfMailMergeRun = 1
		SET @pfWorkflowRun = 1
	END
	ELSE
	BEGIN
		EXEC dbo.spASRIntGetActualUserDetails
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT
			
		DECLARE @unionTable TABLE (ID int PRIMARY KEY CLUSTERED)

		INSERT INTO @unionTable 
			SELECT Object_ID(ViewName) 
			FROM ASRSysViews 
			WHERE viewID IN (SELECT viewID FROM ASRSysSSIViews)
				AND NOT Object_ID(ViewName) IS null
			UNION
			SELECT Object_ID(TableName) 
			FROM ASRSysTables 
			WHERE tableID IN (SELECT tableID FROM ASRSysSSIViews)
				AND NOT Object_ID(TableName) IS null
				AND tableID NOT IN (SELECT tableID 
					FROM ASRSysViewMenuPermissions 
					WHERE ASRSysViewMenuPermissions.groupName = @sGroupName
						AND ASRSysViewMenuPermissions.hideFromMenu = 1)
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null

		DECLARE @readableTables TABLE (name sysname)	
	
		INSERT INTO @readableTables
			SELECT OBJECT_NAME(p.id)
			FROM syscolumns
			INNER JOIN #SysProtects p 
				ON (syscolumns.id = p.id
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
			WHERE syscolumns.name = 'timestamp'
				AND (p.ID IN (SELECT id FROM @unionTable))
				AND p.Action = 193 AND ProtectType IN (204, 205)
				OPTION (KEEPFIXED PLAN)

		SELECT @pfCustomReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CUSTOMREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	
		SELECT @pfCalendarReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CALENDARREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfMailMergeRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'MAILMERGE'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfWorkflowRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'WORKFLOW'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	END

	DECLARE @links TABLE(
		LinkType			integer,
		Text1	 			varchar(200),
		Text2	 			varchar(200),
		SingleRecord		bit,
		LinkToFind			bit,
		TableID				integer,
		ViewID				integer ,
		PrimarySequence		integer,
		SecondarySequence	integer,
		FindPage			integer)

	/* Hypertext links. */
	/* Single Record View UNION Multiple Record Tables/Views UNION Table/View Hypertext Links link */
	INSERT INTO @links
		SELECT 0, linksLinkText, '', 1, 0, tableID, viewID, 0, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 1
			AND LEN(linksLinkText) > 0
		UNION
		SELECT 0, hypertextLinkText, '', 0, 1, tableID, viewID, 2, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND LEN(hypertextLinkText) > 0
		UNION
		SELECT 0, linksLinkText, '', 0, 0, tableID, viewID, 1, sequence, 1
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND tableid = @plngTableID
			AND viewID = @plngViewID

	/* Button links. */
	INSERT INTO @links
	SELECT 1, buttonLinkPromptText, buttonLinkButtonText, 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE buttonLink = 1

	/* DropdownList links. */
	INSERT INTO @links
	SELECT 2, dropdownListLinkText, '', 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE dropdownListLink = 1


	/* Remove linkToFind links for links to views that are not readable by the user, or those that have no valid links defined for them. */
	DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ISNULL(l.viewID, -1) 'viewID', ASRSysViews.viewName, l.tableID, ASRSysTables.tableName
		FROM @links	l
		LEFT OUTER JOIN ASRSysViews	
			ON l.viewID = ASRSysViews.viewID
		INNER JOIN ASRSysTables
			ON l.tableID = ASRSysTables.tableID

	OPEN viewsCursor
	FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fTableViewOK = 0
		
		IF @iViewID > 0 
		BEGIN 
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sViewName
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sTableName
		END 

		IF @iCount > 0
		BEGIN

			DECLARE linksCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysSSIntranetLinks.utilityType,
							ASRSysSSIntranetLinks.utilityID,
							ASRSysSSIntranetLinks.screenID,
							ASRSysSSIntranetLinks.url
			FROM ASRSysSSIntranetLinks
			WHERE tableID = @iTableID 
				AND	viewID = @iViewID
	
			OPEN linksCursor
			FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			WHILE (@@fetch_status = 0) AND (@fTableViewOK = 0)
			BEGIN
				IF LEN(@sURL) > 0 OR (UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA')
				BEGIN
					SET @fTableViewOK = 1
				END
				ELSE
				BEGIN
					IF @iUtilID > 0
					BEGIN
						/* Check if the utility is deleted or hidden from the user. */
						EXECUTE dbo.spASRIntCurrentAccessForRole
												@sGroupName,
												@iUtilType,
												@iUtilID,
												@sAccess	OUTPUT
	
						IF @sAccess <> 'HD' 
						BEGIN
							IF @iUtilType = 2 AND @pfCustomReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 17 AND @pfCalendarReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 9 AND @pfMailMergeRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 25 AND @pfWorkflowRun = 1 SET @fTableViewOK = 1
						END
					END
	
					IF (@iScreenID > 0) 
					BEGIN
						/* Do not display the link if the user does not have permission to read the defined view/tbale for the screen. */
						SELECT @iTableID = ASRSysTables.tableID, 
							@sTableName = ASRSysTables.tableName,
							@iTableType = ASRSysTables.tableType
						FROM ASRSysScreens
										INNER JOIN ASRSysTables 
										ON ASRSysScreens.tableID = ASRSysTables.tableID
						WHERE screenID = @iScreenID
	
						SET @sRealSource = ''
						IF @iTableType  = 2
						BEGIN
							SET @iChildViewID = 0
	
							/* Child table - check child views. */
							SELECT @iChildViewID = childViewID
							FROM ASRSysChildViews2
							WHERE tableID = @iTableID
								AND role = @sGroupName
							
							IF @iChildViewID IS null SET @iChildViewID = 0
							
							IF @iChildViewID > 0 
							BEGIN
								SET @sRealSource = 'ASRSysCV' + 
									convert(varchar(1000), @iChildViewID) +
									'#' + replace(@sTableName, ' ', '_') +
									'#' + replace(@sGroupName, ' ', '_')
							
								SET @sRealSource = left(@sRealSource, 255)
							END
						END
						ELSE
						BEGIN
							/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
							IF @iViewID > 0 
							BEGIN 
								SELECT @sRealSource = viewName
								FROM ASRSysViews
								WHERE viewID = @iViewID
							END
							ELSE
							BEGIN
								SELECT @sRealSource = tableName
								FROM ASRSysTables
								WHERE tableID = @iTableID
							END 
	
							IF @sRealSource IS null SET @sRealSource = ''
						END
	
						IF len(@sRealSource) > 0
						BEGIN
							SELECT @iCount = COUNT(*)
							FROM @readableTables
							WHERE name = @sRealSource
						
							IF @iCount = 1 SET @fTableViewOK = 1
						END
					END
				END
								
				FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			END
			CLOSE linksCursor
			DEALLOCATE linksCursor

		END
		
		IF @fTableViewOK = 0
		BEGIN
			IF @iViewID > 0 
			BEGIN
				DELETE FROM @links
				WHERE viewID = @iViewID
			END
			ELSE
			BEGIN
				DELETE FROM @links
				WHERE tableid = @iTableID AND viewID = @iViewID
			END
		END
	
		FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	END
	CLOSE viewsCursor
	DEALLOCATE viewsCursor

	SELECT *
	FROM @links
	ORDER BY [primarySequence], [secondarySequence]

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetOpFuncShortcuts]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetOpFuncShortcuts]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the operators and functions that have shortcut keys. */
	DECLARE	@iFunctionID		integer, 
			@sParameter			varchar(MAX),
			@iLastFunctionID	integer,
			@sParameters		varchar(MAX);

	SET @iLastFunctionID = 0;
	SET @sParameters = '';

	DECLARE @tempParams TABLE(
		[functionID]	integer,
		[parameters]	varchar(MAX));

	DECLARE paramsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysFunctionParameters.functionID, 
			ASRSysFunctionParameters.parameterName
		FROM ASRSysFunctionParameters
		INNER JOIN ASRSysFunctions ON ASRSysFunctionParameters.functionID = ASRSysFunctions.functionID
			AND LEN(ASRSysFunctions.shortcutKeys) > 0
		ORDER BY ASRSysFunctionParameters.functionID, ASRSysFunctionParameters.parameterIndex;

	OPEN paramsCursor;
	FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iFunctionID <> @iLastFunctionID
		BEGIN
			IF LEN(@sParameters) >0 
			BEGIN
				INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
			END

			SET @iLastFunctionID = @iFunctionID;
			SET @sParameters = @sParameter;
		END
		ELSE
		BEGIN
			SET @sParameters = @sParameters + char(9) + @sParameter;
		END

		FETCH NEXT FROM paramsCursor INTO @iFunctionID, @sParameter;
	END

	IF LEN(@sParameters) >0 
	BEGIN
		INSERT INTO @tempParams ([functionID], [parameters]) VALUES(@iLastFunctionID, @sParameters);
	END

	SET @iLastFunctionID = @iFunctionID;
	SET @sParameters = @sParameter;

	CLOSE paramsCursor;
	DEALLOCATE paramsCursor;
	
	SELECT 5 AS [componentType], 
		ASRSysOperators.operatorID AS [ID], 
		ASRSysOperators.shortcutKeys, 
		'' AS [params],
		name AS [name]
	FROM ASRSysOperators
	WHERE len(shortcutKeys) > 0 
	UNION
	SELECT 2 AS [componentType], 
		ASRSysFunctions.functionID AS [ID], 
		ASRSysFunctions.shortcutKeys, 
		tmp.[parameters] AS [params],
		functionName AS [name]
	FROM ASRSysFunctions
	INNER JOIN @tempParams tmp ON ASRSysFunctions.functionID = tmp.functionID
	WHERE len(shortcutKeys) > 0;

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPageTitle]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetPageTitle] (
	@piTableID		integer,
	@piViewID		integer,
	@psPageTitle	varchar(200) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psPageTitle = PageTitle
	FROM ASRSysSSIViews
	WHERE (TableID = @piTableID) AND  (ViewID = @piViewID);

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParameterPassByType]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetParameterPassByType] (
	@piFunctionID		integer,
	@piParamIndex		integer,
	@piResult		integer		OUTPUT
) AS
	/* Return 1 if the given function parameter is passed by value
	Return 2 if the given parameter is passed by reference */
	DECLARE @iResult	integer
	SET @piResult = 1
	SELECT @iResult = parameterType
	FROM ASRSysFunctionParameters
	WHERE functionID = @piFunctionID
		AND parameterIndex = @piParamIndex
	IF @iResult IS null SET @iResult = 0
	IF @iResult >= 100 SET @piResult = 2

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParentValues]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetParentValues] (
	@piScreenID 		integer,
	@piParentTableID 	integer,
	@piParentRecordID 	integer
)
AS
BEGIN
	
	SET NOCOUNT ON;
	
	/* Return a recordset of the parent record values required for controls in the given screen. */
	DECLARE 
		@iUserGroupID		integer,
		@sRoleName			sysname,
		@iTempCount 		integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iParentChildViewID	integer,
		@sParentRealSource	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@sNewBit			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sParentSelectSQL	nvarchar(MAX),
		@sTemp				varchar(MAX),
		@fColumns			bit,
		@sSQL				nvarchar(MAX),
		@sActualUserName	sysname;

	SET @sParentSelectSQL  = 'SELECT ';
	SET @fColumns = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(tableViewName	sysname,
		columnName	sysname,
		granted		bit);

	SELECT @iTempCount = COUNT(*)
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysControls.columnID = ASRSysColumns.columnID
		AND ASRSysColumns.tableID = @piParentTableID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0;

	IF @iTempCount = 0 RETURN;

	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables
		WHERE tableID = @piParentTableID;

	IF @iParentTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			sysobjects.name,
			syscolumns.name,
			CASE p.protectType
			        	WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM #sysprotects p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		WHERE p.action = 193 
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piParentTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piParentTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SET @sParentRealSource = @sParentTableName;
	END
	ELSE
	BEGIN
		/* Get permitted child view on the parent table. */
		SELECT @iParentChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piParentTableID
			AND role = @sRoleName;
				
		IF @iParentChildViewID IS null SET @iParentChildViewID = 0;
				
		IF @iParentChildViewID > 0 
		BEGIN
			SET @sParentRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iParentChildViewID) +
				'#' + replace(@sParentTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sParentRealSource = left(@sParentRealSource, 255);

			INSERT INTO @columnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysColumns.columnID = ASRSysControls.columnID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0
		AND ASRSysColumns.tableID = @piParentTableID;
	
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
	
		/* Get the select permission on the column. */
		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @columnPermissions
		WHERE tableViewName = @sParentRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			IF @fColumns = 1
			BEGIN
				SET @sTemp = ',';
				SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
			END

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sNewBit = 'convert(varchar(10), ' + @sParentRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sNewBit = @sParentRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
			END

			SET @fColumns = 1;
			SET @sParentSelectSQL = @sParentSelectSQL + @sNewBit;
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @columnPermissions
			WHERE tableViewName <> @sParentRealSource
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';

				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
				END

				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);
				END

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = @sSelectString +
					' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

				IF @fColumns = 1
				BEGIN
					SET @sTemp = ',';
					SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
				END

				SET @fColumns = 1;
				SET @sParentSelectSQL = @sParentSelectSQL + @sSelectString;
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF @fColumns = 0 RETURN;

	SET @sTemp = ' FROM ' + @sParentRealSource;
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName
	FROM @joinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sParentRealSource + '.ID = ' + @sTableViewName + '.ID';
		SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

		FETCH NEXT FROM joinCursor INTO @sTableViewName;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SET @sTemp = ' WHERE ' + @sParentRealSource + '.ID = ' + convert(varchar(100), @piParentRecordID);
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	EXECUTE sp_executeSQL @sParentSelectSQL;
	
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetPicture]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetPicture]
(
	@piPictureID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT TOP 1 name, picture
	FROM ASRSysPictures
	WHERE pictureID = @piPictureID;

END

GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetQuickFindRecord] (
	@plngTableID		integer,
	@plngViewID			integer,
	@plngColumnID		integer,
	@psValue			varchar(MAX),
	@psFilterDef		varchar(MAX),
	@plngRecordID		integer			OUTPUT,
	@psDecimalSeparator	varchar(100),
	@psLocaleDateFormat	varchar(100)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@lngTableID			integer,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sRealSource 		varchar(255),
		@sTableName 		varchar(255),
		@iTableType			integer,
		@iChildViewID		integer,
		@sActualUserName	sysname,
		@sColumnName		sysname,
		@iDataType			integer,
		@iResult			integer,
		@sSQL1				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fPermitted			bit,
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sSubFilterSQL		nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psValue) > 0 SET @psValue = replace(@psValue, '''', '''''')

	SET @plngRecordID = 0
	SET @sFilterSQL = ''

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @plngViewID
	END

	/* Get the table-type. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @lngTableID

	/* Get the column name. */
	SELECT @sColumnName = columnName,
		@iDataType = dataType
	FROM ASRSysColumns
	WHERE columnID = @plngColumnID
	
	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	END

	/* Get the real source of the given screen's table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @plngViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @plngViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		/* Get appropriate child view if required. */
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @lngTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	/* Check the user has permission to read the column. */
	SET @fPermitted = 1
	IF @fSysSecMgr = 0
	BEGIN
		SELECT @iResult = COUNT(*)
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		WHERE sysprotects.uid = @iUserGroupID
			AND sysprotects.action = 193 
			AND syscolumns.name = @sColumnName
			AND sysobjects.name = @sRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		
		IF @iResult = 0 SET @fPermitted = 0
	END
	
	IF @fPermitted = 1
	BEGIN
		/* Construct the SQL query for getting the record. */
		SET @sSQL1 = 'SELECT @result = id' +
			' FROM ' + @sRealSource +
			' WHERE ' + @sColumnName 
			
		IF (@iDataType = 11) AND len(@psValue) = 0
		BEGIN
			/* Date column - handle nulls */
			SET @sSQL1 = @sSQL1 +
				' IS null'
		END
		ELSE
		BEGIN
			SET @sSQL1 = @sSQL1 +	' = '
			IF ((@iDataType = 11) OR (@iDataType = 12)) SET @sSQL1 = @sSQL1 + ''''
			SET @sSQL1 = @sSQL1 + @psValue
			IF ((@iDataType = 11) OR (@iDataType = 12)) SET @sSQL1 = @sSQL1 + ''''
		END
	
		IF len(@psFilterDef)> 0 
		BEGIN
			WHILE charindex('	', @psFilterDef) > 0
			BEGIN
				SET @sSubFilterSQL = ''

				SET @iIndex1 = charindex('	', @psFilterDef)
				SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1)
				SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1)
				
				SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1))
				SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1))
				SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1)
				
				SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3)

				SELECT @iDataType = dataType,
					@sColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @iColumnID
								
				SET @sColumnName = @sRealSource + '.' + @sColumnName

				IF (@iDataType = -7) 
				BEGIN
					/* Logic column (must be the equals operator).	*/
					SET @sSubFilterSQL = @sColumnName + ' = '
				
					IF UPPER(@sValue) = 'TRUE'
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + '1'
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + '0'
					END
				END

				IF ((@iDataType = 2) OR (@iDataType = 4)) 
				BEGIN
					/* Numeric/Integer column. */
					/* Replace the locale decimal separator with '.' for SQL's benefit. */
					SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.')

					IF (@iOperatorID = 1) 
					BEGIN
						/* Equals. */
						SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
	          END
	        END

					IF (@iOperatorID = 2)
					BEGIN
						/* Not Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL'
						END
					END

					IF (@iOperatorID = 3) 
					BEGIN
						/* Less than or Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
	          END
          END
        
					IF (@iOperatorID = 4) 
					BEGIN
						/* Greater than or Equal To. */
						SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END

					IF (@iOperatorID = 5) 
					BEGIN
						/* Greater than. */
						SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END

					IF (@iOperatorID = 6) 
					BEGIN
						/* Less than.*/
						SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue

						IF convert(float, @sValue) = 0
						BEGIN
	            SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL'
						END
					END
				END

				IF (@iDataType = 11) 
				BEGIN
					/* Date column. */
					IF LEN(@sValue) > 0
					BEGIN
						/* Convert the locale date into the SQL format. */
						/* Note that the locale date has already been validated and formatted to match the locale format. */
						SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat)
						SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat)
						SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat)
						
						SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
							+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
							+ SUBSTRING(@sValue, @iIndex3, 4)
					END

					IF (@iOperatorID = 1) 
					BEGIN
						/* Equal To. */
		        IF LEN(@sValue) > 0
		        BEGIN
							SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL'
						END
			    END

					IF (@iOperatorID = 2)
					BEGIN
						/* Not Equal To. */
						IF LEN(@sValue) > 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL'
						END
	        END

					IF (@iOperatorID = 3) 
					BEGIN
						/* Less than or Equal To. */
			      IF LEN(@sValue) > 0 
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL'
					  END
	        END

					IF (@iOperatorID = 4) 
					BEGIN
						/* Greater than or Equal To. */
			      IF LEN(@sValue) > 0
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL'
						END
					END

					IF (@iOperatorID = 5) 
					BEGIN
						/* Greater than. */
			      IF LEN(@sValue) > 0
			      BEGIN
							SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + ''''
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL'
						END
				  END

					IF (@iOperatorID = 6)
					BEGIN
						/* Less than. */
		        IF LEN(@sValue) > 0
		        BEGIN
							SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL'
						END
	        END
				END
			
				IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
				BEGIN
						/* Character/Working Pattern column. */
					IF (@iOperatorID = 1) 
					BEGIN
						/* Equal To. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')
							SET @sValue = replace(@sValue, '*', '%')
							SET @sValue = replace(@sValue, '?', '_')

							SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + ''''
						END
					END

					IF (@iOperatorID = 2) 
					BEGIN
						/* Not Equal To. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')
							SET @sValue = replace(@sValue, '*', '%')
							SET @sValue = replace(@sValue, '?', '_')

							SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + ''''
						END
					END

					IF (@iOperatorID = 7)
					BEGIN
						/* Contains */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')

							SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%'''
						END
					END

					IF (@iOperatorID = 8) 
					BEGIN
						/* Does Not Contain. */
						IF LEN(@sValue) = 0
						BEGIN
							SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL'
						END
						ELSE
						BEGIN
							/* Replace the standard * and ? characters with the SQL % and _ characters. */
							SET @sValue = replace(@sValue, '''', '''''')

							SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%'''
						END
					END
				END
			
				IF LEN(@sSubFilterSQL) > 0
				BEGIN
					/* Add the filter code for this grid record into the complete filter code. */
					IF LEN(@sFilterSQL) > 0
					BEGIN
						SET @sFilterSQL = @sFilterSQL + ' AND ('
					END
					ELSE
					BEGIN
						SET @sFilterSQL = @sFilterSQL + '('
					END

					SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')'
				END
			END

			IF LEN(@sFilterSQL) > 0 
			BEGIN
				SET @sSQL1 = @sSQL1 +
					' AND ' + @sFilterSQL
			END
		END

		SET @sParamDefinition = N'@result integer OUTPUT'
		EXEC sp_executesql @sSQL1, @sParamDefinition, @plngRecordID OUTPUT
		
		IF @plngRecordID IS null SET @plngRecordID = 0
	END	
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordDescriptionInView]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetRecordDescriptionInView] (
	@piViewID 			integer,
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@iCount				integer,
			@sEvalRecDesc		varchar(MAX),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500),
			@sViewName			sysname;

	SET @psRecDesc = '';
	SET @psErrorMessage = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM ASRSysTables 
		WHERE ASRSysTables.tableID = @piTableID;
	END

	IF @iRecordID > 0 
	BEGIN
		/* Check that the given record is still in the given view */
		SELECT @sViewName = viewName
		FROM ASRSysViews
		WHERE viewID = @piViewID;
	
		SET @sExecString = 'SELECT @iCount = COUNT(*) FROM [' + @sViewName + '] WHERE ID = ' + convert(nvarchar(100), @iRecordID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sExecString, @sParamDefinition, @iCount OUTPUT;
		
		IF @iCount = 0 
		BEGIN
			SET @psErrorMessage = 'The requested record is not in the current view.';
		END
		ELSE
		BEGIN
			/* Get the record description. */
			IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
			BEGIN
				SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(100), @iRecDescID) + ' @recDesc OUTPUT, @recID';
				SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
				EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;
		
				IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
			END
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetRecordSelection]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetRecordSelection]
(
	@psType		varchar(255),
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @fSysSecMgr	bit;

	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT
	
	IF UPPER(@psType) = 'PICKLIST'
	BEGIN
		SELECT picklistid, 
			name, 
			username, 
			access 
		FROM [dbo].[ASRSysPicklistName]
		WHERE (tableid = @piTableID)
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END

	IF UPPER(@psType) = 'FILTER'
	BEGIN
		SELECT exprid, 
			name, 
			username, 
			access 
		FROM [dbo].[ASRSysExpressions]
		WHERE tableid = @piTableID 
			AND type = 11 
			AND (returnType = 3 OR type = 10) 
			AND parentComponentID = 0 
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END
	
	IF UPPER(@psType) = 'CALC'
	BEGIN
		IF @piTableID > 0
		BEGIN
			SELECT exprid, 
				name, 
				username, 
				access 
			FROM [dbo].[ASRSysExpressions]
			WHERE (tableid = @piTableID)
				AND  type = 10 
				AND (returnType = 0 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
		ELSE
		BEGIN
			SELECT exprid, 
				name, 
				username, 
				access 
			FROM [dbo].[ASRSysExpressions] 
			WHERE  type = 18 
				AND (returnType = 4 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
	END
END
GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetSingleRecordViewID]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetSingleRecordViewID] 
(
		@piTableID		integer OUTPUT,
		@piViewID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @piTableID = TableID, @piViewID = ViewID
	FROM ASRSysSSIViews
	WHERE SingleRecordView = 1;

	IF @piTableID IS NULL SET @piTableID = 0;
	IF @piViewID IS NULL SET @piViewID = 0;

END

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetSortOrderColumns] (
	@psIncludedColumns		varchar(MAX),
	@psExcludedColumns		varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sSQL nvarchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psIncludedColumns) > 0 SET @psIncludedColumns = replace(@psIncludedColumns, '''', '''''');
	IF len(@psExcludedColumns) > 0 SET @psExcludedColumns = replace(@psExcludedColumns, '''', '''''');

	SET @sSQL = 'SELECT ASRSysColumns.columnID, ' +
		'ASRSysTables.tableName + ''.'' + ASRSysColumns.columnName AS [columnName] ' +
		'FROM ASRSysColumns ' +
		'INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID ' +
		'WHERE ASRSysColumns.columnID IN ('+ @psIncludedColumns + ')';

	IF len(@psExcludedColumns) > 0
	BEGIN
		SET @sSQL = @sSQL + ' AND [columnID] NOT IN (' + @psExcludedColumns + ')';
	END

	SET @sSQL = @sSQL + ' ORDER BY [columnName] ASC';
	
	EXECUTE sp_executeSQL @sSQL;
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetSummaryValues]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetSummaryValues] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sRootTable 		varchar(255),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sTemp				varchar(MAX),
		@sSelectSQL			nvarchar(MAX),
		@sActualUserName	sysname,
		@strTempSepText		varchar(500);

	SET @sSelectSQL = '';
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName	sysname);

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @columnPermissions TABLE (tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	-- Cached view of SysProtects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000));

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID);

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM #SysProtects
				WHERE Action = 193;

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sParentRealSource = left(@sParentRealSource, 255);
			END

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM #SysProtects
				WHERE Action = 193;

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnID
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;

	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @ColumnPermissions
		WHERE tableViewName = @sParentTableName
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			SET @sTemp = ',';
			IF LEN(@sSelectSQL) > 0
				SET @sSelectSQL = @sSelectSQL + @sTemp;

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END 
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sParentTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END

			/* Add the table to the array of tables/views to join if it has not already been added. */
			SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sParentTableName;

			IF @iTempCount = 0
			BEGIN
				INSERT INTO @joinParents (tableViewName) VALUES(@sParentTableName);
			END
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @ColumnPermissions
			WHERE tableViewName <> @sParentTableName
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) > 0 SET @sSelectString = @sSelectString + ',';

				IF @iColumnDataType = 11 /* Date */
					SET @sSelectString = @sSelectString + 'convert(varchar(10),' + @sViewName + '.' + @sColumnName + ',101)';
				ELSE
					SET @sSelectString = @sSelectString + @sViewName + '.' + @sColumnName;


				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = 'COALESCE(' + @sSelectString + ', NULL) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sTemp = ',';

				IF LEN(@sSelectSQL) > 0
					SET @sSelectSQL = @sSelectSQL + @sTemp;

				SET @sTemp = @sSelectString;
				SET @sSelectSQL = @sSelectSQL + @sTemp;
				
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = 'SELECT ' + @sSelectSQL ;

		SELECT @iTempCount = COUNT(tableViewName)
			FROM @joinParents;

		IF @iTempCount = 1 
		BEGIN
			SELECT TOP 1 @sRootTable = tableViewName
			FROM @joinParents;
		END
		ELSE
		BEGIN
			SET @sRootTable = @sParentTableName;
		END

		SET @sTemp = ' FROM ' + @sRootTable;
		SET @sSelectSQL = @sSelectSQL + @sTemp;

		/* Add the join code. */
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sTableViewName <> @sRootTable
			BEGIN
				SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRootTable + '.ID' + ' = ' + @sTableViewName + '.ID';
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END

			FETCH NEXT FROM joinCursor INTO @sTableViewName;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		SET @sTemp = ' WHERE ' + @sRootTable + '.id = ' + convert(varchar(255), @piParentRecordID);
		SET @sSelectSQL = @sSelectSQL + @sTemp;

	END

	-- Run the constructed SQL SELECT string.
	EXEC sp_executeSQL @sSelectSQL;

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetTimestamp]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetTimestamp] (
	@piTimestamp 	int 		OUTPUT, 
	@piRecordID		integer,
	@psRealsource	varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500);

	/* Clean the input string parameters. */
	IF len(@psRealsource) > 0 SET @psRealsource = replace(@psRealsource, '''', '''''');
	
	SET @sTempExecString = 'SELECT @iTimestamp = convert(integer, timestamp) FROM ' + convert(nvarchar(255), @psRealsource) + ' where ID = ' + convert(nvarchar(100), @piRecordID);
	SET @sTempParamDefinition = N'@iTimestamp integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piTimestamp OUTPUT;
END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityAccessRecords]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords] (
	@piUtilityType		integer,
	@piID				integer,
	@piFromCopy			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sDefaultAccess	varchar(2),
		@sAccessTable	sysname,
		@sKey			varchar(255),
		@sSQL			nvarchar(MAX);

	SET @sAccessTable = '';

	IF @piUtilityType = 17
	BEGIN
		/* Calendar Reports */
		SET @sAccessTable = 'ASRSysCalendarReportAccess';
		SET @sKey = 'dfltaccess CalendarReports';
	END

	IF @piUtilityType = 1
	BEGIN
		/* Cross Tabs */
		SET @sAccessTable = 'ASRSysCrossTabAccess';
		SET @sKey = 'dfltaccess CrossTabs';
	END

	IF @piUtilityType = 2
	BEGIN
		/* Custom Reports */
		SET @sAccessTable = 'ASRSysCustomReportAccess';
		SET @sKey = 'dfltaccess CustomReports';
	END

	IF @piUtilityType = 9
	BEGIN
		/* Mail Merge */
		SET @sAccessTable = 'ASRSysMailMergeAccess';
		SET @sKey = 'dfltaccess MailMerge';
	END

	IF LEN(@sAccessTable) > 0
	BEGIN
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SELECT @sDefaultAccess = SettingValue 
			FROM ASRSysUserSettings
			WHERE UserName = system_user
				AND Section = 'utils&reports'
				AND SettingKey = @sKey;
	
			IF (@sDefaultAccess IS null)
			BEGIN
				SET @sDefaultAccess = 'RW';
			END
		END
		ELSE
		BEGIN
			SET @sDefaultAccess = 'HD';
		END
		
		SET @sSQL = 'SELECT sysusers.name + char(9) +
				CASE WHEN	
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE sysusers.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						ELSE ';
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RW'' THEN ''Read / Write''
			 WHEN	CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
			ELSE '
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RO'' THEN ''Read Only''
			ELSE ''Hidden'' 
			END + char(9) +
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
 						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''1''
				ELSE
					''0''
			END AS [accessDefinition]
			FROM sysusers
			LEFT OUTER JOIN ' + @sAccessTable + ' ON (sysusers.name = ' + @sAccessTable + '.groupName
				AND ' + @sAccessTable + '.id = ' + convert(nvarchar(100), @piID) + ')
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0 AND NOT (sysusers.name LIKE ''ASRSys%'') AND NOT (sysusers.name LIKE ''db_%'')
			ORDER BY sysusers.name';

			EXEC sp_executesql @sSQL;
	END

END

GO


/****** Object:  StoredProcedure [dbo].[spASRIntGetUtilityName]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetUtilityName] (
	@piUtilityType	integer,
	@plngID			integer,
	@psName			varchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500);

	SET @sTableName = '';
	SET @psName = '<unknown>';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
    END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sIDColumnName = 'ID';
    END
        
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sIDColumnName = 'DataTransferID';
    END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sIDColumnName = 'functionID';
    END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sIDColumnName = 'mailMergeID';
    END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sIDColumnName = 'recordProfileID';
    END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sIDColumnName = 'matchReportID';
    END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SET @sTableName = 'ASRSysWorkflows';
		SET @sIDColumnName = 'ID';
	END
      	
	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sName = [' + @sTableName + '].[name]
				FROM [' + @sTableName + ']
				WHERE [' + @sTableName + '].[' + @sIDColumnName + '] = ' + convert(nvarchar(255), @plngID);

		SET @sParamDefinition = N'@sName varchar(255) OUTPUT';
		EXEC sp_executesql @sSQL, @sParamDefinition, @psName OUTPUT;
	END

	IF @psName IS null SET @psName = '<unknown>';
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetViewName]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetViewName] (
	@piViewID	integer,
	@psViewName	varchar(255) 	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @piViewID;

END

GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

/****** Object:  StoredProcedure [dbo].[spASRIntSaveCalendarReport]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntSaveCalendarReport]
	(
	@psName						varchar(255),
	@psDescription				varchar(MAX),
	@piBaseTable				integer,
	@pfAllRecords				bit,
	@piPicklist					integer,
	@piFilter					integer,
	@pfPrintFilterHeader		bit,
	@psUserName					varchar(255),
	@piDescription1				integer,
	@piDescription2				integer,
	@piDescriptionExpr			integer,
	@piRegion					integer,
	@pfGroupByDesc				bit,
	@psDescSeparator			varchar(100),
	@piStartType				integer,
	@psFixedStart				varchar(100),
	@piStartFrequency			integer,
	@piStartPeriod				integer,
	@piStartDateExpr			integer,
	@piEndType					integer,
	@psFixedEnd					varchar(100),
	@piEndFrequency				integer,
	@piEndPeriod				integer,
	@piEndDateExpr				integer,
	@pfShowBankHols				bit,
	@pfShowCaptions				bit,
	@pfShowWeekends				bit,
	@pfStartOnCurrentMonth		bit,
	@pfIncludeWorkdays			bit,
	@pfIncludeBankHols			bit,
	@pfOutputPreview			bit,
	@piOutputFormat				integer,
	@pfOutputScreen				bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName		varchar(MAX),
	@pfOutputSave				bit,
	@piOutputSaveExisting		integer,
	@pfOutputEmail				bit,
	@pfOutputEmailAddr			integer,
	@psOutputEmailSubject		varchar(MAX),
	@psOutputEmailAttachAs		varchar(MAX),
	@psOutputFilename			varchar(MAX),
	@psAccess					varchar(MAX),
	@psJobsToHide				varchar(MAX),
	@psJobsToHideGroups			varchar(MAX),
	@psEvents					varchar(MAX),
	@psEvents2					varchar(MAX),
	@psOrderString				varchar(MAX),
	@piID						integer	OUTPUT
	)
AS
BEGIN 

	SET NOCOUNT ON;

	DECLARE	@sTemp					varchar(MAX),
			@iCount					integer,
			@fIsNew					bit,
			@sEventDefn				varchar(MAX),
			@sEventParam			varchar(MAX),
			@sEventKey				varchar(MAX),
			@sEventName				varchar(MAX),
			@iEventTableID			integer,
			@iEventFilterID			integer,
			@iEventStartDateID		integer,
			@iEventStartSessionID	integer,
			@iEventEndDateID		integer,
			@iEventEndSessionID		integer,
			@iEventDurationID		integer,
			@iLegendType			integer,
			@sLegendCharacter		varchar(2),
			@iLegendLookupTableID	integer,
			@iLegendLookupColumnID	integer,
			@iLegendLookupCodeID	integer,
			@iLegendEventColumnID	integer,
			@iEventDesc1ColumnID	integer,
			@iEventDesc2ColumnID	integer,
			@sOrderDefn				varchar(MAX),
			@sOrderParam			varchar(MAX),
			@iOrderTableID			integer,
			@iOrderColumnID			integer,
			@iOrderSequence			integer,
			@sOrderType				varchar(20),
			@sGroup					varchar(255),
			@sAccess				varchar(MAX),
			@sSQL					nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''');
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''');

	SET @fIsNew = 0;

	/* Insert/update the report header. */
	IF @piID = 0
	BEGIN
		/* Creating a new report. */
		INSERT ASRSYSCalendarReports (
			Name, 
			[Description], 
			BaseTable, 
			AllRecords, 
			Picklist, 
			Filter, 
			PrintFilterHeader, 
			UserName, 
			Description1, 
			Description2, 
			DescriptionExpr, 
			Region,
			GroupByDesc,
			DescriptionSeparator, 
			StartType, 
			FixedStart, 
			StartFrequency,
			StartPeriod,
			StartDateExpr,
			EndType,
			FixedEnd,
			EndFrequency,
			EndPeriod,
			EndDateExpr,
			ShowBankHolidays,
			ShowCaptions,
			ShowWeekends,
			StartOnCurrentMonth, 
			IncludeWorkingDaysOnly, 
			IncludeBankHolidays,
			OutputPreview, 
			OutputFormat, 
			OutputScreen, 
			OutputPrinter, 
			OutputPrinterName, 
			OutputSave, 
			OutputSaveExisting, 
			OutputEmail, 
			OutputEmailAddr, 
			OutputEmailSubject, 
			OutputEmailAttachAs, 
			OutputFileName)
		VALUES (
			@psName,
			@psDescription,
			@piBaseTable,
			@pfAllRecords,
			@piPicklist,
			@piFilter,
			@pfPrintFilterHeader,
			@psUserName,
			@piDescription1,
			@piDescription2,
			@piDescriptionExpr,
			@piRegion,
			@pfGroupByDesc,
			@psDescSeparator,
			@piStartType,
			@psFixedStart,
			@piStartFrequency,
			@piStartPeriod,
			@piStartDateExpr,
			@piEndType,
			@psFixedEnd,
			@piEndFrequency,
			@piEndPeriod,
			@piEndDateExpr,
			@pfShowBankHols,
			@pfShowCaptions,
			@pfShowWeekends,
			@pfStartOnCurrentMonth,
			@pfIncludeWorkdays,
			@pfIncludeBankHols,
			@pfOutputPreview,
			@piOutputFormat,
			@pfOutputScreen,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@pfOutputSave,
			@piOutputSaveExisting,
			@pfOutputEmail,
			@pfOutputEmailAddr,
			@psOutputEmailSubject,
			@psOutputEmailAttachAs,
			@psOutputFilename
		);
		
		SET @fIsNew = 1;
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(ID) FROM ASRSysCalendarReports;
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysCalendarReports SET 
			Name = @psName,
			[Description] = @psDescription, 
			BaseTable = @piBaseTable, 
			AllRecords = @pfAllRecords, 
			Picklist = @piPicklist, 
			Filter = @piFilter,
			PrintFilterHeader = @pfPrintFilterHeader,
			Description1 = @piDescription1,
			Description2 = @piDescription2,
			DescriptionExpr = @piDescriptionExpr,
			Region = @piRegion,
			GroupByDesc = @pfGroupByDesc,
			DescriptionSeparator = @psDescSeparator,
			StartType = @piStartType,
			FixedStart = @psFixedStart, 
			StartFrequency = @piStartFrequency,
			StartPeriod = @piStartPeriod,
			StartDateExpr = @piStartDateExpr,
			EndType = @piEndType,
			FixedEnd = @psFixedEnd, 
			EndFrequency = @piEndFrequency,
			EndPeriod = @piEndPeriod,
			EndDateExpr = @piEndDateExpr,
			ShowBankHolidays = @pfShowBankHols,
			ShowCaptions = @pfShowCaptions,
			ShowWeekends = @pfShowWeekends,
			StartOnCurrentMonth = @pfStartOnCurrentMonth,
			IncludeWorkingDaysOnly = @pfIncludeWorkdays,
			IncludeBankHolidays = @pfIncludeBankHols,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName, 
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @pfOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename  
			WHERE ID = @piID;
		
		/* Delete existing report event details. */
		DELETE FROM ASRSysCalendarReportEvents 
		WHERE calendarReportID = @piID;
	END

	/* Create the report's event details records. */
	SET @sTemp = @psEvents;

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sEventDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)

			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psEvents2, 1000)
				IF len(@psEvents2) > 1000
				BEGIN
					SET @psEvents2 = SUBSTRING(@psEvents2, 1001, len(@psEvents2) - 1000)
				END
				ELSE
				BEGIN
					SET @psEvents2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sEventDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the event definition parameters. */
		SET @sEventKey = '';
		SET @sEventName = '';
		SET @iEventTableID = 0;
		SET @iEventFilterID = 0;
		SET @iEventStartDateID = 0;
		SET @iEventStartSessionID = 0;
		SET @iEventEndDateID = 0;
		SET @iEventEndSessionID = 0;
		SET @iEventDurationID = 0;
		SET @iLegendType = 0;
		SET @sLegendCharacter = '';
		SET @iLegendLookupTableID = 0;
		SET @iLegendLookupColumnID = 0;
		SET @iLegendLookupCodeID = 0;
		SET @iLegendEventColumnID = 0;
		SET @iEventDesc1ColumnID = 0;
		SET @iEventDesc2ColumnID = 0;
		
		SET @iCount = 0;
		
		WHILE LEN(@sEventDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sEventDefn) > 0
			BEGIN
				SET @sEventParam = LEFT(@sEventDefn, CHARINDEX('||', @sEventDefn) - 1)
				SET @sEventDefn = RIGHT(@sEventDefn, LEN(@sEventDefn) - CHARINDEX('||', @sEventDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sEventParam = @sEventDefn
				SET @sEventDefn = ''
			END

			IF @iCount = 0 SET @sEventKey = @sEventParam;
			IF @iCount = 1 SET @sEventName = @sEventParam;
			IF @iCount = 2 SET @iEventTableID = convert(integer, @sEventParam);
			IF @iCount = 3 SET @iEventFilterID = convert(integer, @sEventParam);
			IF @iCount = 4 SET @iEventStartDateID = convert(integer, @sEventParam);
			IF @iCount = 5 SET @iEventStartSessionID = convert(integer, @sEventParam);
			IF @iCount = 6 SET @iEventEndDateID = convert(integer, @sEventParam);
			IF @iCount = 7 SET @iEventEndSessionID = convert(integer, @sEventParam);
			IF @iCount = 8 SET @iEventDurationID = convert(integer, @sEventParam);
			IF @iCount = 9 SET @iLegendType = convert(integer, @sEventParam);
			
			IF (@iCount = 10)
				BEGIN 
					IF @iLegendType = 0
						BEGIN
							SET @sLegendCharacter = LEFT(@sEventParam,2);
						END	
					ELSE
						BEGIN
							SET @sLegendCharacter = '';
						END
				END
			IF @iCount = 11 SET @iLegendLookupTableID = convert(integer, @sEventParam);
			IF @iCount = 12 SET @iLegendLookupColumnID = convert(integer, @sEventParam);
			IF @iCount = 13 SET @iLegendLookupCodeID = convert(integer, @sEventParam);
			IF @iCount = 14 SET @iLegendEventColumnID = convert(integer, @sEventParam);
			IF @iCount = 15 SET @iEventDesc1ColumnID = convert(integer, @sEventParam);
			IF @iCount = 16 SET @iEventDesc2ColumnID = convert(integer, @sEventParam);

			SET @iCount = @iCount + 1;
		END

		INSERT ASRSysCalendarReportEvents (EventKey, CalendarReportID, Name, TableID, FilterID, 
				EventStartDateID, EventStartSessionID, EventEndDateID, EventEndSessionID, 
				EventDurationID, LegendType, LegendCharacter, LegendLookupTableID, LegendLookupColumnID, 
				LegendLookupCodeID, LegendEventColumnID, EventDesc1ColumnID, EventDesc2ColumnID)
		VALUES (@sEventKey, @piID, @sEventName, @iEventTableID, @iEventFilterID, 
				@iEventStartDateID, @iEventStartSessionID, @iEventEndDateID, @iEventEndSessionID, 
				@iEventDurationID, @iLegendType, @sLegendCharacter, @iLegendLookupTableID, @iLegendLookupColumnID, 
				@iLegendLookupCodeID, @iLegendEventColumnID, @iEventDesc1ColumnID, @iEventDesc2ColumnID);

	END


	/* Create the report's sort order details records. */
	IF (@fIsNew = 0)
	BEGIN
		/* Delete existing report sort order details. */
		DELETE FROM ASRSysCalendarReportOrder 
		WHERE calendarReportID = @piID;
	END

	SET @sTemp = @psOrderString;

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sOrderDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1);
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1);
		END
		ELSE
		BEGIN
			SET @sOrderDefn = @sTemp;
			SET @sTemp = '';
		END

		/* Rip out the column definition parameters. */
		SET @iOrderTableID = 0;
		SET @iOrderColumnID = 0;
		SET @iOrderSequence = 0;
		SET @sOrderType = '';
		
		SET @iCount = 0;

		WHILE LEN(@sOrderDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sOrderDefn) > 0
			BEGIN
				SET @sOrderParam = LEFT(@sOrderDefn, CHARINDEX('||', @sOrderDefn) - 1);
				SET @sOrderDefn = RIGHT(@sOrderDefn, LEN(@sOrderDefn) - CHARINDEX('||', @sOrderDefn) - 1);
			END
			ELSE
			BEGIN
				SET @sOrderParam = @sOrderDefn;
				SET @sOrderDefn = '';
			END

			--IF @iCount = 0 SET @iOrderTableID = convert(integer, @sOrderParam)
			IF @iCount = 0 SET @iOrderColumnID = convert(integer, @sOrderParam);
			IF @iCount = 1 SET @iOrderSequence = convert(integer, @sOrderParam);
			IF @iCount = 2 SET @sOrderType = @sOrderParam;
	
			SET @iCount = @iCount + 1;
		END

		SELECT @iOrderTableID = ASRSysColumns.TableID
		FROM ASRSysColumns
		WHERE ASRSysColumns.ColumnID = @iOrderColumnID;
		
		INSERT ASRSysCalendarReportOrder 
			(CalendarReportID, TableID, ColumnID, OrderSequence, OrderType) 
		VALUES (@piID, @iOrderTableID, @iOrderColumnID, @iOrderSequence, @sOrderType);

	END
	
	DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piID
	INSERT INTO ASRSysCalendarReportAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0);

	SET @sTemp = @psAccess;
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1);
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)));
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1);
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)));
	
			IF EXISTS (SELECT * FROM ASRSysCalendarReportAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCalendarReportAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup;
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (17, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name());
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND [type] = 17;

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				([type], utilID, savedBy, savedDate, savedHost)
			VALUES (17, @piID, system_user, getdate(), host_name());
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND [type] = 17;
		END
	END
	
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + '''';

		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')';
		EXEC sp_executesql @sSQL;

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))';
		EXEC sp_executesql @sSQL;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntSetEventLogPurge]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntSetEventLogPurge]
(
		@psPeriod		varchar(2),
		@piFrequency	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLogPurge] (Period,Frequency)
	VALUES (@psPeriod, @piFrequency);

END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntShowOutOfOfficeHyperlink]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntShowOutOfOfficeHyperlink]	
	(
		@piTableID		integer,
		@piViewID		integer,
		@pfDisplayHyperlink	bit 	OUTPUT
	)
	AS
	BEGIN
		SELECT @pfDisplayHyperlink = WFOutOfOffice
		FROM ASRSysSSIViews
		WHERE (TableID = @piTableID) 
			AND  (ViewID = @piViewID)
	END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntUDFFunctionsEnabled]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE Procedure [dbo].[spASRIntUDFFunctionsEnabled]
	(
		@pfEnableUDFFunctions bit OUTPUT
	)
As
	DECLARE 
		@sTemp			char(20),
		@iVersion			integer,
		@iTemp 				integer
	SET @pfEnableUDFFunctions = 0
	SELECT @sTemp = CONVERT(char(20), attribute_value)
	FROM master..spt_server_info
	WHERE attribute_id = 500
	SET @iTemp = charindex('.', @sTemp) 
	IF @iTemp > 0
	BEGIN
		SET @sTemp = substring(@sTemp, 1, @iTemp -1)
	END
	SET @iVersion = convert(integer, @sTemp)
	IF @iVersion >= 8
	BEGIN  
		SET @pfEnableUDFFunctions = 1
	END

GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntUpdateRecord]
(
	@piResult		integer	OUTPUT,	/* Output variable to hold the result. */
	@psUpdateDef	varchar(MAX),	/* Update definition to update the record. */
	@piTableID		integer,		/* TableID being updated. */
	@psRealSource	sysname,		/* RealSource being updated. */
	@piID			integer,		/* ID the record being updated. */
	@piTimestamp	integer,			/* Original timestamp of the record being updated. */
	@errorMessage	nvarchar(MAX) OUTPUT
)
AS
BEGIN
	/* Return 0 if the record was OK to update. */
	/* Return 1 if the record has been amended AND is still in the given table/view. */
	/* Return 2 if the record has been amended AND is no longer in the given table/view. */
	/* Return 3 if the record has been deleted from the table. */
	SET NOCOUNT ON;

		-- Check database status before saving
	EXEC dbo.spASRDatabaseStatus @errorMessage OUTPUT;
	IF LEN(@errorMessage) > 0 RETURN;


	DECLARE
		@iCurrentTimestamp	integer,
		@sSQL				nvarchar(MAX),
		@iCount				integer,
		@sUpdateString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@iCounter			integer,
		@iIndex1			integer,
		@iIndex2			integer,
		@sColumnID			varchar(255),
		@sValue				varchar(MAX),
		@iDataType			integer,
		@sColumnName		varchar(255),
		@sMask				varchar(MAX),
		@iOLEType			integer;

	-- Clean the input string parameters.
	IF len(@psRealsource) > 0 SET @psRealsource = replace(@psRealsource, '''', '''''');

	SET @piResult = 0;
	SET @sUpdateString = 'UPDATE ' + convert(varchar(255), @psRealSource) + ' SET ';
	SET @iCounter = 0;

	-- Get status of amended record
	EXEC dbo.sp_ASRRecordAmended @piResult OUTPUT,
	    @piTableID,
		@psRealSource,
		@piID,
		@piTimestamp;

	IF @piResult = 0
	BEGIN
		WHILE charindex(CHAR(9), @psUpdateDef) > 0
		BEGIN
			SET @iIndex1 = charindex(CHAR(9), @psUpdateDef);
			SET @iIndex2 = charindex(CHAR(9), @psUpdateDef, @iIndex1+1);

			SET @sColumnID = replace(LEFT(@psUpdateDef, @iIndex1-1), '''', '''''');
			SET @sValue = replace(SUBSTRING(@psUpdateDef, @iIndex1+1, @iIndex2-@iIndex1-1), '''', '''''');

			IF LEFT(@sColumnID, 3) = 'ID_'
			BEGIN
				SET @sColumnName = @sColumnID;
			END
			ELSE
			BEGIN
				SELECT @sColumnName = ASRSysColumns.columnName,
					@iDataType = ASRSysColumns.dataType,
					@sMask = ASRSysColumns.mask
				FROM ASRSysColumns
				WHERE ASRSysColumns.columnId = convert(integer, @sColumnID);

				-- Date
				IF (@iDataType = 11 AND @sValue <> 'null') SET @sValue = '''' + @sValue + '''';

				-- Character
				IF (@iDataType = 12 AND (LEN(@sMask) = 0 OR @sValue <> 'null')) SET @sValue = '''' + @sValue + '''';

				-- WorkingPattern
				IF (@iDataType = -1) SET @sValue = '''' + @sValue + '''';

				-- Photo / OLE
				IF (@iDataType = -3 OR @iDataType = -4)
				BEGIN
					SET @iOLEType = convert(integer, LEFT(@sValue, 1));
					SET @sValue = SUBSTRING(@sValue, 2, LEN(@sValue) - 1);
					IF (@iOLEType < 2) SET @sValue = '''' + @sValue + '''';
				END
			END

			SET @sTempString =
				CASE
					WHEN @iCounter > 0 THEN ','
					ELSE ''
				END
				+ convert(varchar(255), @sColumnName) + ' = ' + convert(varchar(MAX), @sValue);

			SET @sUpdateString = @sUpdateString + @sTempString;
			SET @iCounter = @iCounter + 1;
			SET @psUpdateDef = SUBSTRING(@psUpdateDef, @iIndex2+1, LEN(@psUpdateDef) - @iIndex2);
		END

		SET @sUpdateString = @sUpdateString + ' WHERE id = ' + convert(varchar(255), @piID);

		-- Run the constructed SQL UPDATE string.
		EXEC sp_executeSQL @sUpdateString;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[spASRIntValidateCalendarReport]    Script Date: 13/09/2013 08:58:00 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntValidateCalendarReport]
	(
	@psUtilName 			varchar(255), 
	@piUtilID 				integer, 
	@piTimestamp 			integer, 
	@piBasePicklistID		integer, 
	@piBaseFilterID			integer,
	@piEmailGroupID			integer,
	@piDescExprID			integer,
	@psEventFilterIDs		varchar(MAX),			/* tab delimited string of event filter ids */ 
	@piCustomStartID		integer,
	@piCustomEndID			integer,
	@psHiddenGroups 		varchar(MAX), 
	@psErrorMsg				varchar(MAX)	OUTPUT,
	@piErrorCode			varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedFilters 		varchar(MAX)	OUTPUT,
	@psHiddenFilters 		varchar(MAX)	OUTPUT,
	@psDeletedCalcs 		varchar(MAX)	OUTPUT,
	@psHiddenCalcs 			varchar(MAX)	OUTPUT,
	@psDeletedPicklists		varchar(MAX)	OUTPUT,
	@psHiddenPicklists 		varchar(MAX)	OUTPUT,
	@psJobIDsToHide			varchar(MAX)	OUTPUT 
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	
			@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(100),
			@sExprName  			varchar(255),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(255),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iActualUserGroupID		integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''
	SET @psDeletedPicklists = ''
	SET @psHiddenPicklists = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT

 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCalendarReports
		WHERE ID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The report has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCalendarReports
			WHERE ID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					17, 
					@piUtilID,
					@sAccess	OUTPUT

				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp) AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the calendar report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSysCalendarReports
			WHERE name = @psUtilName
				AND ID <> @piUtilID
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSysCalendarReports
			WHERE name = @psUtilName
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A report called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBasePicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBasePicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBaseFilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBaseFilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piDescExprID > 0)
	BEGIN
		/* Check that the Base table description calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piDescExprID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table description calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
				CASE
					WHEN LEN(@psDeletedCalcs) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piDescExprID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piDescExprID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table description calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
					CASE
						WHEN LEN(@psHiddenCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piDescExprID)
			END
		END
	END

	/* Check that the selected event filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@psEventFilterIDs) > 0)
	BEGIN
		SET @sTemp = @psEventFilterIDs

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the event filters have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedFilters = @psDeletedFilters +
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @sCurrentID)
					SET @piErrorCode = 1
			 	END
				ELSE
			  	BEGIN
					SELECT @sOwner = userName,
						@sAccess = access
					FROM ASRSysExpressions
					WHERE exprID = convert(integer, @sCurrentID)

					IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @psErrorMsg = 
							@psErrorMsg + 
							CASE
								WHEN LEN(@psHiddenFilters) > 0 THEN ''
								ELSE 
									CASE 
										WHEN LEN(@psErrorMsg) > 0 THEN char(13)
										ELSE ''
									END +
									'One or more of the event filters have been made hidden by another user. They will be automatically removed from the report.'
							END
						SET @psHiddenFilters = @psHiddenFilters +
						CASE
							WHEN LEN(@psHiddenFilters) > 0 THEN ','
							ELSE ''
						END + convert(varchar(100), @sCurrentID)
						
						SET @piErrorCode = 1
					END
			  	END
			END
		END
	END
	
	
	IF (@piErrorCode = 0) AND (@piCustomStartID > 0)
	BEGIN
		/* Check that the start date calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomStartID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The custom start date calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomStartID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piCustomStartID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The custom start date calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
					CASE
						WHEN LEN(@psHiddenCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomStartID)
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piCustomEndID > 0)
	BEGIN
		/* Check that the end date calculation exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomEndID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The custom end date calculation has been deleted by another user.'
			SET @piErrorCode = 1
			
			SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + convert(varchar(100), @piCustomEndID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piCustomEndID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The custom end date calculation has been made hidden by another user.'
				SET @piErrorCode = 1
				
				SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + convert(varchar(100), @piCustomEndID)
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCalendarReports
		WHERE ID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iActualUserGroupID OUTPUT
					
			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCalendarReports.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobDetails.jobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCalendarReports.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Calendar Report ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs

END

GO




/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateTransfers]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidateTransfers]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist2]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidatePicklist2]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidatePicklist]
GO

DROP PROCEDURE [dbo].[sp_ASRIntValidateMailMerge]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateExpression]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidateExpression]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateBulkBookings]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntValidateBulkBookings]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntUpdateCustomReportHeader]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntUpdateCustomReportHeader]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntTransferCourse]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntTransferCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntSaveSetting]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntSaveSetting]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntSavePicklist]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntSavePicklist]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntPopulateDefsel]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntPopulateDefsel]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntNewUser]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntNewUser]
GO

DROP PROCEDURE [dbo].[sp_ASRIntMakeUtilitiesHidden]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntMakeBulkBookings]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntMakeBulkBookings]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetUserGroup]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetUserGroup]
GO


DROP PROCEDURE [dbo].[sp_ASRIntGetUniqueColumns]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetTableScreensMenu]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetTableScreensMenu]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenOrder]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenOrder]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlValuesString]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControlValuesString]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlsString]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControlsString]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControls]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControls]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlAndLookupValuesString]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControlAndLookupValuesString]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordEditInfo]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetRecordEditInfo]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordDescription]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetRecordDescription]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetQuickEntryMenu]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetQuickEntryMenu]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPrimaryTableSubMenu]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetPrimaryTableSubMenu]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPrimaryTableMenu]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetPrimaryTableMenu]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPicklistDefinition]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetPicklistDefinition]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPersonnelParameters]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetPersonnelParameters]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetOrders]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetOrders]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetModuleParameter]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetModuleParameter]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLookupValues]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLookupValues]
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkViews]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLinkViews]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkParentValues]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetLinkParentValues]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetHistoryMainMenu]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetHistoryMainMenu]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowTitle]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetFindWindowTitle]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowInfo]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetFindWindowInfo]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFilterPromptedValues]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValues]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprTables]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprTables]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprOperators]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprOperators]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprLookupValues]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprLookupValues]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFunctionParameters]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprFunctionParameters]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFilters]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprFilters]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExpressionDefinition]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprComponentDefinition]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprComponentDefinition]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprColumns]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprColumns]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprCalcs]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetExprCalcs]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromWLID]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromWLID]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromTBID]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromTBID]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetCrossTabTablesInfo]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetCrossTabTablesInfo]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetConfiguration]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetConfiguration]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetColumns]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetColumns]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAvailableLogins]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetAvailableLogins]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAbsenceTypes]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntGetAbsenceTypes]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntExpressionHasHiddenComponents]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntExpressionHasHiddenComponents]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntDeleteUtility]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntDeleteUtility]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCheckForUsage]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCheckForUsage]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCheckCanMakeHidden]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCheckCanMakeHidden]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCoursePart2]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelCoursePart2]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCourse]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelBooking]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCancelBooking]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCalcDefaults]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntCalcDefaults]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntBookCourse]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntBookCourse]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddFromWaitingList]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntAddFromWaitingList]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddEventLogHeader]    Script Date: 13/09/2013 08:59:32 ******/
DROP PROCEDURE [dbo].[sp_ASRIntAddEventLogHeader]
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddEventLogHeader]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntAddEventLogHeader]
(
    @piNewRecordID	integer OUTPUT,   /* Output variable to hold the new record ID. */
    @piType			integer,
    @psName			varchar(150), 
    @psUserName		varchar(50),
    @psBatchName	varchar(50),
    @piBatchRunID	integer,
    @piBatchJobID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	INSERT INTO [dbo].[ASRSysEventLog] (
		[DateTime],	[Type],	[Name], [Status], [Username],
		[Mode], [BatchName], [SuccessCount], [FailCount], [BatchRunID], [BatchJobID])
	VALUES (GETDATE(), @piType, @psName, 0, @psUserName,
		CASE
			WHEN len(@psBatchName) = 0 THEN 0
			ELSE 1
		END,    
		@psBatchName, NULL,NULL,
		CASE
			WHEN @piBatchRunID > 0 THEN @piBatchRunID
			ELSE null
		END,
		CASE 
			WHEN @piBatchJobID > 0 THEN @piBatchJobID
			ELSE null
		END);
                  
    -- Get the ID of the inserted record.
    SELECT @piNewRecordID = MAX(id) FROM [dbo].[ASRSysEventLog];

END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntAddFromWaitingList]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntAddFromWaitingList] (
	@piEmpRecordID		integer,
	@piCourseRecordID	integer,
	@psStatus			varchar(MAX)
)
AS
BEGIN
	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@fSysSecMgr				bit,
		@sColumnList			varchar(MAX),
		@sValueList				varchar(MAX),
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sExecString			nvarchar(MAX),
		@iEmpTableID			integer,
		@iCourseTableID			integer,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@sTempTBColumnName		sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(MAX),
		@sTempWLColumnName		sysname,
		@sAddedColumns			varchar(MAX),
		@iSourceColumnID		integer,
		@iDestinationColumnID	integer,
		@iIndex					integer,
		@fGranted				bit,
		@iWLCourseTitleColumnID	integer,
		@sWLCourseTitleColumnName	sysname,
		@sCourseTitle			varchar(MAX),
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@sCourseSource			sysname,
		@sActualUserName		sysname;

	SET NOCOUNT ON;

	/* Clean the input string parameters. */
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable';
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable';
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(100), @piCourseRecordID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @sCourseTitle = '';
	END

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus';
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;

	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Initialise the insert strings with the basic values.*/
	SET @sColumnList = 'id_' + convert(varchar(128), @iEmpTableID) + ',' +
		'id_' + convert(varchar(128), @iCourseTableID) + ',' +
		@sTBStatusColumnName;
	SET @sValueList = convert(varchar(128), @piEmpRecordID) + ',' +
		convert(varchar(128), @piCourseRecordID) + ',' +
		'''' + @psStatus + '''';
	SET @sAddedColumns = ',' + convert(varchar(MAX), @iTBStatusColumnID) + ',';

	/* Get the TB and WL column permissions. */
	IF @fSysSecMgr = 0
	BEGIN
		CREATE TABLE #columnPermissions
		(
			columnID	int,
			action		int,		
			granted		bit		
		);

		INSERT INTO #columnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END AS [protectType]
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND (ASRSysColumns.tableID = @iTBTableID
				OR ASRSysColumns.tableID = @iWLTableID))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND (sysobjects.name = @sTBRealSource
				OR sysobjects.name = @sWLRealSource)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	END

	/* Get the Waiting List - Training Booking related columns. */
	DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sourceColumnID, destColumnID
	FROM ASRSysModuleRelatedColumns
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TBWLRelatedColumns';
	OPEN relatedColumns_cursor;
	FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iIndex = charindex(',' + convert(varchar(MAX), @iDestinationColumnID) + ',', @sAddedColumns);

		IF @iIndex = 0
		BEGIN
			/* Check that the user has read permission on the WL column, and update permission on the TB column. */
			SET @fGranted = 1;

			IF @fSysSecMgr = 0
			BEGIN
				SELECT @fGranted = granted
				FROM #columnPermissions
				WHERE columnID = @iDestinationColumnID
					AND action = 193;

				IF @fGranted IS null SET @fGranted = 0;

				IF @fGranted = 1
				BEGIN
					SELECT @fGranted = granted
					FROM #columnPermissions
					WHERE columnID = @iSourceColumnID
						AND action = 197;

					IF @fGranted IS null SET @fGranted = 0;
				END
			END

			IF @fGranted = 1
			BEGIN
				SELECT @sTempTBColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @iSourceColumnID;

				SELECT @sTempWLColumnName = columnName
				FROM ASRSysColumns 
				WHERE columnID = @iDestinationColumnID;

				SET @sColumnList = @sColumnList + ',' + @sTempTBColumnName;
				SET @sValueList = @sValueList + ',' + @sTempWLColumnName;
			END
			
			SET @sAddedColumns = @sAddedColumns + convert(varchar(MAX), @iSourceColumnID) + ',';
		END

		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	END
	CLOSE relatedColumns_cursor;
	DEALLOCATE relatedColumns_cursor;

	IF @fSysSecMgr = 0
	BEGIN
		/* Drop temporary tables no longer required. */
		DROP TABLE #columnPermissions;
	END

	/* Create the booking record. */
	SET @sExecString = 'INSERT INTO ' + @sTBRealSource + 
		'(' + @sColumnList + ')' +
		' SELECT TOP 1 ' + @sValueList + 
		' FROM ' + @sWLRealSource + 
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;

	/* Delete the old Waiting List record(s). */
	SET @sExecString = 'DELETE FROM ' + @sWLRealSource +
		' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + '''' + 
		' AND id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @piEmpRecordID);
	EXEC sp_executesql @sExecString;
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntBookCourse]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntBookCourse] (
	@piWLRecordID	integer,
	@piCourseRecordID	integer,
	@psStatus	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@fSysSecMgr				bit,
		@sColumnList			varchar(MAX),
		@sValueList				varchar(MAX),
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sExecString			nvarchar(MAX),
		@iEmpTableID			integer,
		@iEmpRecordID			integer,
		@iCourseTableID			integer,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(255),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@sTempTBColumnName		sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(255),
		@sTempWLColumnName		sysname,
		@sAddedColumns			varchar(MAX),
		@iSourceColumnID		integer,
		@iDestinationColumnID	integer,
		@iIndex					integer,
		@fGranted				bit,
		@sActualUserName		sysname;

	/* Clean the input string parameters. */
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Get the course title from the given WL record. */
	/* NB. To reach this point we have already checked that the user has 'delete' permission on the Waiting List table,
	'insert' permission on the Training Booking table, 'update' permission on the Training Booking Status column. 
	So, no need to do them again.*/

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iTBTableID;
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @iTBStatusColumnID;

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable'
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iWLTableID;
	
	SELECT @iChildViewID = childViewID
	FROM [dbo].[ASRSysChildViews2]
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM [dbo].[ASRSysChildViews2]
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(255), @iEmpTableID) +
		' FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iEmpRecordID OUTPUT;

	IF @iEmpRecordID IS null SET @iEmpRecordID = 0;

	/* Initialise the insert strings with the basic values.*/
	SET @sColumnList = 'id_' + convert(varchar(255), @iEmpTableID) + ',' +
		'id_' + convert(varchar(255), @iCourseTableID) + ',' +
		@sTBStatusColumnName;
	SET @sValueList = convert(varchar(255), @iEmpRecordID) + ',' +
		convert(varchar(255), @piCourseRecordID) + ',' +
		'''' + @psStatus + '''';
	SET @sAddedColumns = ',' + convert(varchar(MAX), @iTBStatusColumnID) + ',';

	/* Get the TB and WL column permissions. */
	IF @fSysSecMgr = 0
	BEGIN
		DECLARE @columnPermissions TABLE(
			columnID	int,
			[action]		int,		
			granted		bit)

		INSERT INTO @columnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END AS [protectType]
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND (ASRSysColumns.tableID = @iTBTableID
				OR ASRSysColumns.tableID = @iWLTableID))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND (sysobjects.name = @sTBRealSource
				OR sysobjects.name = @sWLRealSource)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
	END

	/* Get the Waiting List - Training Booking related columns. */
	DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sourceColumnID, destColumnID
	FROM ASRSysModuleRelatedColumns
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TBWLRelatedColumns';
		
	OPEN relatedColumns_cursor;
	FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iIndex = charindex(',' + convert(varchar(MAX), @iDestinationColumnID) + ',', @sAddedColumns);

		IF @iIndex = 0
		BEGIN
			/* Check that the user has read permission on the WL column, and update permission on the TB column. */
			SET @fGranted = 1;

			IF @fSysSecMgr = 0
			BEGIN
				SELECT @fGranted = granted
				FROM @columnPermissions
				WHERE columnID = @iDestinationColumnID
					AND action = 193;

				IF @fGranted IS null SET @fGranted = 0;

				IF @fGranted = 1
				BEGIN
					SELECT @fGranted = granted
					FROM @columnPermissions
					WHERE columnID = @iSourceColumnID
						AND action = 197;

					IF @fGranted IS null SET @fGranted = 0;
				END
			END

			IF @fGranted = 1
			BEGIN
				SELECT @sTempTBColumnName = columnName
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iSourceColumnID;

				SELECT @sTempWLColumnName = columnName
				FROM [dbo].[ASRSysColumns]
				WHERE columnID = @iDestinationColumnID;

				SET @sColumnList = @sColumnList + ',' + @sTempTBColumnName;
				SET @sValueList = @sValueList + ',' + @sTempWLColumnName;
			END
			
			SET @sAddedColumns = @sAddedColumns + convert(varchar(MAX), @iSourceColumnID) + ',';
		END

		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
	END
	
	CLOSE relatedColumns_cursor;
	DEALLOCATE relatedColumns_cursor;

	SET @sExecString = 'INSERT INTO ' + @sTBRealSource + 
		'(' + @sColumnList + ')' +
		' SELECT ' + @sValueList + 
		' FROM ' + @sWLRealSource + 
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	EXEC sp_executesql @sExecString;

	SET @sExecString = 'DELETE FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(255), @piWLRecordID);
	EXEC sp_executesql @sExecString;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCalcDefaults]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntCalcDefaults] (
	@piRecordCount			integer OUTPUT,
	@psFromDef 				varchar(MAX),
	@psFilterDef 			varchar(MAX),
	@piTableID				integer,
	@piParentTableID		integer,
	@piParentRecordID		integer,
	@psDefaultCalcColumns	varchar(MAX),
	@psDecimalSeparator		varchar(255),
	@psLocaleDateFormat		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iRecordCount 	integer,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sColumns			varchar(MAX),
		@iID				integer,
		@iDataType			integer,
		@iSize				integer,
		@iDecimals			integer,
		@iDfltExprID		integer,
		@fOneColumnDone		bit,
		@iCount				integer,
		@fOK				bit,
		@iTableID			integer,
		@sCharResult 		varchar(MAX),
		@dblNumericResult 	float,
		@iIntegerResult 	integer,
		@dtDateResult 		datetime,
		@fLogicResult 		bit,
		@sTempTableName		sysname,
		@sTemp 				sysname,
		@iLoop 				integer,
		@sTempDate			varchar(10),
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sSubFilterSQL		nvarchar(MAX),
		@sColumnName 		sysname,
		@sFromSQL			nvarchar(MAX),
		@sRealSource		sysname,
		@sRealSourceAlias	varchar(MAX),
		@sTableViewName		sysname,
		@iJoinTableID		integer,
		@sColumnsDone		varchar(MAX);
		
	SET @fOneColumnDone = 0;
	SET @fOK = 1;
	SET @sFilterSQL = '';

	SET @iIndex1 = charindex(char(9), @psFromDef);
	SET @sRealSource = replace(LEFT(@psFromDef, @iIndex1-1), '''', '''''');
	SET @sRealSourceAlias = 'RS';
	SET @sFromSQL = @sRealSource + ' ' + @sRealSourceAlias + ' ';
	SET @psFromDef = SUBSTRING(@psFromDef, @iIndex1+1, LEN(@psFromDef) - @iIndex1);

	WHILE charindex(char(9), @psFromDef) > 0
	BEGIN
		SET @iIndex1 = charindex(char(9), @psFromDef);
		SET @iIndex2 = charindex(char(9), @psFromDef, @iIndex1+1);
				
		SET @sTableViewName = replace(LEFT(@psFromDef, @iIndex1-1), '''', '''''');
		SET @iJoinTableID = convert(integer, SUBSTRING(@psFromDef, @iIndex1+1, @iIndex2-@iIndex1-1));
				
		SET @psFromDef = SUBSTRING(@psFromDef, @iIndex2+1, LEN(@psFromDef) - @iIndex2);

		SET @sFromSQL = @sFromSQL + 
			' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSourceAlias + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
	END

	IF len(@psFilterDef)> 0 
	BEGIN
		WHILE charindex('	', @psFilterDef) > 0
		BEGIN
			SET @sSubFilterSQL = '';

			SET @iIndex1 = charindex('	', @psFilterDef);
			SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1);
			SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1);
				
			SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1));
			SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1));
			SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1);
				
			SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3);

			SELECT @iDataType = dataType,
				@sColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iColumnID;
							
			SET @sColumnName = @sRealSourceAlias + '.' + @sColumnName;

			IF (@iDataType = -7) 
			BEGIN
				/* Logic column (must be the equals operator).	*/
				SET @sSubFilterSQL = @sColumnName + ' = ';
			
				IF UPPER(@sValue) = 'TRUE'
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '1';
				END
				ELSE
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '0';
				END
			END

			IF ((@iDataType = 2) OR (@iDataType = 4)) 
			BEGIN
				/* Numeric/Integer column. */
				/* Replace the locale decimal separator with '.' for SQL's benefit. */
				SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.');

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equals. */
					SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				    END
				END
        
				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 6) 
				BEGIN
					/* Less than.*/
					SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue;

					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
			END

			IF (@iDataType = 11) 
			BEGIN
				/* Date column. */
				IF LEN(@sValue) > 0
				BEGIN
					/* Convert the locale date into the SQL format. */
					/* Note that the locale date has already been validated and formatted to match the locale format. */
					SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat);
					SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat);
					SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat);
						
					SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex3, 4);
				END

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
		    END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
  				    IF LEN(@sValue) > 0 
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
				    END
				END

				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
				    IF LEN(@sValue) > 0
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
				    IF LEN(@sValue) > 0
				    BEGIN
						SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
			  END

				IF (@iOperatorID = 6)
				BEGIN
					/* Less than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
			END
			
			IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
			BEGIN
				/* Character/Working Pattern column. */
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');

						SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 2) 
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');

						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 7)
				BEGIN
					/* Contains */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');

						SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%''';
					END
				END

				IF (@iOperatorID = 8) 
				BEGIN
					/* Does Not Contain. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');

						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%''';
					END
				END
			END
		
			IF LEN(@sSubFilterSQL) > 0
			BEGIN
				/* Add the filter code for this grid record into the complete filter code. */
				IF LEN(@sFilterSQL) > 0
				BEGIN
					SET @sFilterSQL = @sFilterSQL + ' AND (';
				END
				ELSE
				BEGIN
					SET @sFilterSQL = @sFilterSQL + '(';
				END

				SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')';
			END
		END
	END
	
	/* Get the record count of the current recordset. */
	SET @sCommand = 'SELECT @recordCount = COUNT(' + @sRealSourceAlias + '.id)' +
		' FROM ' + @sFromSQL;

	IF @piParentTableID > 0
	BEGIN
		SET @sCommand = @sCommand +
			' WHERE ' + @sRealSourceAlias + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
		
		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sCommand = @sCommand +	' AND ' + @sFilterSQL;
		END
	END
	ELSE
	BEGIN
		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sCommand = @sCommand +	' WHERE ' + @sFilterSQL;
		END
	END

	SET @sParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordCount OUTPUT;
	SET @piRecordCount = @iRecordCount;

	/* Get the default values for the given columns. */
	SET @sColumns = @psDefaultCalcColumns;
	SET @sColumnsDone = ',';
	WHILE len(@sColumns) > 0
	BEGIN
		IF CHARINDEX(',', @sColumns) > 0
		BEGIN
			SET @iID = convert(integer, left(@sColumns, CHARINDEX(',', @sColumns) - 1));
			SET @sColumns = substring(@sColumns, CHARINDEX(',', @sColumns) + 1, len(@sColumns));
		END
		ELSE
		BEGIN
			SET @iID = convert(integer, @sColumns);
			SET @sColumns = '';
		END

		/* Check the column has not already been done. */
		IF CHARINDEX(',' + convert(varchar(MAX), @iID) + ',', @sColumnsDone) > 0
		BEGIN
			/* Column already been done. */
			SET @iID = 0;
		END
		ELSE
		BEGIN
			/* Column NOT already been done. */
			SET @sColumnsDone = @sColumnsDone + convert(varchar(MAX), @iID) + ',';
		END

		IF @iID > 0 			
		BEGIN
			/* Get the data type and size of the column. */
			SELECT @iDataType = dataType, 
				@iSize = size, 
				@iDecimals = decimals,
				@iDfltExprID = dfltValueExprID
			FROM ASRSysColumns
			WHERE columnID = @iID;

			/* Check the default expression stored procedure exists. */
			SET @sCommand = 'SELECT @count = COUNT(*)' +
				' FROM sysobjects' +
				' WHERE id = object_id(N''sp_ASRDfltExpr_' + convert(varchar(100), @iDfltExprID) + ''')' +
				' AND OBJECTPROPERTY(id, N''IsProcedure'') = 1';
			SET @sParamDefinition = N'@count integer OUTPUT';
			EXEC sp_executesql @sCommand,  @sParamDefinition, @iCount OUTPUT;

			IF @iCount > 0 
			BEGIN
				SET @sCommand = 'exec sp_ASRDfltExpr_' + convert(varchar(100), @iDfltExprID) + ' @result output';	
				SET @fOK = 0;

				IF @iDataType = -7 /* Logic columns. */
				BEGIN
					SET @sParamDefinition = N'@result bit OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 2 /* Numeric columns. */
				BEGIN
					SET @sParamDefinition = N'@result float OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 4 /* Integer columns. */
				BEGIN
					SET @sParamDefinition = N'@result integer OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 11 /* Date columns. */
				BEGIN
					SET @sParamDefinition = N'@result datetime OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = 12 /* Character columns. */
				BEGIN
					SET @sParamDefinition = N'@result varchar(MAX) OUTPUT';
					SET @fOK = 1;
				END
          
				IF @iDataType = -1 /* Working Pattern columns. */
				BEGIN
					SET @sParamDefinition = N'@result varchar(14) OUTPUT';
					SET @fOK = 1;
				END

				IF @fOK = 1
				BEGIN
 					/* Append the parent table ID parameters. */
					DECLARE parentsCursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT parentID

						FROM ASRSysRelations
						WHERE childID = @piTableID
						ORDER BY parentID;
					OPEN parentsCursor;
					FETCH NEXT FROM parentsCursor INTO @iTableID;
					WHILE (@@fetch_status = 0)
					BEGIN
						IF @iTableID = @piParentTableID
						BEGIN
							SET @sCommand = @sCommand + ', ' + convert(varchar(100), @piParentRecordID);
						END
						ELSE
						BEGIN
							SET @sCommand = @sCommand + ', 0';
						END

						FETCH NEXT FROM parentsCursor INTO @iTableID;
					END
					CLOSE parentsCursor;
					DEALLOCATE parentsCursor;

					IF @iDataType = -7 /* Logic columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @fLogicResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] bit NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue bit';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @fLogicResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] bit NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @fLogicResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 2 /* Numeric columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @dblNumericResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] float NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue float';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @dblNumericResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] float NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @dblNumericResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 4 /* Integer columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @iIntegerResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0

							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END


								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] integer NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue integer';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @iIntegerResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] integer NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ' + convert(nvarchar(MAX), @iIntegerResult);
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = 11 /* Date columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @dtDateResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(10) NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(10)';

							SET @sTempDate = convert(varchar(10), @dtDateResult, 101);
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sTempDate;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(10) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + convert(nvarchar(MAX), @dtDateResult, 101) + '''';
							EXEC sp_executesql @sCommand;
						END
					END
          	
					IF @iDataType = 12 /* Character columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(MAX) NULL)';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(MAX)';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(MAX) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + REPLACE(convert(nvarchar(MAX), @sCharResult), '''', '''''') + '''';
							EXEC sp_executesql @sCommand;
						END
					END
          
					IF @iDataType = -1 /* Working Pattern columns. */
					BEGIN
						EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult OUTPUT;
						IF @fOneColumnDone = 0
						BEGIN
							/* Create the temp table to hold the default values. */
							SET @sTempTableName = '';
							SET @iLoop = 1;
							WHILE len(@sTempTableName) = 0
							BEGIN
								SET @sTemp = 'tmpDefaultValues_' + convert(varchar(100), @iLoop);

								SELECT @icount = COUNT(*)
								FROM sysobjects
								WHERE name = @sTemp;

								IF @iCount = 0
								BEGIN
									SET @sTempTableName = @sTemp;
								END
								ELSE
								BEGIN
									SET @iLoop = @iLoop + 1;
								END
							END

							SET @sCommand = 'CREATE TABLE ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + '] varchar(MAX) NULL)';
							EXEC sp_executesql @sCommand;

							SET @sCommand = 'INSERT INTO ' + @sTempTableName +' ([' + convert(varchar(100), @iID) + ']) VALUES (@newValue)';
							SET @sParamDefinition = N'@newValue varchar(MAX)';
							EXEC sp_executesql @sCommand,  @sParamDefinition, @sCharResult;
						END
						ELSE
						BEGIN
							/* Alter the temp table. */
							SET @sCommand = 'ALTER TABLE ' + @sTempTableName +' ADD [' + convert(varchar(100), @iID) + '] varchar(MAX) NULL';
							EXEC sp_executesql @sCommand;
							SET @sCommand = 'UPDATE ' + @sTempTableName +' SET [' + convert(varchar(100), @iID) + '] = ''' + REPLACE(convert(nvarchar(MAX), @sCharResult), '''', '''''') + '''';
							EXEC sp_executesql @sCommand;
						END
					END

					SET @fOneColumnDone = 1;
				END
			END
		END
	END

	IF @fOneColumnDone > 0
	BEGIN
		SET @sCommand = 'SELECT * FROM ' + @sTempTableName;
		EXEC sp_executesql @sCommand;

		SET @sCommand = 'DROP TABLE ' + @sTempTableName;
		EXEC sp_executesql @sCommand;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelBooking]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntCancelBooking] (
	@pfTransferBookings	bit,
	@piTBRecordID		integer,
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	
		@iCount						integer,
		@iUserGroupID				integer,
		@sUserGroupName				sysname,
		@fSysSecMgr					bit,
		@iTBTableID					integer,
		@sTBTableName				sysname,
		@sTBRealSource				sysname,
		@iWLTableID					integer,
		@sWLTableName				sysname,
		@sWLRealSource				sysname,
		@iChildViewID				integer,
		@iTBStatusColumnID			integer,
		@sTBStatusColumnName		sysname,
		@sExecString				nvarchar(MAX),
		@sCommand					nvarchar(MAX),
		@sParamDefinition			nvarchar(500),
		@sTBStatus					varchar(MAX),
		@iEmpID						integer,
		@iCourseID					integer,
		@iEmpTableID				integer,
		@iCourseTableID				integer,
		@iStatusCount				integer,
		@fTBProvisionalStatusExists		bit,
		@iCourseTitleColumnID		integer,
		@sCourseTitleColumnName		sysname,
		@sTempExecString			nvarchar(MAX),
		@sTempParamDefinition		nvarchar(500),
		@sCourseTitle				varchar(MAX),
		@iTBCancelDateColumnID		integer,
		@fTBCancelDateColumnUpdate	bit,
		@sTBCancelDateColumnName	sysname,
		@iWLCourseTitleColumnID		integer,
		@sWLCourseTitleColumnName	sysname,
		@sColumnList				varchar(MAX),
		@sValueList					varchar(MAX),
		@sAddedColumns				varchar(MAX),
		@sCourseSource				sysname,
		@iSourceColumnID			integer, 
		@iDestinationColumnID		integer,
		@iIndex						integer,
		@fGranted					bit,
		@sTempTBColumnName			sysname,
		@sTempWLColumnName			sysname,
		@sActualUserName			sysname;

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	/* Get the training booking status column name. */
	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	SET @fTBProvisionalStatusExists = 0
	SET @sCommand = 'SELECT @iStatusCount = COUNT(*)' +
		' FROM ASRSysColumnControlValues' +
		' WHERE columnID = ' + convert(nvarchar(255), @iTBStatusColumnID) +
		' AND value = ''P''';
	SET @sParamDefinition = N'@iStatusCount integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @iStatusCount OUTPUT;
	IF @iStatusCount > 0 SET @fTBProvisionalStatusExists = 1;

	SELECT @iTBCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookCancelDate';
	IF @iTBCancelDateColumnID IS NULL SET @iTBCancelDateColumnID = 0;

	IF @iTBCancelDateColumnID > 0 
	BEGIN
		SELECT @sTBCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iTBCancelDateColumnID;
	END
	IF @sTBCancelDateColumnName IS NULL SET @sTBCancelDateColumnName = '';

	/* Get the waiting list table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;
	
	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Get the status, employee ID and course ID from the given TB record. */
	/* NB. If we've reached this point we already know that we have 'read' permision on the Trining Booking 'status' and id columns. */	
	SET @sCommand = 'SELECT @sTBStatus = ' + @sTBStatusColumnName +
		', @iEmpID = id_' + convert(nvarchar(255), @iEmpTableID) +
		', @iCourseID = id_' + convert(nvarchar(255), @iCourseTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(varchar(100), @piTBRecordID);

	SET @sParamDefinition = N'@sTBStatus varchar(MAX) OUTPUT, @iEmpID integer OUTPUT, @iCourseID integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @sTBStatus OUTPUT, @iEmpID OUTPUT, @iCourseID OUTPUT;

	/* Check the employee ID, course ID and status are valid. */
	IF (@sTBStatus <> 'B') AND (@sTBStatus <> 'P') 
	BEGIN
		SET @psErrorMessage = 'Bookings can only be cancelled if they have ''Booked''';

		IF @fTBProvisionalStatusExists = 1
		BEGIN
			SET @psErrorMessage = @psErrorMessage + ' or ''Provisional''';
		END
		SET @psErrorMessage = @psErrorMessage + ' status.';
		RETURN;
	END

	IF NOT (@iEmpID > 0) 
	BEGIN
		SET @psErrorMessage = 'The selected Training Booking record has no associated Employee record.';
		RETURN;
	END

	IF NOT (@iCourseID > 0) 
	BEGIN
		SET @psErrorMessage = 'The selected Training Booking record has no associated Course record.';
		RETURN;
	END

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(255), @iCourseID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @sCourseTitle = '';
	END

	/* Check the current user's column permissions on the current course table/view. */
	SET @fTBCancelDateColumnUpdate = 0;

	IF @fSysSecMgr = 1
	BEGIN
		SET @fTBCancelDateColumnUpdate = 1;
	END
	ELSE
	BEGIN
	
		/* Create a temporary table of the column permissions. */
		DECLARE @tbColumnPermissions TABLE(
			columnID	int,
			action		int,		
			granted		bit);

		INSERT INTO @tbColumnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND ASRSysColumns.tableID = @iTBTableID
			AND ASRSysColumns.columnID = @iTBCancelDateColumnID)
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 197)
			AND sysobjects.name = @sTBRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SELECT @fTBCancelDateColumnUpdate = granted
		FROM @tbColumnPermissions
		WHERE columnID =  @iTBCancelDateColumnID;
		IF @fTBCancelDateColumnUpdate IS NULL SET @fTBCancelDateColumnUpdate = 0;

	END

	/* Update the TrainingBooking record. */
	/* Already checked that we have 'update' permission on the ststaus column. */
	SET @sCommand = 'UPDATE ' + @sTBRealSource +
		' SET ' + @sTBStatusColumnName + ' = ''C''';

	IF (@iTBCancelDateColumnID > 0) AND (@fTBCancelDateColumnUpdate = 1)
	BEGIN
		/* Add the 'cancel date' column to the update string if the user has permission to. */
		SET @sCommand = @sCommand +
			', ' + @sTBCancelDateColumnName + ' = getdate()';
	END

	SET @sCommand = @sCommand +
		' WHERE id = ' + convert(varchar(100), @piTBRecordID);
	SET @sParamDefinition = N'@sTBStatus varchar(MAX) OUTPUT, @iEmpID integer OUTPUT, @iCourseID integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @sTBStatus OUTPUT, @iEmpID OUTPUT, @iCourseID OUTPUT;

	/* Create Waiting List record if required. */
	IF @pfTransferBookings = 1
	BEGIN
		/* Check if there is already a WL record for the course. */
		SET @sCommand = 'SELECT @iCount = COUNT(*)' +
			' FROM ' + @sWLRealSource + 
			' WHERE ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + '''' + 
			' AND id_' + convert(nvarchar(255), @iEmpTableID) + ' = ' + convert(nvarchar(MAX), @iEmpID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sCommand, @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0
		BEGIN
			/* Initialise the insert strings with the basic values.*/
			/* NB. To reach this point we've already checked the user has 'update' permission on the 'courseTitle' column in the Waiting List table. */
			SET @sColumnList = 'id_' + convert(nvarchar(255), @iEmpTableID) + ',' +	@sWLCourseTitleColumnName;
			SET @sValueList = convert(nvarchar(255), @iEmpID) + ',' +	'''' + replace(@sCourseTitle, '''', '''''') + '''';
			SET @sAddedColumns = ',' + convert(varchar(255), @iWLCourseTitleColumnID) + ',';

			/* Get the TB and WL column permissions. */
			IF @fSysSecMgr = 0
			BEGIN
				DECLARE @columnPermissions TABLE(
					columnID	int,
					[action]	int,		
					granted		bit);

				INSERT INTO @columnPermissions
				SELECT 
					ASRSysColumns.columnID,
					sysprotects.action,
					CASE protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END AS [protectType]
					FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
					AND (ASRSysColumns.tableID = @iTBTableID
						OR ASRSysColumns.tableID = @iWLTableID))
				WHERE sysprotects.uid = @iUserGroupID
					AND (sysprotects.action = 193 OR sysprotects.action = 197)
					AND (sysobjects.name = @sTBRealSource
						OR sysobjects.name = @sWLRealSource)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END

			/* Get the Waiting List - Training Booking related columns. */
			DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT sourceColumnID, destColumnID
			FROM ASRSysModuleRelatedColumns
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TBWLRelatedColumns';
				
			OPEN relatedColumns_cursor;
			FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @iIndex = charindex(',' + convert(varchar(255), @iDestinationColumnID) + ',', @sAddedColumns);

				IF @iIndex = 0
				BEGIN
					/* Check that the user has read permission on the WL column, and update permission on the TB column. */
					SET @fGranted = 1;

					IF @fSysSecMgr = 0
					BEGIN
						SELECT @fGranted = granted
						FROM @columnPermissions
						WHERE columnID = @iSourceColumnID
							AND [action] = 193;

						IF @fGranted IS null SET @fGranted = 0

						IF @fGranted = 1
						BEGIN
							SELECT @fGranted = granted
							FROM @columnPermissions
							WHERE columnID = @iDestinationColumnID
								AND [action] = 197;

							IF @fGranted IS null SET @fGranted = 0;
						END
					END

					IF @fGranted = 1

					BEGIN
						SELECT @sTempTBColumnName = columnName
						FROM ASRSysColumns
						WHERE columnID = @iSourceColumnID;

						SELECT @sTempWLColumnName = columnName
						FROM ASRSysColumns 
						WHERE columnID = @iDestinationColumnID;

						SET @sColumnList = @sColumnList + ',' + @sTempWLColumnName;
						SET @sValueList = @sValueList + ',' + @sTempTBColumnName;
					END
			
					SET @sAddedColumns = @sAddedColumns + convert(varchar(255), @iSourceColumnID) + ',';
				END

				FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
			END
			CLOSE relatedColumns_cursor;
			DEALLOCATE relatedColumns_cursor;

			/* Create the WL record. */
			SET @sExecString = 'INSERT INTO ' + @sWLRealSource + 
				'(' + @sColumnList + ')' +
				' SELECT TOP 1 ' + @sValueList + 
				' FROM ' + @sTBRealSource + 
				' WHERE id = ' + convert(nvarchar(255), @piTBRecordID);
			EXEC sp_executesql @sExecString;
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCourse]    Script Date: 13/09/2013 08:59:32 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntCancelCourse] (
	@piNumberOfBookings			integer	OUTPUT,
	@piCourseRecordID			integer,
	@piTrainBookTableID			integer,
	@piCourseTableID			integer,
	@piTrainBookStatusColumnID	integer,
	@psCourseRealSource			varchar(MAX),
	@psErrorMessage				varchar(MAX) OUTPUT,
	@psCourseTitle				varchar(MAX) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sCommand					nvarchar(MAX),
			@sParamDefinition			nvarchar(500),
			@sRealSource				sysname,
			@iCourseTableID				integer,
			@fTransferProvisionals		bit,
			@sTrainBookStatusColumnName	sysname,
			@iUserGroupID				integer,
			@sUserGroupName				sysname,
			@fSysSecMgr					bit,
			@iChildViewID				integer,
			@sTemp						varchar(MAX),
			@iCourseTitleColumnID			integer,
			@fCourseTitleColumnSelect		bit,
			@iCourseCancelDateColumnID		integer,
			@fCourseCancelDateColumnUpdate	bit,
			@iCourseCancelByColumnID		integer,
			@fCourseCancelByColumnUpdate	bit,
			@sCourseTitleColumnName		sysname,
			@sTBTableName				sysname,
			@sActualUserName			sysname,
			@sCleanCourseRealSource		sysname;

	/* Clean the input string parameters. */
	SET @sCleanCourseRealSource = @psCourseRealSource;
	IF len(@sCleanCourseRealSource) > 0 SET @sCleanCourseRealSource = replace(@sCleanCourseRealSource, '''', '''''');

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID;
	
	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sRealSource = left(@sRealSource, 255);
	END

	/* Check if we need to transfer provisional bookings. */
	SET @sTemp = '';
	SELECT @sTemp = convert(varchar(MAX), parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTransferProvisionals';
		
	IF @sTemp IS NULL SET @sTemp = '';
	IF @sTemp = 'TRUE'
	BEGIN
		SET @fTransferProvisionals = 1;
	END
	ELSE
	BEGIN
		SET @fTransferProvisionals = 0;
	END

	/* Get the training booking status column name. */
	SELECT @sTrainBookStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @piTrainBookStatusColumnID;

	/* Get the number of training booking records for the current course. */
	SET @sCommand = 'SELECT @iValue = COUNT(ID) ' + 
		' FROM ' + @sRealSource +
		' WHERE id_' + convert(varchar(100), @piCourseTableID) + ' = ' + convert(varchar(100), @piCourseRecordID);

	IF @fTransferProvisionals = 1 
	BEGIN
		SET @sCommand = @sCommand +
			' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
			' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
	END
	ELSE
	BEGIN
		SET @sCommand = @sCommand +
			' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
	END

	SET @sParamDefinition = N'@iValue integer OUTPUT';
	EXEC sp_executesql @sCommand, @sParamDefinition, @piNumberOfBookings OUTPUT;

	IF @piNumberOfBookings IS NULL SET @piNumberOfBookings = 0;

	/* Check the current user's column permissions on the current course table/view. */
	/* Get the IDs of the required columns. */
	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;

	SELECT @iCourseCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelDate';
	IF @iCourseCancelDateColumnID IS NULL SET @iCourseCancelDateColumnID = 0;

	SELECT @iCourseCancelByColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelledBy';
	IF @iCourseCancelByColumnID IS NULL SET @iCourseCancelByColumnID = 0;

	IF @fSysSecMgr = 1
	BEGIN
		SET @fCourseTitleColumnSelect = 1;
		SET @fCourseCancelDateColumnUpdate = 1;
		SET @fCourseCancelByColumnUpdate = 1;
	END
	ELSE
	BEGIN
		/* Create a temporary table of the column permissions. */
		DECLARE @courseColumnPermissions TABLE(
			columnID	int,
			[action]		int,		
			granted		bit);

		INSERT INTO @courseColumnPermissions
		SELECT 
			ASRSysColumns.columnID,
			sysprotects.action,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
			AND ASRSysColumns.tableID = @piCourseTableID
			AND ((ASRSysColumns.columnID = @iCourseTitleColumnID) 
				OR (ASRSysColumns.columnID = @iCourseCancelDateColumnID)
				OR (ASRSysColumns.columnID = @iCourseCancelByColumnID)))
		WHERE sysprotects.uid = @iUserGroupID
			AND (sysprotects.action = 193 OR sysprotects.action = 197)
			AND sysobjects.name = @psCourseRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SELECT @fCourseTitleColumnSelect = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseTitleColumnID
			AND [action] = 193;
		IF @fCourseTitleColumnSelect IS NULL SET @fCourseTitleColumnSelect = 0;

		SELECT @fCourseCancelDateColumnUpdate = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseCancelDateColumnID
			AND action = 197;
		IF @fCourseCancelDateColumnUpdate IS NULL SET @fCourseCancelDateColumnUpdate = 0;

		SELECT @fCourseCancelByColumnUpdate = granted
		FROM @courseColumnPermissions
		WHERE columnID =  @iCourseCancelByColumnID
			AND action = 197;
		IF @fCourseCancelByColumnUpdate IS NULL SET @fCourseCancelByColumnUpdate = 0;

	END

	IF @iCourseTitleColumnID = 0 SET @psErrorMessage = 'Unable to find the Course Title column.';
	IF ((LEN(@psErrorMessage) = 0) AND (@fCourseTitleColumnSelect = 0)) SET @psErrorMessage = 'You do not have ''read'' permission on the Course Title column in the current table/view.';
	IF ((LEN(@psErrorMessage) = 0) AND (@iCourseCancelDateColumnID = 0)) SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
	IF ((LEN(@psErrorMessage) = 0) AND (@fCourseCancelDateColumnUpdate = 0)) SET @psErrorMessage = 'You do not have ''edit'' permission on the Course Cancel Date column in the current table/view.';
	IF ((LEN(@psErrorMessage) = 0) AND (@iCourseCancelByColumnID > 0) AND (@fCourseCancelByColumnUpdate = 0)) SET @psErrorMessage = 'You do not have ''edit'' permission on the Course Cancel By column in the current table/view.';

	SET @psCourseTitle = '';
	IF (@iCourseTitleColumnID > 0) AND (@fCourseTitleColumnSelect = 1)
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM [dbo].[ASRSysColumns]
		WHERE columnID = @iCourseTitleColumnID;

		IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';
		IF LEN(@sCourseTitleColumnName) > 0
		BEGIN
			SET @sCommand = 'SELECT @sValue = ' + @sCourseTitleColumnName +
				' FROM ' + @sCleanCourseRealSource +
				' WHERE id = ' + convert(varchar(100), @piCourseRecordID);

			SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
			EXEC sp_executesql @sCommand, @sParamDefinition, @psCourseTitle OUTPUT;
			IF @psCourseTitle IS NULL SET @psCourseTitle = '';
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCancelCoursePart2]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntCancelCoursePart2] (
	@piEmployeeTableID					integer,
	@piCourseTableID					integer,
	@psCourseRealSource					varchar(MAX),
	@piCourseRecordID					integer,
	@piTransferCourseRecordID			integer,
	@piCourseCancelDateColumnID			integer,
	@psCourseTitle						varchar(MAX),
	@piTrainBookTableID					integer,
	@pfTrainBookTableInsert				bit,
	@piTrainBookStatusColumnID			integer,
	@piTrainBookCancelDateColumnID		integer,
	@piWaitListTableID					integer,
	@pfWaitListTableInsert				bit,
	@piWaitListCourseTitleColumnID		integer,
	@pfWaitListCourseTitleColumnUpdate	bit,
	@pfCreateWaitListRecords			bit,
	@psErrorMessage						varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure actually does the course cancellation, and the associated transferrals, etc. */
	/* Returns an error string if anything went wrong. */
	DECLARE	@sCommand						nvarchar(MAX),
			@sParamDefinition				nvarchar(500),
			@iUserGroupID					integer,
			@sUserGroupName					sysname,
			@iChildViewID					integer,
			@sTemp							varchar(MAX),
			@iCount							integer,
			@fTransferProvisionals			bit,
			@fCStatusExists					bit,
			@fCCStatusExists				bit,
			@sCourseCancelDateColumnName	sysname,
			@iCourseCancelledByColumnID		integer,
			@sCourseCancelledByColumnName	sysname,
			@sWLTableName					sysname,
			@sWaitListRealSource			sysname,
			@sWaitListCourseTitleColumnName	sysname,
			@sTBTableName					sysname,
			@sTrainBookRealSource			sysname,
			@sTrainBookStatusColumnName		sysname,
			@sTrainBookCancelDateColumnName	sysname,
			@sActualUserName				sysname,
			@iSourceColumnID				integer,
			@iDestinationColumnID			integer,
			@sAddedColumns					varchar(MAX),
			@iIndex							integer,
			@fGranted						bit,
			@sTempTBColumnName				sysname,
			@sTempWLColumnName				sysname,
			@sColumnList					varchar(MAX),
			@sValueList						varchar(MAX),
			@fSysSecMgr						bit;

	BEGIN TRANSACTION

	/* Clean the input string parameters. */
	IF len(@psCourseRealSource) > 0 SET @psCourseRealSource = replace(@psCourseRealSource, '''', '''''');
	IF len(@psCourseTitle) > 0 SET @psCourseTitle = replace(@psCourseTitle, '''', '''''');

	SET @psErrorMessage = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID;

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTrainBookRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTrainBookRealSource = left(@sTrainBookRealSource, 255);
	END
	ELSE
	BEGIN
		SET @psErrorMessage = 'Unable to determine the Training Booking child view.';
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if we need to transfer provisional bookings. */
		SET @sTemp = '';
		SELECT @sTemp = convert(varchar(MAX), parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTransferProvisionals';
		IF @sTemp IS NULL SET @sTemp = '';
		IF @sTemp = 'TRUE'
		BEGIN
			SET @fTransferProvisionals = 1;
		END
		ELSE
		BEGIN
			SET @fTransferProvisionals = 0;
		END

		/* Get the Course Cancelled Date column name if there is a column defined. */
		IF @piCourseCancelDateColumnID > 0 
		BEGIN
			SELECT @sCourseCancelDateColumnName = columnName
			FROM ASRSysColumns
			WHERE columnID = @piCourseCancelDateColumnID;
		END

		IF @sCourseCancelDateColumnName IS NULL SET @sCourseCancelDateColumnName = '';
		IF LEN(@sCourseCancelDateColumnName) = 0 SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		/* Get the Course Cancelled By column name if there is a column defined. */
		SELECT @iCourseCancelledByColumnID = convert(integer, parameterValue)
		FROM [dbo].[ASRSysModuleSetup]
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseCancelledBy';
			
		IF @iCourseCancelledByColumnID IS NULL SET @iCourseCancelledByColumnID = 0;
		IF @iCourseCancelledByColumnID > 0
		BEGIN
			SELECT @sCourseCancelledByColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iCourseCancelledByColumnID;
			
			IF @sCourseCancelledByColumnName IS NULL SET @sCourseCancelledByColumnName = '';
			IF LEN(@sCourseCancelledByColumnName) = 0 SET @psErrorMessage = 'Unable to find the Course Cancel Date column.';
		END
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Update the current course record. */
		/* NB. The 'sp_ASRIntCancelCourse' stored procedure is run before this one, and checks certain permissions.
			If the user does not have update permission on the Course Cancelled Date column 
			or Course Cancelled By column (if there is one) then this point won't be reached. */
		SET @sCommand = 'UPDATE ' + @psCourseRealSource +
			' SET ' + @sCourseCancelDateColumnName + ' = getdate()';
		IF @iCourseCancelledByColumnID > 0 SET @sCommand = @sCommand + ', ' + @sCourseCancelledByColumnName + ' = SYSTEM_USER';
		SET @sCommand = @sCommand + ' WHERE id = ' + convert(nvarchar(255), @piCourseRecordID);
		EXEC sp_executesql @sCommand;
	END
	
	IF LEN(@psErrorMessage) = 0 		
	BEGIN	
		/* Get the Training Booking Status column name. */
		IF @piTrainBookStatusColumnID > 0
		BEGIN
			SELECT @sTrainBookStatusColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @piTrainBookStatusColumnID;
		END
		IF @sTrainBookStatusColumnName IS NULL SET @psErrorMessage = 'Unable to find the Training Booking Status column.';
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN	
		/* Transfer course records if required. */
		IF @piTransferCourseRecordID > 0 
		BEGIN
			IF @pfTrainBookTableInsert = 0 SET @psErrorMessage = 'You do not have ''new'' permission on the Training Booking table.';
			IF LEN(@psErrorMessage) = 0 		
			BEGIN
				/* Create the transferred booking records. */
				/* NB. Insert permission on the table is checked above.
					The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
					as the user logs into the intranet module, and checks certain permissions. 
					If the user does not have update permission on the Status column 
					then this point won't be reached. 
				The checks for overbooking, unavailability, overlapped bookings and pre-requisites
				are made as the user selects the new course. */
				SET @sCommand = 'INSERT INTO ' + @sTrainBookRealSource +
					' (' + @sTrainBookStatusColumnName + ', ' +
					'id_' + convert(nvarchar(255), @piEmployeeTableID) + ', ' +
					'id_' + convert(nvarchar(255), @piCourseTableID) + ')' +
					' (SELECT ' +
						@sTrainBookStatusColumnName + ', ' +
						'id_' + convert(nvarchar(255), @piEmployeeTableID) + ', ' +
						convert(nvarchar(255), @piTransferCourseRecordID) +
						' FROM ' + @sTrainBookRealSource +
						' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
				IF @fTransferProvisionals = 1
				BEGIN
					SET @sCommand = @sCommand +
						' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
						' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P''))';
				END	
				ELSE
				BEGIN
					SET @sCommand = @sCommand +
						' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
				END
				EXEC sp_executesql @sCommand;
			END
		END
	END

	IF (LEN(@psErrorMessage) = 0)
		AND (@piTrainBookCancelDateColumnID > 0)
	BEGIN
		/* Change the Cancellation Date of the existing bookings. */	
		/* NB. Update permission on the table is checked above.
			The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Status column or Cancel Date column (if there is one)
				then this point won't be reached. */

		SELECT @sTrainBookCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @piTrainBookCancelDateColumnID;
			
		SET @sCommand = 'UPDATE ' + @sTrainBookRealSource +
			' SET '+ @sTrainBookCancelDateColumnName + ' = getdate()' +
			' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
       
		IF @fTransferProvisionals  = 1
		BEGIN
			SET @sCommand = @sCommand +
          				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
          				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
		END
		EXEC sp_executesql @sCommand;
	END

	IF (LEN(@psErrorMessage) = 0) AND (@piTransferCourseRecordID = 0) AND (@pfCreateWaitListRecords = 1)
	BEGIN	
	
		/* Moved from below to get @sWaitListCourseTitleColumnName in time*/
		IF @piWaitListCourseTitleColumnID > 0
		BEGIN
			/* Get the Waiting List Course Title column name. */
			SELECT @sWaitListCourseTitleColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @piWaitListCourseTitleColumnID;
		END
		IF @sWaitListCourseTitleColumnName IS NULL SET @psErrorMessage = 'Unable to find the Waiting List Course Title column.';

		/*-------------------------------------------------------------------------------------------------------------*/
		/*NPG20080422 Faults 13024 and 13025																		   */
		/*-------------------------------------------------------------------------------------------------------------*/
		IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
		BEGIN
			SET @fSysSecMgr = 1;
		END
		ELSE
		BEGIN	
			/* Check if the current user is a System or Security manager. */
			SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
			FROM ASRSysGroupPermissions
			INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
			WHERE sysusers.uid = @iUserGroupID
				AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' 
				OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
				AND ASRSysGroupPermissions.permitted = 1
				AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
		END	

		/* Initialise the insert strings with the basic values.*/

		SET @sColumnList = @sWaitListCourseTitleColumnName + ',' +
			'id_' + convert(nvarchar(255), @piEmployeeTableID);
		SET @sValueList = '''' + @psCourseTitle  + ''',' +
			'id_' + convert(nvarchar(255), @piEmployeeTableID);
		SET @sAddedColumns = ',' + convert(varchar(255), @piWaitListCourseTitleColumnID) + ',';

		/* Get the TB and WL column permissions. */
		IF @fSysSecMgr = 0
		BEGIN
			DECLARE @columnPermissions TABLE(
				columnID	int,
				[action]		int,		
				granted		bit);
				
			INSERT INTO @columnPermissions
			SELECT 
				ASRSysColumns.columnID,
				sysprotects.action,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END AS [protectType]
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
				AND (ASRSysColumns.tableID = @piTrainBookTableID
					OR ASRSysColumns.tableID = @piWaitListTableID))
			WHERE sysprotects.uid = @iUserGroupID
				AND (sysprotects.action = 193 OR sysprotects.action = 197)
				AND (sysobjects.name = @sTrainBookRealSource
					OR sysobjects.name = @sWaitListRealSource)
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END

		/* Get the Waiting List - Training Booking related columns. */
		DECLARE relatedColumns_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT sourceColumnID, destColumnID
		FROM ASRSysModuleRelatedColumns
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_TBWLRelatedColumns';
			
		OPEN relatedColumns_cursor;
		FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @iIndex = charindex(',' + convert(varchar(255), @iDestinationColumnID) + ',', @sAddedColumns);
			IF @iIndex = 0
			BEGIN
				/* Check that the user has read permission on the WL column, and update permission on the TB column. */
				SET @fGranted = 1;
				IF @fSysSecMgr = 0
				BEGIN
					SELECT @fGranted = granted
					FROM @columnPermissions
					WHERE columnID = @iDestinationColumnID
						AND [action] = 193;
					IF @fGranted IS null SET @fGranted = 0;
					IF @fGranted = 1
					BEGIN
						SELECT @fGranted = granted
						FROM @columnPermissions
						WHERE columnID = @iSourceColumnID
							AND [action] = 197;
						IF @fGranted IS null SET @fGranted = 0;
					END
				END
				IF @fGranted = 1
				BEGIN
					SELECT @sTempTBColumnName = columnName
					FROM [dbo].[ASRSysColumns]
					WHERE columnID = @iSourceColumnID;
					
					SELECT @sTempWLColumnName = columnName
					FROM [dbo].[ASRSysColumns]
					WHERE columnID = @iDestinationColumnID;
					
					SET @sColumnList = @sColumnList + ',' + @sTempWLColumnName;
					SET @sValueList = @sValueList + ',' + @sTempTBColumnName;
				END
				
				SET @sAddedColumns = @sAddedColumns + convert(varchar(255), @iSourceColumnID) + ',';
			END
			FETCH NEXT FROM relatedColumns_cursor INTO @iSourceColumnID, @iDestinationColumnID;
		END

		CLOSE relatedColumns_cursor;
		DEALLOCATE relatedColumns_cursor;
		
		/* Create Waiting List records if required. */
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			IF @pfWaitListCourseTitleColumnUpdate = 0 SET @psErrorMessage = 'You do not have ''edit'' permission on the Waiting List Course Title column.';
		END
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			IF @pfWaitListTableInsert = 0 SET @psErrorMessage = 'You do not have ''new'' permission on the Waiting List table.';
		END
		IF LEN(@psErrorMessage) = 0 
		BEGIN
			SELECT @sWLTableName = tableName
			FROM [dbo].[ASRSysTables]
			WHERE tableID = @piWaitListTableID;
			
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @piWaitListTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sWaitListRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sWLTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sWaitListRealSource = left(@sWaitListRealSource, 255);
			END
			ELSE
			BEGIN
				SET @psErrorMessage = 'Unable to determine the Waiting List child view.';
			END
		END

		IF LEN(@psErrorMessage) = 0 		
		BEGIN	

			/* Create Waiting List records if required. */
			/* NB. Insert permission on the table is checked above.
				The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Course Title column 
				then this point won't be reached. */

			SET @sCommand = 'INSERT INTO ' + @sWaitListRealSource + 
				'(' + @sColumnList + ')' +
				' (SELECT ' + @sValueList + 
				' FROM ' + @sTrainBookRealSource + 
				' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID) +  
				' AND id_' + convert(nvarchar(255), @piEmployeeTableID) + ' > 0' +
				' AND ''' + @psCourseTitle + ''' NOT IN (SELECT ' + @sWaitListRealSource + '.'+ @sWaitListCourseTitleColumnName +
				' FROM ' + @sWaitListRealSource + 
				' WHERE ' + @sWaitListRealSource + '.id_' + convert(nvarchar(255), @piEmployeeTableID) + ' = ' + @sTrainBookRealSource + '.id_' + convert(nvarchar(255), @piEmployeeTableID) + ')';

			IF @fTransferProvisionals  = 1
			BEGIN
				SET @sCommand = @sCommand +
					' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
					' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P''))';
			END
			ELSE
			BEGIN
				SET @sCommand = @sCommand +
					' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B'')';
			END
			EXEC sp_executesql @sCommand;
		END
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Check if the 'CC' status code exists. */
		SET @fCCStatusExists = 0;
		
		SELECT @iCount = count(value)
		FROM [dbo].[ASRSysColumnControlValues]
		WHERE columnID = @piTrainBookStatusColumnID
			AND value = 'CC';
			
		IF @iCount > 0 SET @fCCStatusExists = 1;
		/* Check if the 'C' status code exists. */
		SET @fCStatusExists = 0;
		
		SELECT @iCount = count(value)
		FROM [dbo].[ASRSysColumnControlValues]
		WHERE columnID = @piTrainBookStatusColumnID
			AND value = 'C';
			
		IF @iCount > 0 SET @fCStatusExists = 1;
		IF @fCStatusExists = 0 SET @psErrorMessage = 'The Training Booking Status column does not have ''C'' as a valid value.';
	END

	IF LEN(@psErrorMessage) = 0 		
	BEGIN
		/* Update the existing training booking records. */	
		/* NB. Update permission on the table is checked above.
			The 'sp_ASRIntGetTrainingBookingParameters' stored procedure is run before this one, 
				as the user logs into the intranet module, and checks certain permissions. 
				If the user does not have update permission on the Status column or Cancel Date column (if there is one)
				then this point won't be reached. */
		SET @sCommand = 'UPDATE ' + @sTrainBookRealSource +
			' SET ' + @sTrainBookStatusColumnName + ' = ' +
			CASE 
				WHEN @fCCStatusExists = 1 THEN '''CC'''
				ELSE '''C'''
			END;

		SET @sCommand = @sCommand +
			' WHERE id_' + convert(nvarchar(255), @piCourseTableID) + ' = ' + convert(nvarchar(255), @piCourseRecordID);
       
		IF @fTransferProvisionals  = 1
		BEGIN
			SET @sCommand = @sCommand +
          				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')';
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
          				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''';
		END
		EXEC sp_executesql @sCommand;
	END

	IF LEN(@psErrorMessage) > 0 		
	BEGIN
		RAISERROR(@psErrorMessage, 16, 1);
		ROLLBACK;
	END
	ELSE COMMIT TRANSACTION;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCheckCanMakeHidden]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntCheckCanMakeHidden] (
	@piUtilityType		integer,
	@piUtilityID		integer,
	@piResult			integer			OUTPUT,
	@psMessage			varchar(MAX)	OUTPUT
) AS
BEGIN

	SET NOCOUNT ON;

	/* Check if the given picklist/filter/calculation can be made hidden.
	Return 	0 if there's no problem
		1 if it is used only in utilities owned by the current user - we then need to prompt the user if they want to make these utilities hidden too.
		2 if it is used in utilities which are in batch jobs not owned by the current user - Cannot therefore make the utility hidden. 
		3 if it is used in utilities which are not owned by the current user - Cannot therefore make the utility hidden. */
	DECLARE
		@sCurrentUser				sysname,
		@sUtilName					varchar(255),
		@iUtilID					integer,
		@sUtilOwner					varchar(255),
		@sUtilAccess				varchar(MAX),
		@iCount_Owner				integer,
		@sDetails_Owner				varchar(MAX),
		@iCount_NotOwner			integer,
		@sDetails_NotOwner			varchar(MAX),
		@iCount						integer,
		@sJobName					varchar(MAX),
		@sBatchJobDetails_Owner		varchar(255),
		@fBatchJobsOK				bit,
		@sBatchJobDetails_NotOwner	varchar(MAX),
		@iNonHiddenCount			integer,
		@iScheduled					integer, 
		@sRoleToPrompt				sysname,
		@sCurrentUserGroup			sysname,
		@sScheduledUserGroups		varchar(MAX),
		@sScheduledJobDetails		varchar(MAX),
		@superCursor				cursor,
		@iTemp						integer,
		@fSysSecMgr					bit,
		@sActualUserName			sysname,
		@iUserGroupID				integer;

	SET @sCurrentUser = SYSTEM_USER;
	SET @iCount_Owner = 0;
	SET @sDetails_Owner = '';
	SET @iCount_NotOwner = 0;
	SET @sDetails_NotOwner = '';
	SET @sBatchJobDetails_Owner = '';
	SET @sBatchJobDetails_NotOwner = '';
	SET @fBatchJobsOK = 1;
	SET @psMessage = '';
	SET @piResult = 0;
	SET @sScheduledUserGroups = '';
	SET @sScheduledJobDetails = '';

	EXEC spASRIntSysSecMgr @fSysSecMgr OUTPUT;
	
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sCurrentUserGroup OUTPUT,
		@iUserGroupID OUTPUT;

	DECLARE @batchJobIDs TABLE(id integer)
	DECLARE @calendarReportsIDs TABLE(id integer)
	DECLARE @careerIDs TABLE(id integer)
    DECLARE @crossTabIDs TABLE(id integer)
	DECLARE @customReportsIDs TABLE(id integer)
	DECLARE @dataTransferIDs TABLE(id integer)
	DECLARE @exportIDs TABLE(id integer)
	DECLARE @globalAddIDs TABLE(id integer)
    DECLARE @globalUpdateIDs TABLE(id integer)
    DECLARE @globalDeleteIDs TABLE(id integer)
	DECLARE @labelsIDs TABLE(id integer)
    DECLARE @mailMergeIDs TABLE(id integer)
	DECLARE @matchReportIDs TABLE(id integer)
	DECLARE @recordProfileIDs TABLE(id integer)
	DECLARE @successionIDs TABLE(id integer)
	DECLARE @filterIDs TABLE(id integer)
	DECLARE @calculationIDs TABLE(id integer)
	DECLARE @expressionIDs TABLE(id integer)
	DECLARE @superExpressionIDs TABLE(id integer)

	IF (@piUtilityType = 12) OR (@piUtilityType = 11)
	BEGIN
		/* Calculation/Filter. */
    
    /*---------------------------------------------------*/
    /* Check Calculations/Filters For This Expression		*/
    /* NB. This check must be made before checking the reports/utilities	*/
    /*---------------------------------------------------*/
		INSERT INTO @expressionIDs (id) VALUES (@piUtilityID)
		
		exec spASRIntGetAllExprRootIDs @piUtilityID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO @superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		INSERT INTO @expressionIDs (id) SELECT id FROM @superExpressionIDs

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 10

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calculation whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calculation : ' + @sUtilName + '<BR>'
					INSERT INTO @calculationIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calculation whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calculation : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calculation : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 11

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Filter whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Filter : ' + @sUtilName + '<BR>'
					INSERT INTO @filterIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Filter whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Filter : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Filter : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
			AsrSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportEvents ON AsrSysCalendarReports.ID = ASRSYSCalendarReportEvents.calendarReportID
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON AsrSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE AsrSysCalendarReports.DescriptionExpr IN (SELECT id FROM @expressionIDs)
			OR AsrSysCalendarReports.StartDateExpr IN (SELECT id FROM @expressionIDs)
      OR AsrSysCalendarReports.EndDateExpr IN (SELECT id FROM @expressionIDs)
      OR ASRSysCalendarReports.Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSYSCalendarReportEvents.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
 			AsrSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calendar Report : ' + @sUtilName + '<BR>'
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calendar Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					17,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Calendar Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Career Progression : ' + @sUtilName + '<BR>'
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Career Progression whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					24,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Career Progression ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Career Progression in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCrossTab.Name,
			AsrSysCrossTab.[CrossTabID] AS [ID],
			AsrSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON AsrSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE AsrSysCrossTab.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY AsrSysCrossTab.Name,
			AsrSysCrossTab.crossTabID,
 			AsrSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Cross Tab : ' + @sUtilName + '<BR>'
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Cross Tab whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					1,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
          
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Cross Tab ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Cross Tab in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSysCustomReportsDetails ON ASRSysCustomReportsName.ID = AsrSysCustomReportsDetails.CustomReportID
       LEFT OUTER JOIN ASRSYSCustomReportsChildDetails ON ASRSysCustomReportsName.ID = ASRSYSCustomReportsChildDetails.customReportID
LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysCustomReportsName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysCustomReportsName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSYSCustomReportsChildDetails.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR(AsrSysCustomReportsDetails.Type = 'E' 
					AND AsrSysCustomReportsDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Custom Report : ' + @sUtilName + '<BR>'
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Custom Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					2,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysCustomReportsName ON AsrSysCustomReportsname.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Custom Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Custom Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Data Transfer : ' + @sUtilName + '<BR>'
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Data Transfer whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					3,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Data Transfer ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 1
        AND ((AsrSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysMailMergeColumns.Type = 'E' 
					AND AsrSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Envelopes & Labels whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					18,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Envelopes & Labels ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
			 LEFT OUTER JOIN AsrSysExportDetails ON ASRSysExportName.ID = AsrSysExportDetails.exportID
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysExportName.Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR (AsrSysExportDetails.Type = 'X' 
					AND AsrSysExportDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY AsrSysExportName.Name,
				AsrSysExportName.ID,
        AsrSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Export : ' + @sUtilName + '<BR>'
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Export whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					4,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Export ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Export in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN AsrSysGlobalItems ON ASRSysGlobalFunctions.functionID = AsrSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'A' 
				AND ((AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysGlobalItems.ValueType = 4 
					AND AsrSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Add : ' + @sUtilName + '<BR>'
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Add whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					5,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Add ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Add in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN AsrSysGlobalItems ON ASRSysGlobalFunctions.functionID = AsrSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'U' 
				AND ((AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysGlobalItems.ValueType = 4 
					AND AsrSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Update : ' + @sUtilName + '<BR>'
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Update whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					7,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Update ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Update in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'D' 
				AND AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Delete : ' + @sUtilName + '<BR>'
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Delete whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					6,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Delete ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Delete in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 0
        AND ((AsrSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysMailMergeColumns.Type = 'E' 
					AND AsrSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Mail Merge : ' + @sUtilName + '<BR>'
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Mail Merge whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					9,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Mail Merge ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Match Report : ' + @sUtilName + '<BR>'
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Match Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					14,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Match Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Match Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileTables ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileTables.recordProfileID
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.FilterID IN (SELECT id FROM @expressionIDs)
			OR ASRSYSRecordProfileTables.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Record Profile : ' + @sUtilName + '<BR>'
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Record Profile whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					20,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Record Profile ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Record Profile in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Succession Planning : ' + @sUtilName + '<BR>'
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Succession Planning whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					23,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Succession Planning ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
		
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/* Ok, all relevant utility definitions have now been checked, so check the counts and act accordingly */
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		IF (@iCount_Owner = 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1) AND
			(len(@sBatchJobDetails_Owner) = 0)
		BEGIN
			SET @piResult = 0
			RETURN
		END
      
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1)
		BEGIN
			/* Can change utils and no utils are contained within batch jobs that cant be changed. */
			SET @psMessage = @sDetails_Owner + @sBatchJobDetails_Owner
			SET @piResult = 1
			RETURN
		END
        
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 0)
		BEGIN
			IF Len(@sScheduledUserGroups) > 0 
			BEGIN
				SET @psMessage = @sScheduledJobDetails
				SET @piResult = 4
			END
			ELSE
			BEGIN
				/* Can change utils but abort cos those utils are in batch jobs which cannot be changed. */
				SET @psMessage = @sBatchJobDetails_NotOwner
				SET @piResult = 2
			END
			
			RETURN
		END

		IF @iCount_NotOwner > 0 
		BEGIN
			/* Cannot change utils */
			SET @psMessage = @sDetails_NotOwner
			SET @piResult = 3
			RETURN
		END
	END

	IF @piUtilityType = 10
	BEGIN
    /* Picklist */
    
		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
			AsrSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON AsrSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE AsrSysCalendarReports.Picklist = @piUtilityID
		GROUP BY AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
 			AsrSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Calendar Report : ' + @sUtilName + '<BR>'
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Calendar Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					17,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Calendar Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Calendar Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Career Progression : ' + @sUtilName + '<BR>'
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Career Progression whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					24,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Career Progression : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Career Progression ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Career Progression in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCrossTab.Name,
			AsrSysCrossTab.[CrossTabID] AS [ID],
			AsrSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON AsrSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE AsrSysCrossTab.PicklistID = @piUtilityID
		GROUP BY AsrSysCrossTab.Name,
			AsrSysCrossTab.crossTabID,
 			AsrSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Cross Tab : ' + @sUtilName + '<BR>'
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Cross Tab whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					1,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Cross Tab : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
          
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Cross Tab ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Cross Tab in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent1Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent2Picklist = @piUtilityID
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Custom Report : ' + @sUtilName + '<BR>'
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Custom Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					2,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Custom Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysCustomReportsName ON AsrSysCustomReportsname.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Custom Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Custom Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.PicklistID = @piUtilityID	
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Data Transfer : ' + @sUtilName + '<BR>'
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Data Transfer whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					3,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Data Transfer : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Data Transfer ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 1
        AND AsrSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Envelopes & Labels whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					18,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Envelopes & Labels : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Envelopes & Labels ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysExportName.Picklist = @piUtilityID
				OR ASRSysExportName.Parent1Picklist = @piUtilityID
				OR ASRSysExportName.Parent2Picklist = @piUtilityID
      GROUP BY AsrSysExportName.Name,
				AsrSysExportName.ID,
        AsrSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Export : ' + @sUtilName + '<BR>'
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Export whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					4,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Export : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Export ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Export in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Add : ' + @sUtilName + '<BR>'
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Add whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					5,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Add : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Add ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Add in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Update : ' + @sUtilName + '<BR>'
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Update whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					7,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Update : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Update ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Update in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
      ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Global Delete : ' + @sUtilName + '<BR>'
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Global Delete whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					6,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Global Delete : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Global Delete ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Global Delete in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 0
				AND ASRSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Mail Merge : ' + @sUtilName + '<BR>'
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Mail Merge whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					9,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Mail Merge : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Mail Merge ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Match Report : ' + @sUtilName + '<BR>'
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Match Report whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					14,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Match Report : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Match Report ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Match Report in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.PicklistID = @piUtilityID
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Record Profile : ' + @sUtilName + '<BR>'
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Record Profile whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					20,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Record Profile : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Record Profile ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Record Profile in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					SET @iCount_Owner = @iCount_Owner + 1
					SET @sDetails_Owner = @sDetails_Owner + 'Succession Planning : ' + @sUtilName + '<BR>'
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END
			ELSE
			BEGIN
				/* Found a Succession Planning whose owner is not the same */        
				SET @iCount_NotOwner = @iCount_NotOwner + 1
          
				exec spASRIntCurrentUserAccess 
					23,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : <Hidden> by ' + @sUtilOwner + '<BR>'
				END
				ELSE
				BEGIN
					SET @sDetails_NotOwner = @sDetails_NotOwner + 'Succession Planning : ' + @sUtilName + '<BR>'
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled = 1) 
						AND (Len(@sRoleToPrompt) > 0) 
						AND (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						/*Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
      
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sRoleToPrompt + '<BR>'
						IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sUtilOwner + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sUtilName+ '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							SET @sBatchJobDetails_Owner = @sBatchJobDetails_Owner + 'Batch Job : ' +  @sUtilName + ' (Contains Succession Planning ''' + @sJobName + ''') ' + '<BR>'
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				ELSE
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is not the same */
					SET @fBatchJobsOK = 0
            		
					IF (@sUtilAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : <Hidden> by ' + @sUtilName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sBatchJobDetails_NotOwner = @sBatchJobDetails_NotOwner + 'Batch Job : ' + @sUtilName + '<BR>'
					END
				END            
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

 		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/* Ok, all relevant utility definitions have now been checked, so check the counts and act accordingly */
		/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		IF (@iCount_Owner = 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 1) AND
			(len(@sBatchJobDetails_Owner) = 0)
		BEGIN
			SET @piResult = 0
          			RETURN
		END
           
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
      (@fBatchJobsOK = 1)
		BEGIN
			/* Can change utils and no utils are contained within batch jobs that cant be changed. */
			SET @psMessage = @sDetails_Owner + @sBatchJobDetails_Owner
			SET @piResult = 1
			RETURN
		END
        
		IF (@iCount_Owner > 0) AND
			(@iCount_NotOwner = 0) AND
			(@fBatchJobsOK = 0)
		BEGIN
			IF Len(@sScheduledUserGroups) > 0 
			BEGIN
				SET @psMessage = @sScheduledJobDetails
				SET @piResult = 4
			END
			ELSE
			BEGIN
				/* Can change utils but abort cos those utils are in batch jobs which cannot be changed. */
				SET @psMessage = @sBatchJobDetails_NotOwner
				SET @piResult = 2
			END
			
			RETURN
		END

		IF @iCount_NotOwner > 0 
		BEGIN
			/* Cannot change utils */
			SET @psMessage = @sDetails_NotOwner
			SET @piResult = 3
			RETURN
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntCheckForUsage]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntCheckForUsage]  
(
	@intType int, 
	@intID int
)
AS
BEGIN
	DECLARE @strSQL varchar(500)
	DECLARE @strType varchar(100)
	IF @intType = 1
	BEGIN
		SET @strType = 'Cross Tab'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 2
	BEGIN
		SET @strType = 'Custom Report'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 3
	BEGIN
		SET @strType = 'Data Transfer'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 4
	BEGIN
		SET @strType = 'Export'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 5
	BEGIN
		SET @strType = 'Global Add'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 6
	BEGIN
		SET @strType = 'Global Update'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 7
	BEGIN
		SET @strType = 'Global Delete'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 8
	BEGIN
		SET @strType = 'Import'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	IF @intType = 9
	BEGIN
		SET @strType = 'Mail Merge'
		SET @strSQL = 'SELECT DISTINCT ''Batch Job: '', AsrSysBatchJobName.Name, AsrSysBatchJobName.UserName, AsrSysBatchJobName.Access, AsrSysBatchJobDetails.BatchJobNameID FROM ASRSysBatchJobDetails, AsrSysBatchJobName WHERE AsrSysBatchJobDetails.JobType = ''' +  @strType + ''' AND AsrSysBatchJobDetails.JobID = ' + convert(varchar(100), @intID) + 'AND AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID'
	END
	/* Repeat for all other types eventually*/
	EXECUTE (@strSQL)
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntDeleteUtility]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntDeleteUtility] (
	@piUtilType	integer,
	@piUtilID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iExprID	integer;

	IF @piUtilType = 0
	BEGIN
		/* Batch Jobs */
		DELETE FROM ASRSysBatchJobName WHERE ID = @piUtilID;
		DELETE FROM AsrSysBatchJobDetails WHERE BatchJobNameID = @piUtilID;
		DELETE FROM ASRSysBatchJobAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 1
	BEGIN
		/* Cross Tabs */
		DELETE FROM ASRSysCrossTab WHERE CrossTabID = @piUtilID;
		DELETE FROM ASRSysCrossTabAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 2
	BEGIN
		/* Custom Reports. */
		DELETE FROM ASRSysCustomReportsName WHERE id = @piUtilID;
		DELETE FROM ASRSysCustomReportsDetails WHERE customReportID= @piUtilID;
		DELETE FROM ASRSysCustomReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 3
	BEGIN
		/* Data Transfer. */
		DELETE FROM ASRSysDataTransferName WHERE DataTransferID = @piUtilID;
		DELETE FROM ASRSysDataTransferAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 4
	BEGIN
		/* Export. */
		DELETE FROM ASRSysExportName WHERE ID = @piUtilID;
		DELETE FROM AsrSysExportDetails WHERE ExportID = @piUtilID;
		DELETE FROM ASRSysExportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 5) OR (@piUtilType = 6) OR (@piUtilType = 7)
	BEGIN
		/* Globals. */
		DELETE FROM ASRSysGlobalFunctions  WHERE FunctionID = @piUtilID;
		DELETE FROM ASRSysGlobalAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 8
	BEGIN
		/* Import. */
		DELETE FROM ASRSysImportName  WHERE ID = @piUtilID;
		DELETE FROM ASRSysImportDetails WHERE ImportID = @piUtilID;
		DELETE FROM ASRSysImportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 9) OR (@piUtilType = 18)
	BEGIN
		/* Mail Merge/ Envelopes & Labels. */
		DELETE FROM AsrSysMailMergeName  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeColumns  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 10
	BEGIN
		/* Picklists. */
		DELETE FROM ASRSysPickListName WHERE picklistID = @piUtilID;
		DELETE FROM ASRSysPickListItems WHERE picklistID = @piUtilID;
	END
	
	IF @piUtilType = 11 OR @piUtilType = 12
	BEGIN
		/* Filters and Calculations. */
		DECLARE subExpressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.exprID
			FROM ASRSysExpressions
			INNER JOIN ASRSysExprComponents ON ASRSysExpressions.parentComponentID = ASRSysExprComponents.componentID
			AND ASRSysExprComponents.exprID = @piUtilID;
		OPEN subExpressions_cursor;
		FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		WHILE (@@fetch_status = 0)
		BEGIN
			exec [dbo].[sp_ASRIntDeleteUtility] @piUtilType, @iExprID;
			
			FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		END
		CLOSE subExpressions_cursor;
		DEALLOCATE subExpressions_cursor;

		DELETE FROM ASRSysExprComponents
		WHERE exprID = @piUtilID;

		DELETE FROM ASRSysExpressions WHERE exprID = @piUtilID;
	END	

	IF (@piUtilType = 14) OR (@piUtilType = 23) OR (@piUtilType = 24)
	BEGIN
		/* Match Reports/Succession Planning/Career Progression. */
		DELETE FROM ASRSysMatchReportName WHERE MatchReportID = @piUtilID;
		DELETE FROM ASRSysMatchReportAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 17 
	BEGIN
		/*Calendar Reports*/
		DELETE FROM ASRSysCalendarReports WHERE ID = @piUtilID;
		DELETE FROM ASRSysCalendarReportEvents WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportOrder WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 20 
	BEGIN
		/*Record Profile*/
		DELETE FROM ASRSysRecordProfileName WHERE recordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileDetails WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileTables WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileAccess WHERE ID = @piUtilID;
	END
	
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntExpressionHasHiddenComponents]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntExpressionHasHiddenComponents] (
	@piExprID 			integer, 
	@pfHasHiddenComponents	bit	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Check if the given expression has any hidden componeonts. */
	DECLARE @iExprID	integer,
		@sAccess		varchar(MAX),
		@fTemp			bit;

	SET @pfHasHiddenComponents = 0

	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		CASE
			WHEN ASRSysExprComponents.type = 10 THEN	ASRSysExprComponents.filterID
			WHEN ASRSysExprComponents.type = 3 THEN	ASRSysExprComponents.calculationID
			ELSE ASRSysExprComponents.fieldSelectionFilter
		END AS [exprID]
	FROM ASRSysExprComponents
	WHERE exprID = @piExprID
		AND ((type = 3) 
			OR (type = 10) 
			OR ((type = 1) AND (fieldSelectionFilter > 0)))
	OPEN components_cursor
	FETCH NEXT FROM components_cursor INTO @iExprID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @sAccess = access
		FROM ASRSysExpressions
		WHERE exprID = @iExprID	

		IF @sAccess = 'HD'
		BEGIN
			/* The filter/calc is hidden. */
			SET @pfHasHiddenComponents = 1
			RETURN
		END
		ELSE
		BEGIN
			/* The filter/calc is NOT hidden. Check the sub-components. */
			execute sp_ASRIntExpressionHasHiddenComponents @iExprID, @fTemp OUTPUT

			IF @fTemp = 1
			BEGIN
				SET @pfHasHiddenComponents = 1
				RETURN
			END	
		END

		FETCH NEXT FROM components_cursor INTO @iExprID
	END
	CLOSE components_cursor
	DEALLOCATE components_cursor	
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAbsenceTypes]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetAbsenceTypes]
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sExecString	nvarchar(MAX),
		@sTableName			varchar(255),
		@sColumnName		varchar(255),
		@iTableID			integer,
		@iColumnID			integer,
		@sParameterValue	varchar(MAX);

	SET @sTableName = '';
	SET @sColumnName = '';
	SET @sParameterValue = '';

	/* Get the Absence Type table name. */
	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_TableAbsenceType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iTableID = convert(integer, @sParameterValue);

		SELECT @sTableName = tableName 
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @iTableID;
		
 	END

	/* Get the Absence Type Column name. */
	SET @sParameterValue = '';

	SELECT @sParameterValue = parameterValue
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = 'MODULE_ABSENCE'
		AND parameterKey = 'Param_FieldTypeType';

	IF NOT @sParameterValue IS null
	BEGIN
		SET @iColumnID = convert(integer, @sParameterValue);

		SELECT @sColumnName = columnName 
		FROM [dbo].[ASRSysColumns]
		WHERE columnID = @iColumnID;
		
 	END

	/* Get the Absence Types if everything is ok. */
	IF len(@sTableName) > 0
		AND len(@sColumnName) > 0
	BEGIN
		SET @sExecString = 'SELECT ' + @sColumnName + 
			' FROM ' + @sTableName +
			' ORDER BY ' + @sColumnName;

		/* Return a recordset of the absence types */
		EXECUTE sp_executeSQL @sExecString;
		
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetAvailableLogins]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetAvailableLogins] 
AS
BEGIN

	SET NOCOUNT ON;

	SELECT name FROM sys.server_principals
	WHERE NOT EXISTS (SELECT sysusers.sid
						FROM sysusers
						WHERE sysusers.sid = sys.server_principals.sid)
	AND TYPE IN ('S', 'U')
	AND name != 'NT AUTHORITY\SYSTEM'
	AND is_disabled = 0;

END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetColumns]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetColumns] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ColumnID, ColumnName, OLEType
		FROM [dbo].[ASRSysColumns]
		WHERE tableID = @piTableID AND NOT(ColumnName = 'ID')
		ORDER BY ColumnName;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetConfiguration]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetConfiguration] (
	@psPicturePath varchar(8000) OUTPUT
)
AS
BEGIN
	/* Return the required configuation parameter. */
	SELECT @psPicturePath = IntranetPicturePath
	FROM ASRSysConfig

	IF @psPicturePath IS NULL SET @psPicturePath = ''
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetCrossTabTablesInfo]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetCrossTabTablesInfo]
AS
BEGIN
	/* Return a set of information for all of the tables in the system. */
	/* The information required is :
		table id
		table name
		table type
		string listing the ids of the table's children.
		string listing the ids of the table's parents.
		
	NB. The tables are return in name order. */
	
	SET NOCOUNT ON;
	
	DECLARE	@iTableID	integer,
			@sTableName	sysname,
			@iTableType	integer,
			@sChildren	varchar(MAX),
			@sChildrenNames varchar(2000),
			@sParents	varchar(2000),
			@iChildID	integer,
			@sChildName	varchar(2000),
			@iParentID	integer;

	DECLARE @tableInfo TABLE(
		tableID			integer,
		tableName		sysname,
		tableType		integer,
		childrenString	varchar(MAX),
		childrenNames	varchar(MAX),
		parentsString	varchar(MAX));

	DECLARE tableCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableID,
		tableName,
		tableType
	FROM [dbo].[ASRSysTables]
	         WHERE (SELECT COUNT(*) FROM ASRSysColumns
	         WHERE ASRSysColumns.TableID = ASRSysTables.TableID
	         AND columnType <> 3
	         AND columnType <> 4
	         AND dataType <> -3
	         AND dataType <> -4) > 1;

	OPEN tableCursor;
	FETCH NEXT FROM tableCursor INTO @iTableID, @sTableName, @iTableType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sChildren = '';
		SET @sParents = '';
		SET @sChildrenNames = '';

		DECLARE childCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysRelations.childID, ASRSysTables.TableName
			FROM [dbo].[ASRSysRelations]
			INNER JOIN ASRSysTables ON ASRSysRelations.childID = ASRSysTables.tableID
			WHERE ASRSysRelations.parentID = @iTableID
			ORDER BY ASRSysTables.tableName;

		OPEN childCursor;
		FETCH NEXT FROM childCursor INTO @iChildID, @sChildName;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sChildren = @sChildren + convert(varchar(MAX), @iChildID) + char(9);

			SET @sChildrenNames = @sChildrenNames +	convert(varchar(MAX), @iChildID) + char(9) + convert(varchar(MAX), @sChildName) + char(9);

			FETCH NEXT FROM childCursor INTO @iChildID, @sChildName;
		END
		CLOSE childCursor;
		DEALLOCATE childCursor;

		DECLARE parentCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysRelations.parentID
			FROM [dbo].[ASRSysRelations]
			INNER JOIN ASRSysTables ON ASRSysRelations.parentID = ASRSysTables.tableID
			WHERE ASRSysRelations.childID = @iTableID
			ORDER BY ASRSysTables.tableName;

		OPEN parentCursor;
		FETCH NEXT FROM parentCursor INTO @iParentID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sParents = @sParents + convert(varchar(MAX), @iParentID) + char(9);
			FETCH NEXT FROM parentCursor INTO @iParentID;
		END
		CLOSE parentCursor;
		DEALLOCATE parentCursor;

		INSERT INTO @tableInfo (tableID, tableName, tableType, childrenString, childrenNames, parentsString) 
			VALUES(@iTableID, @sTableName, @iTableType, @sChildren, @sChildrenNames, @sParents);

		FETCH NEXT FROM tableCursor INTO @iTableID, @sTableName, @iTableType;
	END
	CLOSE tableCursor;
	DEALLOCATE tableCursor;

	SELECT *
		FROM @tableInfo 
		ORDER BY tableName;

END

GO



/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromTBID]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromTBID] (
	@piEmpRecordID	integer		OUTPUT,
	@piTBRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@iEmpTableID			integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(255),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List table. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piEmpRecordID OUTPUT;

	IF @piEmpRecordID IS null SET @piEmpRecordID = 0;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetEmpIDFromWLID]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetEmpIDFromWLID] (
	@piEmpRecordID	integer		OUTPUT,
	@piWLRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iChildViewID 			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@iEmpTableID			integer,
		@iWLTableID				integer,
		@sWLRealSource			varchar(255),
		@sWLTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List table. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable'
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;
	
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SET @sTempExecString = 'SELECT @iID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		' FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piWLRecordID);
	SET @sTempParamDefinition = N'@iID integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @piEmpRecordID OUTPUT;

	IF @piEmpRecordID IS null SET @piEmpRecordID = 0;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprCalcs]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprCalcs] (
	@piCurrentExprID	integer,
	@piBaseTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the calc definitions. */
	DECLARE	 @sUserName SYSNAME,
			 @fSysSecMgr BIT,
			 @sRoleName VARCHAR(255),
			 @sActualUserName	VARCHAR(250),
			 @iActualUserGroupID INTEGER

	SET @sUserName = SYSTEM_USER;
	
	--Determine if user is an admin
	EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT;

	SELECT @fSysSecMgr = 
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE ASRSysGroupPermissions.groupname = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
				ELSE 0
			END;


	SELECT Name + char(9) +
		convert(varchar(255), exprID) + char(9) +
		userName AS [definitionString],
		[Description]
	FROM [dbo].[ASRSysExpressions]
	WHERE ExprID <> @piCurrentExprID
		AND Type = 10
		AND TableID = @piBaseTableID
		AND parentComponentID = 0
		AND (Username = @sUserName OR access <> 'HD' OR @fSysSecMgr = 1)
	ORDER BY name;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprColumns]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprColumns] (
	@piTableID			integer,
	@piComponentType	integer,
	@piNumericsOnly		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted column definitions ;
	<column id><tab><column name><tab><data type> */
	DECLARE @iDataType	integer;

	IF @piComponentType = 1
	BEGIN
		SET @iDataType = -3;
	END
	ELSE
	BEGIN
		SET @iDataType = -7;
		SET @piNumericsOnly = 0;
	END

	SELECT 
		convert(varchar(255), columnID) + char(9) +
		columnName + char(9) +
		convert(varchar(255), dataType) AS [definitionString]
	FROM [dbo].[ASRSysColumns]
	WHERE tableID = @piTableID
		AND dataType <> -4
		AND dataType <> -3
		AND dataType <> @iDataType
		AND columnType <> 4
		AND columnType <> 3
		AND ((@piNumericsOnly = 0) OR (dataType = 2) OR (dataType = 4))
	ORDER BY columnName;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprComponentDefinition]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExprComponentDefinition] (
	@piComponentID	integer
)
AS
BEGIN
	/* Return a recordset of tab-delimted table definitions ;
	<table id><tab><table name><tab><table type><tab><related to base table ?> */
	SELECT ASRSysExprComponents.componentID,
		ASRSysExprComponents.exprID,
		ASRSysExprComponents.type,
		ASRSysColumns.tableID AS [fieldTableID],
		ASRSysExprComponents.fieldColumnID,
		ASRSysExprComponents.fieldPassBy,
		ASRSysExprComponents.fieldSelectionTableID,
		ASRSysExprComponents.fieldSelectionRecord,
		ASRSysExprComponents.fieldSelectionLine,
		ASRSysExprComponents.fieldSelectionOrderID,
		ASRSysExprComponents.fieldSelectionFilter,
		ASRSysExprComponents.functionID,
		ASRSysExprComponents.calculationID,
		ASRSysExprComponents.operatorID,
		ASRSysExprComponents.valueType,
		ASRSysExprComponents.valueCharacter,
		ASRSysExprComponents.valueNumeric,
		ASRSysExprComponents.valueLogic,
		convert(varchar(10), ASRSysExprComponents.valueDate, 101) AS [valueDate],
		ASRSysExprComponents.promptDescription,
		ASRSysExprComponents.promptMask,
		ASRSysExprComponents.promptSize,
		ASRSysExprComponents.promptDecimals,
		ASRSysExprComponents.functionReturnType,
		ASRSysExprComponents.lookupTableID,
		ASRSysExprComponents.lookupColumnID,
		ASRSysExprComponents.filterID,
		ASRSysExprComponents.expandedNode,
		ASRSysExprComponents.promptDateType,
		ASRSysOrders.name AS [fieldOrderName],
		ASRSysExpressions.name AS [fieldFilterName]
	FROM ASRSysExprComponents
	LEFT OUTER JOIN ASRSysOrders ON ASRSysExprComponents.FieldSelectionOrderID = ASRSysOrders.orderID
	LEFT OUTER JOIN ASRSysExpressions ON ASRSysExprComponents.FieldSelectionFilter = ASRSysExpressions.exprID
	LEFT OUTER JOIN ASRSysColumns ON ASRSysExprComponents.fieldColumnID = ASRSysColumns.columnID
	WHERE componentID = @piComponentID
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExpressionDefinition]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition] (
	@piExprID		integer,
	@psAction		varchar(100),
	@psErrMsg		varchar(MAX)	OUTPUT,
 	@piTimestamp	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the defintions of each component and expression in the given expression. */
	DECLARE @sExprIDs		varchar(MAX),
		@sComponentIDs		varchar(MAX),
		@sTempExprIDs		varchar(MAX),
		@sTempComponentIDs	varchar(MAX),
		@sCurrentUser		sysname,
		@iCount				integer,
		@sOwner				varchar(255),
		@sAccess			varchar(MAX),
		@iBaseTableID		integer,
		@sBaseTableID		varchar(100),
		@fSysSecMgr			bit,
		@sExecString		nvarchar(MAX);
	
	SET @psErrMsg = '';
	SET @sCurrentUser = SYSTEM_USER;

	/* Check the expressions exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @iCount = 0
	BEGIN
		SET @psErrMsg = 'expression has been deleted by another user.';
		RETURN;
	END

	SELECT @sOwner = userName,
		@sAccess = access,
		@iBaseTableID = tableID,
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @sAccess <> 'RW'
	BEGIN
		exec spASRIntSysSecMgr @fSysSecMgr OUTPUT;
	
		IF @fSysSecMgr = 1 SET @sAccess = 'RW';
	END
	
	IF @iBaseTableID IS null 
	BEGIN
		SET @sBaseTableID = '0';
	END
	ELSE
	BEGIN
		SET @sBaseTableID = convert(varchar(100), @iBaseTableID);
	END

	/* Check the current user can view the expression. */
	IF (@sAccess = 'HD') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made hidden by another user.';
		RETURN;
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made read only by another user.';
		RETURN;
	END

	SET @sExprIDs = convert(varchar(MAX), @piExprID);
	SET @sComponentIDs = '0';

	/* Get a list of the components and sub-expressions in the given expression. */
	exec sp_ASRIntGetSubExpressionsAndComponents @piExprID, @sTempExprIDs OUTPUT, @sTempComponentIDs OUTPUT;

	IF len(@sTempExprIDs) > 0 SET @sExprIDs = @sExprIDs + ',' + @sTempExprIDs;
	IF len(@sTempComponentIDs) > 0 SET @sComponentIDs = @sComponentIDs + ',' + @sTempComponentIDs;

	SET @sExecString = 'SELECT
		''C'' as [type],
		ASRSysExprComponents.componentID AS [id],
		convert(varchar(100), ASRSysExprComponents.componentID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.exprID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.type)+ char(9) +
		CASE WHEN ASRSysExprComponents.fieldColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldPassBy IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldPassBy) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionRecord IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionRecord) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionLine IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionLine) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionOrderID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionOrderID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionFilter IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionFilter) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionID) END + char(9) +
		CASE WHEN ASRSysExprComponents.calculationID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.calculationID) END + char(9) +
		CASE WHEN ASRSysExprComponents.operatorID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.operatorID) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueType) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueCharacter IS null THEN '''' ELSE ASRSysExprComponents.valueCharacter END + char(9) +
		CASE WHEN ASRSysExprComponents.valueNumeric IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueNumeric) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueLogic IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueLogic) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueDate IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueDate, 101) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDescription IS null THEN '''' ELSE ASRSysExprComponents.promptDescription END + char(9) +
		CASE WHEN ASRSysExprComponents.promptMask IS null THEN '''' ELSE ASRSysExprComponents.promptMask END + char(9) +
		CASE WHEN ASRSysExprComponents.promptSize IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptSize) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDecimals IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDecimals) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionReturnType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionReturnType) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.filterID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.filterID) END + char(9) +
		CASE WHEN ASRSysExprComponents.expandedNode IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.expandedNode) END + char(9) + 
		CASE WHEN ASRSysExprComponents.promptDateType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDateType) END + char(9) + 
		CASE 
			WHEN ASRSysExprComponents.type = 1 THEN fldtabs.tablename + 
				CASE 
					WHEN (ASRSysExprComponents.fieldPassBy = 2) OR (ASRSysExprComponents.fieldSelectionRecord <> 5) then '' : '' + fldcols.columnname
					ELSE ''''
				END +
				CASE 
					WHEN ASRSysExprComponents.fieldPassBy = 2 then ''''
					ELSE
						CASE 
							WHEN fldrelations.parentID IS null THEN ''''
							ELSE
								CASE 
									WHEN ASRSysExprComponents.fieldSelectionRecord = 1 THEN '' (first record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 2 THEN '' (last record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 3 THEN '' (line '' + convert(varchar(100), ASRSysExprComponents.fieldSelectionLine)
									WHEN ASRSysExprComponents.fieldSelectionRecord = 4 THEN '' (total''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 5 THEN '' (record count''
									ELSE '' (''
								END +
								CASE 
									WHEN fldorders.name IS null THEN ''''
									ELSE '', order by '''''' + fldorders.name + ''''''''
								END  +
								CASE 
									WHEN fldfilters.name IS null then ''''
									ELSE '', filter by '''''' + fldfilters.name + ''''''''
								END + 
								'')''
						END
				END
			WHEN ASRSysExprComponents.type = 2 THEN ASRSysFunctions.functionName
			WHEN ASRSysExprComponents.type = 3 THEN calcexprs.name
			WHEN ASRSysExprComponents.type = 5 THEN ASRSysOperators.name
			WHEN ASRSysExprComponents.type = 10 THEN filtexprs.name
			ELSE ''''
		END + char(9) +
		CASE WHEN fldcols.tableID IS null THEN '''' ELSE convert(varchar(100), fldcols.tableID) END + char(9) + 
		CASE WHEN fldorders.name IS null THEN '''' ELSE fldorders.name END + char(9) + 
		CASE WHEN fldfilters.name IS null THEN '''' ELSE fldfilters.name END
		AS [definition]
	FROM ASRSysExprComponents
	LEFT OUTER JOIN ASRSysExpressions calcexprs ON ASRSysExprComponents.calculationID = calcexprs.exprID
	LEFT OUTER JOIN ASRSysExpressions filtexprs ON ASRSysExprcomponents.filterID = filtexprs.exprID
	LEFT OUTER JOIN ASRSysColumns fldcols ON ASRSysExprComponents.FieldColumnID = fldcols.columnID
	LEFT OUTER JOIN ASRSysTables fldtabs ON fldcols.tableID = fldtabs.tableID
	LEFT OUTER JOIN ASRSysFunctions ON ASRSysExprComponents.functionID = asrsysfunctions.functionID 
	LEFT OUTER JOIN ASRSysOperators ON ASRSysExprComponents.operatorID = asrsysoperators.operatorID 
	LEFT OUTER JOIN ASRSysRelations fldrelations ON (ASRSysExprComponents.fieldTableID = fldrelations.childID and fldrelations.parentID = ' + @sBaseTableID + ')
	LEFT OUTER JOIN ASRSysOrders fldorders ON ASRSysExprComponents.fieldSelectionOrderID = fldorders.orderID
	LEFT OUTER JOIN ASRSysExpressions fldfilters ON ASRSysExprComponents.fieldSelectionFilter = fldfilters.exprID	
	WHERE ASRSysExprComponents.componentID IN (' + @sComponentIDs + ')
	UNION
	SELECT 	
		''E'' as [type],
		ASRSysExpressions.exprID AS [id],
		convert(varchar(100), ASRSysExpressions.exprID)+ char(9) +
		ASRSysExpressions.name + char(9) +
		convert(varchar(100), ASRSysExpressions.tableID) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnType) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnSize) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnDecimals) + char(9) +
		convert(varchar(100), ASRSysExpressions.type) + char(9) +
		convert(varchar(100), ASRSysExpressions.parentComponentID) + char(9) +
		ASRSysExpressions.userName + char(9) +
		ASRSysExpressions.access + char(9) +
		CASE WHEN ASRSysExpressions.description IS null THEN '''' ELSE ASRSysExpressions.description END + char(9) +
		convert(varchar(100), convert(integer, ASRSysExpressions.timestamp)) + char(9) + 
		convert(varchar(100), isnull(ASRSysExpressions.viewInColour, 0)) + char(9) +
		convert(varchar(100), isnull(ASRSysExpressions.expandedNode, 0)) AS [definition]
	FROM ASRSysExpressions
	WHERE ASRSysExpressions.exprID IN (' + @sExprIDs + ')
	ORDER BY [id]';
	
	EXECUTE sp_EXecuteSQL @sExecString;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFilters]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprFilters] (
	@piCurrentExprID	integer,
	@piBaseTableID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the filter definitions. */
	DECLARE	 @sUserName SYSNAME,
			 @fSysSecMgr BIT,
			 @sRoleName VARCHAR(255),
			 @sActualUserName	VARCHAR(250),
			 @iActualUserGroupID INTEGER

	SET @sUserName = SYSTEM_USER;
	
	--Determine if user is an admin
	EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT;

	SELECT @fSysSecMgr = 
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE ASRSysGroupPermissions.groupname = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
				ELSE 0
			END;

	SELECT name + char(9) +
		convert(varchar(255), exprID) + char(9) +
		userName AS [definitionString],
		[description]
	FROM [dbo].[ASRSysExpressions]
	WHERE exprID <> @piCurrentExprID
		AND type = 11
		AND TableID = @piBaseTableID
		AND parentComponentID = 0
		AND (Username = @sUserName OR access <> 'HD' OR @fSysSecMgr = 1)
	ORDER BY name;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprFunctionParameters]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprFunctionParameters] 
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the runtiume function partameter definitions. */
	DECLARE @fEnableUDFFunctions	bit,
			@sSQLVersion int

	SET @fEnableUDFFunctions = 0
	SELECT @sSQLVersion = dbo.udfASRSQLVersion()

	IF @sSQLVersion >= 8
	BEGIN  
		SET @fEnableUDFFunctions = 1
	END
	SELECT ASRSysFunctions.functionID, 
		ASRSysFunctionParameters.parameterName
	FROM ASRSysFunctions
	LEFT OUTER JOIN ASRSysFunctionParameters ON ASRSysFunctions.functionID = ASRSysFunctionParameters.functionID
	WHERE (ASRSysFunctions.runtime = 1)
		OR ((ASRSysFunctions.UDF = 1) AND (@fEnableUDFFunctions = 1))
	ORDER BY ASRSysFunctions.functionID, ASRSysFunctionParameters.parameterIndex
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprLookupValues]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprLookupValues]
(	@piColumnID		integer,
	@piDataType		integer		OUTPUT)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of values for the given lookup column. */
	DECLARE @sColumnName	sysname,
			@sTableName		sysname,
			@sExecString	nvarchar(MAX);

	SELECT @sColumnName = ASRSysColumns.columnName, 
		@sTableName = ASRSysTables.tableName,
		@piDataType = ASRSysColumns.dataType
	FROM ASRSysColumns
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE ASRSysColumns.columnID = @piColumnID

	IF @piDataType = 11
	BEGIN
		SET @sExecString = 'SELECT DISTINCT convert(varchar(10), ' + @sColumnName + ', 101) AS lookUpValue' +
			' FROM ' + @sTableName +
			' ORDER BY lookUpValue;';
	END
	ELSE
	BEGIN
		SET @sExecString = 'SELECT DISTINCT ' + @sColumnName + ' AS lookUpValue' +
			' FROM ' + @sTableName +
			' ORDER BY lookUpValue;';
	END
	
	-- Get the data
	EXECUTE sp_executeSQL @sExecString;
	
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprOperators]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprOperators]
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted operator definitions ;
	<operator id><tab><operator name><tab><operator category> */
	SELECT 
		convert(varchar(100), operatorID) + char(9) +
		name + 
		CASE 
			WHEN len(shortcutKeys) > 0 THEN ' (' + shortcutKeys + ')'
			ELSE ''
		END + char(9) +
		category AS [definitionString]
	FROM [dbo].[ASRSysOperators];
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetExprTables]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetExprTables] (
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimted table definitions ;
	<table id><tab><table name><tab><table type><tab><related to base table ?><tab><is child of base table ?> */
	SELECT 
		convert(varchar(255), tableID) + char(9) +
		tableName + char(9) +
		convert(varchar(255), tableType) + char(9) +
		CASE 
			WHEN (tableID = @piTableID) OR (children.childID IS NOT null) OR (parents.parentID IS NOT null) THEN '1'
			ELSE '0'
		END + char(9) +
		CASE 
			WHEN (children.childID IS NOT null) THEN '1'
			ELSE '0'
		END AS [definitionString]
	FROM [dbo].[ASRSysTables]
	LEFT OUTER JOIN ASRSysRelations children ON	(ASRSysTables.tableid = children.childID AND children.parentID = @piTableID)
	LEFT OUTER JOIN ASRSysRelations parents ON	(ASRSysTables.tableid = parents.parentID AND parents.childID = @piTableID)
	ORDER BY tableName;
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFilterPromptedValues]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValues] (
	@piFilterID 		integer,
	@psComponents		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a list of the prompted values in the given filter (and sub-filters). */
	DECLARE	@iComponentID	integer, 
			@iType			integer,
			@sComponents	varchar(MAX),
			@iExprID		integer,
			@iFieldFilterID	integer;

	SET @psComponents = '';

	/* Get the prompted value components, and also the subexpressions (sub-filters and function parameters). */
	DECLARE components_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT componentID, 
			type, 
			CASE 
				WHEN type = 3 THEN calculationID
				ELSE filterID
			END AS filterID, 
			fieldSelectionFilter
		FROM [dbo].[ASRSysExprComponents]
		WHERE exprID = @piFilterID
			AND ((type = 7) 
				OR ((type = 1) AND (fieldSelectionFilter > 0)) 
				OR (type = 2) 
				OR (type = 3) 
				OR (type = 10))
		ORDER BY componentID;
		
	OPEN components_cursor;
	FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iType = 1
		BEGIN
			/* Field value with filter. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFieldFilterID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END

		IF @iType = 7
		BEGIN
			/* Prompted value. */
			SET @psComponents = @psComponents + 
				CASE
					WHEN LEN(@psComponents) > 0 THEN ','
					ELSE ''
				END +
				convert(varchar(255), @iComponentID);
		END

		IF (@iType = 10) OR (@iType = 3)
		BEGIN
			/* Sub-filter or calculation. */
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

			IF LEN(@sComponents) > 0
			BEGIN
				SET @psComponents = @psComponents + 
					CASE
						WHEN LEN(@psComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents;
			END
		END
	
		IF @iType = 2
		BEGIN
			/* Function. Check if there are any prompted values in the parameter expressions.. */
			DECLARE function_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT exprID 
				FROM [dbo].[ASRSysExpressions]
				WHERE parentComponentID = @iComponentID;
				
			OPEN function_cursor;
			FETCH NEXT FROM function_cursor INTO @iExprID;
			WHILE (@@fetch_status = 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iExprID, @sComponents OUTPUT;

				IF LEN(@sComponents) > 0
				BEGIN
					SET @psComponents = @psComponents + 
						CASE
							WHEN LEN(@psComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents;
				END

				FETCH NEXT FROM function_cursor INTO @iExprID;
			END
			CLOSE function_cursor;
			DEALLOCATE function_cursor;
		END
	
		FETCH NEXT FROM components_cursor INTO @iComponentID, @iType, @iExprID, @iFieldFilterID;
	END
	
	CLOSE components_cursor;
	DEALLOCATE components_cursor;

END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowInfo]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetFindWindowInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry 	bit 			OUTPUT, 
	@plngScreenID	integer,
	@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the find window title for the given screen. 	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* Get the screen name. */
	IF @plngScreenID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @psTitle = name,
			@pfQuickEntry = quickEntry
		FROM [dbo].[ASRSysScreens]
		WHERE screenID = @plngScreenID;

		IF @psTitle IS NULL 
		BEGIN
			SET @psTitle = '<unknown screen>';
		END
		IF @pfQuickEntry IS NULL 
		BEGIN
			SET @pfQuickEntry = 0;
		END
	END
	ELSE
	BEGIN
		SET @psTitle = '<unknown screen>';
	END	

	/* Get the view name. */
	IF @plngViewID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @sViewName = viewName
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @plngViewID;

		IF @sViewName IS NULL 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFindWindowTitle]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetFindWindowTitle] (@psTitle varchar(100) OUTPUT, @plngScreenID int)
AS
BEGIN
	/* Return the OUTPUT variable @psTitle with the find window title for the given screen. 	*/
	DECLARE @sScreenName	sysname
	
	/* Get the screen name. */
	IF @plngScreenID > 0
	BEGIN
		/* Find title is just the table name. */
		SELECT @psTitle = name
		FROM ASRSysScreens
		WHERE screenID = @plngScreenID
		IF @psTitle IS NULL 
		BEGIN
			SET @psTitle = '<unknown screen>'
		END
	END
	ELSE
	BEGIN
		SET @psTitle = '<unknown screen>'
	END	
END

GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetFullAccessChildView]
(
	@piChildTableID	integer,
	@piChildViewID		integer OUTPUT
)
AS
BEGIN
	/* Return the child view that gives full access to the given table. */
	DECLARE @iParentID		integer, 
		@iTableType		integer,
		@iChildViewID		integer,
		@iParentCount		integer,
		@sSQL			nvarchar(4000),
		@fChildViewTypeExists	bit,
		@iCount		integer
	/* Only do the childview type stuff if the database has been updated to use these. */
	SET @fChildViewTypeExists = 0
	SELECT @iCount = count(*) 
	FROM syscolumns
	INNER JOIN sysobjects ON syscolumns.id = sysobjects.id
	WHERE syscolumns.name  = 'type'
		AND sysobjects.name  = 'asrsyschildviews'
	IF @iCount > 0 SET @fChildViewTypeExists = 1
	SET @iParentCount = 0
	SET @sSQL = 'SELECT @piResult = ASRSysChildViews.childViewID' +
		' FROM ASRSysChildViews'
	/* Populate the temp table with the required table's parents. */
	DECLARE parents_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRelations.parentID,  
			ASRSysTables.tableType
		FROM ASRSysRelations
		INNER JOIN ASRSysTables ON ASRSysRelations.parentID = ASRSysTables.tableID
		WHERE ASRSysRelations.childID = @piChildTableID
	OPEN parents_cursor
	FETCH NEXT FROM parents_cursor INTO @iParentID, @iTableType
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @iParentCount = @iParentCount + 1
		IF @iTableType = 1 /* top-level table */
		BEGIN
			SET @sSQL = @sSQL +
				' INNER JOIN ASRSysChildViewParents tmpTable_' + convert(varchar(100), @iParentCount) +
				' ON (ASRSysChildViews.childViewID = tmpTable_' + convert(varchar(100), @iParentCount) + '.childViewID' +
				' AND tmpTable_' + convert(varchar(100), @iParentCount) + '.parentType = ''UT''' +
				' AND tmpTable_' + convert(varchar(100), @iParentCount) + '.parentID = ' + convert(varchar(100), @iParentID) + ')'
		END
		ELSE
		BEGIN
			execute sp_ASRIntGetFullAccessChildView @iParentID, @iChildViewID OUTPUT
			SET @sSQL = @sSQL +
				' INNER JOIN ASRSysChildViewParents tmpTable_' + convert(varchar(100), @iParentCount) +
				' ON (ASRSysChildViews.childViewID = tmpTable_' + convert(varchar(100), @iParentCount) + '.childViewID' +
				' AND tmpTable_' + convert(varchar(100), @iParentCount) + '.parentType = ''SV''' +
				' AND tmpTable_' + convert(varchar(100), @iParentCount) + '.parentID = ' + convert(varchar(100), @iChildViewID) + ')'
		END
		FETCH NEXT FROM parents_cursor INTO @iParentID, @iTableType
	END
	CLOSE parents_cursor
	DEALLOCATE parents_cursor
  
	SET @sSQL = @sSQL +
		' INNER JOIN ASRSysChildViewParents parentCount ON (ASRSysChildViews.childViewID = parentCount.childViewID)' +
		' GROUP BY ASRSysChildViews.childViewID, ASRSysChildViews.tableID'
	IF @fChildViewTypeExists = 1 SET @sSQL = @sSQL + ', ASRSysChildViews.type'
	SET @sSQL = @sSQL +
		' HAVING ASRSysChildViews.tableID = ' + convert(varchar(100), @piChildTableID) 
	IF @fChildViewTypeExists = 1 SET @sSQL = @sSQL + ' AND (ASRSysChildViews.type = 0 OR ASRSysChildViews.type IS NULL)'
	SET @sSQL = @sSQL +
		' AND COUNT(parentCount.childViewID) = ' + convert(varchar(100), @iParentCount)
	EXECUTE sp_executesql @sSQL,
		N'@piResult int OUTPUT',
		@piChildViewID OUTPUT
	IF @piChildViewID IS NULL
	BEGIN
		SET @piChildViewID = 0
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetHistoryMainMenu]    Script Date: 13/09/2013 08:59:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetHistoryMainMenu]
AS
BEGIN
	/* Return a recordset of information that can be used to format the History menu for the current user. 
	The recordset contains a row for each parent screen and history table in the HR Pro database. 
	The following information is given :
		parentScreenID		ID of the parent screen
		childTableID		ID of the child table
		childTableName		Name of the child table
		childTableScreenCount	Number of screens associated with the child table
		childTableScreenID	ID of the screen associated with the child table 
		childTableScreenName	Name of the screen associated with the child table
	If childTableScreenCount = 1 then the child table just requires a tool on the Database menu that calls up the given screen.
	Else, the child table requires a tool on the Database menu that calls up a sub-band of the collection of screens available for the child table. */
	DECLARE @iCurrentRoleID		integer,
		@fSysSecMgr			bit,
		@iChildTableID			integer,
		@fTableReadable		bit,
		@iTempCount			integer
	/* Get the current user's role name and ID. */
	SELECT @iCurrentRoleID = a.uid
	FROM sysusers a
	INNER JOIN sysusers b 
		ON a.uid = b.gid
	WHERE b.name = CURRENT_USER
	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iCurrentRoleID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #historyScreens
	(
		parentScreenID		integer,
		childTableID		integer,
		childTableName		sysname,
		childTableScreenCount	integer,
		childTableScreenID	integer,
		childTableScreenName	sysname
	)
	/* Create a temporary table to hold the permitted child views. This speeds things up later. */
	IF @fSysSecMgr = 0
	BEGIN
		CREATE TABLE #permittedChildViews
		(
			childViewName	sysname
		)
		INSERT INTO #permittedChildViews (childViewName)
			(SELECT sysobjects.name
				FROM syscolumns
				INNER JOIN sysprotects ON (syscolumns.id = sysprotects.id
					AND sysprotects.action = 193 
					AND sysprotects.uid = @iCurrentRoleID
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				WHERE sysobjects.name like 'ASRSysChildView_%'
					AND syscolumns.name = 'timestamp'
					AND ((sysprotects.protectType = 205) OR (sysprotects.protectType = 204)))
	END
	/* Loop through the child screen tables getting more information for each one. */
	DECLARE screensCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT childScreens.tableID
		FROM ASRSysScreens parentScreens
		INNER JOIN ASRSysHistoryScreens ON parentScreens.screenID = ASRSysHistoryScreens.parentScreenID
		INNER JOIN ASRSysScreens childScreens ON ASRSysHistoryScreens.historyScreenID = childScreens.screenID
		INNER JOIN ASRSysTables ON childScreens.tableID = ASRSysTables.tableID
		WHERE childScreens.quickEntry = 0
	OPEN screensCursor
	FETCH NEXT FROM screensCursor INTO @iChildTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		/* Determine if the current user has SELECT permission on the child table. */
		SET @fTableReadable = @fSysSecMgr
		IF @fTableReadable = 0
		BEGIN
			/* The user is not a system or security manager so read the table permissions. */
			SELECT @iTempCount = COUNT(*) 
			FROM ASRSysChildViews 
			WHERE ASRSysChildViews.tableID = @iChildTableID
				AND 'ASRSysChildView_' + convert(sysname, ASRSysChildViews.childViewID) IN (SELECT childViewName FROM #permittedChildViews)
			
			IF @iTempCount > 0 SET @fTableReadable = 1
		END
		IF @fTableReadable = 1
		BEGIN
			/* The table is readable so add it to the array of history screens. */
			SELECT @iTempCount = COUNT(*)
			FROM ASRSysScreens parentScreens
			INNER JOIN ASRSysHistoryScreens ON parentScreens.screenID = ASRSysHistoryScreens.parentScreenID
			INNER JOIN ASRSysScreens childScreens ON ASRSysHistoryScreens.historyScreenID = childScreens.screenID
			INNER JOIN ASRSysTables ON childScreens.tableID = ASRSysTables.tableID
			WHERE childScreens.tableID = @iChildTableID
				AND childScreens.quickEntry = 0
		   	 INSERT INTO #historyScreens (
				parentScreenID,
				childTableID,
				childTableName,
				childTableScreenCount,
				childTableScreenID,
				childTableScreenName)
			(SELECT parentScreens.screenID, 
				childScreens.tableID,
				ASRSysTables.tableName,
				(
					SELECT COUNT(*) 
					FROM ASRSysScreens 
					WHERE ASRSysScreens.tableID = childScreens.tableID 
						AND ASRSysScreens.quickEntry = 0
						AND ASRSysScreens.screenID IN 
							(
								SELECT historyScreenID 
								FROM ASRSysHistoryScreens 
								WHERE parentScreenID = parentScreens.screenID
							)
				),
				childScreens.screenID,
				childScreens.name
				FROM ASRSysScreens parentScreens
				INNER JOIN ASRSysHistoryScreens ON parentScreens.screenID = ASRSysHistoryScreens.parentScreenID
				INNER JOIN ASRSysScreens childScreens ON ASRSysHistoryScreens.historyScreenID = childScreens.screenID
				INNER JOIN ASRSysTables ON childScreens.tableID = ASRSysTables.tableID
				WHERE childScreens.tableID = @iChildTableID
					AND childScreens.quickEntry = 0)
		END
		FETCH NEXT FROM screensCursor INTO @IChildTableID
	END
	CLOSE screensCursor
	DEALLOCATE screensCursor
	/* Return the resultset. */
	SELECT *
	FROM #historyScreens 
	ORDER BY parentScreenID, 
		childTableName DESC,
		childTableScreenName DESC
END


GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkParentValues]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetLinkParentValues] (
	@piChildScreenID 	integer,
	@piTableID 			integer,
	@piRecordID			integer	
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of values from the given record in the given table that in the given child screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iScreenTableID 	integer,
		@iTableType			integer,
		@sTableName			varchar(255),
		@sRealSource 		varchar(1000),
		@iChildViewID 		integer,
		@sViewName 			varchar(255),
		@sSelectSQL 		varchar(MAX),
		@sFromSQL 			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sExecString		nvarchar(MAX),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sTemp				varchar(MAX),
		@sTempSPName		sysname,
		@iLoop				integer,
		@sActualUserName	sysname;

	/* Initialise variables. */
	SET @sSelectSQL = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the screen's table ID. */
	SELECT @iScreenTableID = tableID
	FROM ASRSysScreens
	WHERE screenID = @piChildScreenID

	/* Check if the current user is System or Security Manager. 
	If so we don't need to do so much work figuring out what permissions they have. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	
		/* Check if the current user is a System or Security manager. */
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	END

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sRealSource = @sTableName
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	/* Create a temporary table to hold the views that need to be joined. */
	DECLARE @joinViews TABLE(viewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(
		tableViewName	sysname,
		columnName		sysname,
		granted			bit);

	IF @fSysSecMgr = 1
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			@sRealSource,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns
		INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
		WHERE ASRSysTables.tableID = @piTableID

	END
	ELSE
	BEGIN
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piTableID)
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID 
		AND ASRSysColumns.columnID = ASRSysControls.columnID
	WHERE screenID = @piChildScreenID
	AND ASRSysControls.columnID > 0
	AND ASRSysControls.tableID = @piTableID

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @fSysSecMgr = 1 
		BEGIN
			SET @fSelectGranted = 1
		END
		ELSE
		BEGIN

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
		END

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the table. */
			IF len(@sSelectSQL) > 0 SET @sSelectSQL = @sSelectSQL + ', '
			
			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']'
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']'
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END			
		END
		ELSE	
		BEGIN
			IF @iTableType = 1 /* Top-level. */
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sSelectString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableViewName <> @sRealSource
					AND columnName = @sColumnName
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1 

					IF len(@sSelectString) = 0 SET @sSelectString = 'CASE'
	
					IF @iColumnDataType = 11 /* Date */
					BEGIN
						 /* Date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)'
					END
					ELSE
					BEGIN
						 /* Non-date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
					END

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(viewName)
					FROM @joinViews
					WHERE viewName = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinViews (viewName) VALUES(@sViewName)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSelectString) > 0
				BEGIN
					SET @sSelectString = @sSelectString +
						' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']'
					IF LEN(@sSelectSQL) > 0 SET @sSelectSQL = @sSelectSQL + ', '
					SET @sSelectSQL = @sSelectSQL + @sSelectString		
				END
			END

		END

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor

	/* Add the id column to the select string. */
	SELECT @iColumnID = columnID
		FROM ASRSysColumns
		WHERE columnName = 'ID_' + convert(varchar(255), @piTableID)
		AND tableID = @iScreenTableID

	SET @sTemp = 	CASE
			WHEN LEN(@sSelectSQL) > 0 THEN ', '
			ELSE ''
		END + 
		@sRealSource + '.ID AS [' + convert(varchar(100), @iColumnID) + ']'

	SET @sSelectSQL = @sSelectSQL + @sTemp


	/* Create the FROM code. */
	SET @sFromSQL = @sRealSource;
	SELECT @sFromSQL = @sFromSQL
		+ ' LEFT OUTER JOIN ' + ViewName + ' ON ' + @sRealSource
		+ '.ID = ' + ViewName + '.ID'
	FROM @joinViews;


	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF LEN(@sSelectSQL) > 0 
	BEGIN

		/* Create the temp stored procedure name. */
		SET @sTempSPName = ''
		SET @iLoop = 1
		WHILE len(@sTempSPName) = 0
		BEGIN
			SET @sTemp = 'tmpsp_ASRIntGetLinkParentValues' + convert(varchar(100), @iLoop)

			SELECT @iTempCount = COUNT(*)
			FROM sysobjects
			WHERE name = @sTemp

			IF @iTempCount = 0
			BEGIN
				SET @sTempSPName = @sTemp
			END
			ELSE
			BEGIN
				SET @iLoop = @iLoop + 1
			END
		END

		SET @sTemp = convert(varchar(255), @piRecordID)
	
		SET @sExecString = 'CREATE PROCEDURE ' + @sTempSPName + ' AS' +
			' BEGIN' +
			' SELECT ' + @sSelectSQL + 
			' FROM ' + @sFromSQL + 
			' WHERE ' + @sRealSource + '.ID = ' + @sTemp +
			' END'

		-- Create the temporary stored procedure
		EXECUTE sp_executeSQL @sExecString;

		-- Execute the temporary stored procedure
		EXECUTE sp_executeSQL @sTempSPName;

		SET @sExecString = 'DROP PROCEDURE ' + @sTempSPName
		exec sp_executeSQL @sExecString;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLinkViews]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetLinkViews]
(
	@plngTableID 		integer,
	@plngDfltOrderID 	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the views of the given table for use in the link find page. */
	DECLARE @sTableName 	varchar(255),
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iChildViewID 		integer,
		@iTableType			integer,
		@lngPermissionCount	integer,
		@sActualUserName	sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table-type. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iTableType = ASRSysTables.tableType,
		@plngDfltOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @plngTableID;

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	

		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @viewInfo TABLE(
		viewID		integer,
		viewName	sysname,
		orderTag	integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1)
	BEGIN
		/* Populate the temporary table. */
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		VALUES (
			0,
			@sTableName,
			0);
		
   		INSERT INTO @viewInfo (
			viewID, 
			viewName,
			orderTag)
		(SELECT viewID, 
			viewName,
			1
		FROM [dbo].[ASRSysViews]
		WHERE viewTableID = @plngTableID);
		
	END
	ELSE
	BEGIN
		IF @iTableType <> 2
		BEGIN
			/* Table is a top-level or lookup table. */
			SELECT @lngPermissionCount = COUNT(*)
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protectType <> 206
				AND syscolumns.name <> 'timestamp'
				AND syscolumns.name <> 'ID'
				AND sysobjects.name = @sTableName
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

			IF @lngPermissionCount > 0 
			BEGIN
				INSERT INTO @viewInfo (
					viewID, 
					viewName,
					orderTag)
				VALUES (
					0,
					@sTableName,
					0);
			END

			/* Now check on the views on this table. */
			INSERT INTO @viewInfo (
				viewID, 
				viewName,
				orderTag)
			(SELECT ASRSysViews.viewID, 
				ASRSysViews.viewName, 
				1
			FROM [dbo].[ASRSysViews]
			INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
			INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
			WHERE ASRSysViews.viewTableID = @plngTableID
				AND sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193
				AND sysprotects.protecttype <> 206);
		END
		ELSE
		BEGIN
			/* Get appropriate child view if required. */
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @plngTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				INSERT INTO @viewInfo (
					viewID, 
					viewName,
					orderTag)
				VALUES (
					0,
					@sTableName,
					0);
			END

		END
	END

	/* Return the resultset. */
	SELECT viewID, viewName
		FROM @viewInfo
		ORDER BY orderTag, viewName;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetLookupValues]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetLookupValues] (
	@piColumnID 	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the lookup values for the given lookup column. */
	DECLARE	@sColumnName	sysname,
			@sTableName		sysname,
			@sExecString	nvarchar(MAX);

	SELECT @sTableName = ASRSysTables.tableName,
		@sColumnName = ASRSysColumns.columnName
	FROM ASRSysColumns
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE columnID = @piColumnID;

	SET @sExecString = 'SELECT ' + @sColumnName + 
		' FROM ' + @sTableName +
		' ORDER BY ' + @sColumnName;

	/* Return a recordset of the required columns in the required order from the given table/view. */
	EXECUTE sp_executeSQL @sExecString;
	
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetModuleParameter]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetModuleParameter]
(
	@psModuleKey 		varchar(255), 
	@psParameterKey 	varchar(255),
	@psParameter		varchar(1000) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT @psParameter = parameterValue 
	FROM [dbo].[ASRSysModuleSetup]
	WHERE moduleKey = @psModuleKey 
		AND parameterKey = @psParameterKey;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetOrders]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetOrders] (@plngTableID int, @plngViewID int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the orders available for the given table/view. */
	DECLARE @lngTableID		int,
		@lngDefaultOrderID	int

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @plngViewID
	END

	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #orderInfo
	(
		orderID			int,
		orderName		sysname,
		defaultOrder		bit
	)

	/* Populate the temporary table with information on the order for the given table. */
   	 INSERT INTO #orderInfo (
		orderID, 
		orderName,
		defaultOrder)	
	(SELECT ASRSysOrders.orderID, 
		ASRSysOrders.name,
		0
	FROM ASRSysOrders
	WHERE ASRSysOrders.tableID = @lngTableID)

	/* Get the table's default order. */
	SELECT @lngDefaultOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @lngTableID

	IF @lngDefaultOrderID > 0 
	BEGIN
		UPDATE #orderInfo
		SET defaultOrder = 1 
		WHERE orderID = @lngDefaultOrderID
	END

	/* Return the resultset. */
	SELECT *
	FROM #orderInfo 
	ORDER BY orderName
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPersonnelParameters]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetPersonnelParameters] (
	@piEmployeeTableID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @fOK			bit,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sActualUserName	sysname;

	/* Personnel information. */
	SET @fOK = 1;
	SET @piEmployeeTableID = 0;

	/* Get the current user's group id. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'PERSONNEL', @fOK OUTPUT;

	/* Get the required training booking module paramaters. */
	IF @fOK = 1
	BEGIN
		/* Get the EMPLOYEE table information. */
		SELECT @piEmployeeTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_PERSONNEL'
			AND parameterKey = 'Param_TablePersonnel';
		IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPicklistDefinition]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetPicklistDefinition] (
	@piPicklistID 			integer, 
	@psAction				varchar(255),
	@psErrorMsg				varchar(MAX)	OUTPUT,
	@psPicklistName			varchar(255)	OUTPUT,
	@psPicklistOwner		varchar(255)	OUTPUT,
	@psPicklistDesc			varchar(MAX)	OUTPUT,
	@psAccess				varchar(255)	OUTPUT,
 	@piTimestamp			integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount		integer,
		@sCurrentUser	sysname,
		@fSysSecMgr		bit;

	SET @psErrorMsg = '';
	SET @sCurrentUser = SYSTEM_USER;

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
	/* Check the picklist exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysPicklistName 
	WHERE picklistID = @piPicklistID

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'picklist has been deleted by another user.'
		RETURN
	END

	SELECT @psPicklistName = name,
		@psPicklistOwner = userName,
		@psPicklistDesc = description,
		@psAccess = access,
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysPicklistName 
	WHERE picklistID = @piPicklistID

	/* Check the current user can view the report. */
	IF (@psAccess = 'HD') AND (@psPicklistOwner <> @sCurrentUser) AND (@fSysSecMgr = 0)
	BEGIN
		SET @psErrorMsg = 'picklist has been made hidden by another user.'
		RETURN
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@psAccess = 'RO') AND (@psPicklistOwner <> @sCurrentUser)  AND (@fSysSecMgr = 0)
	BEGIN
		SET @psErrorMsg = 'picklist has been made read only by another user.'
		RETURN
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psPicklistName = left('copy of ' + @psPicklistName, 50)
		SET @psPicklistOwner = @sCurrentUser
	END

	/* Get the picklist records. */
	SELECT recordID
	FROM ASRSysPickListItems
	WHERE pickListID = @piPicklistID
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPrimaryTableMenu]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetPrimaryTableMenu] 
AS
BEGIN
	/* Return a recordset of information that can be used to format the main Database menu for the current user. 
	The recordset contains a row for each primary table in the HR Pro database. 
	For each primary table the following information is given :
		tableID			ID of the primary table
		tableName		Name of the primary table
		tableScreenCount	Number of screens associated with the primary table
		tableScreenID		If the current user has SELECT permission on the primary table, and the primary table has only one screen associated with it, 
					and (the current user does not have SELECT permission on any views on the primary table, or there are no screens associated with the view)
					then the ID of the one screen associated with the primary table is returned
		tableReadable		True if the current user has SELECT permission on the primary table
		tableViewCount		Number of views on the primary table that the current user has SELECT permission on
		viewID			If (the current user does not have SELECT permission on the primary table, or the primary table has no screens associated with it), 
					and (the current user has SELECT permission on only one view on the primary table, and there are is only one screen associated with the view)
					then the ID of the view is returned
		viewName		If (the current user does not have SELECT permission on the primary table, or the primary table has no screens associated with it), 
					and (the current user has SELECT permission on only one view on the primary table, and there are is only one screen associated with the view)
					then the name of the view is returned
		viewScreenCount	Number of screens associated with the views
		viewScreenID		If (the current user does not have SELECT permission on the primary table, or the primary table has no screens associated with it), 
					and (the current user has SELECT permission on only one view on the primary table, and there are is only one screen associated with the view)
					then the name of the screen associated with the view is returned
	If the recordset for a primary table has a non-zero value in the tableScreenID field then the table just requires a tool on the Database menu that calls up the given screen.
	Else, if the recordset for a primary table has a non-zero value in the viewID field then the table just requires a tool on the Database menu that calls up the given screen for the permitted view.
	Else, if the recordset for a primary table has a non-zero value in the viewScreenCount field OR (the tableReadable value is 1 AND the tableScreenCount is greater than 1) then 
		the table requires a tool on the Database menu that calls up a sub-band of the collection of views/screens available for the primary table.
	Else, the primary table should not appear on the menu. */
	DECLARE @sCurrentRole		sysname,
		@lngCurrentRoleID		int,
		@lngTableID			int,
		@sTableName			sysname,
		@lngTableScreenCount		int,
		@lngTableScreenID		int,
		@fTableReadable		bit,
		@lngTableViewCount		int,
		@lngViewID			int,
		@sViewName			sysname,
		@lngViewScreenCount		int,
		@lngViewScreenID		int,
		@lngTotalViewScreenCount	int,
		@lngPermissionCount		int
	
	/* Get the current user's role name and ID. */
	SELECT @sCurrentRole =  a.name,
		@lngCurrentRoleID = a.uid
	FROM sysusers a
	INNER JOIN sysusers b 
		ON a.uid = b.gid
	WHERE b.name = SYSTEM_USER
	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #primaryTableInfo
	(
		tableID			int,
		tableName		sysname,
		tableScreenCount	int,
		tableScreenID		int,
		tableReadable		bit,
		tableViewCount		int,
		viewID			int,
		viewName		sysname,
		viewScreenCount	int,
		viewScreenID		int		
	)
	/* Populate the temporary table with information on the primary tables. */
   	 INSERT INTO #primaryTableInfo (
		tableID, 
		tableName,
		tableScreenCount,
		tableScreenID,
		tableReadable,
		tableViewCount,
		viewID,
		viewName,
		viewScreenCount,
		viewScreenID)	
	(SELECT 
		ASRSysTables.tableID, 
		ASRSysTables.tableName,
		COUNT(DISTINCT ASRSysScreens.name),
		0,
		0,
		0,
		0,
		'',
		0,
		0 
	FROM ASRSysTables
	INNER JOIN ASRSysScreens 
		ON ASRSysTables.tableID = ASRSysScreens.tableID 
	GROUP BY ASRSysTables.tableID, 
		ASRSysTables.tableName,
		ASRSysTables.tableType
	HAVING ASRSysTables.tableType = 1)
	/* Loop through the tables getting more information for each one. */
	DECLARE primaryTables_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT #primaryTableInfo.tableID, 
			#primaryTableInfo.tableName,
			#primaryTableInfo.tableScreenCount
		FROM #primaryTableInfo
	OPEN primaryTables_cursor
	FETCH NEXT FROM primaryTables_cursor INTO @lngTableID, @sTableName, @lngTableScreenCount
	WHILE (@@fetch_status = 0)
	BEGIN
		/* Determine if the current user has SELECT permission on the table. */
		SELECT @lngPermissionCount = COUNT(*)
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		WHERE sysprotects.uid = @lngCurrentRoleID
			AND sysprotects.action = 193
			AND sysprotects.protectType <> 206
			AND syscolumns.name <> 'timestamp'
			AND syscolumns.name <> 'ID'
			AND sysobjects.name = @sTableName
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		IF @lngPermissionCount > 0
		BEGIN
			/* Update the temporary table of primary table information with a flag showing if the current
			user has SELECT permission on the table. */
			UPDATE #primaryTableInfo
			SET tableReadable = 1
			WHERE tableID = @lngTableID 
			SET @fTableReadable = 1
		END
		ELSE
		BEGIN
			SET @fTableReadable = 0
		END
		/* Get a cursor of the views on the table that the current user has SELECT permission on. */		
		SET @lngTableViewCount = 0
		SET @lngTotalViewScreenCount = 0
		DECLARE tablesViews_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysViews.viewName, 
				COUNT(ASRSysViewScreens.screenID)
			FROM ASRSysViews
			INNER JOIN sysobjects 
				ON ASRSysViews.viewName = sysobjects.name
			INNER JOIN sysprotects 
				ON sysobjects.id = sysprotects.id  
			LEFT OUTER JOIN ASRSysViewScreens 
				ON ASRSysViews.viewID = ASRSysViewScreens.viewID
			GROUP BY ASRSysViews.viewName, 
				ASRSysViews.viewTableID, 
				sysprotects.uid, 
				sysprotects.action, 
				sysprotects.protecttype
			HAVING ASRSysViews.viewTableID = @lngTableID
				AND sysprotects.uid = @lngCurrentRoleID
				AND sysprotects.action = 193
				AND sysprotects.protecttype = 205
		OPEN tablesViews_cursor
		FETCH NEXT FROM tablesViews_cursor INTO @sViewName, @lngViewScreenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			/* Total the number of views that the user has SELECT permission on, and that have screens associated with them, 
			and total the number of screens associated with the selectable views. */
			IF @lngViewScreenCount > 0 
			BEGIN
				SET @lngTableViewCount = @lngTableViewCount + 1
				SET @lngTotalViewScreenCount = @lngTotalViewScreenCount + @lngViewScreenCount
			END
			
			FETCH NEXT FROM tablesViews_cursor INTO @sViewName, @lngViewScreenCount
		END
		CLOSE tablesViews_cursor
		DEALLOCATE tablesViews_cursor
		/* Update the temporary table of primary table information with the number views that the current user 
		has SELECT permission on. */
		UPDATE #primaryTableInfo
		SET tableViewCount = @lngTableViewCount
		WHERE tableID = @lngTableID 
		/* JPD 23/7/01 */
		IF @lngTableViewCount > 1 
		BEGIN
			UPDATE #primaryTableInfo
			SET viewScreenCount = @lngTotalViewScreenCount
			WHERE tableID = @lngTableID 
		END
		IF @lngTableViewCount = 1 
		BEGIN
			UPDATE #primaryTableInfo
			SET viewScreenCount = @lngTotalViewScreenCount
			WHERE tableID = @lngTableID 
			/* Get the viewID, viewName, viewScreenID if required. */
			IF (@lngTotalViewScreenCount = 1) AND (@fTableReadable = 0 OR @lngTableScreenCount = 0)
			BEGIN
				SELECT @lngViewID = ASRSysViews.viewID,
					@sViewName = ASRSysViews.viewName,
					@lngViewScreenID = ASRSysViewScreens.screenID
				FROM ASRSysViews
				INNER JOIN ASRSysViewScreens
					ON ASRSysViews.viewID = ASRSysViewScreens.viewID
				INNER JOIN sysobjects 
					ON ASRSysViews.viewname = sysobjects.name
				INNER JOIN sysprotects 
					ON sysobjects.id = sysprotects.id
				WHERE ASRSysViews.viewTableID = @lngTableID
					AND sysprotects.action = 193
					AND sysprotects.protecttype = 205
					AND sysprotects.uid = @lngCurrentRoleID
				/* Update the temporary table of primary table information with the view ID, name and associated screen ID. */
				UPDATE #primaryTableInfo
				SET viewID = @lngViewID,
					viewName = @sViewName,
					viewScreenID = @lngViewScreenID
				WHERE tableID = @lngTableID 
			END
		END
		/* Get the table's screenID if the user has SELECT permission on the table, the table has only one screen, and their are no views on the table. */
		IF (@lngTableScreenCount = 1) AND (@lngTotalViewScreenCount = 0) AND (@fTableReadable = 1)
		BEGIN
			SELECT @lngTableScreenID = ASRSysScreens.screenID
			FROM ASRSysScreens
			WHERE ASRSysScreens.tableID = @lngTableID
			/* Update the temporary table of primary table information with the table's associated screen ID. */
			UPDATE #primaryTableInfo
			SET tableScreenID = @lngTableScreenID
			WHERE tableID = @lngTableID 
		END
		FETCH NEXT FROM primaryTables_cursor INTO @lngTableID, @sTableName, @lngTableScreenCount
	END
	CLOSE primaryTables_cursor
	DEALLOCATE primaryTables_cursor
	/* Return the resultset. */
	SELECT *
	FROM #primaryTableInfo 
	ORDER BY tableName DESC
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetPrimaryTableSubMenu]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetPrimaryTableSubMenu] (@plngPrimaryTableID integer)
AS
BEGIN
	/* Return a recordset of information that can be used to format the given table's sub-menu on the Database menu for the current user. 
	The recordset contains a row for each screen and view screen. 
	For each primary table the following information is given :
	screenID		ID of the screen
	screenName		Name of the screen
	viewID			ID of the view
	viewName		Name of the view
	*/
	DECLARE @lngCurrentRoleID		integer,
		@fSysSecMgr			bit,
		@lngPermissionCount		integer
	/* Get the current user's role ID. */
	SELECT @lngCurrentRoleID = sysusers.gid
	FROM sysusers
	WHERE sysusers.name = CURRENT_USER
	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @lngCurrentRoleID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS'
	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #primaryTableInfo
	(
		screenID		int,
		screenName		varchar(255),
		viewID			int,
		viewName		sysname
	)
	IF @fSysSecMgr = 1 
	BEGIN
		SET @lngPermissionCount = 1
	END
	ELSE
	BEGIN
		/* Determine if the current user has SELECT permission on the given table,
		and which views the user has permission to see. */
		SELECT @lngPermissionCount = COUNT(*)
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		WHERE sysprotects.uid = @lngCurrentRoleID
			AND sysprotects.action = 193
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @plngPrimaryTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		AND sysprotects.protectType <> 206
		AND syscolumns.name <> 'ID'
	END
	IF @lngPermissionCount > 0
	BEGIN
		/* The current user does have SELECT permission on the given table, so populate the temporary 
		table with records for each screen associated with the primary table. */
		INSERT INTO #primaryTableInfo (
			screenID,
			screenName,
			viewID,
			viewName)	
		(SELECT 
			ASRSysScreens.screenID, 
			ASRSysScreens.name,
			0,
			''
		FROM ASRSysScreens
		WHERE ASRSysScreens.tableID = @plngPrimaryTableID)
	END
	/* Populate the temporary table with records for each screen for each permitted view on the primary table. */
	INSERT INTO #primaryTableInfo (
		screenID,
		screenName,
		viewID,
		viewName)	
	(SELECT 
		ASRSysViewScreens.screenID,
		ASRSysScreens.name,
		ASRSysViews.viewID,
		ASRSysViews.viewName
	FROM ASRSysViews
	INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
	INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
	INNER JOIN ASRSysViewScreens ON ASRSysViews.viewID = ASRSysViewScreens.viewID
	INNER JOIN ASRSysScreens ON ASRSysViewScreens.screenID = ASRSysScreens.screenID
	WHERE ASRSysViews.viewTableID = @plngPrimaryTableID
		AND sysprotects.uid = @lngCurrentRoleID
		AND sysprotects.action = 193
		AND sysprotects.protecttype = 205)
	/* Return the resultset. */
	SELECT *
	FROM #primaryTableInfo 
	ORDER BY screenName DESC,
		viewName DESC
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetQuickEntryMenu]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetQuickEntryMenu] 
AS
BEGIN
	/* Return a recordset of information that can be used to format the Quick Entry menu for the current user. 
	The recordset contains a row for each quick entry in the HR Pro database. 
	For each quick entry screen the following information is given :
		screenID		ID of the quick entry screen
		name			Name of the quick entry screen
		tableID			ID of the table associated with the quick entry screen
	*/
	DECLARE @lngCurrentRoleID	int,
		@lngScreenID		int,
		@sScreenName		varchar(8000),
		@lngTableID		int,
		@sSource		varchar(8000),
		@lngChildViewID	int,
		@lngCount		int
	/* Get the current user's role name and ID. */
	SELECT @lngCurrentRoleID = a.uid
	FROM sysusers a
	INNER JOIN sysusers b 
		ON a.uid = b.gid
	WHERE b.name = CURRENT_USER
	/* Create a temporary table to hold our resultset. */
	CREATE TABLE #quickAccessInfo
	(
		screenID	int,
		name		varchar(8000),
		tableID		int		
	)
	/* Get the permitted tables. */
	DECLARE permittedTables_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT sysobjects.name
		FROM syscolumns
		INNER JOIN sysprotects ON (syscolumns.id = sysprotects.id
			AND sysprotects.action = 193 
			AND sysprotects.uid = @lngCurrentRoleID
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		WHERE syscolumns.name = 'timestamp'
			AND ((sysprotects.protectType = 205) 
			OR (sysprotects.protectType = 204))
	OPEN permittedTables_cursor
	FETCH NEXT FROM permittedTables_cursor INTO @sSource
	WHILE (@@fetch_status = 0)
	BEGIN
		/* Determine if the permitted table has a quick access screen associated with it. */
		IF left(@sSource, 16) = 'ASRSysChildView_'
		BEGIN
			/* The source is a child view so get the associated table. */
			SET @lngChildViewID = convert(int, substring(@sSource, 17, len(@sSource) - 16))
			SELECT @lngTableID = ASRSysChildViews.tableID
			FROM ASRSysChildViews 
			WHERE childViewID = @lngChildViewID
		END
		ELSE
		BEGIN
			SELECT @lngTableID = ASRSysTables.tableID
			FROM ASRSysTables 
			WHERE tableName = @sSource
		END
		IF NOT @lngTableID IS NULL
		BEGIN
			SELECT @lngCount = COUNT(*) 
			FROM #quickAccessInfo
			WHERE tableID = @lngTableID
			IF @lngCount = 0
			BEGIN
				INSERT INTO #quickAccessInfo	(screenID, name, tableID)
					SELECT ASRSysScreens.screenID, 
						ASRSysScreens.name, 
						ASRSysScreens.tableID
					FROM ASRSysScreens
					WHERE ASRSysScreens.quickEntry = 1
					AND ASRSysScreens.tableID = @lngTableID
			END			
		END
		FETCH NEXT FROM permittedTables_cursor INTO @sSource
	END
	CLOSE permittedTables_cursor
	DEALLOCATE permittedTables_cursor
	SELECT *
	FROM #quickAccessInfo
	ORDER BY name DESC
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordDescription]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetRecordDescription] (
	@piTableID 			integer,
	@piRecordID			integer,
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psRecDesc			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the record descriptiuon for the given record, screen, view. */
	DECLARE	@iRecordID			integer,
			@iRecDescID			integer,
			@sEvalRecDesc		varchar(8000),
			@sExecString		nvarchar(MAX),
			@sParamDefinition	nvarchar(500);

	SET @psRecDesc = '';

	/* Return the parent record description if we have a parent record. */
	IF (@piParentTableID > 0) AND  (@piParentRecordID > 0)
	BEGIN
		SET @iRecordID = @piParentRecordID;

		/* Get the parent table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		SET @iRecordID = @piRecordID;
 
		/* Get the table's record description ID. */
		SELECT @iRecDescID =  ASRSysTables.RecordDescExprID
		FROM  [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piTableID;
	END

	/* Get the record description. */
	IF (NOT @iRecDescID IS null) AND (@iRecDescID > 0) AND (@iRecordID > 0)
	BEGIN
		SET @sExecString = 'exec sp_ASRExpr_' + convert(nvarchar(255), @iRecDescID) + ' @recDesc OUTPUT, @recID';
		SET @sParamDefinition = N'@recDesc varchar(MAX) OUTPUT, @recID integer';
		EXEC sp_executesql @sExecString, @sParamDefinition, @sEvalRecDesc OUTPUT, @iRecordID;

		IF (NOT @sEvalRecDesc IS null) AND (LEN(@sEvalRecDesc) > 0) SET @psRecDesc = @sEvalRecDesc;
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetRecordEditInfo]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetRecordEditInfo] (
	@psTitle 		varchar(500) 	OUTPUT, 
	@pfQuickEntry	bit				OUTPUT, 
	@piScreenID 	integer, 
	@piViewID 		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the OUTPUT variable @psTitle with the Record Edit window title for the given screen/view . 
	    The title is in the format <screen name>[ - <view name> view)]	*/
	DECLARE @sScreenName	sysname,
			@sViewName		sysname;
	
	/* The title always starts with the screen name. */
	SELECT @psTitle = ASRSysScreens.name,
		@pfQuickEntry = ASRSysScreens.quickEntry
	FROM ASRSysScreens
	WHERE ASRSysScreens.screenID = @piScreenID;

	IF @psTitle IS NULL 
	BEGIN
		SET @psTitle = '<unknown screen>';
	END
	IF @pfQuickEntry IS NULL 
	BEGIN
		SET @pfQuickEntry = 0;
	END

	IF @piViewID > 0
	BEGIN
		/* Find title is the table name with the view name in brackets. */
		SELECT @sViewName = ASRSysViews.viewName
		FROM ASRSysViews
		WHERE ASRSysViews.viewID = @piViewID;

		IF (@sViewName IS NULL) 
		BEGIN
			SET @psTitle = @psTitle + ' (<unknown view>)';
		END
		ELSE
		BEGIN
			SET @psTitle = @psTitle + ' (' + @sViewName + ' view)';
		END
	END
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlAndLookupValuesString]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControlAndLookupValuesString] (
	@piScreenID 	integer)
AS
BEGIN
	/* Return a recordset of the column control and lookup column values in the given screen. */
	DECLARE @iColumnID			integer,
		@sValue			varchar(8000),
		@iLastColumnID			integer,
		@sDefinition			varchar(8000),
		@sLookupTableName		sysname,
		@sLookupColumnName		sysname,
		@iLookupColumnDataType	integer,
		@sCommand			nvarchar(4000),
		@sParamDefinition 		nvarchar(4000),
		@sDefString			varchar(8000)
	CREATE TABLE #valuesInfo
	(
		valueDefinition		varchar(8000)
	)
	SET @iLastColumnID = 0
	SET @sDefinition = ''
	/* Insert definition strings for the column control values into the temporary table. */
	DECLARE values_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.value
		FROM ASRSysColumnControlValues
		INNER JOIN ASRSysColumns ON ASRSysColumnControlValues.columnID = ASRSysColumns.columnID
		INNER JOIN ASRSysScreens ON ASRSysColumns.tableID = ASRSysScreens.tableID
		WHERE ASRSysScreens.screenID = @piScreenID
		ORDER BY ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.sequence
	OPEN values_cursor
	FETCH NEXT FROM values_cursor INTO @iColumnID, @sValue
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iLastColumnID <> @iColumnID
		BEGIN
			IF @iLastColumnID <> 0
			BEGIN
				INSERT INTO #valuesInfo (valueDefinition) VALUES(@sDefinition)
			END
			SET @sDefinition = convert(varchar(8000), @iColumnID) + char(9) + case when @sValue IS null then '' else @sValue end
		END
		ELSE
		BEGIN
			SET @sDefinition = @sDefinition + char(9) + case when @sValue IS null then '' else @sValue end
		END
		SET @iLastColumnID = @iColumnID
		FETCH NEXT FROM values_cursor INTO @iColumnID, @sValue
	END
	CLOSE values_cursor
	DEALLOCATE values_cursor
	/* Do the last row. */
	IF @iLastColumnID <> 0
	BEGIN
		INSERT INTO #valuesInfo (valueDefinition) VALUES(@sDefinition)
	END
	/* Insert definition strings for the lookup column values into the temporary table. */
	DECLARE lookupColumnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnID, 
		lookupTables.tableName,
		lookupColumns.columnName,
		lookupColumns.dataType
	FROM ASRSysColumns 
	INNER JOIN ASRSysScreens ON ASRSysColumns.tableID = ASRSysScreens.tableID
	INNER JOIN ASRSysColumns lookupColumns ON ASRSysColumns.lookupColumnID = lookupColumns.columnID
	INNER JOIN ASRSysTables lookupTables ON ASRSysColumns.lookupTableID = lookupTables.tableID
	WHERE ASRSysScreens.screenID = @piScreenID
		AND ASRSysColumns.columnType = 1
	OPEN lookupColumnsCursor
	FETCH NEXT FROM lookupColumnsCursor INTO @iColumnID, @sLookupTableName, @sLookupColumnName, @iLookupColumnDataType
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sCommand = 'DECLARE @sValue	varchar(8000)' +
			' SET @defString = ''''' +
			' DECLARE values_cursor CURSOR LOCAL FAST_FORWARD FOR' +
			' 	SELECT DISTINCT convert(varchar(8000), ' + @sLookupColumnName + case when @iLookupColumnDataType = 11 then ', 101' else '' end + ')' +
			' 	FROM ' + @sLookupTableName +
			' 	ORDER BY convert(varchar(8000),' + @sLookupColumnName + case when @iLookupColumnDataType = 11 then ', 101' else '' end + ')' +
			' OPEN values_cursor' +
			' FETCH NEXT FROM values_cursor INTO @sValue' +
			' WHILE (@@fetch_status = 0)' +
			' BEGIN' +
			' 	IF len(@defString) > 0' +
			' 	BEGIN ' +
			'		SET @defString = @defString + char(9)' +
			' 	END' +
			' 	SET @defString = @defString + case when @sValue IS null then '''' else @sValue end' +
			'	FETCH NEXT FROM values_cursor INTO @sValue' +
			' END' +
			' CLOSE values_cursor' +
			' DEALLOCATE values_cursor'
		SET @sParamDefinition = N'@defString varchar(8000) OUTPUT'
		EXEC sp_executesql @sCommand,  @sParamDefinition, @sDefString OUTPUT
		IF len(@sDefString) > 0 
		BEGIN
			SET @sDefString = convert(varchar(8000), @iColumnID) + char(9) + @sDefString
			INSERT INTO #valuesInfo (valueDefinition) VALUES(@sDefString)
		END
		FETCH NEXT FROM lookupColumnsCursor INTO @iColumnID, @sLookupTableName, @sLookupColumnName, @iLookupColumnDataType
	END
	CLOSE lookupColumnsCursor
	DEALLOCATE lookupColumnsCursor
	/* Return the definition strings. */
	SELECT *
	FROM #valuesInfo
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControls]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControls] (
	@plngScreenID 	int,
	@plngViewId	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the controls in the given screen. */
	SELECT tableID, columnID, controlType,
		topCoord, leftCoord, height, width,	caption
	FROM [dbo].[ASRSysControls]
	WHERE screenID = @plngScreenID;
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlsString]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControlsString] (
	@plngScreenID 	int)
AS
BEGIN
	/* Return a recordset of the controls in the given screen. */
	SELECT 
		convert(varchar(8000), case when ASRSysControls.pageNo IS null then '' else ASRSysControls.pageNo end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.tableID IS null then '' else ASRSysControls.tableID end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.columnID IS null then '' else ASRSysControls.columnID end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.controlType IS null then '' else ASRSysControls.controlType end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.topCoord IS null then '' else ASRSysControls.topCoord end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.leftCoord IS null then '' else ASRSysControls.leftCoord end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.height IS null then '' else ASRSysControls.height end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.width IS null then '' else ASRSysControls.width end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.caption IS null then '' else ASRSysControls.caption end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.backColor IS null then '' else ASRSysControls.backColor end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.foreColor IS null then '' else ASRSysControls.foreColor end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontName IS null then '' else ASRSysControls.fontName end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontSize IS null then '' else ASRSysControls.fontSize end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontBold IS null then '' else ASRSysControls.fontBold end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontItalic IS null then '' else ASRSysControls.fontItalic end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontStrikethru IS null then '' else ASRSysControls.fontStrikethru end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.fontUnderline IS null then '' else ASRSysControls.fontUnderline end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.displayType IS null then '' else ASRSysControls.displayType end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.tabIndex IS null then '' else ASRSysControls.tabIndex end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.borderStyle IS null then '' else ASRSysControls.borderStyle end) + char(9) +
		convert(varchar(8000), case when ASRSysControls.alignment IS null then '' else ASRSysControls.alignment end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.columnName IS null then '' else ASRSysColumns.columnName end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.columnType IS null then '' else ASRSysColumns.columnType end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.datatype IS null then '' else ASRSysColumns.datatype end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.defaultValue IS null then '' else ASRSysColumns.defaultValue end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.size IS null then '' else ASRSysColumns.size end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.decimals IS null then '' else ASRSysColumns.decimals end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.lookupTableID IS null then '' else ASRSysColumns.lookupTableID end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.lookupColumnID IS null then '' else ASRSysColumns.lookupColumnID end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.spinnerMinimum IS null then '' else ASRSysColumns.spinnerMinimum end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.spinnerMaximum IS null then '' else ASRSysColumns.spinnerMaximum end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.spinnerIncrement IS null then '' else ASRSysColumns.spinnerIncrement end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.mandatory IS null then '' else ASRSysColumns.mandatory end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.uniquechecktype IS null then '' when ASRSysColumns.uniquechecktype <> 0 then 1 else 0 end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.convertcase IS null then '' else ASRSysColumns.convertcase end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.mask IS null then '' else rtrim(ASRSysColumns.mask) end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.blankIfZero IS null then '' else ASRSysColumns.blankIfZero end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.multiline IS null then '' else ASRSysColumns.multiline end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.alignment IS null then '' else ASRSysColumns.alignment end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.dfltValueExprID IS null then '' else ASRSysColumns.dfltValueExprID end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.readOnly IS null then '' else ASRSysColumns.readOnly end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.statusBarMessage IS null then '' else ASRSysColumns.statusBarMessage end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.linkTableID IS null then '' else ASRSysColumns.linkTableID end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.linkOrderID IS null then '' else ASRSysColumns.linkOrderID end) + char(9) +
		convert(varchar(8000), case when ASRSysColumns.Afdenabled IS null then '' else ASRSysColumns.Afdenabled end) + char(9) +
		convert(varchar(8000), case when ASRSysTables.TableName IS null then '' else ASRSysTables.TableName end)
		AS controlDefinition
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnID = ASRSysControls.columnID
	WHERE screenID = @plngScreenID
	ORDER BY ASRSysControls.pageNo, 
		ASRSysControls.controlLevel DESC, 
		ASRSysControls.tabIndex
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenControlValuesString]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControlValuesString] (
	@plngScreenID 	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the column control values in the given screen. */
	DECLARE @lngColumnID	integer,
		@sValue				varchar(MAX),
		@lngLastColumnID	integer,
		@sDefinition		varchar(MAX);

	DECLARE @valuesInfo TABLE (valueDefinition varchar(MAX));

	SET @lngLastColumnID = 0;
	SET @sDefinition = '';

	DECLARE values_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.value
		FROM ASRSysColumnControlValues
		WHERE ASRSysColumnControlValues.columnID IN (
			SELECT ASRSysControls.columnID
			FROM ASRSysControls
			WHERE ASRSysControls.screenID = @plngScreenID)
		ORDER BY ASRSysColumnControlValues.columnID, ASRSysColumnControlValues.sequence;
				
	OPEN values_cursor;
	FETCH NEXT FROM values_cursor INTO @lngColumnID, @sValue;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @lngLastColumnID <> @lngColumnID
		BEGIN
			IF @lngLastColumnID <> 0
			BEGIN
				INSERT INTO @valuesInfo (valueDefinition) VALUES(@sDefinition);
			END

			SET @sDefinition = convert(varchar(MAX), @lngColumnID) + char(9) + case when @sValue IS null then '' else @sValue end;
		END
		ELSE
		BEGIN
			SET @sDefinition = @sDefinition + char(9) + case when @sValue IS null then '' else @sValue end;
		END

		SET @lngLastColumnID = @lngColumnID;
		FETCH NEXT FROM values_cursor INTO @lngColumnID, @sValue;
	END
	
	CLOSE values_cursor;
	DEALLOCATE values_cursor;

	/* Do the last row. */
	IF @lngLastColumnID <> 0
	BEGIN
		INSERT INTO @valuesInfo (valueDefinition) VALUES(@sDefinition);
	END

	SELECT * FROM @valuesInfo;
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenOrder]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenOrder] (
	@plngOrderID 	int OUTPUT, 
	@plngScreenID	int)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the order ID of the given screen in the @plngOrderID parameter. */
	DECLARE @lngDefaultOrderID	integer;

	/* Get the order ID, and associated tbale id of the given screen. */
	SELECT @plngOrderID = ASRSysScreens.orderID,
		@lngDefaultOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysScreens
	INNER JOIN ASRSysTables 
		ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.screenID = @plngScreenID;

	/* If no order is defined then use the associated table's default order. */
	IF (@plngOrderID IS NULL) OR (@plngOrderID <= 0)
	BEGIN
		SET @plngOrderID = @lngDefaultOrderID;
	END
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetTableScreensMenu]    Script Date: 13/09/2013 08:59:34 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTableScreensMenu] 
AS
BEGIN
	/* Return a recordset of information that can be used to format the Quick Entry menu for the current user. 
	The recordset contains a row for each quick entry in the HR Pro database. 
	For each quick entry screen the following information is given :
		tableID			ID of the lookup table
		tableName		Name of the lookup table
		screenID		ID of the lookup table screen
	*/
	DECLARE @lngCurrentRoleID		int
	/* Get the current user's role name and ID. */
	SELECT @lngCurrentRoleID = a.uid
	FROM sysusers a
	INNER JOIN sysusers b 
		ON a.uid = b.gid
	WHERE b.name = CURRENT_USER
	/* Return a recordset of the quick entry screens on which the current user has SELECT permission. */
	SELECT ASRSysTables.tableID, 
		ASRSysTables.tableName, 
		ASRSysScreens.screenID
	FROM ASRSysTables
	INNER JOIN ASRSysScreens 
		ON ASRSysTables.tableID = ASRSysScreens.tableID
	INNER JOIN sysobjects 
		ON ASRSystables.tableName = sysobjects.name
	INNER JOIN sysprotects 
		ON sysobjects.id = sysprotects.id 
	WHERE ASRSysTables.tableType = 3
		AND sysprotects.uid = @lngCurrentRoleID
		AND sysprotects.action = 193
		AND sysprotects.protecttype = 205
	ORDER BY ASRSysTables.tableName DESC
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetUniqueColumns]
(
	@plngTableID 	integer, 
	@plngViewID 	integer,
	@psRealSource	varchar(MAX) output
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the unique columns available for the given table/view. */
	DECLARE @lngTableID		integer,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sRealSource 		varchar(MAX),
		@sTableName 		varchar(255),
		@iTableType			integer,
		@iChildViewID		integer,
		@sActualUserName	sysname;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID;
	END
	ELSE
	BEGIN
		SELECT @lngTableID = viewTableID
		FROM [dbo].[ASRSysViews]
		WHERE viewID = @plngViewID;
	END

	/* Get the table-type. */
	SELECT @iTableType = tableType,
		@sTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @lngTableID;

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @columnInfo TABLE(
		columnID	integer,
		columnName	sysname,
		dataType	integer,
		columnSize	integer,
		readGranted	bit,
		columnDecimals	integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1 )
	BEGIN
		/* Populate the temporary table with information on the order for the given table. */
		IF @plngViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @plngViewID;

	   		INSERT INTO @columnInfo (
				columnID, 
				columnName,
				dataType,
				columnSize,
				readGranted,
				columnDecimals)
			(SELECT ASRSysColumns.columnID, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				ASRSysColumns.size,
				1, 
				ASRSysColumns.decimals
			FROM ASRSysColumns
			INNER JOIN ASRSysViewColumns ON ASRSysColumns.columnID = ASRSysViewColumns.columnID
			WHERE ASRSysColumns.tableID = @lngTableID
				AND ASRSysColumns.columnType <> 4
				AND ASRSysColumns.columnType <> 3
				AND (ASRSysColumns.dataType = 2
					OR ASRSysColumns.dataType = 4
					OR ASRSysColumns.dataType = 11
					OR ASRSysColumns.dataType =12)
				AND ASRSysColumns.uniqueCheckType <> 0
				AND ASRSysViewColumns.viewID = @plngViewID
				AND ASRSysViewColumns.inView = 1);
		END
		ELSE
		BEGIN
			IF @iTableType <> 2 /* ie. top-level or lookup */
			BEGIN
				/* RealSource is the table. */	
				SET @sRealSource = @sTableName;
			END 
			ELSE
			BEGIN
				/* RealSource is the child view on the table which is derived from full access on the table's parents. */	
				SELECT @iChildViewID = childViewID
				FROM [dbo].[ASRSysChildViews2]
				WHERE tableID = @lngTableID
					AND [role] = @sUserGroupName;
					
				IF @iChildViewID IS null SET @iChildViewID = 0;
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_');
					SET @sRealSource = left(@sRealSource, 255);
				END
			END

	   		 INSERT INTO @columnInfo (
				columnID, 
				columnName,
				dataType,
				columnSize,
				readGranted,
				columnDecimals)
			(SELECT ASRSysColumns.columnID, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				ASRSysColumns.size,
				1,
				ASRSysColumns.decimals
			FROM ASRSysColumns
			WHERE ASRSysColumns.tableID = @lngTableID
				AND columnType <> 4
				AND columnType <> 3
				AND (ASRSysColumns.dataType = 2
					OR ASRSysColumns.dataType = 4
					OR ASRSysColumns.dataType = 11
					OR ASRSysColumns.dataType =12)
				AND ASRSysColumns.uniqueCheckType <> 0);
		END
	END
	ELSE
	BEGIN
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @plngViewID > 0 
			BEGIN	
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM [dbo].[ASRSysViews]
				WHERE viewID = @plngViewID;
			END
			ELSE
			BEGIN
				SET @sRealSource = @sTableName;
			END 
		END
		ELSE
		BEGIN
			/* Get appropriate child view if required. */
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @lngTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sRealSource = left(@sRealSource, 255);
			END
		END

   		 INSERT INTO @columnInfo (
			columnID, 
			columnName,
			dataType,
			columnSize,
			readGranted,
			columnDecimals)
		(SELECT 
			ASRSysColumns.columnID,
			syscolumns.name,
			ASRSysColumns.dataType,
			ASRSysColumns.size,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END,
			ASRSysColumns.decimals
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		INNER JOIN ASRSysColumns ON syscolumns.name = ASRSysColumns.columnName
		WHERE sysprotects.uid = @iUserGroupID
			AND sysprotects.action = 193 
			AND ASRSysColumns.tableID = @lngTableID
			AND ASRSysColumns.columnType <> 4
			AND ASRSysColumns.columnType <> 3
			AND (ASRSysColumns.dataType = 2
				OR ASRSysColumns.dataType = 4
				OR ASRSysColumns.dataType = 11
				OR ASRSysColumns.dataType =12)
			AND ASRSysColumns.uniqueCheckType <> 0
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name = @sRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)));
	END

	SET @psRealSource = @sRealSource;

	/* Return the resultset. */
	SELECT columnID, columnName, dataType, columnSize, columnDecimals
	FROM @columnInfo 
	WHERE readGranted = 1
	ORDER BY columnName;
	
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetUserGroup]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetUserGroup]
	( 
	@psItemKey				varchar(50),
	@psUserGroup			varchar(250)	OUTPUT
	)
AS
BEGIN
	set @psUserGroup = '';
	/* SET NOCOUNT ON added to prevent extra result sets from interfering with SELECT statements. */
	SET NOCOUNT ON;
	SET @psUserGroup = (SELECT CASE 
		WHEN (usg.uid IS null) THEN null
		ELSE usg.name
	END as groupname
	FROM sysusers usu 
	LEFT OUTER JOIN (sysmembers mem INNER JOIN sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
	LEFT OUTER JOIN master.dbo.syslogins lo ON usu.sid = lo.sid
	WHERE (usu.islogin = 1 AND usu.isaliased = 0 AND usu.hasdbaccess = 1) 
		AND (usg.issqlrole = 1 OR usg.uid IS null)
		AND lo.loginname = SYSTEM_USER
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END NOT LIKE 'ASRSys%' AND usg.name NOT LIKE 'db_owner'
		AND CASE 
			WHEN (usg.uid IS null) THEN null
			ELSE usg.name
			END IN (
				SELECT [groupName]
				FROM [dbo].[ASRSysGroupPermissions]
				WHERE itemID IN (
					SELECT [itemID]
					FROM [dbo].[ASRSysPermissionItems]
					WHERE categoryID = 1
					AND itemKey LIKE '%' + @psItemKey + '%'
				)  
				AND [permitted] = 1))
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntMakeBulkBookings]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntMakeBulkBookings] (
	@piCourseRecordID		integer,
	@psEmployeeRecordIDs	varchar(MAX),
	@psStatus				varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iEmpTableID			integer,
		@iEmployeeID			integer,
		@iCourseTableID			integer,
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@sCourseTitle			varchar(MAX),
		@sCourseSource			sysname,
		@iTBTableID				integer,
		@sTBTableName			sysname,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@iWLTableID				integer,
		@sWLTableName			sysname,
		@sWLRealSource			varchar(MAX),
		@iWLCourseTitleColumnID	integer,
		@sWLCourseTitleColumnName	sysname,
		@iIndex					integer,
		@iChildViewID			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sActualUserName		sysname;

	/* Clean the input string parameters. */
	IF len(@psEmployeeRecordIDs) > 0 SET @psEmployeeRecordIDs = replace(@psEmployeeRecordIDs, '''', '''''');
	IF len(@psStatus) > 0 SET @psStatus = replace(@psStatus, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable';
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0;

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable';
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle';
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;

	SELECT @sCourseTitleColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iCourseTitleColumnID;

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable';
	IF @iTBTableID IS NULL SET @iTBTableID = 0;

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID;
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus';
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0;

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID;

	/* Get the WAITING LIST table information. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;
	
	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;

	SELECT @sWLCourseTitleColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iWLCourseTitleColumnID;

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND [role] = @sUserGroupName;
		
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sTBRealSource = left(@sTBRealSource, 255);
	END

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(100), @piCourseRecordID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	WHILE len(@psEmployeeRecordIDs) > 0
	BEGIN
		/* Rip out the individual empoyee record ID from the given comma-delimited string of employee IDs. */
		SELECT @iIndex = charindex(',', @psEmployeeRecordIDs);
		IF @iIndex > 0
		BEGIN
			SET  @iEmployeeID = substring(@psEmployeeRecordIDs, 1, @iIndex - 1);
			SELECT @psEmployeeRecordIDs = substring(@psEmployeeRecordIDs, @iIndex + 1, len(@psEmployeeRecordIDs));
		END
		ELSE
		BEGIN
			SET  @iEmployeeID = @psEmployeeRecordIDs;
			SET @psEmployeeRecordIDs = '';
		END

		/* Create the new booking record. */
		SET @sTempExecString = 'INSERT INTO ' + @sTBRealSource + 
			' (' + @sTBStatusColumnName +
			', id_' + convert(nvarchar(100), @iEmpTableID) +
			', id_' + convert(nvarchar(100), @iCourseTableID) +
			') VALUES (''' + @psStatus + '''' +
			', ' + convert(nvarchar(100), @iEmployeeID) +
			', ' + convert(nvarchar(100), @piCourseRecordID) + ')';
		EXEC sp_executesql @sTempExecString;

		/* Remove any Waiting List records. */
		SET @sTempExecString = 'DELETE FROM ' + @sWLRealSource + 
			' WHERE id_' + convert(nvarchar(MAX), @iEmpTableID) + ' = ' + convert(nvarchar(100), @iEmployeeID) +
			' AND ' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + '''';
		EXEC sp_executesql @sTempExecString;
	END
END

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntMakeUtilitiesHidden] (
	@piUtilityType		integer,
	@piUtilityID		integer
) AS
BEGIN

	SET NOCOUNT ON;

	/* Hide any utilities the use the given picklist/filter/calculation. */
	DECLARE
		@sCurrentUser		sysname,
		@sUtilName			varchar(255),
		@iUtilID			integer,
		@sUtilOwner			varchar(255),
		@sUtilAccess		varchar(MAX),
		@iCount				integer,
		@sJobName			varchar(255),
		@iNonHiddenCount	integer,
		@iScheduled			integer, 
		@sRoleToPrompt		sysname,
		@sCurrentUserGroup	sysname,
		@superCursor		cursor,
		@iTemp				integer,
		@iUserGroupID		integer,
		@sActualUserName	sysname;

	SET @sCurrentUser = SYSTEM_USER;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sCurrentUserGroup OUTPUT,
		@iUserGroupID OUTPUT;

	DECLARE @batchJobIDs		TABLE(id integer)
	DECLARE @calendarReportsIDs TABLE(id integer)
	DECLARE @careerIDs			TABLE(id integer)
	DECLARE @crossTabIDs		TABLE(id integer)
	DECLARE @customReportsIDs	TABLE(id integer)
	DECLARE @dataTransferIDs	TABLE(id integer)
	DECLARE @exportIDs			TABLE(id integer)
	DECLARE @globalAddIDs		TABLE(id integer)
	DECLARE @globalUpdateIDs	TABLE(id integer)
	DECLARE @globalDeleteIDs	TABLE(id integer)
	DECLARE @labelsIDs			TABLE(id integer)
	DECLARE @mailMergeIDs		TABLE(id integer)
	DECLARE @matchReportIDs		TABLE(id integer)
	DECLARE @recordProfileIDs	TABLE(id integer)
	DECLARE @successionIDs		TABLE(id integer)
	DECLARE @filterIDs			TABLE(id integer)
	DECLARE @calculationIDs		TABLE(id integer)
	DECLARE @expressionIDs		TABLE(id integer)
	DECLARE @superExpressionIDs	TABLE(id integer)

	IF (@piUtilityType = 12) OR (@piUtilityType = 11)
	BEGIN
		/* Calculation/Filter. */

    /*---------------------------------------------------*/
    /* Check Calculations/Filters For This Expression		*/
    /* NB. This check must be made before checking the reports/utilities	*/
    /*---------------------------------------------------*/
		INSERT INTO @expressionIDs (id) VALUES (@piUtilityID)
		
		exec spASRIntGetAllExprRootIDs @piUtilityID, @superCursor output
		
		FETCH NEXT FROM @superCursor INTO @iTemp
		WHILE (@@fetch_status = 0)
		BEGIN
			INSERT INTO @superExpressionIDs (id) VALUES (@iTemp)
			
			FETCH NEXT FROM @superCursor INTO @iTemp 
		END
		CLOSE @superCursor
		DEALLOCATE @superCursor

		INSERT INTO @expressionIDs (id) SELECT id FROM @superExpressionIDs

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 10

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calculation whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					INSERT INTO @calculationIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.Name,
				ASRSysExpressions.exprID AS [ID],
				ASRSysExpressions.Username,
				ASRSysExpressions.Access
			FROM ASRSysExpressions
			WHERE ASRSysExpressions.exprID IN (SELECT id FROM @superExpressionIDs)
				AND ASRSysExpressions.type = 11

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Filter whose owner is the same */
				IF @sUtilAccess <> 'HD'
				BEGIN
					INSERT INTO @filterIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @sUtilAccess
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
			AsrSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportEvents ON AsrSysCalendarReports.ID = ASRSYSCalendarReportEvents.calendarReportID
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON AsrSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE AsrSysCalendarReports.DescriptionExpr IN (SELECT id FROM @expressionIDs)
			OR AsrSysCalendarReports.StartDateExpr IN (SELECT id FROM @expressionIDs)
      OR AsrSysCalendarReports.EndDateExpr IN (SELECT id FROM @expressionIDs)
      OR ASRSysCalendarReports.Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSYSCalendarReportEvents.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
 			AsrSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCrossTab.Name,
			AsrSysCrossTab.[CrossTabID] AS [ID],
			AsrSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON AsrSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE AsrSysCrossTab.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY AsrSysCrossTab.Name,
			AsrSysCrossTab.crossTabID,
 			AsrSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSysCustomReportsDetails ON ASRSysCustomReportsName.ID = AsrSysCustomReportsDetails.CustomReportID
       LEFT OUTER JOIN ASRSYSCustomReportsChildDetails ON ASRSysCustomReportsName.ID = ASRSYSCustomReportsChildDetails.customReportID
       LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Filter IN (SELECT id FROM @expressionIDs)
				OR ASRSysCustomReportsName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSysCustomReportsName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR ASRSYSCustomReportsChildDetails.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR(AsrSysCustomReportsDetails.Type = 'E' 
					AND AsrSysCustomReportsDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysCustomReportsName ON AsrSysCustomReportsname.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 1
        AND ((AsrSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysMailMergeColumns.Type = 'E' 
					AND AsrSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
			 LEFT OUTER JOIN AsrSysExportDetails ON ASRSysExportName.ID = AsrSysExportDetails.exportID
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysExportName.Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.Parent1Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.Parent2Filter IN (SELECT id FROM @expressionIDs)
        OR AsrSysExportName.ChildFilter IN (SELECT id FROM @expressionIDs)
        OR (AsrSysExportDetails.Type = 'X' 
					AND AsrSysExportDetails.ColExprID IN (SELECT id FROM @expressionIDs))
      GROUP BY AsrSysExportName.Name,
				AsrSysExportName.ID,
        AsrSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN AsrSysGlobalItems ON ASRSysGlobalFunctions.functionID = AsrSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'A' 
				AND ((AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysGlobalItems.ValueType = 4 
					AND AsrSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) > 0) 
						OR (@sRoleToPrompt <> @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
			 LEFT OUTER JOIN AsrSysGlobalItems ON ASRSysGlobalFunctions.functionID = AsrSysGlobalItems.FunctionID
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'U' 
				AND ((AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysGlobalItems.ValueType = 4 
					AND AsrSysGlobalItems.ExprID IN (SELECT id FROM @expressionIDs)))
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE AsrSysGlobalFunctions.Type = 'D' 
				AND AsrSysGlobalFunctions.FilterID IN (SELECT id FROM @expressionIDs)
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Expression. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 0
        AND ((AsrSysMailMergeName.FilterID IN (SELECT id FROM @expressionIDs))
				OR (AsrSysMailMergeColumns.Type = 'E' 
					AND AsrSysMailMergeColumns.ColumnID IN (SELECT id FROM @expressionIDs)))
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileTables ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileTables.recordProfileID
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.FilterID IN (SELECT id FROM @expressionIDs)
			OR ASRSYSRecordProfileTables.FilterID IN (SELECT id FROM @expressionIDs)
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Expression. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Filter IN (SELECT id FROM @expressionIDs)
      OR ASRSysMatchReportName.table2Filter IN (SELECT id FROM @expressionIDs))
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
	END

	IF @piUtilityType = 10
	BEGIN
    /* Picklist */
    
		/*---------------------------------------------------*/
		/* Check Calendar Reports for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
			AsrSysCalendarReports.Username,
			COUNT (ASRSYSCalendarReportAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCalendarReports
		LEFT OUTER JOIN ASRSYSCalendarReportAccess ON AsrSysCalendarReports.ID = ASRSYSCalendarReportAccess.ID
			AND ASRSYSCalendarReportAccess.access <> 'HD'
			AND ASRSYSCalendarReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE AsrSysCalendarReports.Picklist = @piUtilityID
		GROUP BY AsrSysCalendarReports.Name,
			AsrSysCalendarReports.ID,
 			AsrSysCalendarReports.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Calendar Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @calendarReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Calendar Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @calendarReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCalendarReports.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCalendarReports ON ASRSysCalendarReports.ID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Calendar Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @calendarReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCalendarReports.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Calendar Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Career Progression for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 2
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Career Progression whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @careerIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Career Progressions are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @careerIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Career Progression'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @careerIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Career Progression in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Cross Tabs for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT AsrSysCrossTab.Name,
			AsrSysCrossTab.[CrossTabID] AS [ID],
			AsrSysCrossTab.Username,
			COUNT (ASRSYSCrossTabAccess.Access) AS [nonHiddenCount]
		FROM AsrSysCrossTab
		LEFT OUTER JOIN ASRSYSCrossTabAccess ON AsrSysCrossTab.crossTabID = ASRSYSCrossTabAccess.ID
			AND ASRSYSCrossTabAccess.access <> 'HD'
			AND ASRSYSCrossTabAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE AsrSysCrossTab.PicklistID = @piUtilityID
		GROUP BY AsrSysCrossTab.Name,
			AsrSysCrossTab.crossTabID,
 			AsrSysCrossTab.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Cross Tab whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @crossTabIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Cross Tabs are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @crossTabIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCrossTab.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @crossTabIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCrossTab.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a cross tab in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Custom Reports For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysCustomReportsName.Name,
        ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username,
        COUNT (ASRSYSCustomReportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysCustomReportsName
       LEFT OUTER JOIN ASRSYSCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSYSCustomReportAccess.ID
				AND ASRSYSCustomReportAccess.access <> 'HD'
        AND ASRSYSCustomReportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysCustomReportsName.Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent1Picklist = @piUtilityID
				OR ASRSysCustomReportsName.Parent2Picklist = @piUtilityID
      GROUP BY ASRSysCustomReportsName.Name,
				ASRSysCustomReportsName.ID,
        ASRSysCustomReportsName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Custom Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @customReportsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Custom Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @customReportsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysCustomReportsName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysCustomReportsName ON AsrSysCustomReportsname.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @customReportsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysCustomReportsName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Custom Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Data Transfer For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysDataTransferName.Name,
        ASRSysDataTransferName.DataTransferID AS [ID],
        ASRSysDataTransferName.Username,
        COUNT (ASRSYSDataTransferAccess.Access) AS [nonHiddenCount]
       FROM ASRSysDataTransferName
       LEFT OUTER JOIN ASRSYSDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSYSDataTransferAccess.ID
				AND ASRSYSDataTransferAccess.access <> 'HD'
        AND ASRSYSDataTransferAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysDataTransferName.PicklistID = @piUtilityID	
      GROUP BY ASRSysDataTransferName.Name,
				ASRSysDataTransferName.DataTransferID,
        ASRSysDataTransferName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Data Transfer whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @dataTransferIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Data Transfers are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @dataTransferIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysDataTransferName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysDataTransferName ON ASRSysDataTransferName.DataTransferID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Data Transfer'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @dataTransferIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysDataTransferName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Data Transfer in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Envelopes & Labels For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 1
        AND AsrSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Envelopes & Labels whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @labelsIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Envelopes & Labels are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @labelsIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Envelopes & Labels'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @labelsIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Envelopes & Labels in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Export For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExportName.Name,
        ASRSysExportName.ID,
        ASRSysExportName.Username,
        COUNT (ASRSYSExportAccess.Access) AS [nonHiddenCount]
       FROM ASRSysExportName
       LEFT OUTER JOIN ASRSYSExportAccess ON ASRSysExportName.ID = ASRSYSExportAccess.ID
				AND ASRSYSExportAccess.access <> 'HD'
        AND ASRSYSExportAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysExportName.Picklist = @piUtilityID
				OR ASRSysExportName.Parent1Picklist = @piUtilityID
				OR ASRSysExportName.Parent2Picklist = @piUtilityID
      GROUP BY AsrSysExportName.Name,
				AsrSysExportName.ID,
        AsrSysExportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Export whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @exportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Export are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @exportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysExportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysExportName ON ASRSysExportName.ID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Export'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @exportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysExportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Export in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Add For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'A' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Add whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalAddIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Adds are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalAddIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Add'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalAddIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Add in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Update For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'U' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Update whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalUpdateIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Updates are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalUpdateIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Update'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalUpdateIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Update in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Global Delete For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysGlobalFunctions.Name,
        ASRSysGlobalFunctions.functionID AS [ID],
        ASRSysGlobalFunctions.Username,
        COUNT (ASRSYSGlobalAccess.Access) AS [nonHiddenCount]
       FROM ASRSysGlobalFunctions
       LEFT OUTER JOIN ASRSYSGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSYSGlobalAccess.ID
				AND ASRSYSGlobalAccess.access <> 'HD'
        AND ASRSYSGlobalAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysGlobalFunctions.Type = 'D' 
				AND ASRSysGlobalFunctions.PicklistID = @piUtilityID
      GROUP BY ASRSysGlobalFunctions.Name,
				ASRSysGlobalFunctions.functionID,
        ASRSysGlobalFunctions.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Global Delete whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @globalDeleteIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Global Deletes are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @globalDeleteIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysGlobalFunctions.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalFunctions.FunctionID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Global Delete'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @globalDeleteIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysGlobalFunctions.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Global Delete in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*-----------------------------------------------------------------------*/
		/* Check Mail Merge For This Picklist. */
		/*-----------------------------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT AsrSysMailMergeName.Name,
        AsrSysMailMergeName.MailMergeID AS [ID],
        AsrSysMailMergeName.Username,
        COUNT (ASRSYSMailMergeAccess.Access) AS [nonHiddenCount]
       FROM AsrSysMailMergeName
			 LEFT OUTER JOIN AsrSysMailMergeColumns ON AsrSysMailMergeName.mailMergeID = AsrSysMailMergeColumns.mailMergeID
       LEFT OUTER JOIN ASRSYSMailMergeAccess ON AsrSysMailMergeName.MailMergeID = ASRSYSMailMergeAccess.ID
				AND ASRSYSMailMergeAccess.access <> 'HD'
        AND ASRSYSMailMergeAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
      WHERE AsrSysMailMergeName.isLabel = 0
				AND ASRSysMailMergeName.PicklistID = @piUtilityID
      GROUP BY AsrSysMailMergeName.Name,
				AsrSysMailMergeName.MailMergeID,
        AsrSysMailMergeName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Mail Merge whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @mailMergeIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Mail Merges are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @mailMergeIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					AsrSysMailMergeName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = AsrSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @mailMergeIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					AsrSysMailMergeName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Mail Merge in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Match Report for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 0
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Match Report whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @matchReportIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Match Reports are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @matchReportIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Match Report'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @matchReportIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Match Report in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Record Profile for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID AS [ID],
			ASRSysRecordProfileName.Username,
			COUNT (ASRSYSRecordProfileAccess.Access) AS [nonHiddenCount]
		FROM ASRSysRecordProfileName
		LEFT OUTER JOIN ASRSYSRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileAccess.ID
			AND ASRSYSRecordProfileAccess.access <> 'HD'
			AND ASRSYSRecordProfileAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
		WHERE ASRSysRecordProfileName.PicklistID = @piUtilityID
		GROUP BY ASRSysRecordProfileName.Name,
			ASRSysRecordProfileName.recordProfileID,
 			ASRSysRecordProfileName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Record Profile whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @recordProfileIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Record Profiles are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @recordProfileIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysRecordProfileName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysRecordProfileName ON ASRSysRecordProfileName.recordProfileID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Record Profile'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @recordProfileIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysRecordProfileName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Record Profile in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END

		/*---------------------------------------------------*/
		/* Check Succession Planning for this Picklist. */
		/*---------------------------------------------------*/
		DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID AS [ID],
			ASRSysMatchReportName.Username,
			COUNT (ASRSYSMatchReportAccess.Access) AS [nonHiddenCount]
		FROM ASRSysMatchReportName
		LEFT OUTER JOIN ASRSYSMatchReportAccess ON ASRSysMatchReportName.MatchReportID = ASRSYSMatchReportAccess.ID
			AND ASRSYSMatchReportAccess.access <> 'HD'
			AND ASRSYSMatchReportAccess.groupName NOT IN (SELECT sysusers.name
				FROM sysusers
				INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
					AND ASRSysGroupPermissions.permitted = 1
				INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
 					AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
					OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
				INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
					AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
				WHERE sysusers.uid = sysusers.gid
					AND sysusers.uid <> 0)
    WHERE ASRSysMatchReportName.matchReportType = 1
			AND (ASRSysMatchReportName.table1Picklist = @piUtilityID
      OR ASRSysMatchReportName.table2Picklist = @piUtilityID)
		GROUP BY ASRSysMatchReportName.Name,
			ASRSysMatchReportName.MatchReportID,
 			ASRSysMatchReportName.Username

		OPEN check_cursor
		FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sUtilOwner = @sCurrentUser
			BEGIN
				/* Found a Succession Planning whose owner is the same */
				IF @iNonHiddenCount > 0
				BEGIN
					INSERT INTO @successionIDs (id) VALUES (@iUtilID)
				END
			END

			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @sUtilOwner, @iNonHiddenCount
		END
		CLOSE check_cursor
		DEALLOCATE check_cursor

		/* Now check that any of these Succession Plannings are contained within a batch job */
		SELECT @iCount = COUNT(*)
		FROM @successionIDs

		IF @iCount > 0 
		BEGIN
			DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ASRSysBatchJobName.[Name],
					ASRSysBatchJobName.[ID],
					convert(integer, ASRSysBatchJobName.scheduled) AS [scheduled],
					ASRSysBatchJobName.roleToPrompt,
					COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
					ASRSysBatchJobName.[Username],
					ASRSysMatchReportName.[Name] AS 'JobName' 
				FROM ASRSysBatchJobDetails
				INNER JOIN ASRSysBatchJobName ON AsrSysBatchJobName.ID = AsrSysBatchJobDetails.BatchJobNameID
				INNER JOIN ASRSysMatchReportName ON ASRSysMatchReportName.matchReportID = ASRSysBatchJobdetails.JobID
				LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
					AND ASRSysBatchJobAccess.access <> 'HD'
					AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
						FROM sysusers
						INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
							AND ASRSysGroupPermissions.permitted = 1
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
							OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
						WHERE sysusers.uid = sysusers.gid
							AND sysusers.uid <> 0)
				WHERE ASRSysBatchJobDetails.JobType = 'Succession Planning'
					AND ASRSysBatchJobDetails.JobID IN (SELECT id FROM @successionIDs)
				GROUP BY ASRSysBatchJobName.Name,
					ASRSysBatchJobName.ID,
					convert(integer, ASRSysBatchJobName.scheduled),
					ASRSysBatchJobName.roleToPrompt,
					ASRSysBatchJobName.Username,
					ASRSysMatchReportName.Name

			OPEN check_cursor
			FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			WHILE (@@fetch_status = 0)
			BEGIN
				exec spASRIntCurrentUserAccess 
					0,
					@iUtilID,
					@sUtilAccess	OUTPUT

				IF @sUtilOwner = @sCurrentUser
				BEGIN
					/* Found a Succession Planning in a batch job whose owner is the same */
					IF (@iScheduled <> 1) 
						OR (Len(@sRoleToPrompt) = 0) 
						OR (@sRoleToPrompt = @sCurrentUserGroup)
					BEGIN
						IF @iNonHiddenCount > 0
						BEGIN
							INSERT INTO @batchJobIDs (id) VALUES(@iUtilID)
						END
					END
				END
	
				FETCH NEXT FROM check_cursor INTO @sUtilName, @iUtilID, @iScheduled, @sRoleToPrompt, @iNonHiddenCount, @sUtilOwner, @sJobName
			END
			CLOSE check_cursor
			DEALLOCATE check_cursor
		END
	END

	/*---------------------------------------------------------*/
	/* Mark all relevent utilities as hidden. */
	/*---------------------------------------------------------*/
	
	/* Calculations */
	UPDATE ASRSysExpressions
	SET access = 'HD'
	WHERE exprID IN (SELECT id FROM @calculationIDs)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @calculationIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 12

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (12, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 12
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor

	/* Filters */
	UPDATE ASRSysExpressions
	SET access = 'HD'
	WHERE exprID IN (SELECT id FROM @filterIDs)

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @filterIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 11

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (11, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 11
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor

	/* Batch Jobs */
	DELETE FROM ASRSysBatchJobAccess
	WHERE ID IN (SELECT id FROM @batchJobIDs)

	INSERT INTO ASRSysBatchJobAccess
		(ID, groupName, access)
		(SELECT ASRSysBatchJobName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysBatchJobName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysBatchJobName.ID IN (SELECT id FROM @batchJobIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @batchJobIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 0

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (0, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 0
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Calendar Reports */
	DELETE FROM ASRSysCalendarReportAccess
	WHERE ID IN (SELECT id FROM @calendarReportsIDs)

	INSERT INTO ASRSysCalendarReportAccess
		(ID, groupName, access)
		(SELECT ASRSysCalendarReports.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCalendarReports
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCalendarReports.ID IN (SELECT id FROM @calendarReportsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @calendarReportsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 17

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (17, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 17
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Career Progression */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @careerIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @careerIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @careerIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 24

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (24, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 24
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Cross Tabs */
	DELETE FROM ASRSysCrossTabAccess
	WHERE ID IN (SELECT id FROM @crossTabIDs)

	INSERT INTO ASRSysCrossTabAccess
		(ID, groupName, access)
		(SELECT ASRSysCrossTab.CrossTabID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCrossTab
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCrossTab.CrossTabID IN (SELECT id FROM @crossTabIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @crossTabIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 1

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (1, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 1
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Custom Reports */
	DELETE FROM ASRSysCustomReportAccess
	WHERE ID IN (SELECT id FROM @customReportsIDs)

	INSERT INTO ASRSysCustomReportAccess
		(ID, groupName, access)
		(SELECT ASRSysCustomReportsName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysCustomReportsName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysCustomReportsName.ID IN (SELECT id FROM @customReportsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @customReportsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 2

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (2, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 2
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Data Transfers */
	DELETE FROM ASRSysDataTransferAccess
	WHERE ID IN (SELECT id FROM @dataTransferIDs)

	INSERT INTO ASRSysDataTransferAccess
		(ID, groupName, access)
		(SELECT ASRSysDataTransferName.dataTransferID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysDataTransferName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysDataTransferName.dataTransferID IN (SELECT id FROM @dataTransferIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @dataTransferIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 3

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (3, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 3
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Exports */
	DELETE FROM ASRSysExportAccess
	WHERE ID IN (SELECT id FROM @exportIDs)

	INSERT INTO ASRSysExportAccess
		(ID, groupName, access)
		(SELECT ASRSysExportName.ID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysExportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysExportName.ID IN (SELECT id FROM @exportIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @exportIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 4

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (4, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 4
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Adds */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalAddIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalAddIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalAddIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 5

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (5, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 5
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Updates */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalUpdateIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalUpdateIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalUpdateIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 7

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (7, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 7
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Global Deletes */
	DELETE FROM ASRSysGlobalAccess
	WHERE ID IN (SELECT id FROM @globalDeleteIDs)

	INSERT INTO ASRSysGlobalAccess
		(ID, groupName, access)
		(SELECT ASRSysGlobalFunctions.functionID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysGlobalFunctions
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysGlobalFunctions.functionID IN (SELECT id FROM @globalDeleteIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @globalDeleteIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 6

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (6, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 6
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Labels */
	DELETE FROM ASRSysMailMergeAccess
	WHERE ID IN (SELECT id FROM @labelsIDs)

	INSERT INTO ASRSysMailMergeAccess
		(ID, groupName, access)
		(SELECT ASRSysMailMergeName.mailMergeID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMailMergeName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMailMergeName.mailMergeID IN (SELECT id FROM @labelsIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @labelsIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 18

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (18, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 18
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Mail Merges */
	DELETE FROM ASRSysMailMergeAccess
	WHERE ID IN (SELECT id FROM @mailMergeIDs)

	INSERT INTO ASRSysMailMergeAccess
		(ID, groupName, access)
		(SELECT ASRSysMailMergeName.mailMergeID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMailMergeName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMailMergeName.mailMergeID IN (SELECT id FROM @mailMergeIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @mailMergeIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 9

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (9, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 9
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Match Reports */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @matchReportIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @matchReportIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @matchReportIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 14

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (14, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 14
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Record Profiles */
	DELETE FROM ASRSysRecordProfileAccess
	WHERE ID IN (SELECT id FROM @recordProfileIDs)

	INSERT INTO ASRSysRecordProfileAccess
		(ID, groupName, access)
		(SELECT ASRSysRecordProfileName.recordProfileID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysRecordProfileName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysRecordProfileName.recordProfileID IN (SELECT id FROM @recordProfileIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @recordProfileIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 20

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (20, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 20
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

	/* Succession Planning */
	DELETE FROM ASRSysMatchReportAccess
	WHERE ID IN (SELECT id FROM @successionIDs)

	INSERT INTO ASRSysMatchReportAccess
		(ID, groupName, access)
		(SELECT ASRSysMatchReportName.matchReportID, 
			sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers,
			ASRSysMatchReportName
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.uid <> 0
			AND ASRSysMatchReportName.matchReportID IN (SELECT id FROM @successionIDs))

	DECLARE check_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT id
		FROM @successionIDs
	OPEN check_cursor
	FETCH NEXT FROM check_cursor INTO @iUtilID
	WHILE (@@fetch_status = 0)
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @iUtilID
			AND type = 23

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (23, @iUtilID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @iUtilID
				AND type = 23
		END

		FETCH NEXT FROM check_cursor INTO @iUtilID
	END
	CLOSE check_cursor
	DEALLOCATE check_cursor         

END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntNewUser]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntNewUser] (
	@psUserName	sysname)
AS
BEGIN

	SET NOCOUNT ON;

	/* Create an user associated with the given SQL login. 
	Put the new user in the current user's role.
	Return 1 if everything is done okay, else 0. */
	DECLARE @hResult 		integer,
		@sRoleName			sysname,
		@sActualUserName	sysname,
		@iUserGroupID		integer;

	/* Create a user in the database for the given login. */
	EXEC @hResult = sp_grantdbaccess @psUsername, @psUserName;
	IF @hResult <> 0 GOTO Done

	/* Determine the current user's role. */
	EXEC dbo.spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Put the new user in the same role as the current user. */
	EXEC @hResult = sp_addrolemember @sRoleName, @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Make the new user a dbo. */
	EXEC @hResult = sp_addrolemember 'db_owner', @psUserName;
	IF @hResult <> 0 GOTO Err;

	/* Jump over the error handling code. */
	GOTO Done;

Err:
	/* Remove the user from the database if it was added okay, but not assigned to a role. */
	EXEC sp_revokedbaccess @psUsername;

Done:
	RETURN (@hResult);

	END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntPopulateDefsel]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntPopulateDefsel] (
	@intType int, 
	@blnOnlyMine bit,
	@intTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the details with which to populate the intranet defsel grid. */
	DECLARE 
		@strSQL 			nvarchar(MAX),
		@strExplicitSQL 	varchar(MAX),
		@strTableName		varchar(255),
		@strIDName 			varchar(255),
		@sExtraWhereSQL		varchar(MAX),
		@fNewAccess			bit,
		@sRecordSourceWhere	varchar(MAX),
		@sAccessTableName	varchar(255),
		@sRoleName			varchar(255),
		@fSysSecMgr			bit,
		@fDoneWhere			bit,
		@sActualUserName	varchar(250),
		@iActualUserGroupID	integer

	SET @fNewAccess = 0;
	SET @sExtraWhereSQL = '';
	SET @fDoneWhere = 0;
	SET @strExplicitSQL = '';
	
	IF ((@intTableID <=0) OR (@intTableID IS null)) AND (@intType <> 17) AND (@intType <> 9)
	BEGIN
		/* No table ID passed in, so use the first table alphabetically. */
		SELECT TOP 1 @intTableID = tableID
		FROM [dbo].[ASRSysTables]
		ORDER BY tableName;
	END

	IF @intType = 1 /*'crosstabs'*/
	BEGIN
		SET @strTableName = 'AsrSysCrossTab';
		SET @strIDName = 'CrossTabID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCrossTabAccess';
	END

	IF @intType = 2 /*'customreports'*/
	BEGIN
		SET @strTableName = 'AsrSysCustomReportsName';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCustomReportAccess';
	END

	IF @intType = 9 /*'mailmerge'*/
	BEGIN
		SET @strTableName = 'AsrSysMailMergeName';
		SET @strIDName = 'MailMergeID';
		SET @fNewAccess = 1;
		SET @sRecordSourceWhere = 'ASRSysMailMergeName.IsLabel = 0';
		SET @sAccessTableName= 'ASRSysMailMergeAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysMailMergeName.TableID = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 10 /*'picklists'*/
	BEGIN
		SET @strTableName = 'ASRSysPickListName';
		SET @strIDName = 'picklistID';
		SET @sExtraWhereSQL = ' TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 11 /*'filters'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 11 AND (returnType = 3 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 12 /*'calculations'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 10 AND (returnType = 0 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END
	
	IF @intType = 17 /*'calendarreports'*/
	BEGIN
		SET @strTableName = 'ASRSysCalendarReports';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCalendarReportAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysCalendarReports.BaseTable = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 25 /*'workflow'*/
	BEGIN
		SET @strExplicitSQL = 'SELECT 
			Name, 
			replace(ASRSysWorkflows.description, char(9), '''') AS [description],
			'''' AS [Username],
			''rw'' AS [Access],
			ID
			FROM ASRSysWorkflows
			WHERE ASRSysWorkflows.enabled = 1
				AND ISNULL(ASRSysWorkflows.initiationType, 0) = 0
			ORDER BY ASRSysWorkflows.name';
	END
	
	IF len(@strExplicitSQL) > 0 
	BEGIN
		SET @strSQL = @strExplicitSQL;
	END
	ELSE
	BEGIN
		EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT;

		SELECT @fSysSecMgr = 
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE ASRSysGroupPermissions.groupname = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
				ELSE 0
			END;
			
		IF @fNewAccess = 1
		BEGIN
			SET @strSQL = 'SELECT ' + @strTableName + '.Name, ' +
				'replace(' + @strTableName + '.Description, char(9), '''') AS [description], ' +
				'lower(' +@strTableName + '.Username) as ''Username'', ';
				
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(' + @sAccessTableName + '.Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
								
			SET @strSQL = @strSQL +
				@strTableName + '.' + @strIDName + '  as ''ID'' 
				FROM ' + @strTableName + 
				' INNER JOIN ' + @sAccessTableName + ' ON ' + @strTableName + '.' + @strIDName +  ' = ' + @sAccessTableName + '.ID
				AND ' + @sAccessTableName + '.groupname = ''' + @sRoleName + '''';

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END

			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END
			
			SET @strSQL = @strSQL + ' ORDER BY ' + @strTableName + '.Name';
		END
		ELSE
		BEGIN
			SET @strSQL = 'SELECT Name, replace(Description, char(9), '''') AS [description], lower(Username) as ''Username'', ';
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
			SET @strSQL = @strSQL +
				@strIDName + '  as ''ID'' FROM ' + @strTableName;

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END
			
			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END

			SET @strSQL = @strSQL + ' ORDER BY Name';
		END
	END
	
	/* Return the resultset. */
	EXECUTE sp_executeSQL @strSQL;
	
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntSavePicklist]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntSavePicklist] (
	@psName			varchar(255),
	@psDescription	varchar(MAX),
	@psAccess		varchar(MAX),
	@psUserName		varchar(255),
	@psColumns		varchar(MAX),
	@psColumns2		varchar(MAX),
	@piID			integer	OUTPUT,
	@piTableID		integer	
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iIndex		integer,
		@iCount	integer,
		@sSubstring	varchar(MAX)

	/* Clean the input string parameters. */
	IF len(@psColumns) > 0 SET @psColumns = replace(@psColumns, '''', '''''')
	IF len(@psColumns2) > 0 SET @psColumns2 = replace(@psColumns2, '''', '''''')

	IF @piID = 0 
	BEGIN
		/* Saving a new picklist. */
		INSERT INTO ASRSysPickListName
			(name, description, tableID, access, userName)
		VALUES
			(@psName, @psDescription, @piTableID, @psAccess, @psUserName)

		/* Get the ID of the inserted record.
		NB. We do not use @@IDENTITY as the insertion that we have just performed may have triggered
		other insertions (eg. into the Audit Trail table. The @@IDENTITY variable would then be the last IDENTITY value
		entered in the Audit Trail table.*/
		SELECT @piID = MAX(picklistID) 
		FROM ASRSysPickListName

		WHILE len(@psColumns) > 0
		BEGIN
			SET @iIndex = charindex(',', @psColumns)
	
			IF @iIndex > 0
			BEGIN
				SET @sSubstring = left(@psColumns, @iIndex -1)
				SET @psColumns = substring(@psColumns, @iIndex + 1, len(@psColumns) - @iIndex)

				INSERT INTO ASRSysPickListItems (pickListID, recordID)
				VALUES(@piID, convert(integer, @sSubstring))

				IF (len(@psColumns2) > 0) AND (len(@psColumns) < 7000)
				BEGIN
					SET @psColumns = @psColumns + left(@psColumns2, 1000)
					IF len(@psColumns2) > 1000
					BEGIN
						SET @psColumns2 = substring(@psColumns, 1001, len(@psColumns2) - 1000)
					END
					ELSE
					BEGIN
						SET @psColumns2 = ''
					END
				END
			END
			ELSE
			BEGIN
				BREAK
			END
		END

		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (10, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Saving an existing picklist. */

		IF @psAccess = 'HD'
		BEGIN
			/* Hide any utilities that use this picklist. NB. The check to see if we can do this has already been done in sp_ASRIntCheckCanMakeHidden. */
			exec sp_ASRIntMakeUtilitiesHidden 10, @piID
		END
		
		DELETE FROM ASRSysPickListItems
		WHERE pickListID = @piID

		UPDATE ASRSysPickListName SET
			name = @psName, 
			description = @psDescription, 
			tableID = @piTableID,
			access = @psAccess
		WHERE pickListID = @piID

		WHILE len(@psColumns) > 0
		BEGIN
			SET @iIndex = charindex(',', @psColumns)
	
			IF @iIndex > 0
			BEGIN
				SET @sSubstring = left(@psColumns, @iIndex -1)
				SET @psColumns = substring(@psColumns, @iIndex + 1, len(@psColumns) - @iIndex)

				INSERT INTO ASRSysPickListItems (pickListID, recordID)
				VALUES(@piID, convert(integer, @sSubstring))

				IF (len(@psColumns2) > 0) AND (len(@psColumns) < 7000)
				BEGIN
					SET @psColumns = @psColumns + left(@psColumns2, 1000)
					IF len(@psColumns2) > 1000
					BEGIN
						SET @psColumns2 = substring(@psColumns, 1001, len(@psColumns2) - 1000)
					END
					ELSE
					BEGIN
						SET @psColumns2 = ''
					END
				END
			END
			ELSE
			BEGIN
				BREAK
			END
		END

		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 10

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (10, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 10
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntSaveSetting]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntSaveSetting] (
	@psSection		varchar(255),
	@psKey			varchar(255),
	@pfUserSetting	bit,
	@psValue		varchar(MAX)	
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Save the given user or system setting. */
	IF @pfUserSetting = 1
	BEGIN
		DELETE FROM [dbo].[ASRSysUserSettings]
		WHERE section = @psSection
			AND settingKey = @psKey
			AND userName = SYSTEM_USER;

		INSERT INTO [dbo].[ASRSysUserSettings]
			(section, settingKey, settingValue, userName)
		VALUES (@psSection, @psKey, @psValue, SYSTEM_USER);
	END
	ELSE
	BEGIN
		DELETE FROM [dbo].[ASRSysSystemSettings]
		WHERE section = @psSection
			AND settingKey = @psKey;

		INSERT INTO [dbo].[ASRSysSystemSettings]
			(section, settingKey, settingValue)
		VALUES (@psSection, @psKey, @psValue);
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntTransferCourse]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntTransferCourse] (
	@piTBRecordID		integer,
	@piCourseRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName			sysname,
		@iEmpTableID			integer,
		@iEmpRecordID			integer,
		@iCourseTableID			integer,
		@iOriginalCourseRecordID	integer,
		@iTBTableID				integer,
		@sTBRealSource			varchar(MAX),
		@iTBStatusColumnID		integer,
		@sTBStatusColumnName	sysname,
		@iTBCancelDateColumnID	integer,
		@sTBCancelDateColumnName	sysname,
		@sBookingStatus			varchar(MAX),
		@fTStatusExists			bit,
		@iCount					integer,
		@iChildViewID			integer,
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sTBTableName			sysname,
		@sActualUserName		sysname;

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the EMPLOYEE table information. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0

	/* Get the COURSE table information. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0

	/* Get the TRAINING BOOKING table information. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID

	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0

	SELECT @sTBStatusColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBStatusColumnID

	SELECT @iTBCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookCancelDate'
	IF @iTBCancelDateColumnID IS NULL SET @iTBCancelDateColumnID = 0

	SELECT @sTBCancelDateColumnName = columnName
	FROM ASRSysColumns
	WHERE columnID = @iTBCancelDateColumnID

	/* Check if the 'T' status code exists. */
	SET @fTStatusExists = 0
	SELECT @iCount = count(value)
	FROM ASRSysColumnControlValues
	WHERE columnID = @iTBStatusColumnID
		AND value = 'T'
	IF @iCount > 0 SET @fTStatusExists = 1

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTBRealSource = left(@sTBRealSource, 255)
	END

	SET @sTempExecString = 'SELECT @iEmpRecordID = ID_' + convert(nvarchar(100), @iEmpTableID) +
		', @iOriginalCourseRecordID = ID_' + convert(nvarchar(100), @iCourseTableID) +
		', @sBookingStatus = ' + @sTBStatusColumnName +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)
	SET @sTempParamDefinition = N'@iEmpRecordID integer OUTPUT, @iOriginalCourseRecordID integer OUTPUT, @sBookingStatus varchar(MAX) OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iEmpRecordID OUTPUT, @iOriginalCourseRecordID OUTPUT, @sBookingStatus OUTPUT


	IF @iEmpRecordID IS null SET @iEmpRecordID = 0
	IF @iOriginalCourseRecordID IS null SET @iOriginalCourseRecordID = 0

	/* Create the new booking record. */
	SET @sTempExecString = 'INSERT INTO ' + @sTBRealSource + 
		' (' + @sTBStatusColumnName +
		', id_' + convert(nvarchar(100), @iEmpTableID) +
		', id_' + convert(nvarchar(100), @iCourseTableID) +
		') VALUES (''' + @sBookingStatus + '''' +
		', ' + convert(nvarchar(100), @iEmpRecordID) +
		', ' + convert(nvarchar(100), @piCourseRecordID) + ')'
	EXEC sp_executesql @sTempExecString

	/* Update the old booking record. */     
	SET @sTempExecString = 'UPDATE ' + @sTBRealSource + 
		' SET ' + @sTBStatusColumnName + ' = ' + 
		CASE @fTStatusExists
			WHEN 1 THEN '''T'''
			ELSE '''C'''
		END

	IF len(@sTBCancelDateColumnName) > 0 
	BEGIN
		SET @sTempExecString = @sTempExecString +
			', ' + @sTBCancelDateColumnName + ' = getdate()'
	END

	SET @sTempExecString = @sTempExecString +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)

	EXEC sp_executesql @sTempExecString
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntUpdateCustomReportHeader]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntUpdateCustomReportHeader]
(
    @psInsertString varchar(8000)    /* SQL Insert string to insert the new record. */
)
AS
BEGIN
    /* Run the given SQL INSERT string. */
    EXECUTE (@psInsertString)
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateBulkBookings]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidateBulkBookings] (
	@piCourseRecordID				integer,
	@psEmployeeRecordIDs			varchar(MAX),
	@psBookingStatus				varchar(MAX),
	@psErrorMessage				varchar(MAX)	OUTPUT,
	@psPreReqCheckFailsCount			integer	  	OUTPUT,
	@psUnavailabilityCheckFailCount	integer		OUTPUT,
	@psOverlapCheckFailCount			integer		OUTPUT,
	@psCourseOverbooked				integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks on booking being made. 
	Return codes are:
		000 - completely valid
		If non-zero then the result code is composed as abc,
		where a is the result of the OVERBOOKING check
			a is the result of the PRE-REQUISITES check
			b is the result of the AVAILABILITY check
			c is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overlapped bookings check, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 012.

		The SP returns a table indicating the result code for each Employee record (see below) plus a parameter that indicates if the course is overbooked

		EmployeeID  ResultCode
		----------- ----------
		1094        020		--> ResultCode is codified as described above
		961         000	     --> ResultCode is codified as described above

		The output @psCourseOverbooked parameter will be set to one of the following values:
		  0 - No overbooking
		  1 - Course fully booked
		  2 - Course fully booked (over-rideable by the user).
	*/

	DECLARE	
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount				integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@iIndex				integer,
			@fFailure				bit,
			@iEmployeeID			integer,
			@fDoPreReqCheck		bit,
			@iPreReqTableID		integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sTemp				varchar(MAX),
			@piTableID			integer,
			@psRecordDescription	varchar(MAX),
			@psEmployeeName		varchar(MAX),
			@piResultCode			varchar(10)


	SET @piResultCode = ''
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0
	SET @psErrorMessage = ''
	SET @psPreReqCheckFailsCount = 0
	SET @psUnavailabilityCheckFailCount = 0
	SET @psOverlapCheckFailCount = 0
	SET @psCourseOverbooked = 0
	
	DECLARE @TempTable TABLE (EmployeeID INTEGER, EmployeeName VARCHAR(MAX), ResultCode VARCHAR(5))

	/* Clean the input string parameters. */
	IF len(@psEmployeeRecordIDs) > 0 SET @psEmployeeRecordIDs = replace(@psEmployeeRecordIDs, '''', '''''')

	/* Check if we need to do the overbooking check. */
	SELECT @sTemp = parameterValue
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseIncludeProvisionals'
	IF @psBookingStatus = 'B' OR @sTemp = 'TRUE'
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1
	END
	
	/* Check if we need to do the pre-requisite check. */
	SELECT @iPreReqTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_PreReqTable'
	IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

	IF @iPreReqTableID > 0 
	BEGIN
		/* Check if the pre-req stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoPreReqCheck = 1
	END

	/* Check if we need to do the unavailibility check. */
	SELECT @iUnavailTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_UnavailTable'
	IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

	IF @iUnavailTableID > 0 
	BEGIN
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckUnavailability')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
	END

	/* Check if we need to do the overlap check. */
	/* Check if the unavailibility stored procedure exists. */
	SELECT @iCount = COUNT(*) 
	FROM sysobjects
	WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
		AND sysstat & 0xf = 4
	
	IF @iCount > 0 SET @fDoOverlapCheck = 1

	/* Loop thourgh the given employee records. */
	SET @fFailure = 0
	SET @piResultCode = ''
	SET @iNumberBooked = 0

	WHILE len(@psEmployeeRecordIDs) > 0
	BEGIN
		/* Rip out the individual employee record ID from the given comma-delimited string of employee IDs. */
		SELECT @iIndex = charindex(',', @psEmployeeRecordIDs)
		IF @iIndex > 0
		BEGIN
			SET  @iEmployeeID = substring(@psEmployeeRecordIDs, 1, @iIndex - 1)
			SELECT @psEmployeeRecordIDs = substring(@psEmployeeRecordIDs, @iIndex + 1, len(@psEmployeeRecordIDs))
		END
		ELSE
		BEGIN
			SET  @iEmployeeID = @psEmployeeRecordIDs
			SET @psEmployeeRecordIDs = ''
		END

		BEGIN
			SET @piTableID = 1 /* Need to derive the Personnel table */
			EXECUTE dbo.spASRRecordDescription 1, @iEmployeeID, @psRecordDescription OUTPUT
			SET  @psEmployeeName = @psRecordDescription
		END

		IF @fDoPreReqCheck = 1
		BEGIN
				/* Return 0 if the given record in the personnel table has satisfied the pre-requisite criteria for the given course record.
				Return 1 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record.
				Return 2 if the given record in the personnel table has NOT satisfied the pre-requisite criteria for the given course record but the user can override this failure. */
				exec sp_ASR_TBCheckPreRequisites @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				IF @iResult = 1 OR @iResult = 2
				BEGIN
	   				SET @psPreReqCheckFailsCount = @psPreReqCheckFailsCount + 1
				END
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
				exec sp_ASR_TBCheckUnavailability @piCourseRecordID,  @iEmployeeID, @iResult OUTPUT
				/* Return 0 if the given record in the personnel table IS available for the given course record.
				Return 1 if the given record in the personnel table is NOT available for the given course record.
				Return 2 if the given record in the personnel table is NOT available for the given course record but the user can override this failure. */
				IF @iResult = 1  OR @iResult = 2
				BEGIN
					SET @psUnavailabilityCheckFailCount = @psUnavailabilityCheckFailCount + 1
				END				
				 
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		IF @fDoOverlapCheck = 1
		BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecordID,  @iEmployeeID, 0, @iResult OUTPUT
				  /* Return 0 if the given course does NOT overlap with another course that the given delegate is booked on.
				  Return 1 if the given course DOES overlap with another course that the given delegate is booked on.
				  Return 2 if the given course does NOT overlap with another course that the given delegate is booked on, but the user can override this failure. */
				IF @iResult = 1  OR @iResult = 2
				BEGIN
					SET @psOverlapCheckFailCount = @psOverlapCheckFailCount + 1
				END
				SET @piResultCode = @piResultCode + CONVERT(varchar(10), @iResult)
		END

		INSERT INTO @TempTable VALUES (@iEmployeeID, @psEmployeeName, @piResultCode)

		SET @iNumberBooked = @iNumberBooked + 1

		SET @piResultCode = ''
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		SET @psCourseOverbooked = @iResult
	END

	SELECT EmployeeID, EmployeeName, ResultCode FROM @TempTable
END

GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateExpression]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidateExpression] (
	@psUtilName 			varchar(255), 
	@piUtilID 				integer, 
	@piUtilType 			integer, 
	@psUtilOwner 			sysname, 
	@piBaseTableID 			integer, 
	@psComponentDefn		varchar(MAX),
	@piTimestamp 			integer, 
	@psDeletedKeys			varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any deleted calcs/filters. */
	@psHiddenOwnerKeys		varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any hidden calcs/filters that the current user owns. */
	@psHiddenNotOwnerKeys	varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node keys of any hidden calcs/filters that the current user does not own. */
	@psDeletedDescs			varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any deleted calcs/filters. */
	@psHiddenOwnerDescs		varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any hidden calcs/filters that the current user owns. */
	@psHiddenNotOwnerDescs	varchar(MAX)	OUTPUT,	/*	Tab-delimited string of node descriptions of any hidden calcs/filters that the current user does not own. */
	@piErrorCode			integer 		OUTPUT	/* 	0 = No error (but must check the strings of keys above)
										1 = Expression deleted by another user. Save as new ? 
										2 = Made hidden/read-only by another user. Save as new ? 
										3 = Modified by another user (still writable). Overwrite ? 
										4 = Non-unique name. Save fails */
	/* 	If there are any keys in the @psDeletedKeys string then these components need to be removed from the expression. The save fails.
		If there are any keys in the @psHiddenOwnerKeys or @psHiddenNotOwnerKeys strings then
			If current user does NOT own the expression then
				the expression needs to be made hidden, and the current user cannot edit it. Save and edit fails.
			Else
				If there are any keys in the @psHiddenNotOwnerKeys string then
					the hidden components need to be removed from the expression. Save fails.
				Else
					expression must also be made hidden
	*/
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp			integer,
			@sOwner				varchar(255),
			@sTemp				varchar(MAX),
			@sCompType			char(1),		/* 'U' = unknown, 'E' = expression, 'C' = component */
			@sParameter			varchar(MAX),
			@iComponentIndex	integer,
			@sTempAccess		varchar(MAX),
			@fHidden			bit,
			@sTempOwner			varchar(255),
			@sCurrentUser		sysname,
			@iCount				integer,
			@sExprID			varchar(100),
			@sName				varchar(255),
			@sTableID			varchar(100),
			@sReturnType		varchar(100),
			@sReturnSize		varchar(100),
			@sReturnDecimals	varchar(100),
			@sType				varchar(100),
			@sParentComponentID	varchar(100),
			@sUserName			varchar(255),
			@sAccess			varchar(MAX),
			@sDescription		varchar(MAX),
			@sTimestamp			varchar(100),
			@sViewInColour		varchar(100),
			@sExpandedNode		varchar(100),
			@fTemp				bit,
			@iCalculationID		integer,
			@sNodeKey			varchar(100),
			@sCompID			varchar(100),
			@sFieldColumnID		varchar(100),
			@sFieldPassBy			varchar(100),
			@sFieldSelectionTableID	varchar(100),
			@sFieldSelectionRecord	varchar(100),
			@sFieldSelectionLine	varchar(100),
			@sFieldSelectionOrderID	varchar(100),
			@sFieldSelectionFilter	varchar(MAX),
			@sFunctionID			varchar(100),
			@sCalculationID			varchar(100),
			@sOperatorID			varchar(100),
			@sValueType				varchar(100),
			@sValueCharacter		varchar(MAX),
			@sValueNumeric			varchar(100),
			@sValueLogic			varchar(100),
			@sValueDate				varchar(100),
			@sPromptDescription		varchar(MAX),
			@sPromptMask			varchar(MAX),
			@sPromptSize			varchar(100),
			@sPromptDecimals		varchar(100),
			@sFunctionReturnType	varchar(100),
			@sLookupTableID			varchar(100),
			@sLookupColumnID		varchar(100),
			@sFilterID				varchar(100),
			@sPromptDateType		varchar(100),
			@sFieldTableID			varchar(100),
			@sFieldSelectionOrderName	varchar(255),
			@sFieldSelectionFilterName	varchar(255);

	SET @sCurrentUser = SYSTEM_USER
	SET @piErrorCode = 0
	SET @psDeletedKeys = ''
	SET @psHiddenOwnerKeys = ''
	SET @psHiddenNotOwnerKeys = ''
	SET @psDeletedDescs = ''
	SET @psHiddenOwnerDescs = ''
	SET @psHiddenNotOwnerDescs = ''

	/* Loop through each component in the definition. */
	SET @sTemp = @psComponentDefn
	SET @sCompType = 'U'

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sParameter = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
		END
		ELSE
		BEGIN
			SET @sParameter = @sTemp
			SET @sTemp = ''
		END

		IF @sCompType = 'U' 
		BEGIN
			/* Reading a new component. */
			IF @sParameter = 'ROOT'
			BEGIN
				SET @sCompType = 'C'
			END
			ELSE
			BEGIN
				IF left(@sParameter, 1) = 'C'
				BEGIN
					SET @sCompType = 'E'
				END
				ELSE
				BEGIN
					SET @sCompType = 'C'
				END
			END	

			SET @iComponentIndex = 1
		END
		ELSE
		BEGIN
			IF @sCompType = 'E' 
			BEGIN
				/* Currently reading an expression. */
				IF @iComponentIndex = 1 SET @sNodeKey = @sParameter
				IF @iComponentIndex = 2 SET @sExprID = @sParameter
				IF @iComponentIndex = 3 SET @sName = @sParameter
				IF @iComponentIndex = 4 SET @sTableID = @sParameter
				IF @iComponentIndex = 5 SET @sReturnType = @sParameter
				IF @iComponentIndex = 6 SET @sReturnSize = @sParameter
				IF @iComponentIndex = 7 SET @sReturnDecimals = @sParameter
				IF @iComponentIndex = 8 SET @sType = @sParameter
				IF @iComponentIndex = 9 SET @sParentComponentID = @sParameter
				IF @iComponentIndex = 10 SET @sUserName = @sParameter
				IF @iComponentIndex = 11 SET @sAccess = @sParameter
				IF @iComponentIndex = 12 SET @sDescription = @sParameter
				IF @iComponentIndex = 13 SET @sTimestamp = @sParameter
				IF @iComponentIndex = 14 SET @sViewInColour = @sParameter
				IF @iComponentIndex = 15 
				BEGIN
					SET @sExpandedNode = @sParameter
					SET @sCompType = 'U'
				END
			END
			ELSE
			BEGIN
				/* Currently reading a component. */
				IF @iComponentIndex = 1 SET @sNodeKey = @sParameter
				IF @iComponentIndex = 2 SET @sCompID = @sParameter
				IF @iComponentIndex = 3 SET @sExprID = @sParameter
				IF @iComponentIndex = 4 SET @sType = @sParameter
				IF @iComponentIndex = 5 SET @sFieldColumnID = @sParameter
				IF @iComponentIndex = 6 SET @sFieldPassBy = @sParameter
				IF @iComponentIndex = 7 SET @sFieldSelectionTableID = @sParameter
				IF @iComponentIndex = 8 SET @sFieldSelectionRecord = @sParameter
				IF @iComponentIndex = 9 SET @sFieldSelectionLine = @sParameter
				IF @iComponentIndex = 10 SET @sFieldSelectionOrderID = @sParameter
				IF @iComponentIndex = 11 SET @sFieldSelectionFilter = @sParameter
				IF @iComponentIndex = 12 SET @sFunctionID = @sParameter
				IF @iComponentIndex = 13 SET @sCalculationID = @sParameter
				IF @iComponentIndex = 14 SET @sOperatorID = @sParameter
				IF @iComponentIndex = 15 SET @sValueType = @sParameter
				IF @iComponentIndex = 16 SET @sValueCharacter = @sParameter
				IF @iComponentIndex = 17 SET @sValueNumeric = @sParameter
				IF @iComponentIndex = 18 SET @sValueLogic = @sParameter
				IF @iComponentIndex = 19 SET @sValueDate = @sParameter
				IF @iComponentIndex = 20 SET @sPromptDescription = @sParameter
				IF @iComponentIndex = 21 SET @sPromptMask = @sParameter
				IF @iComponentIndex = 22 SET @sPromptSize = @sParameter
				IF @iComponentIndex = 23 SET @sPromptDecimals = @sParameter
				IF @iComponentIndex = 24 SET @sFunctionReturnType = @sParameter
				IF @iComponentIndex = 25 SET @sLookupTableID = @sParameter
				IF @iComponentIndex = 26 SET @sLookupColumnID = @sParameter
				IF @iComponentIndex = 27 SET @sFilterID = @sParameter
				IF @iComponentIndex = 28 SET @sExpandedNode = @sParameter
				IF @iComponentIndex = 29 SET @sPromptDateType = @sParameter
				IF @iComponentIndex = 30 SET @sDescription = @sParameter
				IF @iComponentIndex = 31 SET @sFieldTableID = @sParameter
				IF @iComponentIndex = 32 SET @sFieldSelectionOrderName = @sParameter
				IF @iComponentIndex = 33 
				BEGIN
					SET @sFieldSelectionFilterName = @sParameter
					SET @sCompType = 'U'
					IF (@sType = '3') 
						OR (@sType = '10') 
						OR ((@sType = '1') AND (convert(integer, @sFieldSelectionFilter) > 0))
					BEGIN
						/* Check if the calculation/filter still exists and hasn't been made hidden. */
						IF (@sType = '3') 
						BEGIN
							SET @iCalculationID = convert(integer, @sCalculationID)
						END
						ELSE
						BEGIN
							IF (@sType = '10') 
							BEGIN
								SET @iCalculationID = convert(integer, @sFilterID)
							END
							ELSE
							BEGIN
								SET @iCalculationID = convert(integer, @sFieldSelectionFilter)
							END
						END

						SELECT @sTempAccess = access ,
							 @sTempOwner = userName 
						FROM ASRSysExpressions
						WHERE exprID = @iCalculationID
						IF @sTempAccess IS null
						BEGIN
							/* Calculation has been deleted. */
							SET @psDeletedKeys = @psDeletedKeys +
								CASE 
									WHEN len(@psDeletedKeys) > 0 THEN char(9)
									ELSE ''
								END +
								@sNodeKey
							SET @psDeletedDescs = @psDeletedDescs +
								CASE 
									WHEN len(@psDeletedDescs) > 0 THEN char(9)
									ELSE ''
								END +
								@sDescription
						END
						ELSE 
						BEGIN
							/* Calculation still exists. Is it hidden ? */
							SET @fHidden = 0
							
							IF @sTempAccess = 'HD'
							BEGIN
								SET @fHidden = 1
							END
							ELSE
							BEGIN
								/* The calc isn't hidden. Are any sub-components hidden ? */
								execute sp_ASRIntExpressionHasHiddenComponents @iCalculationID, @fTemp OUTPUT

								IF @fTemp = 1 
								BEGIN
									SET @fHidden = 1
								END
							END

							IF @fHidden = 1
							BEGIN
								IF @sTempOwner = @sCurrentUser
								BEGIN
									SET @psHiddenOwnerKeys = @psHiddenOwnerKeys +
										CASE 
											WHEN len(@psHiddenOwnerKeys) > 0 THEN char(9)
											ELSE ''
										END +
										@sNodeKey
									SET  @psHiddenOwnerDescs = @psHiddenOwnerDescs +
										CASE 
											WHEN len(@psHiddenOwnerDescs) > 0 THEN char(9)
											ELSE ''
										END +
										@sDescription
								END
								ELSE
								BEGIN
									SET @psHiddenNotOwnerKeys = @psHiddenNotOwnerKeys +
										CASE 
											WHEN len(@psHiddenNotOwnerKeys) > 0 THEN char(9)
											ELSE ''
										END +
										@sNodeKey
									SET  @psHiddenNotOwnerDescs = @psHiddenNotOwnerDescs +
										CASE 
											WHEN len(@psHiddenNotOwnerDescs) > 0 THEN char(9)
											ELSE ''
										END +
										@sDescription
								END
							END
						END
					END
				END
			END		

			SET @iComponentIndex = @iComponentIndex + 1
		END
	END

	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions
		WHERE exprID = @piUtilID

		IF @iCount = 0
		BEGIN
			/* Expression has been deleted by another user. Save as new ? */
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sAccess = access, 
				@sOwner = userName
			FROM ASRSysExpressions
			WHERE exprID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW')
				BEGIN
					/* Modified by another user, and made hidden/read-only. Save as new ? */
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					/* Modified by another user, still writable. Overwrite ? */
					SET @piErrorCode = 3
				END
			END
		END
	END

	/* Check that the expression name is unique. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysExpressions
	WHERE exprID <> @piUtilID
		AND parentComponentID = 0
		AND name = @psUtilName
		AND TableID = @piBaseTableID
		AND type = @piUtilType

	IF @iCount > 0 
	BEGIN
		SET @piErrorCode = 4
	END
END

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidateMailMerge] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@psCalculations 	varchar(MAX), 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ?
								4 = saving will cause batch jobs to be made hiiden. Prompt to continue */
	@psDeletedCalcs 	varchar(MAX)	OUTPUT, 
	@psHiddenCalcs 		varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The mail merge has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysMailMergeName
			WHERE MailMergeID = @piUtilID

			IF (@iTimestamp <> @piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					9, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName
				AND MailMergeID <> @piUtilID AND IsLabel = 0
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName AND IsLabel = 0
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A mail merge called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	/* Check that the selected runtime calculations exists. */
	IF (@piErrorCode = 0) AND (LEN(@psCalculations) > 0)
	BEGIN
		SET @sTemp = @psCalculations

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(',', @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(',', @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(',', @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			SELECT @iCount = COUNT(*)
			FROM ASRSysExpressions
			 WHERE exprID = convert(integer, @sCurrentID)

			IF @iCount = 0
			BEGIN
				SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							'One or more runtime calculations have been deleted by another user. They will be automatically removed from the mail merge.'
					END
				SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
				SET @piErrorCode = 1
			END
			ELSE
			BEGIN
				SELECT @sOwner = userName,
					@sAccess = access
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 
						@psErrorMsg + 
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ''
							ELSE 
								CASE 
									WHEN LEN(@psErrorMsg) > 0 THEN char(13)
									ELSE ''
								END +
								'One or more runtime calculations have been made hidden by another user. They will be automatically removed from the mail merge.'
						END
					SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
					SET @piErrorCode = 1
				END
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				AsrSysMailMergeName.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN AsrSysMailMergeName ON AsrSysMailMergeName.MailMergeID = ASRSysBatchJobDetails.jobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				AsrSysMailMergeName.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Mail Merge ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs
	
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidatePicklist] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@psAccess 			varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								2 = definition changed by someone else, overwrite ? */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp			integer,
			@sAccess			varchar(MAX),
			@sOwner				varchar(255),
			@iCount				integer,
			@sCurrentUser		sysname;

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysPickListName]
		WHERE picklistID = @piUtilID;

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The picklist has been deleted by another user.<BR>Save as a new definition ?';
			SET @piErrorCode = 1;
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sAccess = access, 
				@sOwner = userName
			FROM [dbo].[ASRSysPickListName]
			WHERE picklistID = @piUtilID;

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user and is now Read Only.<BR>Save as a new definition ?';
					SET @piErrorCode = 1;
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The picklist has been amended by another user.<BR>Would you like to overwrite this definition ?';
					SET @piErrorCode = 2;
				END
			END
		END
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidatePicklist2]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidatePicklist2] (
	@psUtilName 		varchar(255),
	@piUtilID 			integer,
	@psAccess 			varchar(MAX),
	@piBaseTableID 		integer, 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT /* 	0 = no errors, 
								1 = error, 
								2 = definition used in utilities owned by the current user. Prompt to make these hidden too. */
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount					integer,
			@sCurrentUser			sysname,
			@iHiddenCheckResult 	integer,
			@sHiddenCheckMessage	varchar(MAX);

	SELECT @sCurrentUser = SYSTEM_USER;
	SET @psErrorMsg = '';
	SET @piErrorCode = 0;

	/* Check that the picklist name is unique. */
	IF @piUtilID > 0
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND picklistID <> @piUtilID
			AND tableID = @piBaseTableID;
	END
	ELSE
	BEGIN
		SELECT @iCount = COUNT(*) 
		FROM [dbo].[ASRSysPickListName]
		WHERE name = @psUtilName
			AND tableID = @piBaseTableID;
	END

	IF @iCount > 0 
	BEGIN
		SET @psErrorMsg = 'A picklist called ''' + @psUtilName + ''' already exists.';
		SET @piErrorCode = 1;
	END

	IF (@piErrorCode = 0) AND (@psAccess = 'HD') AND (@piUtilID > 0)
	BEGIN
		/* Check that the picklist can be made hidden (ie. is not used in any utilities owned by other people. */
		exec [dbo].[sp_ASRIntCheckCanMakeHidden] 10, @piUtilID, @iHiddenCheckResult OUTPUT, @sHiddenCheckMessage OUTPUT;

		IF @iHiddenCheckResult = 1
		BEGIN
			/* picklist used only in utilities owned by the current user - we then need to prompt the user if they want to make these utilities hidden too. */
			SET @psErrorMsg = 'Changing the selected picklist to hidden will automatically make the following definition(s), of which you are the owner, hidden also :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage +
				'<BR><BR>' +
				'Do you wish to continue ?';
			SET @piErrorCode = 2;
		END

		IF @iHiddenCheckResult = 2
		BEGIN
			/* picklist used in utilities which are in batch jobs not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 3
		BEGIN
			/* picklist used in utilities which are not owned by the current user - Cannot therefore make the utility hidden. */
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in the following definition(s), of which you are not the owner :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
			SET @piErrorCode = 1;
		END

		IF @iHiddenCheckResult = 4
		BEGIN
			SET @psErrorMsg = 'This picklist cannot be made hidden as it is used in definition(s) which are included in the following batch jobs which are scheduled to be run by other user groups :' + 
				'<BR><BR>' +
				@sHiddenCheckMessage;
 				
			SET @piErrorCode = 1;
		END
	END
END

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidateTrainingBooking] (
	@piResultCode		varchar(MAX) OUTPUT,
	@piEmpRecID		integer,
	@piCourseRecID		integer,
	@psBookingStatus	varchar(MAX),
	@piTBRecID		integer,
	@psCourseOverbooked integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Perform the Training Booking validation on the given insert/update SQL string.
	Return codes are :
		@piResultCode = '000' - completely valid
		If non-zero then the result code is composed as abc,
		where a is the result of the PRE-REQUISITES check
			b is the result of the AVAILABILITY check
			c is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

	The psCourseOverbooked parameter returns if the course is overbooked
	*/
	DECLARE @fOK				bit,
		@fIncludeProvisionals	bit,
		@sIncludeProvisionals	varchar(MAX),
		@iCount					integer,
		@iResult				integer,
		@iTemp					integer,
		@piResultOverlapping   integer,
		@piResultPrerequisites	integer,
		@piResultUnavailability	integer

	SET @fOK = 1
	SET @piResultCode = ''
	SET @piResultOverlapping = 0
    SET @piResultPrerequisites = 0
	SET @piResultUnavailability= 0
	SET @psCourseOverbooked = 0

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'TRAINING', @fOK OUTPUT
		
	IF @fOK = 0
	BEGIN
		/* Do not perform any training Booking checks if the module is not licenced. */
		RETURN
	END

	IF (@piCourseRecID > 0) AND ((@psBookingStatus = 'B') OR (@psBookingStatus = 'P'))
	BEGIN  
		SELECT @sIncludeProvisionals = parameterValue
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseIncludeProvisionals'
		IF @sIncludeProvisionals IS NULL SET @sIncludeProvisionals = 'FALSE'
		IF @sIncludeProvisionals = 'FALSE'
		BEGIN
			SET @sIncludeProvisionals = 0
		END
		ELSE
		BEGIN
			SET @sIncludeProvisionals = 1
		END

		/* Only check that the selected course is not fully booked if the new booking is included in the number booked. */
		IF (@fIncludeProvisionals = 1) OR (@psBookingStatus = 'B') 
		BEGIN
			/* Check if the overbooking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverbooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverbooking @piCourseRecID, @piTBRecID, 1, @iResult OUTPUT
				SET @psCourseOverbooked = @iResult -- @iResult = 1 -> Course fully booked (error). @iResult = 2 -> Course fully booked (over-rideable by the user).
			END
		END
      
		IF @piEmpRecID > 0
		BEGIN
			/* Check that the employee has satisfied the pre-requisite criteria for the selected course. */
			/* First check if the pre-requisite table is configured. If not, we do not need to do the pre-req check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_PreReqTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the pre-req stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckPreRequisites @piCourseRecID, @piEmpRecID, @iResult OUTPUT
					SET @piResultPrerequisites = @iResult -- @iResult = 1 -> Pre-requisites not satisfied (error). @iResult = 2 -> Pre-requisites not satisfied (over-rideable by the user). 
				END
			END

			/* Check that the employee is available for the selected course. */
			/* First check if the unavailability table is configured. If not, we do not need to do the unavailability check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_UnavailTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the unavailability stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckUnavailability')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckUnavailability @piCourseRecID, @piEmpRecID, @iResult OUTPUT
					SET @piResultUnavailability = @iResult -- @iResult = 1 -> Employee unavailable (error). @iResult = 2 -> Employee unavailable (over-rideable by the user).
				END
			END

			/* Check if the overlapped booking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecID, @piEmpRecID, @piTBRecID, @iResult OUTPUT
				SET @piResultOverlapping = @iResult -- @iResult = 1 -> Overlapped booking (error). @iResult = 2 -> Overlapped booking (over-rideable by the user). 
			END
		END
		SET @piResultCode = CONVERT(VARCHAR(1), @piResultPrerequisites) + CONVERT(VARCHAR(1), @piResultUnavailability) + CONVERT(VARCHAR(1), @piResultOverlapping)
	END
END

GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntValidateTransfers]    Script Date: 13/09/2013 08:59:35 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_ASRIntValidateTransfers] (
	@piEmployeeTableID			integer,
	@piCourseTableID			integer,
	@piCourseRecordID			integer,
	@piTransferCourseRecordID	integer,
	@piTrainBookTableID			integer,
	@piTrainBookStatusColumnID	integer,
	@piResultCode				integer			OUTPUT,
	@psErrorMessage				varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* This stored procedure run the pre-requisite, overbooking, overlapped booking and unavailability checks
	on booking being transferred from one course (@piCourseRecordID) to another (@piTransferCourseRecordID). 
	Return codes are :
		0 - completely valid
		If non-zero then the result code is composed as abcd,
		where a is the result of the OVERBOOKING check
			b is the result of the PRE-REQUISITES check
			c is the result of the AVAILABILITY check
			d is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

		eg. if the current record passed the overbooking or overlapped bookings checks, but failed the availability check (overridable),
		and the pre-requisite check (not overridable) then the result code would be 0120.
	*/
	DECLARE	@sCommand				nvarchar(MAX),
			@sParamDefinition		nvarchar(500),
			@iUserGroupID			integer,
			@sUserGroupName			sysname,
			@iChildViewID			integer,
			@fTransferProvisionals	bit,
			@sTemp					varchar(MAX),
			@fPreReqsOverridden		bit,
			@fUnavailOverridden		bit,
			@fOverlapOverridden		bit,
			@iCount					integer,
			@iNumberBooked			integer,
			@iResult				integer,
			@sTBTableName			sysname,
			@sTrainBookRealSource	sysname,
			@sTrainBookStatusColumnName		sysname,
			@fDoPreReqCheck			bit,
			@iPreReqTableID			integer,
			@fDoUnavailabilityCheck	bit,
			@iUnavailTableID		integer,
			@fDoOverlapCheck		bit,
			@fDoOverbookingCheck	bit,
			@sActualUserName		sysname;

	SET @piResultCode = 0
	SET @psErrorMessage = ''
	SET @fPreReqsOverridden = 0
	SET @fUnavailOverridden = 0
	SET @fOverlapOverridden = 0
	SET @iNumberBooked = 0
	SET @fDoPreReqCheck = 0
	SET @fDoUnavailabilityCheck = 0
	SET @fDoOverlapCheck = 0
	SET @fDoOverbookingCheck = 0

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTrainBookTableID

	/* Get the realSource of the training booking table. */
	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @piTrainBookTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTrainBookRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTrainBookRealSource = left(@sTrainBookRealSource, 255)
	END
	ELSE
	BEGIN
		SET @psErrorMessage = 'Unable to determine the Training Booking child view.'
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		IF @piTrainBookStatusColumnID > 0
		BEGIN
			SELECT @sTrainBookStatusColumnName = columnName
				FROM ASRSysColumns
				WHERE columnID = @piTrainBookStatusColumnID
			IF @sTrainBookStatusColumnName IS NULL SET @psErrorMessage = 'Unable to find the Training Booking Status column.'
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if we need to transfer provisional bookings. */
		SET @sTemp = ''
		SELECT @sTemp = convert(varchar(MAX), parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTransferProvisionals'
		IF @sTemp IS NULL SET @sTemp = ''
		IF @sTemp = 'TRUE'
		BEGIN
			SET @fTransferProvisionals = 1
		END
		ELSE
		BEGIN
			SET @fTransferProvisionals = 0
		END
	END

	IF LEN(@psErrorMessage) = 0 
	BEGIN
		/* Check if the overbooking stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverbooking')
			AND sysstat & 0xf = 4

		IF @iCount > 0 SET @fDoOverbookingCheck = 1

		/* Check if we need to do the pre-requisite check. */
		SELECT @iPreReqTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_PreReqTable'
		IF @iPreReqTableID IS NULL SET @iPreReqTableID = 0

		IF @iPreReqTableID > 0 
		BEGIN
			/* Check if the pre-req stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoPreReqCheck = 1
		END

		/* Check if we need to do the unavailibility check. */
		SELECT @iUnavailTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_UnavailTable'
		IF @iUnavailTableID IS NULL SET @iUnavailTableID = 0

		IF @iUnavailTableID > 0 
		BEGIN
			/* Check if the unavailibility stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckUnavailability')
				AND sysstat & 0xf = 4
			
			IF @iCount > 0 SET @fDoUnavailabilityCheck = 1
		END

		/* Check if we need to do the overlap check. */
		/* Check if the unavailibility stored procedure exists. */
		SELECT @iCount = COUNT(*) 
		FROM sysobjects
		WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
			AND sysstat & 0xf = 4
		
		IF @iCount > 0 SET @fDoOverlapCheck = 1
	END

	IF LEN(@psErrorMessage) = 0
	BEGIN
		SET @sCommand = 
			'DECLARE @iEmployeeID	integer,' +
			'	@sStatus		varchar(MAX),' + 
			'	@iResult		integer,' +
			'	@fFailure		bit,' +
			'	@sCodeString		varchar(10),' +
			'	@sCurrentCode		varchar(1)' +
			' SET @piResultCode = 0' +
			' SET @fFailure = 0' +
			' SET @piNumberBooked = 0' +
			' DECLARE transfersCursor CURSOR LOCAL FAST_FORWARD FOR ' + 
			' SELECT id_' + convert(nvarchar(100), @piEmployeeTableID) + 
			', ' + @sTrainBookStatusColumnName +
			' FROM ' + @sTrainBookRealSource +
			' WHERE id_' + convert(nvarchar(100), @piCourseTableID) + ' = ' + convert(nvarchar(100), @piCourseRecordID)

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' AND (LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B''' +
				' OR LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''P'')'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' AND LEFT(UPPER(' + @sTrainBookStatusColumnName + '), 1) = ''B'''
		END

		SET @sCommand = @sCommand  + 
			' OPEN transfersCursor' +
			' FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' WHILE (@@fetch_status = 0) AND (@fFailure = 0)' +
			' BEGIN' +
			'	SET @sCodeString = convert(varchar(10), @piResultCode)'

		IF @fDoPreReqCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF LEN(@sCodeString) >= 3' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 3), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckPreRequisites ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Pre-requisites not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (100 * convert(integer, @sCurrentCode)) + (100 * @iResult)' +
				'	END'
		END

		IF @fDoUnavailabilityCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 2' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 2), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckUnavailability ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Unavailability check not satisfied (error). */' +
				'		SET @piResultCode = @piResultCode - (10 * convert(integer, @sCurrentCode)) + (10 * @iResult)' +
				'	END'
		END

		IF @fDoOverlapCheck = 1
		BEGIN
			SET @sCommand = @sCommand  + 
				'	IF len(@sCodeString) >= 1' +
				'	BEGIN' + 
				'		SET @sCurrentCode = LEFT(RIGHT(@sCodeString, 1), 1)' +
				'	END' +
				'	ELSE SET @sCurrentCode = 0' +
				'	IF @sCurrentCode <> ''1''' +
				'	BEGIN' +
				'		exec sp_ASR_TBCheckOverlappedBooking ' + convert(nvarchar(100), @piTransferCourseRecordID) + ',  @iEmployeeID, 0, @iResult OUTPUT' +
				'		IF @iResult = 1 SET @fFailure = 1 /* Overlapped booking (error). */' +
				'		SET @piResultCode = @piResultCode - convert(integer, @sCurrentCode) + @iResult' +
				'	END'
		END

		IF @fTransferProvisionals = 1
		BEGIN
			SET @sCommand = @sCommand +
				' SET @piNumberBooked = @piNumberBooked + 1'
		END
		ELSE
		BEGIN
			SET @sCommand = @sCommand +
				' IF @sStatus = ''B'' SET @piNumberBooked = @piNumberBooked + 1'
		END

		SET @sCommand = @sCommand  + 
			'	FETCH NEXT FROM transfersCursor INTO @iEmployeeID, @sStatus' +
			' END' +
			' CLOSE transfersCursor' +
			' DEALLOCATE transfersCursor'

		SET @sParamDefinition = N'@piResultCode integer OUTPUT, @piNumberBooked integer OUTPUT'
		EXEC sp_executesql @sCommand,  @sParamDefinition, @piResultCode OUTPUT, @iNumberBooked OUTPUT
	END

	IF LEN(@psErrorMessage) = 0 AND (@fDoOverbookingCheck = 1)
	BEGIN
		exec sp_ASR_TBCheckOverbooking @piTransferCourseRecordID, 0, @iNumberBooked, @iResult OUTPUT

		IF @iResult = 1 /* Course fully booked (error). */
		BEGIN
			SET @piResultCode = @piResultCode + 1000
		END
		IF @iResult = 2 /* Course fully booked (over-rideable by the user). */
		BEGIN
			SET @piResultCode = @piResultCode + 2000
		END
	END
END

GO



---------------------------------------------------------------
-- Script 8.0.13 (Not necessary)
---------------------------------------------------------------


---------------------------------------------------------------
-- Script 8.0.14
---------------------------------------------------------------


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASR_Bradford_DeleteAbsences]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASR_Bradford_DeleteAbsences];
GO

CREATE PROCEDURE [dbo].[sp_ASR_Bradford_DeleteAbsences]
(
	@pdReportStart	  	datetime,
	@pdReportEnd				datetime,
	@pbOmitBeforeStart	bit,
	@pbOmitAfterEnd			bit,
	@pcReportTableName	char(30)
)
AS
BEGIN

	SET NOCOUNT ON;

	declare @piID as integer;
	declare @pdStartDate as datetime;
	declare @pdEndDate as datetime;
	declare @iDuration as float;
	declare @pbDeleteThisAbsence as bit;
	declare @sSQL as varchar(MAX);

	set @sSQL = 'DECLARE BradfordIndexCursor2 CURSOR FOR SELECT Absence_ID, Start_Date, End_Date, Duration FROM ' + @pcReportTableName;
	execute(@sSQL);
	open BradfordIndexCursor2;

	Fetch Next From BradfordIndexCursor2 Into @piID, @pdStartDate, @pdEndDate, @iDuration;
	while @@FETCH_STATUS = 0
		begin
			set @pbDeleteThisAbsence = 0;
			if @pdEndDate < @pdReportStart set @pbDeleteThisAbsence = 1;
			if @pdStartDate > @pdReportEnd set @pbDeleteThisAbsence = 1;
			if @iDuration = 0 set @pbDeleteThisAbsence = 1;

			if @pbOmitBeforeStart = 1 and (@pdStartDate < @pdReportStart)  set @pbDeleteThisAbsence = 1;
			if @pbOmitAfterEnd = 1 and (@pdEndDate > @pdReportEnd)  set @pbDeleteThisAbsence = 1;

			if @pbDeleteThisAbsence = 1
				begin
					set @sSQL = 'DELETE FROM ' + @pcReportTableName + ' Where Absence_ID = Convert(Int,' + Convert(char(10),@piId) + ')';
					execute(@sSQL);
				end

			Fetch Next From BradfordIndexCursor2 Into @piID, @pdStartDate, @pdEndDate, @iDuration;
		end

	close BradfordIndexCursor2;
	deallocate BradfordIndexCursor2;

END

GO

---------------------------------------------------------------
-- Script 8.0.16 (Not necessary)
---------------------------------------------------------------


---------------------------------------------------------------
-- Script 8.0.18
---------------------------------------------------------------


CREATE PROCEDURE [dbo].[spASRIntGetSSIWelcomeDetails]	
(
		@piWelcomeColumnID integer,
		@piPhotographColumnID integer,
		@piSingleRecordViewID integer,
		@psUserName varchar(255),	
		@psWelcomeMessage varchar(255) OUTPUT,
		@psSelfServiceWelcomeColumn varchar(255) OUTPUT,
		@psSelfServicePhotograph varbinary(max) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sql nvarchar(max)
	DECLARE @dtLastLogon datetime
	DECLARE @myval varchar(max)
	DECLARE @myvalVarBinary as varbinary(max)
	DECLARE @psLogonTime varchar(20)
	DECLARE @psLogonDay varchar(20)
	DECLARE @psWelcomeName varchar(255)
	DECLARE @psLastLogon varchar(50)		

	--- try to get the users welcome name

	BEGIN TRY
		SELECT @sql = 'SELECT @outparm = ['+c.columnname+'] FROM ['+v.viewname+']'
			FROM ASRSysColumns c, ASRSysViews v
			WHERE c.columnID = @piWelcomeColumnID AND v.ViewID = @piSingleRecordViewID

		EXEC sp_executesql @sql, N'@outparm nvarchar(max) output', @myval OUTPUT
	
		IF LEN(LTRIM(RTRIM(@myval))) = 0 OR @@ROWCOUNT = 0 or ISNULL(@myval, '') = ''
		BEGIN
			SET @psWelcomeName = ''
		END
		ELSE
		BEGIN
			SET @psWelcomeName = ' ' + isnull(@myval, '')
		END

	END TRY
	
	BEGIN CATCH
		SET @psWelcomeName = ''
	END CATCH
	
	-- Get the user's photograph
	BEGIN TRY
		SELECT @sql = 'SELECT @outparm = ['+c.columnname+'] FROM ['+v.viewname+']'
			FROM ASRSysColumns c, ASRSysViews v
			WHERE c.columnID = @piPhotographColumnID AND v.ViewID = @piSingleRecordViewID

		EXEC sp_executesql @sql, N'@outparm varbinary(max) output', @myvalVarBinary OUTPUT
	
		SET @psSelfServicePhotograph = @myvalVarBinary
	END TRY
	
	BEGIN CATCH
		SET @psSelfServicePhotograph = null
	END CATCH

	--- Now get the last logon details

	SELECT TOP 1 @dtLastLogon = DateTimeStamp
				FROM ASRSysAuditAccess WHERE [UserName] = @psUserName
				AND [HRProModule] in ('OpenHR Web', 'Intranet', 'Self-service')
				AND [Action] = 'log in'
							AND ID NOT IN (                  
															SELECT top 1 ID
															FROM ASRSysAuditAccess WHERE [UserName] = @psUserName
															AND [HRProModule] in ('OpenHR Web', 'Intranet', 'Self-service')
															AND [Action] = 'log in'
															ORDER BY DateTimeStamp DESC)                  
	ORDER BY DateTimeStamp DESC
			

	IF @@ROWCOUNT > 0 
	BEGIN
		SET @psLogonTime = CONVERT(varchar(5),@dtLastLogon, 108)
		SELECT @psLogonDay = 
			CASE datediff(day, @dtLastLogon, GETDATE())
			WHEN 0 THEN 'today'
			WHEN 1 THEN 'yesterday'
			ELSE 'on ' + CAST(DAY(@dtLastLogon) AS VARCHAR(2)) + ' ' + DATENAME(MM, @dtLastLogon) + ' ' + CAST(YEAR(@dtLastLogon) AS VARCHAR(4))
		END
		SET @psWelcomeMessage = 'Welcome back' + @psWelcomeName + ', you last logged in at ' + @psLogonTime + ' ' + @psLogonDay
	END
	ELSE
	BEGIN
		SET @psWelcomeMessage = 'Welcome ' + @psWelcomeName
	END

	SET @psSelfServiceWelcomeColumn = @psWelcomeName;

END

GO




---------------------------------------------------------------
-- Script 8.0.20 (Not necessary)
---------------------------------------------------------------


---------------------------------------------------------------
-- Script 8.0.21 (Not necessary)
---------------------------------------------------------------


---------------------------------------------------------------
-- Script 8.0.22
---------------------------------------------------------------

DROP PROCEDURE [dbo].[sp_ASRIntGetScreenDefinition]
GO

DROP PROCEDURE [dbo].[spASRIntGetSummaryValues]
GO

DROP PROCEDURE [dbo].[spASRIntGetParentValues]
GO

DROP PROCEDURE [dbo].[spASRIntGetNavigationLinks]
GO

DROP PROCEDURE [dbo].[spASRIntAllTablePermissions]
GO




IF TYPE_ID(N'DataPermissions') IS NOT NULL
	DROP TYPE [dbo].[DataPermissions]

GO

CREATE TYPE [dbo].[DataPermissions] AS TABLE
(
	name	varchar(255)
)

GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetCustomReport]    Script Date: 08/01/2014 16:44:09 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE [dbo].[spASRIntGetCustomReport]
	(@ReportID integer)
AS
BEGIN

	SET NOCOUNT ON;
	
	-- Base report info
	SELECT c.[ID], c.[Name], c.[Description], c.[BaseTable], c.[AllRecords], c.[Picklist], c.[Filter]
		 , c.[Parent1Table], c.[Parent1Filter], c.[Parent2Table], c.[Parent2Filter], c.[Summary], c.[PrintFilterHeader]
		 , c.[UserName], c.[Timestamp], c.[Parent1AllRecords]
 		 , ISNULL(c.[Parent1Picklist],0) AS [Parent1Picklist]
		 , c.[Parent2AllRecords]
		 , ISNULL(c.[Parent2Picklist],0) AS [Parent2Picklist]
		 , c.[OutputPreview], c.[OutputFormat], c.[OutputScreen], c.[OutputPrinter], c.[OutputPrinterName], c.[OutputSave]
		 , c.[OutputSaveExisting], c.[OutputEmail], c.[OutputEmailAddr], c.[OutputEmailSubject], c.[OutputFilename]
		 , ISNULL(c.[OutputEmailAttachAs],0) AS [OutputEmailAttachAs]
		 , c.[IgnoreZeros]
		, t.tablename AS TableName
		, ISNULL(e.Name, '') AS EmailGroupName
		FROM dbo.ASRSYSCustomReportsName c
			INNER JOIN ASRSysTables t ON t.tableid = c.BaseTable
			LEFT JOIN ASRSysEmailGroupName e ON c.OutputEmailAddr = e.EmailGroupID
		WHERE c.ID = @ReportID;

	-- Child Report info
	SELECT C.ChildTable, C.ChildFilter, C.ChildMaxRecords, T.TableName, C.ChildOrder
		FROM ASRSYSCustomReportsChildDetails C
		      INNER JOIN ASRSysTables T ON T.TableID = C.ChildTable 
		WHERE C.CustomReportID = @ReportID;

END


GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetFilterColumns]    Script Date: 02/01/2014 20:50:36 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetFilterColumns]
(
	@plngTableID 	integer, 
	@plngViewID 	integer,
	@psRealSource	varchar(8000) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the IDs and names of the columns available for the given table/view. */
	DECLARE @lngTableID		integer,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sRealSource 		varchar(255),
		@sTableName 		varchar(255),
		@iTableType			integer,
		@iChildViewID		integer,
		@sActualUserName	sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the table ID from the view ID (if required). */
	IF @plngTableID > 0 
	BEGIN
		SET @lngTableID = @plngTableID;
	END
	ELSE
	BEGIN
		SELECT @lngTableID = ASRSysViews.viewTableID
		FROM [dbo].[ASRSysViews]
		WHERE ASRSysViews.viewID = @plngViewID;
	END

	/* Get the table-type. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM [dbo].[ASRSysTables]
	WHERE ASRSysTables.tableID = @lngTableID;

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1;
	END
	ELSE
	BEGIN	
		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
	END

	/* Create a temporary table to hold our resultset. */
	DECLARE @ColumnInfo TABLE(
		columnID	integer,
		columnName	sysname,
		dataType	integer,
		readGranted	bit,
		size		integer,
		decimals	integer);

	/* Get the real source of the given screen's table/view. */
	IF (@fSysSecMgr = 1 )
	BEGIN
		/* Populate the temporary table with information on the order for the given table. */
		IF @plngViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @plngViewID;

	   		INSERT INTO @ColumnInfo (
				columnID, 
				columnName,
				dataType,
				readGranted,
				size,
				decimals)
			(SELECT ASRSysColumns.columnId, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				1,
				ASRSysColumns.size,
				ASRSysColumns.decimals				
			FROM ASRSysColumns
			INNER JOIN ASRSysViewColumns ON ASRSysColumns.columnId = ASRSysViewColumns.columnID
			WHERE ASRSysColumns.tableID = @lngTableID
				AND ASRSysColumns.columnType <> 4
				AND ASRSysColumns.columnType <> 3
				AND ASRSysColumns.dataType <> -3
				AND ASRSysColumns.dataType <> -4
				AND ASRSysViewColumns.viewID = @plngViewID
				AND ASRSysViewColumns.inView=1);
		END
		ELSE
		BEGIN
			IF @iTableType <> 2 /* ie. top-level or lookup */
			BEGIN
				/* RealSource is the table. */	
				SET @sRealSource = @sTableName;
			END 
			ELSE
			BEGIN
				SELECT @iChildViewID = childViewID
				FROM [dbo].[ASRSysChildViews2]
				WHERE tableID = @lngTableID
					AND role = @sUserGroupName;
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_');
					SET @sRealSource = left(@sRealSource, 255);
				END
			END

	   		INSERT INTO @ColumnInfo (
				columnID, 
				columnName,
				dataType,
				readGranted,
				size,
				decimals)
			(SELECT ASRSysColumns.columnId, 
				ASRSysColumns.columnName,
				ASRSysColumns.dataType,
				1,
				ASRSysColumns.size,
				ASRSysColumns.decimals				
			FROM ASRSysColumns
			WHERE ASRSysColumns.tableID = @lngTableID
				AND columnType <> 4
				AND columnType <> 3
				AND dataType <> -3
				AND dataType <> -4);
		END
	END
	ELSE
	BEGIN
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @plngViewID > 0 
			BEGIN	
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM [dbo].[ASRSysViews]
				WHERE viewID = @plngViewID;
			END
			ELSE
			BEGIN
				SET @sRealSource = @sTableName;
			END 
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @lngTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sRealSource = left(@sRealSource, 255);
			END
		END

   		 INSERT INTO @ColumnInfo (
			columnID, 
			columnName,
			dataType,
			readGranted,
			size,
			decimals)
		(SELECT 
			ASRSysColumns.columnId,
			syscolumns.name,
			ASRSysColumns.dataType,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END,
			ASRSysColumns.size,
			ASRSysColumns.decimals				
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		INNER JOIN ASRSysColumns ON syscolumns.name = ASRSysColumns.columnName
		WHERE p.action = 193 
			AND p.uid = @iUserGroupID
			AND ASRSysColumns.tableID = @lngTableID
			AND ASRSysColumns.columnType <> 4
			AND ASRSysColumns.columnType <> 3
			AND ASRSysColumns.dataType <> -3
			AND ASRSysColumns.dataType <> -4
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name = @sRealSource
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)));
	END

	SET @psRealSource = @sRealSource;

	/* Return the resultset. */
	SELECT columnID, columnName, dataType, size, decimals
	FROM @ColumnInfo 
	WHERE readGranted = 1
	ORDER BY columnName;
END
GO


/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetScreenDefinition]    Script Date: 02/01/2014 20:50:38 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenDefinition] (
	@piScreenID 		integer,
	@piViewID			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @iTabCount 		integer,
		@sTabCaptions		varchar(MAX),
		@sTabCaption		varchar(MAX),
		@fSysSecMgr			bit,
		@fInsertGranted		bit,
		@fDeleteGranted		bit,
		@sRealSource		sysname,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iTableID			integer,
		@iTableType			integer,
		@sTableName			sysname,
		@iTempAction		integer,
		@iChildViewID 		integer,
		@sActualUserName	varchar(250);

	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT
					
	/* Get the table type and name. */
	SELECT @iTableID = ASRSysScreens.tableID,
		@iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	/* Get the real source and insert/delete permissions for the table. */
	IF @fSysSecMgr = 1 
	BEGIN
		/* Permission must be granted for System or Security mangers. */
		SET @fInsertGranted = 1
		SET @fDeleteGranted = 1	

		/* Get the realSource of the table. */
		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @piViewID > 0 
			BEGIN
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM ASRSysViews
				WHERE viewID = @piViewID	
			END
			ELSE
			BEGIN
				/* RealSource is the table. */	
				SET @sRealSource = @sTableName
			END 
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)
			END
		END
	END
	ELSE
	BEGIN

		/* Permission must be read from the database  for Non-System and Non-Security mangers. */
		SET @fInsertGranted = 0
		SET @fDeleteGranted = 0	

		IF @iTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			IF @piViewID > 0 
			BEGIN	
				/* RealSource is the view. */	
				SELECT @sRealSource = viewName
				FROM ASRSysViews
				WHERE viewID = @piViewID
			END
			ELSE
			BEGIN
				SET @sRealSource = @sTableName
			END 

			/* Get the insert/delete permissions for the realSource. */
			DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT p.action
				FROM ASRSysProtectsCache p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				WHERE p.UID = @iUserGroupID AND p.action  IN (195, 196)
					AND sysobjects.name = @sRealSource
					AND ProtectType <> 206

			OPEN tableInfo_cursor
			FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
			WHILE (@@fetch_status = 0)
			BEGIN
				IF @iTempAction = 195
				BEGIN
					SET @fInsertGranted = 1
				END
				ELSE
				BEGIN
					SET @fDeleteGranted = 1	
				END
				FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
			END
			CLOSE tableInfo_cursor
			DEALLOCATE tableInfo_cursor
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sRealSource = left(@sRealSource, 255)

				/* Get appropriate child view if required. */
				DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
					SELECT p.action
					FROM ASRSysProtectsCache p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					WHERE sysobjects.name = @sRealSource
						AND p.UID = @iUserGroupID
						AND p.Action IN(193, 195, 196)
						AND ProtectType <> 206

				OPEN tableInfo_cursor
				FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
				WHILE (@@fetch_status = 0)
				BEGIN
					IF @iTempAction = 195
					BEGIN
						SET @fInsertGranted = 1
					END
					ELSE
					BEGIN
						IF @iTempAction = 196
						BEGIN
							SET @fDeleteGranted = 1	
						END
					END
					FETCH NEXT FROM tableInfo_cursor INTO @iTempAction
				END
				CLOSE tableInfo_cursor
				DEALLOCATE tableInfo_cursor
			END
		END
	END
	
	/* Get the tab page captions info. */
	SET @iTabCount = 0
	SET @sTabCaptions = ''
	
	DECLARE captions_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT caption 
		FROM ASRSysPageCaptions
		WHERE screenID = @piScreenID
		ORDER BY pageIndexID

	OPEN captions_cursor
	FETCH NEXT FROM captions_cursor INTO @sTabCaption
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTabCount > 0 SET @sTabCaptions = @sTabCaptions + char(9) 

		SET @iTabCount = @iTabCount + 1
		SET @sTabCaptions = @sTabCaptions + @sTabCaption
			
		FETCH NEXT FROM captions_cursor INTO @sTabCaption
	END
	CLOSE captions_cursor
	DEALLOCATE captions_cursor

	SELECT @sTableName AS tableName,
		@sRealSource AS realSource,
		@fInsertGranted AS insertGranted,
		@fDeleteGranted AS deleteGranted,
		height,
		width,
		fontName,
		fontSize,
		fontBold,
		fontItalic,
		fontStrikethru,
		fontUnderline,
		@iTabCount AS tabCount,
		@sTabCaptions AS tabCaptions
	FROM ASRSysScreens
	WHERE screenID = @piScreenID
	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetSummaryFields]    Script Date: 02/01/2014 20:50:38 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetSummaryFields] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer,
	@pfCanSelect		bit OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@sColumnName 		varchar(255),
		@fSelectGranted 	bit,
		@iCount				integer,
		@sActualUserName	sysname;

	SET @pfCanSelect = 0;

	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @ColumnPermissions TABLE(
				tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID)

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM ASRSysProtectsCache p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE p.UID = @iUserGroupID
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0))
					AND p.Action = 193

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sParentRealSource = left(@sParentRealSource, 255)
			END

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM ASRSysProtectsCache p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.UID = @iUserGroupID
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				AND p.Action = 193
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnName
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @sColumnName
	WHILE (@@fetch_status = 0) AND (@pfCanSelect = 0)
	BEGIN
		SET @fSelectGranted = 0

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @iCount = COUNT(*)
		FROM @ColumnPermissions
		WHERE columnName = @sColumnName
			AND granted = 1

		IF @iCount > 0 
		BEGIN
			SET @pfCanSelect = 1
		END

		FETCH NEXT FROM columnsCursor INTO @sColumnName
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor


	SELECT DISTINCT ASRSysSummaryFields.sequence, 
    	ASRSysSummaryFields.startOfGroup, 
		ASRSysColumns.columnName, 
		ASRSysColumns.columnId, 
		ASRSysColumns.dataType, 
		ASRSysColumns.size, 
		ASRSysColumns.decimals, 
		ASRSysColumns.controlType, 
		ASRSysColumns.alignment,
		ASRSysColumns.Use1000Separator
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns 
		ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;
	
END
GO

/****** Object:  StoredProcedure [dbo].[sp_ASRIntGetTrainingBookingParameters]    Script Date: 02/01/2014 20:50:39 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTrainingBookingParameters] (
	@piEmployeeTableID			integer	OUTPUT,
	@piCourseTableID			integer	OUTPUT,
	@piCourseCancelDateColumnID	integer	OUTPUT,
	@piTBTableID				integer	OUTPUT,
	@pfTBTableSelect			bit		OUTPUT,
	@pfTBTableInsert			bit		OUTPUT,
	@pfTBTableUpdate			bit		OUTPUT,
	@piTBStatusColumnID			integer	OUTPUT,
	@pfTBStatusColumnUpdate		bit		OUTPUT,
	@piTBCancelDateColumnID		integer	OUTPUT,
	@pfTBCancelDateColumnUpdate	bit		OUTPUT,
	@pfTBProvisionalStatusExists	bit	OUTPUT,
	@piWaitListTableID			integer	OUTPUT,
	@pfWaitListTableInsert			bit	OUTPUT,
	@pfWaitListTableDelete			bit	OUTPUT,
	@piWaitListCourseTitleColumnID		integer	OUTPUT,
	@pfWaitListCourseTitleColumnUpdate	bit	OUTPUT,
	@pfWaitListCourseTitleColumnSelect	bit	OUTPUT,
	@piBulkBookingDefaultViewID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @fOK			bit,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sTempName			sysname,
		@iTempAction		integer,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRealSource		sysname,
		@iStatusCount		integer,
		@iChildViewID		integer,
		@sTBTableName		sysname,
		@sWLTableName		sysname,
		@sActualUserName	sysname;
		
	/* Training Booking information. */
	SET @fOK = 1

	SET @piEmployeeTableID = 0

	SET @piCourseTableID = 0
	SET @piCourseCancelDateColumnID = 0

	SET @piTBTableID = 0
	SET @pfTBTableSelect = 0
	SET @pfTBTableInsert = 0
	SET @pfTBTableUpdate = 0
	SET @piTBStatusColumnID = 0
	SET @pfTBStatusColumnUpdate = 0
	SET @piTBCancelDateColumnID = 0
	SET @pfTBCancelDateColumnUpdate = 0
	SET @pfTBProvisionalStatusExists = 0

	SET @piWaitListTableID = 0
	SET @pfWaitListTableInsert = 0
	SET @pfWaitListTableDelete = 0
	SET @piWaitListCourseTitleColumnID = 0
	SET @pfWaitListCourseTitleColumnUpdate = 0
	SET @pfWaitListCourseTitleColumnSelect = 0

	SET @piBulkBookingDefaultViewID = 0
	
	/* Get the current user's group id. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	-- Activate module
	EXEC [dbo].[spASRIntActivateModule] 'TRAINING', @fOK OUTPUT

	/* Get the required training booking module paramaters. */
	IF @fOK = 1
	BEGIN
		/* Get the EMPLOYEE table information. */
		SELECT @piEmployeeTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_EmployeeTable'
		IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0

		/* Get the COURSE table information. */
		SELECT @piCourseTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTable'
		IF @piCourseTableID IS NULL SET @piCourseTableID = 0

		IF @piCourseTableID > 0
		BEGIN
			SELECT @piCourseCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_CourseCancelDate'
			IF @piCourseCancelDateColumnID IS NULL SET @piCourseCancelDateColumnID = 0
		END

		/* Get the TRAINING BOOKING table information. */
		SELECT @piTBTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_TrainBookTable'
		IF @piTBTableID IS NULL SET @piTBTableID = 0


		-- Cached view of the sysprotects table
		DECLARE @SysProtects TABLE([ID]				int,
								   [columns]		varbinary(8000),
								   [Action]			tinyint,
								   [ProtectType]	tinyint)
		INSERT INTO @SysProtects
		SELECT [ID], [Columns], [Action], [ProtectType] FROM ASRSysProtectsCache
			WHERE [UID] = @iUserGroupID AND [Action] IN (193, 195, 196, 197)

		IF @piTBTableID > 0
		BEGIN
			SELECT @sTBTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piTBTableID

			SELECT @piTBStatusColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookStatus'
			IF @piTBStatusColumnID IS NULL SET @piTBStatusColumnID = 0

			SELECT @piTBCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookCancelDate'
			IF @piTBCancelDateColumnID IS NULL SET @piTBCancelDateColumnID = 0

			SET @sCommand = 'SELECT @iStatusCount = COUNT(*)' +
				' FROM ASRSysColumnControlValues' +
				' WHERE columnID = ' + convert(nvarchar(100), @piTBStatusColumnID) +
				' AND value = ''P'''
			SET @sParamDefinition = N'@iStatusCount integer OUTPUT'
			EXEC sp_executesql @sCommand, @sParamDefinition, @iStatusCount OUTPUT
			IF @iStatusCount > 0 SET @pfTBProvisionalStatusExists = 1

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				/* System/Security managers must have all permissions granted. */
				SET @pfTBTableSelect = 1
				SET @pfTBTableInsert = 1
				SET @pfTBTableUpdate = 1
				SET @pfTBStatusColumnUpdate = 1
				SET @pfTBCancelDateColumnUpdate = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piTBTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN

					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTBTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (193, 195, 197)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN

						IF @iTempAction = 193
						BEGIN
							SET @pfTBTableSelect = 1
						END
						IF @iTempAction = 195
						BEGIN
							SET @pfTBTableInsert = 1
						END
						IF @iTempAction = 197
						BEGIN
							SET @pfTBTableUpdate = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @tbColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @tbColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piTBTableID
						AND (ASRSysColumns.columnId = @piTBStatusColumnID
							OR ASRSysColumns.columnId = @piTBCancelDateColumnID))
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfTBStatusColumnUpdate = granted

					FROM @tbColumnPermissions
					WHERE columnID = @piTBStatusColumnID
						AND action = 197
					IF @pfTBStatusColumnUpdate IS NULL SET @pfTBStatusColumnUpdate = 0

					SELECT @pfTBCancelDateColumnUpdate = granted
					FROM @tbColumnPermissions
					WHERE columnID = @piTBCancelDateColumnID
						AND action = 197
					IF @pfTBCancelDateColumnUpdate IS NULL SET @pfTBCancelDateColumnUpdate = 0

				END
			END
		END

		/* Get the waiting list table information. */
		SELECT @piWaitListTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_WaitListTable'
		IF @piWaitListTableID IS NULL SET @piWaitListTableID = 0

		IF @piWaitListTableID > 0
		BEGIN
			SELECT @sWLTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piWaitListTableID

			SELECT @piWaitListCourseTitleColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_WaitListCourseTitle'
			IF @piWaitListCourseTitleColumnID IS NULL SET @piWaitListCourseTitleColumnID = 0

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				SET @pfWaitListTableInsert = 1
				SET @pfWaitListTableDelete = 1
				SET @pfWaitListCourseTitleColumnUpdate = 1
				SET @pfWaitListCourseTitleColumnSelect = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piWaitListTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sWLTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (195, 196)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN
						IF @iTempAction = 195
						BEGIN
							SET @pfWaitListTableInsert = 1
						END
						IF @iTempAction = 196
						BEGIN
							SET @pfWaitListTableDelete = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction

					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @waitListColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @waitListColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piWaitListTableID
						AND ASRSysColumns.columnId = @piWaitListCourseTitleColumnID)
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfWaitListCourseTitleColumnUpdate = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 197
					IF @pfWaitListCourseTitleColumnUpdate IS NULL SET @pfWaitListCourseTitleColumnUpdate = 0

					SELECT @pfWaitListCourseTitleColumnSelect = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 193
					IF @pfWaitListCourseTitleColumnSelect IS NULL SET @pfWaitListCourseTitleColumnSelect = 0

				END
			END
		END

		/* Get the Bulk Booking default view. */
		SELECT @piBulkBookingDefaultViewID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_BulkBookingDefaultView'
		IF @piBulkBookingDefaultViewID IS NULL SET @piBulkBookingDefaultViewID = 0
	END
END
GO



/****** Object:  StoredProcedure [dbo].[spASRIntAllTablePermissions]    Script Date: 02/01/2014 20:52:28 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntAllTablePermissions]
(
	@psSQLLogin 		varchar(255)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
		@sUserGroupName				sysname,
		@sActualUserName			sysname;

	-- Cached view of the objects 
	DECLARE @SysObjects TABLE([ID]		integer PRIMARY KEY CLUSTERED,
							  [Name]	sysname);
		
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
							  
	INSERT INTO @SysObjects
		SELECT [ID], [Name] FROM sysobjects
		WHERE [Name] LIKE 'ASRSysCV%' AND [XType] = 'v'
		UNION 
		SELECT OBJECT_ID(tableName), TableName 
		FROM ASRSysTables
		WHERE NOT OBJECT_ID(tableName) IS null
		UNION
		SELECT OBJECT_ID(viewName), ViewName 
		FROM ASRSysViews
		WHERE NOT OBJECT_ID(viewName) IS null;

	-- Cached view of the sysprotects table
	DECLARE @SysProtects TABLE([ID]				integer,
							   [columns]		varbinary(8000),
							   [Action]			tinyint,
							   [ProtectType]	tinyint);
	INSERT INTO @SysProtects
	SELECT p.ID, p.Columns, p.Action, p.ProtectType FROM ASRSysProtectsCache p
		INNER JOIN @SysObjects o ON p.ID = o.ID
		WHERE p.UID = @iUserGroupID AND ((p.ProtectType <> 206 AND p.Action <> 193) OR (p.Action = 193 AND p.ProtectType IN (204,205)));

	SELECT UPPER(o.name) AS [name], p.action, ISNULL(cv.tableID,0) AS [tableid]
		FROM @SysProtects p
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE p.protectType <> 206
			AND p.action <> 193
	UNION
	SELECT UPPER(o.name) AS [name], 193, ISNULL(cv.tableID,0) AS [tableid]
		FROM sys.columns c
		INNER JOIN @SysProtects p ON (c.object_id = p.id
			AND p.action = 193 
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.column_id/8+1,1))&power(2,c.column_id&7)) = 0)))
		INNER JOIN @SysObjects o ON p.id = o.id
		LEFT JOIN ASRSysChildViews2 cv ON cv.childViewID = CASE SUBSTRING(o.Name, 1, 8) WHEN 'ASRSysCV' THEN SUBSTRING(o.Name, 9, CHARINDEX('#',o.Name, 0) - 9) ELSE 0 END
		WHERE (c.name <> 'timestamp' AND c.name <> 'ID')
			AND p.protectType IN (204, 205) 
		ORDER BY name;

END

GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGet1000SeparatorBlankIfZeroFindColumns]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGet1000SeparatorBlankIfZeroFindColumns]
GO

CREATE PROCEDURE [dbo].[spASRIntGet1000SeparatorBlankIfZeroFindColumns] (
	@pfError 				bit 			OUTPUT, 
	@piTableID 				integer, 
	@piViewID 				integer, 
	@piOrderID 				integer, 
	@ps1000SeparatorCols	varchar(MAX)	OUTPUT,
	@psBlankIfZeroCols		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@sType	 			varchar(10),
		@fSelectGranted 	bit,
		@iCount				integer,
		@bUse1000Separator	bit,
		@bBlankIfZero		bit,
		@sActualLoginName	varchar(250);

	/* Initialise variables. */
	SET @pfError = 0;
	SET @ps1000SeparatorCols = '';
	SET @psBlankIfZeroCols = '';
	SET @sRealSource = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualLoginName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID;

	IF (@sTableName IS NULL) 
	BEGIN 
		SET @pfError = 1;
		RETURN;
	END

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND [role] = @sUserGroupName;
		
		IF @iChildViewID IS null SET @iChildViewID = 0;
		
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	-- Cached view of sysprotects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000))
	INSERT INTO @SysProtects
		SELECT ID, ProtectType, [Columns] FROM ASRSysProtectsCache
		WHERE [UID] = @iUserGroupID AND Action = 193;

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @ColumnPermissions TABLE(
				tableID			integer,
				tableViewName	sysname,
				columnName		sysname,
				selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE p.protectType
				    WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @Sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, c.columnName, t.tableName, oi.type, c.Use1000Separator, c.BlankIfZero
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID AND oi.type = 'F'
			AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @sColumnName, @sColumnTableName, @sType, @bUse1000Separator, @bBlankIfZero;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END;
				SET @psBlankIfZeroCols = @psBlankIfZeroCols +
					CASE
						WHEN @bBlankIfZero = 1 THEN '1'
						ELSE '0'
					END;
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
	
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END;
				SET @psBlankIfZeroCols = @psBlankIfZeroCols +
					CASE
						WHEN @bBlankIfZero = 1 THEN '1'
						ELSE '0'
					END;
			END
			ELSE	
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1;

				IF @iCount > 0 
				BEGIN
					SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
						CASE
							WHEN @bUse1000Separator = 1 THEN '1'
							ELSE '0'
						END;
					SET @psBlankIfZeroCols = @psBlankIfZeroCols +
						CASE
							WHEN @bBlankIfZero = 1 THEN '1'
							ELSE '0'
						END;
				END
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @sColumnName, @sColumnTableName, @sType, @bUse1000Separator, @bBlankIfZero;
	END

	CLOSE orderCursor;
	DEALLOCATE orderCursor;

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetNavigationLinks]    Script Date: 02/01/2014 20:52:29 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetNavigationLinks]
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iCount					integer,
		@iViewID				integer,
		@iUtilType				integer, 
		@iUtilID				integer, 
		@iScreenID				integer, 
		@sURL					varchar(MAX),
		@iTableID				integer,
		@sTableName				sysname,
		@iTableType				integer,
		@sRealSource			sysname,
		@iChildViewID			integer,
		@sAccess				varchar(MAX),
		@fTableViewOK			bit,
		@pfCustomReportsRun		bit,
		@pfCalendarReportsRun	bit,
		@pfMailMergeRun			bit,
		@pfWorkflowRun			bit,
		@sGroupName				varchar(255),
		@sActualUserName		sysname,
		@iActualUserGroupID 	integer, 
		@sViewName				sysname,
		@iLinkType 				integer,			/* 0 = Hypertext, 1 = Button, 2 = Dropdown List */
		@fFindPage				bit

	/* See if the current user can run the defined Reports/Utilties. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER)))  = 'SA'
	BEGIN
		SET @pfCustomReportsRun = 1
		SET @pfCalendarReportsRun = 1
		SET @pfMailMergeRun = 1
		SET @pfWorkflowRun = 1
	END
	ELSE
	BEGIN

		EXEC dbo.spASRIntGetActualUserDetails
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT
			
		DECLARE @unionTable TABLE (ID int PRIMARY KEY CLUSTERED)

		INSERT INTO @unionTable 
			SELECT Object_ID(ViewName) 
			FROM ASRSysViews 
			WHERE viewID IN (SELECT viewID FROM ASRSysSSIViews)
				AND NOT Object_ID(ViewName) IS null
			UNION
			SELECT Object_ID(TableName) 
			FROM ASRSysTables 
			WHERE tableID IN (SELECT tableID FROM ASRSysSSIViews)
				AND NOT Object_ID(TableName) IS null
				AND tableID NOT IN (SELECT tableID 
					FROM ASRSysViewMenuPermissions 
					WHERE ASRSysViewMenuPermissions.groupName = @sGroupName
						AND ASRSysViewMenuPermissions.hideFromMenu = 1)
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null

		DECLARE @readableTables TABLE (name sysname)	
	
		INSERT INTO @readableTables
			SELECT OBJECT_NAME(p.id)
			FROM syscolumns
			INNER JOIN ASRSysProtectsCache p 
				ON (syscolumns.id = p.id
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0)))
			WHERE p.UID = @iActualUserGroupID
				AND syscolumns.name = 'timestamp'
				AND (p.ID IN (SELECT id FROM @unionTable))
				AND p.Action = 193 AND ProtectType IN (204, 205)
				OPTION (KEEPFIXED PLAN)

		SELECT @pfCustomReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CUSTOMREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	
		SELECT @pfCalendarReportsRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'CALENDARREPORTS'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfMailMergeRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'MAILMERGE'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'

		SELECT @pfWorkflowRun = ASRSysGroupPermissions.permitted
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories 
			ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
				AND ASRSysPermissionCategories.categoryKey = 	'WORKFLOW'
		LEFT OUTER JOIN ASRSysGroupPermissions 
			ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
				AND ASRSysGroupPermissions.groupName = @sGroupName
		WHERE ASRSysPermissionItems.itemKey = 'RUN'
	END

	DECLARE @links TABLE(
		LinkType			integer,
		Text1	 			varchar(200),
		Text2	 			varchar(200),
		SingleRecord		bit,
		LinkToFind			bit,
		TableID				integer,
		ViewID				integer ,
		PrimarySequence		integer,
		SecondarySequence	integer,
		FindPage			integer)

	/* Hypertext links. */
	/* Single Record View UNION Multiple Record Tables/Views UNION Table/View Hypertext Links link */
	INSERT INTO @links
		SELECT 0, linksLinkText, '', 1, 0, tableID, viewID, 0, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 1
			AND LEN(linksLinkText) > 0
		UNION
		SELECT 0, hypertextLinkText, '', 0, 1, tableID, viewID, 2, sequence, 0
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND LEN(hypertextLinkText) > 0
		UNION
		SELECT 0, linksLinkText, '', 0, 0, tableID, viewID, 1, sequence, 1
		FROM ASRSysSSIViews
		WHERE singleRecordView = 0
			AND tableid = @plngTableID
			AND viewID = @plngViewID

	/* Button links. */
	INSERT INTO @links
	SELECT 1, buttonLinkPromptText, buttonLinkButtonText, 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE buttonLink = 1

	/* DropdownList links. */
	INSERT INTO @links
	SELECT 2, dropdownListLinkText, '', 0, 1, tableID, viewID, 0, sequence, 0
	FROM ASRSysSSIViews
	WHERE dropdownListLink = 1


	/* Remove linkToFind links for links to views that are not readable by the user, or those that have no valid links defined for them. */
	DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ISNULL(l.viewID, -1) 'viewID', ASRSysViews.viewName, l.tableID, ASRSysTables.tableName
		FROM @links	l
		LEFT OUTER JOIN ASRSysViews	
			ON l.viewID = ASRSysViews.viewID
		INNER JOIN ASRSysTables
			ON l.tableID = ASRSysTables.tableID

	OPEN viewsCursor
	FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fTableViewOK = 0
		
		IF @iViewID > 0 
		BEGIN 
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sViewName
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @readableTables
			WHERE name = @sTableName
		END 

		IF @iCount > 0
		BEGIN

			DECLARE linksCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysSSIntranetLinks.utilityType,
							ASRSysSSIntranetLinks.utilityID,
							ASRSysSSIntranetLinks.screenID,
							ASRSysSSIntranetLinks.url
			FROM ASRSysSSIntranetLinks
			WHERE tableID = @iTableID 
				AND	viewID = @iViewID
	
			OPEN linksCursor
			FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			WHILE (@@fetch_status = 0) AND (@fTableViewOK = 0)
			BEGIN
				IF LEN(@sURL) > 0 OR (UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA')
				BEGIN
					SET @fTableViewOK = 1
				END
				ELSE
				BEGIN
					IF @iUtilID > 0
					BEGIN
						/* Check if the utility is deleted or hidden from the user. */
						EXECUTE dbo.spASRIntCurrentAccessForRole
												@sGroupName,
												@iUtilType,
												@iUtilID,
												@sAccess	OUTPUT
	
						IF @sAccess <> 'HD' 
						BEGIN
							IF @iUtilType = 2 AND @pfCustomReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 17 AND @pfCalendarReportsRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 9 AND @pfMailMergeRun = 1 SET @fTableViewOK = 1
							IF @iUtilType = 25 AND @pfWorkflowRun = 1 SET @fTableViewOK = 1
						END
					END
	
					IF (@iScreenID > 0) 
					BEGIN
						/* Do not display the link if the user does not have permission to read the defined view/tbale for the screen. */
						SELECT @iTableID = ASRSysTables.tableID, 
							@sTableName = ASRSysTables.tableName,
							@iTableType = ASRSysTables.tableType
						FROM ASRSysScreens
										INNER JOIN ASRSysTables 
										ON ASRSysScreens.tableID = ASRSysTables.tableID
						WHERE screenID = @iScreenID
	
						SET @sRealSource = ''
						IF @iTableType  = 2
						BEGIN
							SET @iChildViewID = 0
	
							/* Child table - check child views. */
							SELECT @iChildViewID = childViewID
							FROM ASRSysChildViews2
							WHERE tableID = @iTableID
								AND role = @sGroupName
							
							IF @iChildViewID IS null SET @iChildViewID = 0
							
							IF @iChildViewID > 0 
							BEGIN
								SET @sRealSource = 'ASRSysCV' + 
									convert(varchar(1000), @iChildViewID) +
									'#' + replace(@sTableName, ' ', '_') +
									'#' + replace(@sGroupName, ' ', '_')
							
								SET @sRealSource = left(@sRealSource, 255)
							END
						END
						ELSE
						BEGIN
							/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
							IF @iViewID > 0 
							BEGIN 
								SELECT @sRealSource = viewName
								FROM ASRSysViews
								WHERE viewID = @iViewID
							END
							ELSE
							BEGIN
								SELECT @sRealSource = tableName
								FROM ASRSysTables
								WHERE tableID = @iTableID
							END 
	
							IF @sRealSource IS null SET @sRealSource = ''
						END
	
						IF len(@sRealSource) > 0
						BEGIN
							SELECT @iCount = COUNT(*)
							FROM @readableTables
							WHERE name = @sRealSource
						
							IF @iCount = 1 SET @fTableViewOK = 1
						END
					END
				END
								
				FETCH NEXT FROM linksCursor INTO @iUtilType, @iUtilID, @iScreenID, @sURL
			END
			CLOSE linksCursor
			DEALLOCATE linksCursor

		END
		
		IF @fTableViewOK = 0
		BEGIN
			IF @iViewID > 0 
			BEGIN
				DELETE FROM @links
				WHERE viewID = @iViewID
			END
			ELSE
			BEGIN
				DELETE FROM @links
				WHERE tableid = @iTableID AND viewID = @iViewID
			END
		END
	
		FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName, @iTableID, @sTableName
	END
	CLOSE viewsCursor
	DEALLOCATE viewsCursor

	SELECT *
	FROM @links
	ORDER BY [primarySequence], [secondarySequence]

END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetParentValues]    Script Date: 02/01/2014 20:52:29 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetParentValues] (
	@piScreenID 		integer,
	@piParentTableID 	integer,
	@piParentRecordID 	integer
)
AS
BEGIN
	
	SET NOCOUNT ON;
	
	/* Return a recordset of the parent record values required for controls in the given screen. */
	DECLARE 
		@iUserGroupID		integer,
		@sRoleName			sysname,
		@iTempCount 		integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iParentChildViewID	integer,
		@sParentRealSource	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@sNewBit			varchar(MAX),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sParentSelectSQL	nvarchar(MAX),
		@sTemp				varchar(MAX),
		@fColumns			bit,
		@sSQL				nvarchar(MAX),
		@sActualUserName	sysname;

	SET @sParentSelectSQL  = 'SELECT ';
	SET @fColumns = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName sysname);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(tableViewName	sysname,
		columnName	sysname,
		granted		bit);

	SELECT @iTempCount = COUNT(*)
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysControls.columnID = ASRSysColumns.columnId
		AND ASRSysColumns.tableID = @piParentTableID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0;

	IF @iTempCount = 0 RETURN;

	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables
		WHERE tableID = @piParentTableID;

	IF @iParentTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			sysobjects.name,
			syscolumns.name,
			CASE p.protectType
			        	WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		INNER JOIN syscolumns ON p.id = syscolumns.id
		WHERE p.UID = @iUserGroupID
			AND p.action = 193 
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @piParentTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @piParentTableID)
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		SET @sParentRealSource = @sParentTableName;
	END
	ELSE
	BEGIN
		/* Get permitted child view on the parent table. */
		SELECT @iParentChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piParentTableID
			AND role = @sRoleName;
				
		IF @iParentChildViewID IS null SET @iParentChildViewID = 0;
				
		IF @iParentChildViewID > 0 
		BEGIN
			SET @sParentRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iParentChildViewID) +
				'#' + replace(@sParentTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sParentRealSource = left(@sParentRealSource, 255);

			INSERT INTO @columnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysControls
	INNER JOIN ASRSysColumns ON ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE ASRSysControls.screenID = @piScreenID
		AND ASRSysControls.columnID > 0
		AND ASRSysColumns.tableID = @piParentTableID;
	
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
	
		/* Get the select permission on the column. */
		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @columnPermissions
		WHERE tableViewName = @sParentRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			IF @fColumns = 1
			BEGIN
				SET @sTemp = ',';
				SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
			END

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sNewBit = 'convert(varchar(10), ' + @sParentRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
			END
			ELSE
			BEGIN
				 /* Non-date */
				SET @sNewBit = @sParentRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
			END

			SET @fColumns = 1;
			SET @sParentSelectSQL = @sParentSelectSQL + @sNewBit;
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @columnPermissions
			WHERE tableViewName <> @sParentRealSource
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';

				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sSelectString = @sSelectString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
				END

				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);
				END

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = @sSelectString +
					' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

				IF @fColumns = 1
				BEGIN
					SET @sTemp = ',';
					SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;
				END

				SET @fColumns = 1;
				SET @sParentSelectSQL = @sParentSelectSQL + @sSelectString;
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF @fColumns = 0 RETURN;

	SET @sTemp = ' FROM ' + @sParentRealSource;
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName
	FROM @joinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sParentRealSource + '.ID = ' + @sTableViewName + '.ID';
		SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

		FETCH NEXT FROM joinCursor INTO @sTableViewName;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SET @sTemp = ' WHERE ' + @sParentRealSource + '.ID = ' + convert(varchar(100), @piParentRecordID);
	SET @sParentSelectSQL = @sParentSelectSQL + @sTemp;

	EXECUTE sp_executeSQL @sParentSelectSQL;
	
END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetSelfServiceRecordID]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetSelfServiceRecordID];
GO


CREATE PROCEDURE [dbo].[spASRIntGetSelfServiceRecordID] (
	@piRecordID		integer 		OUTPUT,
	@piRecordCount	integer 		OUTPUT,
	@piViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iUserGroupID	integer,
		@sUserGroupName			sysname,
		@sActualUserName		sysname,
		@sViewName		sysname,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@iRecordID			integer,
		@iRecordCount		integer, 
		@fSysSecMgr			bit,
		@fAccessGranted		bit;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	SET @iRecordID = 0;
	SET @iRecordCount = 0;

	SELECT @sViewName = viewName
		FROM ASRSysViews
		WHERE viewID = @piViewID;

	IF len(@sViewName) > 0
	BEGIN
		/* Check if the user has permission to read the Self-service view. */
		exec spASRIntSysSecMgr @fSysSecMgr OUTPUT;

		IF @fSysSecMgr = 1
		BEGIN
			SET @fAccessGranted = 1;
		END
		ELSE
		BEGIN
		
			SELECT @fAccessGranted =
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM ASRSysProtectsCache p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.UID = @iUserGroupID
				AND p.action = 193 
				AND syscolumns.name = 'ID'
				AND sysobjects.name = @sViewName
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	
		IF @fAccessGranted = 1
		BEGIN
			SET @sCommand = 'SELECT @iValue = COUNT(ID)' + 
				' FROM ' + @sViewName;
			SET @sParamDefinition = N'@iValue integer OUTPUT';
			EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordCount OUTPUT;

			IF @iRecordCount = 1 
			BEGIN
				SET @sCommand = 'SELECT @iValue = ' + @sViewName + '.ID ' + 
					' FROM ' + @sViewName;
				SET @sParamDefinition = N'@iValue integer OUTPUT';
				EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordID OUTPUT;
			END
		END
	END

	SET @piRecordID = @iRecordID;
	SET @piRecordCount = @iRecordCount;
END
GO

/****** Object:  StoredProcedure [dbo].[spASRIntGetSummaryValues]    Script Date: 02/01/2014 20:52:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[spASRIntGetSummaryValues] (
	@piHistoryTableID	integer,
	@piParentTableID 	integer,
	@piParentRecordID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@fSysSecMgr			bit,
		@iParentTableType	integer,
		@sParentTableName	varchar(255),
		@iChildViewID 		integer,
		@sParentRealSource 	varchar(255),
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sRootTable 		varchar(255),
		@sSelectString 		varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	varchar(255),
		@sTemp				varchar(MAX),
		@sSelectSQL			nvarchar(MAX),
		@sActualUserName	sysname,
		@strTempSepText		varchar(500);

	SET @sSelectSQL = '';
		
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
		AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
		OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
		AND ASRSysGroupPermissions.permitted = 1
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';

	/* Get the parent table type and name. */
	SELECT @iParentTableType = tableType,
		@sParentTableName = tableName
	FROM ASRSysTables 
	WHERE ASRSysTables.tableID = @piParentTableID;

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(tableViewName	sysname);

	/* Create a temporary table of the 'read' column permissions for all tables/views used. */
	DECLARE @columnPermissions TABLE (tableViewName	sysname,
				columnName	sysname,
				granted		bit);

	-- Cached view of SysProtects
	DECLARE @SysProtects TABLE([ID] int, [ProtectType] tinyint, [Columns] varbinary(8000));

	/* Get the column permissions for the parent table, and any associated views. */
	IF @fSysSecMgr = 1 
	BEGIN
		INSERT INTO @ColumnPermissions
		SELECT 
			@sParentTableName,
			ASRSysColumns.columnName,
			1
		FROM ASRSysColumns 
		WHERE ASRSysColumns.tableID = @piParentTableID;
	END
	ELSE
	BEGIN
		IF @iParentTableType <> 2 /* ie. top-level or lookup */
		BEGIN

			-- Get list of views/table columns that are summary fields
			DECLARE @SummaryColumns TABLE ([ID] int, [TableName] sysname, [ColumnName] sysname, [ColID] int)
			INSERT @SummaryColumns
				SELECT sysobjects.id, sysobjects.name,
					syscolumns.name, syscolumns.ColID
				FROM sysobjects
				INNER JOIN syscolumns ON sysobjects.id = syscolumns.id
				WHERE sysobjects.name IN (SELECT ASRSysTables.tableName
												FROM ASRSysTables
												WHERE ASRSysTables.tableID = @piParentTableID
											UNION SELECT ASRSysViews.viewName
												FROM ASRSysViews
												WHERE ASRSysViews.viewTableID = @piParentTableID)
					AND syscolumns.name IN (SELECT ac.ColumnName
												FROM ASRSysSummaryFields am
												INNER JOIN ASRSysColumns ac ON am.ParentColumnID = ac.ColumnID
												WHERE HistoryTableID = @piHistoryTableID);

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM ASRSysProtectsCache
				WHERE [UID] = @iUserGroupID AND Action = 193;

			-- Generate security context on selected columns
			INSERT INTO @ColumnPermissions
				SELECT sm.TableName,
					sm.ColumnName,
					CASE p.protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN @SummaryColumns sm ON p.id = sm.id
				WHERE (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sm.colid/8+1,1))&power(2,sm.colid&7)) = 0));

		END
		ELSE
		BEGIN
			/* Get permitted child view on the parent table. */
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @piParentTableID
				AND role = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sParentRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sParentTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sParentRealSource = left(@sParentRealSource, 255);
			END

			INSERT INTO @SysProtects
				SELECT ID, ProtectType, Columns FROM ASRSysProtectsCache
				WHERE [UID] = @iUserGroupID AND Action = 193;

			INSERT INTO @ColumnPermissions
			SELECT 
				@sParentRealSource,
				syscolumns.name,
				CASE p.protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sParentRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
	END

	/* Populate the temporary table with info for all columns used in the summary controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnId, 
		ASRSysColumns.columnName, 
		ASRSysColumns.dataType
	FROM ASRSysSummaryFields 
	INNER JOIN ASRSysColumns ON ASRSysSummaryFields.parentColumnID = ASRSysColumns.columnId
	WHERE ASRSysSummaryFields.historyTableID = @piHistoryTableID
		AND ASRSysColumns.tableID = @piParentTableID 
	ORDER BY ASRSysSummaryFields.sequence;

	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the select permission on the column. */

		/* Check if the column is selectable directly from the table. */
		SELECT @fSelectGranted = granted
		FROM @ColumnPermissions
		WHERE tableViewName = @sParentTableName
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		IF @fSelectGranted = 1 
		BEGIN
			/* Column COULD be read directly from the parent table. */
			SET @sTemp = ',';
			IF LEN(@sSelectSQL) > 0
				SET @sSelectSQL = @sSelectSQL + @sTemp;

			IF @iColumnDataType = 11 /* Date */
			BEGIN
				 /* Date */
				SET @sTemp = 'convert(varchar(10), ' + @sParentTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END 
			ELSE
			BEGIN
				 /* Non-date */
				SET @sTemp = @sParentTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sSelectSQL = @sSelectSQL + @sTemp;
			END

			/* Add the table to the array of tables/views to join if it has not already been added. */
			SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sParentTableName;

			IF @iTempCount = 0
			BEGIN
				INSERT INTO @joinParents (tableViewName) VALUES(@sParentTableName);
			END
		END
		ELSE	
		BEGIN
			/* Column could NOT be read directly from the parent table, so try the views. */
			SET @sSelectString = '';

			DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @ColumnPermissions
			WHERE tableViewName <> @sParentTableName
				AND columnName = @sColumnName
				AND granted = 1;

			OPEN viewCursor;
			FETCH NEXT FROM viewCursor INTO @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				/* Column CAN be read from the view. */
				SET @fSelectGranted = 1;

				IF len(@sSelectString) > 0 SET @sSelectString = @sSelectString + ',';

				IF @iColumnDataType = 11 /* Date */
					SET @sSelectString = @sSelectString + 'convert(varchar(10),' + @sViewName + '.' + @sColumnName + ',101)';
				ELSE
					SET @sSelectString = @sSelectString + @sViewName + '.' + @sColumnName;


				/* Add the view to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName;

				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName) VALUES(@sViewName);

				FETCH NEXT FROM viewCursor INTO @sViewName;
			END
			CLOSE viewCursor;
			DEALLOCATE viewCursor;

			IF len(@sSelectString) > 0
			BEGIN
				SET @sSelectString = 'COALESCE(' + @sSelectString + ', NULL) AS [' + convert(varchar(100), @iColumnID) + ']';
				SET @sTemp = ',';

				IF LEN(@sSelectSQL) > 0
					SET @sSelectSQL = @sSelectSQL + @sTemp;

				SET @sTemp = @sSelectString;
				SET @sSelectSQL = @sSelectSQL + @sTemp;
				
			END
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName, @iColumnDataType;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = 'SELECT ' + @sSelectSQL ;

		SELECT @iTempCount = COUNT(tableViewName)
			FROM @joinParents;

		IF @iTempCount = 1 
		BEGIN
			SELECT TOP 1 @sRootTable = tableViewName
			FROM @joinParents;
		END
		ELSE
		BEGIN
			SET @sRootTable = @sParentTableName;
		END

		SET @sTemp = ' FROM ' + @sRootTable;
		SET @sSelectSQL = @sSelectSQL + @sTemp;

		/* Add the join code. */
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName
			FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @sTableViewName <> @sRootTable
			BEGIN
				SET @sTemp = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRootTable + '.ID' + ' = ' + @sTableViewName + '.ID';
				SET @sSelectSQL = @sSelectSQL + @sTemp
			END

			FETCH NEXT FROM joinCursor INTO @sTableViewName;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		SET @sTemp = ' WHERE ' + @sRootTable + '.id = ' + convert(varchar(255), @piParentRecordID);
		SET @sSelectSQL = @sSelectSQL + @sTemp;

	END

	-- Run the constructed SQL SELECT string.
	EXEC sp_executeSQL @sSelectSQL;

END

GO

CREATE PROCEDURE [dbo].[spASRIntGetColumnPermissions]
	(@SourceList AS dbo.dataPermissions READONLY)
AS
BEGIN
	
	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
			@sActualUserName	sysname,
			@sRoleName				sysname;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT UPPER(so.name) AS tableViewName, UPPER(syscolumns.name) AS columnName, p.action
		, CASE p.protectType WHEN 205 THEN 1 WHEN 204 THEN 1 ELSE 0 END AS permission, sl.*
		FROM ASRSysProtectsCache p
		INNER JOIN sysobjects so ON p.id = so.id
		INNER JOIN @SourceList sl ON sl.name = so.name
		INNER JOIN syscolumns ON p.id = syscolumns.id 
		WHERE p.uid = @iUserGroupID
			AND (p.action = 193 OR p.action = 197)
			AND syscolumns.name <> 'timestamp'
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0) OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		ORDER BY tableViewName;

END

GO

CREATE PROCEDURE dbo.spASRIntSetupTablesCollection
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID		integer,
			@sActualUserName	sysname,
			@sRoleName			sysname,
			@SysSecPerms		integer = 0;

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;
	
	SELECT @SysSecPerms = COUNT(*) 
		FROM ASRSysGroupPermissions
			INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
			INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
			INNER JOIN sysusers a ON ASRSysGroupPermissions.groupName = a.name AND a.name = @sRoleName
		WHERE (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER' OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1 AND ASRSysPermissionCategories.categorykey = 'MODULEACCESS';

	-- Security Info
	SELECT @sActualUserName AS [ActualLogin], @sRoleName AS [UserGroup], SYSTEM_USER AS [UserName]
		, CASE WHEN @SysSecPerms > 0 THEN 1 ELSE 0 END AS [IsSysSecMgr];

		
	-- Individual system permissions		
	SELECT ASRSysPermissionCategories.categoryKey + '_' + ASRSysPermissionItems.itemKey AS [key],
		CASE
			WHEN NOT ASRSysGroupPermissions.permitted IS NULL THEN ASRSysGroupPermissions.permitted
			ELSE 0
		END AS [permitted]
	FROM ASRSysPermissionItems
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	LEFT OUTER JOIN ASRSysGroupPermissions ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
		AND ASRSysGroupPermissions.groupName = @sRoleName;


	-- Views
	SELECT v.viewID, UPPER(v.viewName) AS [viewname], t.tableID
		, UPPER(t.tableName) AS [tablename], t.tableType, t.defaultOrderID, t.recordDescExprID
		FROM ASRSysViews v
			INNER JOIN ASRSysTables t ON v.viewTableID = t.tableID;

END


GO

CREATE PROCEDURE [dbo].[spASRIntGetSessionSettings]
AS
BEGIN

	SET NOCOUNT ON;

	-- Declarations and their default values.
	DECLARE @BlockSize				integer = 1000,
			@PrimaryStartMode		tinyint = 3,
			@HistoryStartMode		tinyint = 3,
			@LookupStartMode		tinyint = 2,
			@QuickAccessStartMode	tinyint = 1,
			@ExprColourMode			integer	= 1,
			@ExprNodeMode			tinyint	= 1;

	DECLARE @SupportTelNo			varchar(50) = '+44 (0)1582 714820',
			@SupportFax				varchar(50) = '+44 (0)1582 714814',
			@SupportEmail			varchar(50) = 'service.delivery@advancedcomputersoftware.com',
			@SupportWebpage			varchar(50)	= 'http://webfirst.advancedcomputersoftware.com',
			@DesktopColour			varchar(20) = 2147483660;



	SELECT @BlockSize = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'IntranetFindWindow' AND settingKey = 'BlockSize';

	SELECT @PrimaryStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'Primary';

	SELECT @HistoryStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'History';

	SELECT @LookupStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'LookUp';

	SELECT @QuickAccessStartMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'RecordEditing' AND settingKey = 'QuickAccess';

	SELECT @ExprColourMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'ExpressionBuilder' AND settingKey = 'ViewColours';

	SELECT @ExprNodeMode = settingValue
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER AND section = 'ExpressionBuilder' AND settingKey = 'NodeSize';
	
	SELECT @SupportTelNo = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Telephone No';

	SELECT @SupportFax = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Fax';

	SELECT @SupportEmail = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'Email';
		
	SELECT @SupportWebpage = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'Support' AND settingKey = 'WebPage';

	SELECT @DesktopColour = settingValue
		FROM ASRSysSystemSettings
		WHERE section = 'DesktopSetting' AND settingKey = 'BackgroundColour';


	SELECT @BlockSize			AS [BlockSize]
		, @PrimaryStartMode		AS [PrimaryStartMode]
		, @HistoryStartMode		AS [HistoryStartMode]
		, @LookupStartMode		AS [LookupStartMode]
		, @QuickAccessStartMode	AS [QuickAccessStartMode]
		, @ExprColourMode		AS [ExprColourMode]
		, @ExprColourMode		AS [ExprColourMode]
		, @ExprNodeMode			AS [ExprNodeMode]
		, @SupportTelNo			AS [SupportTelNo]
		, @SupportFax			AS [SupportFax]
		, @SupportEmail			AS [SupportEmail]
		, @SupportWebpage		AS [SupportWebpage]
		, @DesktopColour		AS [DesktopColour];


END

GO

CREATE PROCEDURE [dbo].[spASRGetMetadata] (@Username varchar(255))
WITH ENCRYPTION
AS
BEGIN

	DECLARE @licenseKey			varchar(MAX);

	EXEC [dbo].[sp_ASRIntGetSystemSetting] 'Licence', 'Key', 'moduleCode', @licenseKey OUTPUT, 0, 0;


	SELECT TableID, TableName, TableType, DefaultOrderID, RecordDescExprID FROM dbo.ASRSysTables;

	SELECT ColumnID, TableID, ColumnName, DataType, Use1000Separator, Size, Decimals FROM dbo.ASRSysColumns;

	SELECT ParentID, ChildID FROM dbo.ASRSysRelations;

	SELECT ModuleKey, ParameterKey, ISNULL(ParameterValue,'') AS ParameterValue, ParameterType FROM dbo.ASRSysModuleSetup;

	SELECT * FROM dbo.ASRSysUserSettings WHERE Username = @Username;

	SELECT functionID, functionName, returnType FROM dbo.ASRSysFunctions;

	SELECT * FROM dbo.ASRSysFunctionParameters ORDER BY functionID, parameterIndex;

	SELECT * FROM dbo.ASRSysOperators;

	SELECT * FROM dbo.ASRSysOperatorParameters ORDER BY OperatorID, parameterIndex;
	
	-- Which modules are enabled?
	SELECT 'WORKFLOW' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,1024) AS [enabled]
	UNION
	SELECT 'PERSONNEL' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,1) AS [enabled]
	UNION
	SELECT 'ABSENCE' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,4) AS [enabled]
	UNION
	SELECT 'TRAINING' AS [name],  dbo.udfASRNetIsModuleLicensed(@licenseKey,8) AS [enabled]
	UNION
	SELECT  'VERSIONONE' AS [name], dbo.udfASRNetIsModuleLicensed(@licenseKey,2048) AS [enabled];


	-- Selected system settings
	SELECT * FROM ASRSysSystemSettings;



END



GO

CREATE PROCEDURE dbo.spASRIntGetExpressionAndComponents
	(@ExpressionID integer, @ExpressionType integer)
AS
BEGIN

	IF @ExpressionType = 14
		SELECT name, 0 AS tableID, returnType, type, parentComponentID, Username,
			access, description, ViewInColour, CONVERT(integer, timestamp) AS intTimestamp, '' AS tableName
			FROM ASRSysExpressions
			WHERE exprID = @ExpressionID;

	ELSE
		SELECT e.name, ISNULL(e.TableID, 0) AS [tableID]
			, ISNULL(e.returnType, 0) AS [returntype]
			, ISNULL(e.type, 0) AS [type]
			, ISNULL(e.parentComponentID, 0) AS [parentComponentID]
			, ISNULL(e.Username, SYSTEM_USER) AS [username]
			, ISNULL(e.access, 'RW') AS [access]
			, ISNULL(e.description,'') AS [description]
			, ISNULL(e.ViewInColour,0) AS [ViewInColour]
			, CONVERT(integer, e.timestamp) AS [intTimestamp]
			, ISNULL(t.tableName,'') AS [tablename]
			FROM ASRSysExpressions e
				LEFT OUTER JOIN ASRSysTables t ON e.TableID = t.tableID
			WHERE exprID = @ExpressionID;

	-- Components for this expression
	SELECT * FROM ASRSysExprComponents WHERE exprID = @ExpressionID ORDER BY componentID;

END

GO


CREATE PROCEDURE [dbo].[spASRIntGetUniqueExpressionID](
	@settingkey AS varchar(50),
	@settingvalue AS integer OUTPUT)
AS
BEGIN

	SELECT @settingvalue = [SettingValue] FROM [asrsyssystemsettings] WHERE [Section] = 'AUTOID' AND [SettingKey] = @settingkey;

	IF @settingvalue IS NULL
		INSERT ASRSysSystemSettings([Section], [SettingKey], [SettingValue]) VALUES ('AUTOID', @settingkey, 1);	
	ELSE
	BEGIN
		SET @settingvalue = @settingvalue + 1
		UPDATE ASRSysSystemSettings SET [SettingValue] = @settingvalue  WHERE [Section] ='AUTOID' AND [SettingKey] = @settingkey;
	END

END

GO


---------------------------------------------------------------
-- Script 8.0.26 (And "ghost" items during script merge)
---------------------------------------------------------------

IF NOT EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRSysMobileCheckPendingWorkflowSteps]') AND xtype in (N'P'))
BEGIN
	declare @nvar nvarchar(MAX);

	SET @nvar = 'CREATE PROCEDURE [dbo].[spASRSysMobileCheckPendingWorkflowSteps] (
		@psKeyParameter varchar(MAX))
	AS
	BEGIN

		SELECT '''' AS [name], '''' AS [description], '''' AS [URL];

	END'

	EXECUTE sp_executeSQL @nvar;

END

GO

IF NOT EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntCheckPendingWorkflowSteps]') AND xtype in (N'P'))
BEGIN
	declare @nvar nvarchar(MAX);

	SET @nvar = 'CREATE PROCEDURE [dbo].[spASRIntCheckPendingWorkflowSteps]
	AS
	BEGIN

		SELECT '''' AS [description], '''' AS [URL];

	END'

	EXECUTE sp_executeSQL @nvar;

END

GO
CREATE PROCEDURE [dbo].[spASRWorkflowOutOfOfficeConfigured]
(
    @pfOutOfOfficeConfigured bit output
)
AS
BEGIN
	DECLARE	@iCount	integer;

	-- Check if the SP that checks if the current user is OutOfOffice exists
	SELECT @iCount = COUNT(*)
	FROM sysobjects
	WHERE id = object_id('spASRWorkflowOutOfOfficeCheck')
		AND sysstat & 0xf = 4;

	IF @iCount > 0 
	BEGIN
		-- Check if the SP that sets/resets the current user to be OutOfOffice exists
		SELECT @iCount = COUNT(*)
		FROM sysobjects
		WHERE id = object_id('spASRWorkflowOutOfOfficeSet')
			AND sysstat & 0xf = 4;
	END

	IF @iCount > 0 
	BEGIN
		-- Check if the the Activation column has been defined
		SELECT @iCount = convert(integer, isnull(parameterValue, '0'))
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_WORKFLOW'
			AND parameterKey = 'Param_DelegationActivatedColumn';
	END

	SET @pfOutOfOfficeConfigured = 
	CASE	
		WHEN @iCount > 0 THEN 1
		ELSE 0
	END;
END

GO
CREATE PROCEDURE dbo.[spASRIntGetLoginDetails]
AS
BEGIN

	DECLARE @psUserName			nvarchar(MAX), 
			@psUserGroup		nvarchar(MAX),
			@piUserGroupID		integer,
			@licenseKey			varchar(MAX),
			@sSysManagerVersion	varchar(200),
			@sIntranetDBVersion	varchar(200),
			@bIsLocked			bit = 0,
			@sLockMessage		varchar(MAX) = '',
			@bUpdateInProgress	bit = 0;

	-- Get security info for this user
	EXEC [dbo].[spASRIntGetActualUserDetails] @psUserName OUTPUT, @psUserGroup OUTPUT, @piUserGroupID OUTPUT
	SELECT @psUserName, @psUserGroup, @piUserGroupID

	-- DB information
	SELECT @licenseKey = SettingValue FROM ASRSysSystemSettings WHERE section = 'Licence' AND SettingKey = 'Key';		
	SELECT @sSysManagerVersion = SettingValue FROM ASRSysSystemSettings WHERE section = 'database' AND SettingKey = 'version';		
	SELECT @sIntranetDBVersion = SettingValue FROM ASRSysSystemSettings WHERE section = 'intranet' AND SettingKey = 'version';		

	-- Lock information
	IF EXISTS(SELECT * FROM ASRSysLock WHERE Priority = 1)
	BEGIN
		SELECT @sLockMessage = SettingValue FROM ASRSysSystemSettings WHERE section = 'messaging' AND SettingKey = 'lockmessage';
		SET @bUpdateInProgress = 1;
	END

	IF EXISTS(SELECT * FROM ASRSysLock WHERE Priority = 2)
	BEGIN
		SET @bIsLocked = 1;
		SET @bUpdateInProgress = 1;
	END

	SELECT @licenseKey AS LicenseKey, @sSysManagerVersion AS SysMgrDBVersion, @sIntranetDBVersion AS IntDBVersion,
			@bUpdateInProgress AS UpdateInProgress, @bIsLocked AS IsLocked, @sLockMessage AS LockMessage

	-- Permissions for this user
	SELECT c.categoryKey, i.itemKey, i.categoryID, g.itemID, g.permitted AS permitted
		FROM [ASRSysGroupPermissions] g
			INNER JOIN ASRSysPermissionItems i ON i.itemID = g.itemID
			INNER JOIN ASRSysPermissionCategories c ON c.categoryID = i.categoryID
		WHERE g.groupName = @psUserGroup
		ORDER BY i.categoryID;

	-- Server roles
	SELECT IS_SRVROLEMEMBER('serveradmin') AS IsServerAdmin
		, IS_SRVROLEMEMBER('securityadmin') AS IsSecurityAdmin
		, IS_SRVROLEMEMBER('sysadmin') AS IsSysAdmin;

END
GO

CREATE PROCEDURE dbo.[spASRIntCopyRecordPostSave] (
	@tableID		integer,
	@FromRecordID	integer,
	@ToRecordID		integer)
WITH EXECUTE AS OWNER
AS
BEGIN
	DECLARE @nvarCommand nvarchar(MAX) = '',
			@tablename		varchar(255) = '',
			@updateFields	varchar(MAX) = '',
			@readFields		varchar(MAX) = ''

	SELECT @updateFields = @updateFields + CASE WHEN LEN(@updateFields) > 0 THEN ', ' ELSE '' END + c.columnname + ' = newData.' + c.columnname,
		   @readFields = @readFields + CASE WHEN LEN(@readFields) > 0 THEN ', ' ELSE '' END + c.columnname 
	FROM ASRSysColumns c
	WHERE c.tableid = @tableID AND c.datatype IN (-3, -4);

	SELECT @tablename = t.tablename
		FROM ASRSysTables t
		WHERE t.tableid = @tableID;

	IF LEN(@updateFields) > 0
	BEGIN
		SET @nvarCommand = 'UPDATE ' + @tableName + ' SET ' + @updateFields 
			+ ' FROM (SELECT ' + @readFields + ' FROM ' + @tableName + ' WHERE ID = ' + convert(varchar(10), @FromRecordID)
			+ ') newdata WHERE ID = ' + convert(varchar(10), @ToRecordID);

		EXECUTE sp_executeSQL @nvarCommand;

	END

END


GO
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetCrosstabReportData]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetCrosstabReportData]
GO

CREATE PROCEDURE [dbo].[spASRIntGetCrosstabReportData](
	@tablename					char(30),
	@recordDescid				integer,
	@isAbsenceBreakdown	bit,
	@startDate					datetime = NULL,
	@endDate						datetime = NULL)
AS
BEGIN

	DECLARE @sSQL						nvarchar(MAX),
					@ParmDefinition nvarchar(500);

	IF EXISTS (SELECT * FROM sysobjects WHERE type = 'P' AND name = 'sp_ASRExpr_' + convert(varchar,@RecordDescID))
	BEGIN
		SET @sSQL = '
			declare @tableid int;
			declare @recordid int;
			declare @recorddesc varchar(MAX);

			DECLARE table_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ID FROM '+ convert(nvarchar(MAX), @tablename) +'; 

			OPEN table_cursor;
			FETCH NEXT FROM table_cursor INTO @recordid;

			WHILE (@@fetch_status = 0)
			BEGIN
				exec sp_ASRExpr_' + convert(nvarchar(128),@RecordDescID) + ' @RecordDesc OUTPUT, @Recordid
				UPDATE ' + convert(nvarchar(128), @tablename) + ' SET RecDesc = @recordDesc WHERE id = @Recordid; 
				FETCH NEXT FROM table_cursor INTO @recordid
			END
			CLOSE table_cursor
			DEALLOCATE table_cursor';
		EXEC sp_executesql @ssql;

	END

	IF @isAbsenceBreakdown = 1
	BEGIN
		SET @ParmDefinition = N'@pdReportStart datetime, @pdReportEnd datetime, @pcReportTableName char(30)';
		EXECUTE sp_executeSQL N'sp_ASR_AbsenceBreakdown_Run @pdReportStart, @pdReportEnd, @pcReportTableName', @ParmDefinition
			, @pdReportStart = @startDate, @pdReportEnd = @endDate, @pcReportTableName = @tablename
	END

	SET @sSQL ='SELECT * FROM ' + @tablename;
	EXECUTE sp_executeSQL @sSQL;

END



GO
DECLARE @sSQL nvarchar(MAX),
		@sGroup sysname,
		@sObject sysname,
		@sObjectType char(2);

/*---------------------------------------------*/
/* Ensure the required permissions are granted */
/*---------------------------------------------*/
DECLARE curObjects CURSOR LOCAL FAST_FORWARD FOR
SELECT sysobjects.name, sysobjects.xtype
FROM sysobjects
		 INNER JOIN sysusers ON sysobjects.uid = sysusers.uid
WHERE (((sysobjects.xtype = 'p') AND (sysobjects.name LIKE 'sp_asr%' OR sysobjects.name LIKE 'spasr%'))
		OR ((sysobjects.xtype = 'u') AND (sysobjects.name LIKE 'asrsys%'))
		OR ((sysobjects.xtype = 'fn') AND (sysobjects.name LIKE 'udf_ASRFn%')))
		AND (sysusers.name = 'dbo')

OPEN curObjects
FETCH NEXT FROM curObjects INTO @sObject, @sObjectType
WHILE (@@fetch_status = 0)
BEGIN
		IF rtrim(@sObjectType) = 'P' OR rtrim(@sObjectType) = 'FN'
		BEGIN
				SET @sSQL = 'GRANT EXEC ON [' + @sObject + '] TO [ASRSysGroup]'
				EXEC(@sSQL)
		END
		ELSE
		BEGIN
				SET @sSQL = 'GRANT SELECT,INSERT,UPDATE,DELETE ON [' + @sObject + '] TO [ASRSysGroup]'
				EXEC(@sSQL)
		END

		FETCH NEXT FROM curObjects INTO @sObject, @sObjectType
END
CLOSE curObjects
DEALLOCATE curObjects

GO

GRANT EXEC ON TYPE::[dbo].[DataPermissions] TO ASRSysGroup



-- V8.1 Update script


---- Drop redundant functions (or renamed)

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetColumnTableID]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetColumnTableID]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetSystemPermissions]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRIntGetSystemPermissions]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetMiscParameters]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntGetMiscParameters]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetTableName]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRIntGetTableName]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntIsLookupTable]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[spASRIntIsLookupTable]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetMinimumPasswordLength]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetMinimumPasswordLength]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntPasswordOK]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntPasswordOK]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntAuditAccess]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntAuditAccess]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntPoll]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntPoll]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntCheckPolls]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntCheckPolls]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTables]') AND type in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTables]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetRecord]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRIntGetRecord]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetRecordEditWindowTitle]') AND xtype = 'P')
	DROP PROCEDURE [dbo].[sp_ASRIntGetRecordEditWindowTitle]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetFindRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFindRecords]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetFindRecords2]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFindRecords2]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetFindRecords3]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFindRecords3]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetFilterPromptedValuesRecordset]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetFilterPromptedValuesRecordset]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetMailMergeDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetMailMergeDefinition];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetEventLogRecords]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetEventLogRecords];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetEventLogBatchDetails]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].spASRIntGetEventLogBatchDetails;
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetCrossTabDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetCrossTabDefinition];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetReportDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetReportDefinition];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCalendarReportOrder]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCalendarReportOrder];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetReportChilds]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetReportChilds];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCalendarReportColumns]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCalendarReportColumns];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetReportColumns]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetReportColumns];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntDefProperties]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntDefProperties];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetEmailGroups]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetEmailGroups];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetEmailAddresses]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetEmailAddresses];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntSaveMailMerge]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntSaveMailMerge];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntSaveCrossTab]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntSaveCrossTab];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntSaveCustomReport]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntSaveCustomReport];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntValidateCrossTab]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntValidateCrossTab];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntValidateReport]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntValidateReport];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntValidateMailMerge]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntValidateMailMerge];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRTrackSession]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRTrackSession]
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetMessages]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetMessages];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetWorkflowParameters]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetWorkflowParameters];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUtilityBaseTable]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityBaseTable];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUtilityName]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityName];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetExprFunctions]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetExprFunctions];
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntActivateModule]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntActivateModule];
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetSystemSetting]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetSystemSetting]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetSetting]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetSetting]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetUtilityPromptedValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetUtilityPromptedValues]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntInsertCustomReportDetails]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntInsertCustomReportDetails]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetScreenStrings]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetScreenStrings]
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTablesInfo]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTablesInfo]
GO




-- Functions we do want to keep

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntPopulateDefsel]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntPopulateDefsel];
GO

CREATE PROCEDURE [dbo].[sp_ASRIntPopulateDefsel] (
	@intType int, 
	@blnOnlyMine bit,
	@intTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the details with which to populate the intranet defsel grid. */
	DECLARE 
		@strSQL 			nvarchar(MAX),
		@strExplicitSQL 	varchar(MAX),
		@strTableName		varchar(255),
		@strIDName 			varchar(255),
		@sExtraWhereSQL		varchar(MAX),
		@fNewAccess			bit,
		@sRecordSourceWhere	varchar(MAX),
		@sAccessTableName	varchar(255),
		@sRoleName			varchar(255),
		@fSysSecMgr			bit,
		@fDoneWhere			bit,
		@sActualUserName	varchar(250),
		@iActualUserGroupID	integer

	SET @fNewAccess = 0;
	SET @sExtraWhereSQL = '';
	SET @fDoneWhere = 0;
	SET @strExplicitSQL = '';
	
	IF ((@intTableID <=0) OR (@intTableID IS null)) AND (@intType <> 17) AND (@intType <> 9)
	BEGIN
		/* No table ID passed in, so use the first table alphabetically. */
		SELECT TOP 1 @intTableID = tableID
		FROM [dbo].[ASRSysTables]
		ORDER BY tableName;
	END

	IF @intType = 1 /*'crosstabs'*/
	BEGIN
		SET @strTableName = 'ASRSysCrossTab';
		SET @strIDName = 'CrossTabID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCrossTabAccess';
		SET @sExtraWhereSQL = ' CrossTabType = 0';
	END

	IF @intType = 2 /*'customreports'*/
	BEGIN
		SET @strTableName = 'ASRSysCustomReportsName';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCustomReportAccess';
	END

	IF @intType = 9 /*'mailmerge'*/
	BEGIN
		SET @strTableName = 'ASRSysMailMergeName';
		SET @strIDName = 'MailMergeID';
		SET @fNewAccess = 1;
		SET @sRecordSourceWhere = 'ASRSysMailMergeName.IsLabel = 0';
		SET @sAccessTableName= 'ASRSysMailMergeAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysMailMergeName.TableID = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 10 /*'picklists'*/
	BEGIN
		SET @strTableName = 'ASRSysPickListName';
		SET @strIDName = 'picklistID';
		SET @sExtraWhereSQL = ' TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 11 /*'filters'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 11 AND (returnType = 3 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END

	IF @intType = 12 /*'calculations'*/
	BEGIN
		SET @strTableName = 'ASRSysExpressions';
		SET @strIDName = 'exprID';
		SET @sExtraWhereSQL = ' type = 10 AND (returnType = 0 OR type = 10) AND parentComponentID = 0	AND TableID = ' + convert(varchar(255), @intTableID);
	END
	
	IF @intType = 17 /*'calendarreports'*/
	BEGIN
		SET @strTableName = 'ASRSysCalendarReports';
		SET @strIDName = 'ID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCalendarReportAccess';
		if (@intTableID > 0)
		BEGIN
			SET @sExtraWhereSQL = 'ASRSysCalendarReports.BaseTable = ' + convert(varchar(255), @intTableID);
		END
	END

	IF @intType = 25 /*'workflow'*/
	BEGIN
		SET @strExplicitSQL = 'SELECT 
			Name, 
			replace(ASRSysWorkflows.description, char(9), '''') AS [description],
			'''' AS [Username],
			''rw'' AS [Access],
			ID
			FROM ASRSysWorkflows
			WHERE ASRSysWorkflows.enabled = 1
				AND ISNULL(ASRSysWorkflows.initiationType, 0) = 0
			ORDER BY ASRSysWorkflows.name';
	END

	IF @intType = 35 /*'nineboxgridreport'*/
	BEGIN
		SET @strTableName = 'AsrSysCrossTab';
		SET @strIDName = 'CrossTabID';
		SET @fNewAccess = 1;
		SET @sAccessTableName= 'ASRSysCrossTabAccess';
		SET @sExtraWhereSQL = ' CrossTabType = 4';
	END
		
	IF len(@strExplicitSQL) > 0 
	BEGIN
		SET @strSQL = @strExplicitSQL;
	END
	ELSE
	BEGIN
		EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sRoleName OUTPUT,
			@iActualUserGroupID OUTPUT;

		SELECT @fSysSecMgr = 
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE ASRSysGroupPermissions.groupname = @sRoleName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 1
				ELSE 0
			END;
			
		IF @fNewAccess = 1
		BEGIN
			SET @strSQL = 'SELECT ' + @strTableName + '.Name, ' +
				'replace(' + @strTableName + '.Description, char(9), '''') AS [description], ' +
				'lower(' +@strTableName + '.Username) as ''Username'', ';
				
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(' + @sAccessTableName + '.Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
								
			SET @strSQL = @strSQL +
				@strTableName + '.' + @strIDName + '  as ''ID'' 
				FROM ' + @strTableName + 
				' INNER JOIN ' + @sAccessTableName + ' ON ' + @strTableName + '.' + @strIDName +  ' = ' + @sAccessTableName + '.ID
				AND ' + @sAccessTableName + '.groupname = ''' + @sRoleName + '''';

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END

			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END
			
			SET @strSQL = @strSQL + ' ORDER BY ' + @strTableName + '.Name';
		END
		ELSE
		BEGIN
			SET @strSQL = 'SELECT Name, replace(Description, char(9), '''') AS [description], lower(Username) as ''Username'', ';
			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					'lower(Access) as ''Access'', ';
			END
			ELSE
			BEGIN
				SET @strSQL = @strSQL +
					'''rw'' as ''Access'', ';
			END
			SET @strSQL = @strSQL +
				@strIDName + '  as ''ID'' FROM ' + @strTableName;

			IF (@fSysSecMgr = 0)  
			BEGIN
				SET @strSQL = @strSQL +
					 ' WHERE ([Username] = SYSTEM_USER';
				IF @blnOnlyMine = 0 SET @strSQL = @strSQL + ' OR [Access] <> ''HD''';
				SET @strSQL = @strSQL + ')';
				SET @fDoneWhere = 1;
			END
			ELSE
			BEGIN
				IF @blnOnlyMine = 1
				BEGIN
					SET @strSQL = @strSQL +
						 ' WHERE ([Username] = SYSTEM_USER)';
					SET @fDoneWhere = 1;
				END
			END
			
			IF LEN(@sRecordSourceWhere) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sRecordSourceWhere + ')';
			END
			
			IF LEN(@sExtraWhereSQL) > 0 
			BEGIN
				IF @fDoneWhere = 0
				BEGIN
					SET @strSQL = @strSQL  + ' WHERE';
					SET @fDoneWhere = 1;
				END
				ELSE
				BEGIN
					SET @strSQL = @strSQL  + ' AND';
				END

				SET @strSQL = @strSQL  + ' (' + @sExtraWhereSQL + ')';
			END

			SET @strSQL = @strSQL + ' ORDER BY Name';
		END
	END
	
	/* Return the resultset. */
	EXECUTE sp_executeSQL @strSQL;
	
END

GO

-- modified (chr(9) to be , AS [xxxx] so that columns come back in non string delimated format, also return types are noiw rw/ro/hd instead of readable text
IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUtilityAccessRecords]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords];
GO
CREATE PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords] (
	@piUtilityType		integer,
	@piID				integer,
	@piFromCopy			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sDefaultAccess	varchar(2),
		@sAccessTable	sysname,
		@sKey			varchar(255),
		@sSQL			nvarchar(MAX);

	SET @sAccessTable = '';

	IF @piUtilityType = 17
	BEGIN
		/* Calendar Reports */
		SET @sAccessTable = 'ASRSysCalendarReportAccess';
		SET @sKey = 'dfltaccess CalendarReports';
	END

	IF @piUtilityType = 1
	BEGIN
		/* Cross Tabs */
		SET @sAccessTable = 'ASRSysCrossTabAccess';
		SET @sKey = 'dfltaccess CrossTabs';
	END

	IF @piUtilityType = 2
	BEGIN
		/* Custom Reports */
		SET @sAccessTable = 'ASRSysCustomReportAccess';
		SET @sKey = 'dfltaccess CustomReports';
	END

	IF @piUtilityType = 9
	BEGIN
		/* Mail Merge */
		SET @sAccessTable = 'ASRSysMailMergeAccess';
		SET @sKey = 'dfltaccess MailMerge';
	END

	IF LEN(@sAccessTable) > 0
	BEGIN
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SELECT @sDefaultAccess = SettingValue 
			FROM ASRSysUserSettings
			WHERE UserName = system_user
				AND Section = 'utils&reports'
				AND SettingKey = @sKey;
	
			IF (@sDefaultAccess IS null)
			BEGIN
				SET @sDefaultAccess = 'RW';
			END
		END
		ELSE
		BEGIN
			SET @sDefaultAccess = 'HD';
		END
		
		SET @sSQL = 'SELECT sysusers.name ,
				CASE WHEN	
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE sysusers.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						ELSE ';
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RW'' THEN ''RW''
			 WHEN	CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
			ELSE '
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RO'' THEN ''RO''
			ELSE ''HD'' 
			END AS [access] ,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
 						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''1''
				ELSE
					''0''
			END AS [isOwner]
			FROM sysusers
			LEFT OUTER JOIN ' + @sAccessTable + ' ON (sysusers.name = ' + @sAccessTable + '.groupName
				AND ' + @sAccessTable + '.id = ' + convert(nvarchar(100), @piID) + ')
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0 AND NOT (sysusers.name LIKE ''ASRSys%'') AND NOT (sysusers.name LIKE ''db_%'')
			ORDER BY sysusers.name';

			EXEC sp_executesql @sSQL;

	END

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetMailMergeDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetMailMergeDefinition];
GO
CREATE PROCEDURE [dbo].[spASRIntGetMailMergeDefinition] (	
	@piReportID 			integer, 	
	@psCurrentUser			varchar(255),		
	@psAction				varchar(255)
)		
AS		
BEGIN		
	SET NOCOUNT ON;

	DECLARE	@iCount		integer,		
			@sTempHidden	varchar(MAX),		
			@sAccess 		varchar(MAX),		
			@fSysSecMgr		bit;		

	DECLARE @psErrorMsg			varchar(MAX) = '',	
			@psPicklistName		varchar(255) = '',
			@pfPicklistHidden	bit = 0,
			@psFilterName		varchar(255) = '',
			@pfFilterHidden		bit = 0,
			@psWarningMsg		varchar(255) = '',
			@psReportOwner		varchar(255),
			@psReportName		varchar(255),
			@piPicklistID		integer = 0,
			@piFilterID			integer = 0;

	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;

	/* Check the mail merge exists. */		
	SELECT @iCount = COUNT(*)		
	FROM [dbo].[ASRSysMailMergeName]		
	WHERE MailMergeID = @piReportID;		

	IF @iCount = 0		
		SET @psErrorMsg = 'mail merge has been deleted by another user.';		

	SELECT @psReportOwner = [username], @psReportName = [name]
			, @piPicklistID = picklistID, @piFilterID = FilterID
		FROM [dbo].[ASRSysMailMergeName]		
		WHERE MailMergeID = @piReportID;
	
	-- Check the current user can view the report.
	EXEC [dbo].[spASRIntCurrentUserAccess] 9, @piReportID, @sAccess OUTPUT;

	IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 		
		SET @psErrorMsg = 'mail merge has been made hidden by another user.';		

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 		
		SET @psErrorMsg = 'mail merge has been made read only by another user.';		

	-- Check the report has details.
	SELECT @iCount = COUNT(*)		
	FROM [dbo].[ASRSysMailMergeColumns]		
	WHERE MailMergeID = @piReportID;		
	IF @iCount = 0		
		SET @psErrorMsg = 'mail merge contains no details.';		

	-- Check the report has sort order details.
	SELECT @iCount = COUNT(*)		
	FROM [dbo].[ASRSysMailMergeColumns]		
	WHERE ASRSysMailMergeColumns.MailMergeID = @piReportID		
		AND ASRSysMailMergeColumns.sortOrderSequence > 0;		
	IF @iCount = 0		
		SET @psErrorMsg = 'mail merge contains no sort order details.';		

	IF @psAction = 'copy' 		
	BEGIN		
		SET @psReportName = left('copy of ' + @psReportName, 50);		
		SET @psReportOwner = @psCurrentUser;		
	END		

	IF @piPicklistID > 0 		
	BEGIN		
		SELECT @psPicklistName = name, @sTempHidden = access		
		FROM [dbo].[ASRSysPicklistName]		
		WHERE picklistID = @piPicklistID;		
		IF UPPER(@sTempHidden) = 'HD'		
			SET @pfPicklistHidden = 1;		

	END		
	IF @piFilterID > 0 		
	BEGIN		
		SELECT @psFilterName = name, @sTempHidden = access		
		FROM [dbo].[ASRSysExpressions]		
		WHERE exprID = @piFilterID;		
		IF UPPER(@sTempHidden) = 'HD'		
			SET @pfFilterHidden = 1;		

	END

	-- Definition
	SELECT @psReportName AS [Name], [description], @psReportOwner AS [owner],		
		tableID AS BaseTableID,		
		selection AS SelectionType,
		picklistID,	
		@psPicklistName AS PicklistName,
		FilterID,
		@psFilterName AS FilterName,
		outputformat AS [Format],		
		outputsave AS [SaveToFile],		
		outputfilename AS [Filename],		
		emailAddrID AS [EmailGroupID],		
		emailSubject,		
		templateFileName,		
		outputscreen AS [DisplayOutputOnScreen],		
		emailasattachment AS [EmailAsAttachment],		
		ISNULL(emailattachmentname,'') AS [EmailAttachmentName],		
		suppressblanks AS SuppressBlankLines,		
		PauseBeforeMerge,		
		outputprinter AS [SendToPrinter],		
		outputprintername AS [PrinterName],		
		documentmapid,		
		manualdocmanheader,
		PromptStart AS PauseBeforeMerge,
		CONVERT(integer, timestamp) AS [Timestamp],
		CASE WHEN @pfPicklistHidden = 1 OR @pfFilterHidden = 1 THEN 'HD' ELSE '' END AS [BaseViewAccess]
	FROM [dbo].[ASRSysMailMergeName]		
	WHERE MailMergeID = @piReportID;		

	-- Columns
	SELECT ASRSysMailMergeColumns.ColumnID AS [ID],
		0 AS [IsExpression],
		0 AS [accesshidden],
		ASRSysColumns.tableID,
		ASRSysTables.tableName + '.' + ASRSysColumns.columnName AS [name],
		ASRSysColumns.columnName AS [heading], 
		ASRSysColumns.DataType,
		ASRSysMailMergeColumns.size,
		ASRSysMailMergeColumns.decimals,
		'' AS Heading,
		0 AS IsAverage,
		0 AS IsCount,
		0 AS IsTotal,
		0 AS IsHidden,
		0 AS IsGroupWithNext,
		0 AS IsRepeated,
		ASRSysMailMergeColumns.SortOrderSequence AS [sequence]
	FROM ASRSysMailMergeColumns		
	INNER JOIN ASRSysColumns ON ASRSysMailMergeColumns.columnID = ASRSysColumns.columnId		
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID		
	WHERE ASRSysMailMergeColumns.MailMergeID = @piReportID		
		AND ASRSysMailMergeColumns.type = 'C'
	UNION
	SELECT ASRSysMailMergeColumns.columnID AS [ID],
		1 AS [IsExpression],
		CASE WHEN ASRSysExpressions.access = 'HD' THEN 1 ELSE 0 END AS [accesshidden],		
		ASRSysExpressions.tableID,
		ASRSysExpressions.name AS [name],
		convert(varchar(MAX), replace(ASRSysExpressions.name, '_', ' ')) AS [heading],
		0 AS DataType,
		ASRSysMailMergeColumns.size,
		ASRSysMailMergeColumns.decimals,
		'' AS Heading,
		0 AS IsAverage,
		0 AS IsCount,
		0 AS IsTotal,
		0 AS IsHidden,
		0 AS IsGroupWithNext,
		0 AS IsRepeated,
		ASRSysMailMergeColumns.SortOrderSequence AS [sequence]
	FROM ASRSysMailMergeColumns		
	INNER JOIN ASRSysExpressions ON ASRSysMailMergeColumns.columnID = ASRSysExpressions.exprID		
	WHERE ASRSysMailMergeColumns.MailMergeID = @piReportID		
		AND ASRSysMailMergeColumns.type <> 'C'		
		AND ((ASRSysExpressions.username = @psReportOwner)	OR (ASRSysExpressions.access <> 'HD'))		

	-- Orders
	SELECT ASRSysMailMergeColumns.columnID AS [id],
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) AS [name],
		ASRSysMailMergeColumns.sortOrder AS [order],
		ASRSysTables.tableID,
		ASRSysMailMergeColumns.sortOrderSequence AS [sequence]
	FROM ASRSysMailMergeColumns		
	INNER JOIN ASRSysColumns ON ASRSysMailMergeColumns.columnid = ASRSysColumns.columnId		
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID		
	WHERE ASRSysMailMergeColumns.MailMergeID = @piReportID		
		AND ASRSysMailMergeColumns.sortOrderSequence > 0		
	ORDER BY ASRSysMailMergeColumns.type, [sequence] ASC;

	IF @fSysSecMgr = 0 		
	BEGIN		
		SELECT @iCount = COUNT(ASRSysMailMergeColumns.ID)		
		FROM [dbo].[ASRSysMailMergeColumns]		
		INNER JOIN ASRSysExpressions ON ASRSysMailMergeColumns.columnID = ASRSysExpressions.exprID		
		WHERE ASRSysMailMergeColumns.MailMergeID = @piReportID		
			AND ASRSysMailMergeColumns.type <> 'C'		
			and ((ASRSysExpressions.username <> @psReportOwner) and (ASRSysExpressions.access = 'HD'));		
							
		IF @iCount > 0 		
		BEGIN		
			IF @iCount = 1		
			BEGIN		
				SET @psWarningMsg = 'A calculation used in this definition has been made hidden by another user. It will be removed from the definition';		
			END		
			ELSE		
			BEGIN		
				SET @psWarningMsg = 'Some calculations used in this definition have been made hidden by another user. They will be removed from the definition';		
			END		
		END		
	END		
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCrossTabDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCrossTabDefinition];
GO
CREATE PROCEDURE [dbo].[spASRIntGetCrossTabDefinition] (
	@piReportID 			integer, 
	@psCurrentUser			varchar(255),
	@psAction				varchar(255))
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @psErrorMsg				varchar(MAX) = '',
			@psReportName			varchar(255) = '',
			@psReportOwner			varchar(255) = '',
			@psReportDesc			varchar(MAX) = '',
			@piBaseTableID			integer = 0,
			@piSelection			integer = 0,
			@piPicklistID			integer = 0,
			@psPicklistName			varchar(255) = '',
			@pfPicklistHidden		bit,
			@piFilterID				integer = 0,
			@psFilterName			varchar(255) = '',
			@pfFilterHidden			bit,
			@pfPrintFilterHeader	bit,
			@HColID					integer = 0,
			@HStart					varchar(20) = '',
			@HStop					varchar(20) = '',
			@HStep					varchar(20) = '',
			@VColID					integer = 0,
			@VStart					varchar(20) = '',
			@VStop					varchar(20) = '',
			@VStep					varchar(20) = '',
			@PColID					integer = 0,
			@PStart					varchar(20) = '',
			@PStop					varchar(20) = '',
			@PStep					varchar(20) = '',
			@IType					integer = 0,
			@IColID					integer = 0,
			@Percentage				bit,
			@PerPage				bit,
			@Suppress				bit,
			@Thousand				bit,
			@pfOutputPreview		bit,
			@piOutputFormat			integer = 0,
			@pfOutputScreen			bit,
			@pfOutputPrinter		bit,
			@psOutputPrinterName	varchar(MAX) = '',
			@pfOutputSave			bit,
			@piOutputSaveExisting	integer = 0,
			@pfOutputEmail			bit,
			@piOutputEmailAddr		integer = 0,
			@psOutputEmailName		varchar(MAX) = '',
			@psOutputEmailSubject	varchar(MAX) = '',
			@psOutputEmailAttachAs	varchar(MAX) = '',
			@psOutputFilename		varchar(MAX) = '',
 			@piTimestamp			integer	= 0;	

	DECLARE	@iCount			integer,
			@sTempHidden	varchar(MAX),
			@sAccess 		varchar(MAX);


	/* Check the report exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'cross tab has been deleted by another user.'
		RETURN
	END

	SELECT @psReportName = name, @psReportDesc	 = description, @psReportOwner = userName,
		@piBaseTableID = TableID, @piSelection = Selection, @piPicklistID = PicklistID,
		@piFilterID = FilterID,	@pfPrintFilterHeader = PrintFilterHeader, @psReportOwner = userName,
		@HColID = HorizontalColID, @HStart = HorizontalStart, @HStop = HorizontalStop, @HStep = HorizontalStep,
		@VColID = VerticalColID, @VStart = VerticalStart, @VStop = VerticalStop, @VStep = VerticalStep,
		@PColID = PageBreakColID, @PStart = PageBreakStart,	@PStop = PageBreakStop,	@PStep = PageBreakStep,
		@IType = IntersectionType, @IColID = IntersectionColID,	@Percentage = Percentage, @PerPage = PercentageofPage,
		@Suppress = SuppressZeros,@Thousand = ThousandSeparators,
		@pfOutputPreview = OutputPreview, @piOutputFormat = OutputFormat, @pfOutputScreen = OutputScreen,
		@pfOutputPrinter = OutputPrinter, @psOutputPrinterName = OutputPrinterName,
		@pfOutputSave = OutputSave,	@piOutputSaveExisting = OutputSaveExisting,
		@pfOutputEmail = OutputEmail, @piOutputEmailAddr = OutputEmailAddr,
		@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
		@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
		@psOutputFilename = ISNULL(OutputFilename,''),
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID;

	/* Check the current user can view the report. */
	EXEC spASRIntCurrentUserAccess 	1, @piReportID,	@sAccess OUTPUT;

	IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
		SET @psErrorMsg = 'cross tab has been made hidden by another user.';

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
		SET @psErrorMsg = 'cross tab has been made read only by another user.';

	IF @psAction = 'copy'
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50);
		SET @psReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access
		FROM ASRSysPicklistName 
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfPicklistHidden = 1;
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfFilterHidden = 1;
		END
	END

	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM ASRSysEmailGroupName
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;
		SET @psOutputEmailName = '';
	END

	SELECT @psErrorMsg AS ErrorMsg, @psReportName AS Name, @psReportOwner AS [Owner], @psReportDesc AS [Description]
		, @piBaseTableID AS [BaseTableID], @piSelection AS SelectionType
		, @piPicklistID AS PicklistID, @psPicklistName AS PicklistName, @pfPicklistHidden AS [IsPicklistHidden]
		, @piFilterID AS FilterID, @psFilterName AS [FilterName], @pfFilterHidden AS [IsFilterHidden]
		, @pfPrintFilterHeader AS [PrintFilterHeader]
		, @HColID AS HorizontalID, @HStart AS HorizontalStart, @HStop AS HorizontalStop, @HStep AS HorizontalIncrement
		, @VColID AS VerticalID, @VStart AS VerticalStart, @VStop AS VerticalStop, @VStep AS VerticalIncrement
		, @PColID AS PageBreakID, @PStart AS PageBreakStart, @PStop AS PageBreakStop, @PStep AS PageBreakIncrement
		, @IType AS IntersectionType, @IColID AS IntersectionID
		, @Percentage AS PercentageOfType, @PerPage AS PercentageOfPage
		, @Suppress	AS SuppressZeros, @Thousand AS [UseThousandSeparators]
		, @pfOutputPreview AS IsPreview, @piOutputFormat AS [Format],	@pfOutputScreen AS [ToScreen]
		, @pfOutputPrinter AS [ToPrinter], @psOutputPrinterName	AS [PrinterName]
		, @pfOutputSave AS [SaveToFile], @piOutputSaveExisting AS [SaveExisting]
		, @pfOutputEmail AS [SendToEmail], @piOutputEmailAddr AS [EmailGroupID], @psOutputEmailName AS [EmailGroupName]
		, @psOutputEmailSubject AS [EmailSubject], @psOutputEmailAttachAs AS [EmailAttachmentName]
		, @psOutputFilename AS [FileName], @piTimestamp AS [Timestamp],
		CASE WHEN @pfPicklistHidden = 1 OR @pfFilterHidden = 1 THEN 'HD' ELSE '' END AS [BaseViewAccess];

END
GO

	
IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntDeleteCheck]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntDeleteCheck];
GO

CREATE PROCEDURE [dbo].[spASRIntDeleteCheck] (
	@piUtilityType	integer,
	@plngID			integer,
	@pfDeleted		bit				OUTPUT,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fNewAccess			bit,
		@iCount				integer,
		@sAccess			varchar(MAX),
		@fSysSecMgr			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';
	SET @pfDeleted = 0;
	SET @fNewAccess = 0;

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END

	IF @piUtilityType = 1 OR @piUtilityType = 35 /* Cross Tab or 9-Box Grid*/
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
 	END
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
		SET @fNewAccess = 1;
  END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
		SET @fNewAccess = 1;
  END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
		SET @fNewAccess = 1
  END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
		SET @fNewAccess = 1;
  END

	IF (@piUtilityType = 11) OR (@piUtilityType = 12)  /* Filters/Calcs */
	BEGIN
		SET @sTableName = 'ASRSysExpressions';
		SET @sIDColumnName = 'exprID';
  END

	IF (@piUtilityType = 10)  /* Picklists */
	BEGIN
		SET @sTableName = 'ASRSysPicklistName';
		SET @sIDColumnName = 'picklistID';
  END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @iCount = COUNT(*)
				FROM ' + @sTableName + 
				' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
		SET @sParamDefinition = N'@iCount integer OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @iCount OUTPUT;

		IF @iCount = 0 
		BEGIN
			SET @pfDeleted = 1;
		END
		ELSE
		BEGIN
			IF @fNewAccess = 1
			BEGIN
				exec [dbo].[spASRIntCurrentUserAccess] @piUtilityType,	@plngID, @psAccess OUTPUT;
			END
			ELSE
			BEGIN
				exec [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
				
				IF @fSysSecMgr = 1 
				BEGIN
					SET @psAccess = 'RW';
				END
				ELSE
				BEGIN
					SET @sSQL = 'SELECT @sAccess = CASE 
								WHEN userName = system_user THEN ''RW''
								ELSE access
							END
							FROM ' + @sTableName + 
							' WHERE ' + @sTableName + '.' + @sIDColumnName + ' = ' + convert(nvarchar(255), @plngID);
					SET @sParamDefinition = N'@sAccess varchar(MAX) OUTPUT';
					EXEC sp_executesql @sSQL,  @sParamDefinition, @sAccess OUTPUT;

					SET @psAccess = @sAccess;
				END
			END
		END
	END
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntDeleteUtility]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntDeleteUtility];
GO

CREATE PROCEDURE [dbo].[sp_ASRIntDeleteUtility] (
	@piUtilType	integer,
	@piUtilID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iExprID	integer;

	IF @piUtilType = 0
	BEGIN
		/* Batch Jobs */
		DELETE FROM ASRSysBatchJobName WHERE ID = @piUtilID;
		DELETE FROM ASRSysBatchJobDetails WHERE BatchJobNameID = @piUtilID;
		DELETE FROM ASRSysBatchJobAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 1 OR @piUtilType = 35
	BEGIN
		/* Cross Tabs or 9-Box Grid*/
		DELETE FROM ASRSysCrossTab WHERE CrossTabID = @piUtilID;
		DELETE FROM ASRSysCrossTabAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 2
	BEGIN
		/* Custom Reports. */
		DELETE FROM ASRSysCustomReportsName WHERE id = @piUtilID;
		DELETE FROM ASRSysCustomReportsDetails WHERE customReportID= @piUtilID;
		DELETE FROM ASRSysCustomReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 3
	BEGIN
		/* Data Transfer. */
		DELETE FROM ASRSysDataTransferName WHERE DataTransferID = @piUtilID;
		DELETE FROM ASRSysDataTransferAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 4
	BEGIN
		/* Export. */
		DELETE FROM ASRSysExportName WHERE ID = @piUtilID;
		DELETE FROM ASRSysExportDetails WHERE ExportID = @piUtilID;
		DELETE FROM ASRSysExportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 5) OR (@piUtilType = 6) OR (@piUtilType = 7)
	BEGIN
		/* Globals. */
		DELETE FROM ASRSysGlobalFunctions  WHERE FunctionID = @piUtilID;
		DELETE FROM ASRSysGlobalAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 8
	BEGIN
		/* Import. */
		DELETE FROM ASRSysImportName  WHERE ID = @piUtilID;
		DELETE FROM ASRSysImportDetails WHERE ImportID = @piUtilID;
		DELETE FROM ASRSysImportAccess WHERE ID = @piUtilID;
	END

	IF (@piUtilType = 9) OR (@piUtilType = 18)
	BEGIN
		/* Mail Merge/ Envelopes & Labels. */
		DELETE FROM ASRSysMailMergeName  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeColumns  WHERE MailMergeID = @piUtilID;
		DELETE FROM ASRSysMailMergeAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 10
	BEGIN
		/* Picklists. */
		DELETE FROM ASRSysPickListName WHERE picklistID = @piUtilID;
		DELETE FROM ASRSysPickListItems WHERE picklistID = @piUtilID;
	END
	
	IF @piUtilType = 11 OR @piUtilType = 12
	BEGIN
		/* Filters and Calculations. */
		DECLARE subExpressions_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysExpressions.exprID
			FROM ASRSysExpressions
			INNER JOIN ASRSysExprComponents ON ASRSysExpressions.parentComponentID = ASRSysExprComponents.componentID
			AND ASRSysExprComponents.exprID = @piUtilID;
		OPEN subExpressions_cursor;
		FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		WHILE (@@fetch_status = 0)
		BEGIN
			exec [dbo].[sp_ASRIntDeleteUtility] @piUtilType, @iExprID;
			
			FETCH NEXT FROM subExpressions_cursor INTO @iExprID;
		END
		CLOSE subExpressions_cursor;
		DEALLOCATE subExpressions_cursor;

		DELETE FROM ASRSysExprComponents
		WHERE exprID = @piUtilID;

		DELETE FROM ASRSysExpressions WHERE exprID = @piUtilID;
	END	

	IF (@piUtilType = 14) OR (@piUtilType = 23) OR (@piUtilType = 24)
	BEGIN
		/* Match Reports/Succession Planning/Career Progression. */
		DELETE FROM ASRSysMatchReportName WHERE MatchReportID = @piUtilID;
		DELETE FROM ASRSysMatchReportAccess WHERE ID = @piUtilID;
	END

	IF @piUtilType = 17 
	BEGIN
		/*Calendar Reports*/
		DELETE FROM ASRSysCalendarReports WHERE ID = @piUtilID;
		DELETE FROM ASRSysCalendarReportEvents WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportOrder WHERE CalendarReportID = @piUtilID;
		DELETE FROM ASRSysCalendarReportAccess WHERE ID = @piUtilID;
	END
	
	IF @piUtilType = 20 
	BEGIN
		/*Record Profile*/
		DELETE FROM ASRSysRecordProfileName WHERE recordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileDetails WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileTables WHERE RecordProfileID = @piUtilID;
		DELETE FROM ASRSysRecordProfileAccess WHERE ID = @piUtilID;
	END
	
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSaveCrossTab]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntSaveCrossTab];
GO

CREATE PROCEDURE [dbo].[spASRIntSaveCrossTab] (
	@psName				varchar(255),
	@psDescription		varchar(MAX),
	@piTableID			integer,
	@piSelection		integer,
	@piPicklistID		integer,
	@piFilterID			integer,
	@pfPrintFilter		bit,
	@psUserName			varchar(255),
	@piHColID			integer,
	@psHStart			varchar(100),
	@psHStop			varchar(100),
	@psHStep			varchar(100),
	@piVColID			integer,
	@psVStart			varchar(100),
	@psVStop			varchar(100),
	@psVStep			varchar(100),
	@piPColID			integer,
	@psPStart			varchar(100),
	@psPStop			varchar(100),
	@psPStep			varchar(100),
	@piIType			integer,
	@piIColID			integer,
	@pfPercentage		bit,
	@pfPerPage			bit,
	@pfSuppress			bit,
	@pfUse1000Separator	bit,
	@pfOutputPreview	bit,
	@piOutputFormat		integer,
	@pfOutputScreen		bit,
	@pfOutputPrinter	bit,
	@psOutputPrinterName	varchar(MAX),
	@pfOutputSave		bit,
	@piOutputSaveExisting	integer,
	@pfOutputEmail		bit,
	@piOutputEmailAddr	integer,
	@psOutputEmailSubject	varchar(MAX),
	@psOutputEmailAttachAs	varchar(MAX),
	@psOutputFilename	varchar(MAX),
	@psAccess			varchar(MAX),
	@psJobsToHide		varchar(MAX),
	@psJobsToHideGroups	varchar(MAX),
	@piID				integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
			@fIsNew		bit,
			@sTemp		varchar(MAX),
			@iCount		integer,
			@sGroup		varchar(MAX),
			@sAccess	varchar(MAX),
			@sSQL		nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')

	SET @fIsNew = 0

	/* Insert/update the report header. */
	IF (@piID = 0)
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysCrossTab (
			Name, 
			Description, 
			TableID, 
			Selection, 
			PicklistID, 
			FilterID, 
 			PrintFilterHeader, 
 			UserName, 
 			HorizontalColID, 
 			HorizontalStart, 
 			HorizontalStop, 
 			HorizontalStep, 
			VerticalColID, 
			VerticalStart, 
			VerticalStop, 
			VerticalStep, 
			PageBreakColID, 
			PageBreakStart, 
			PageBreakStop, 
			PageBreakStep, 
			IntersectionType, 
			IntersectionColID, 
			Percentage, 
			PercentageofPage, 
			SuppressZeros, 
			ThousandSeparators, 
			OutputPreview, 
			OutputFormat, 
			OutputScreen, 
			OutputPrinter, 
			OutputPrinterName, 
			OutputSave, 
			OutputSaveExisting, 
			OutputEmail, 
			OutputEmailAddr, 
			OutputEmailSubject, 
			OutputEmailAttachAs, 
			OutputFileName,
			CrossTabType)
		VALUES (
			@psName,
			@psDescription,
			@piTableID,
			@piSelection,
			@piPicklistID,
			@piFilterID,
			@pfPrintFilter,
			@psUserName,
			@piHColID,
			@psHStart,
			@psHStop,
			@psHStep,
			@piVColID,
			@psVStart,
			@psVStop,
			@psVStep,
			@piPColID,
			@psPStart,
			@psPStop,
			@psPStep,
			@piIType,
			@piIColID,
			@pfPercentage,
			@pfPerPage,
			@pfSuppress,
			@pfUse1000Separator,
			@pfOutputPreview,
			@piOutputFormat,
			@pfOutputScreen,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@pfOutputSave,
			@piOutputSaveExisting,
			@pfOutputEmail,
			@piOutputEmailAddr,
			@psOutputEmailSubject,
			@psOutputEmailAttachAs,
			@psOutputFilename,
			0 -- Cross tab
		)

		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(CrossTabID) FROM ASRSysCrossTab
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysCrossTab SET 
			Name = @psName,
			Description = @psDescription,
			TableID = @piTableID,
			Selection = @piSelection,
			PicklistID = @piPicklistID,
			FilterID = @piFilterID,
			PrintFilterHeader = @pfPrintFilter,
			HorizontalColID = @piHColID,
			HorizontalStart = @psHStart,
			HorizontalStop = @psHStop,
			HorizontalStep = @psHStep,	
			VerticalColID = @piVColID,
			VerticalStart = @psVStart,
			VerticalStop = @psVStop,
			VerticalStep = @psVStep,	
			PageBreakColID = @piPColID,
			PageBreakStart = @psPStart,
			PageBreakStop = @psPStop,
			PageBreakStep = @psPStep,	
			IntersectionType = @piIType,
			IntersectionColID = @piIColID,
			Percentage = @pfPercentage,
			PercentageofPage = @pfPerPage,
			SuppressZeros = @pfSuppress,
			ThousandSeparators = @pfUse1000Separator,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @piOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename
		WHERE CrossTabID = @piID
	END

	DELETE FROM ASRSysCrossTabAccess WHERE ID = @piID

	INSERT INTO ASRSysCrossTabAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)

	SET @sTemp = @psAccess
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysCrossTabAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCrossTabAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (1, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 1

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (1, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 1
		END
	END
	
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''
		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' + @psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
	
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUtilityAccessRecords]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords];
GO

CREATE PROCEDURE [dbo].[spASRIntGetUtilityAccessRecords] (
	@piUtilityType		integer,
	@piID				integer,
	@piFromCopy			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@sDefaultAccess	varchar(2),
		@sAccessTable	sysname,
		@sKey			varchar(255),
		@sSQL			nvarchar(MAX);

	SET @sAccessTable = '';

	IF @piUtilityType = 17
	BEGIN
		/* Calendar Reports */
		SET @sAccessTable = 'ASRSysCalendarReportAccess';
		SET @sKey = 'dfltaccess CalendarReports';
	END

	IF @piUtilityType = 1 OR @piUtilityType = 35
	BEGIN
		/* Cross Tabs or 9-box Grid*/
		SET @sAccessTable = 'ASRSysCrossTabAccess';
		SET @sKey = 'dfltaccess CrossTabs';
	END

	IF @piUtilityType = 2
	BEGIN
		/* Custom Reports */
		SET @sAccessTable = 'ASRSysCustomReportAccess';
		SET @sKey = 'dfltaccess CustomReports';
	END

	IF @piUtilityType = 9
	BEGIN
		/* Mail Merge */
		SET @sAccessTable = 'ASRSysMailMergeAccess';
		SET @sKey = 'dfltaccess MailMerge';
	END

	IF LEN(@sAccessTable) > 0
	BEGIN
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SELECT @sDefaultAccess = SettingValue 
			FROM ASRSysUserSettings
			WHERE UserName = system_user
				AND Section = 'utils&reports'
				AND SettingKey = @sKey;
	
			IF (@sDefaultAccess IS null)
			BEGIN
				SET @sDefaultAccess = 'RW';
			END
		END
		ELSE
		BEGIN
			SET @sDefaultAccess = 'HD';
		END
		
		SET @sSQL = 'SELECT sysusers.name ,
				CASE WHEN	
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE sysusers.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						ELSE ';
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RW'' THEN ''RW''
			 WHEN	CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
			ELSE '
  
		IF (@piID = 0) OR (@piFromCopy = 1)
		BEGIN
			SET @sSQL = @sSQL + ' ''' + @sDefaultAccess + '''';
		END
		ELSE
		BEGIN
			SET @sSQL = @sSQL + 
				' CASE
					WHEN ' + @sAccessTable + '.access IS null THEN ''' + @sDefaultAccess + '''
					ELSE ' + @sAccessTable + '.access
				END';
		END

		SET @sSQL = @sSQL + 
			' END = ''RO'' THEN ''RO''
			ELSE ''HD'' 
			END AS [access] ,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
 						OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''1''
				ELSE
					''0''
			END AS [isOwner]
			FROM sysusers
			LEFT OUTER JOIN ' + @sAccessTable + ' ON (sysusers.name = ' + @sAccessTable + '.groupName
				AND ' + @sAccessTable + '.id = ' + convert(nvarchar(100), @piID) + ')
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0 AND NOT (sysusers.name LIKE ''ASRSys%'') AND NOT (sysusers.name LIKE ''db_%'')
			ORDER BY sysusers.name';

			EXEC sp_executesql @sSQL;

	END

END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntValidateNineBoxGrid]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntValidateNineBoxGrid];
GO

CREATE PROCEDURE [dbo].[spASRIntValidateNineBoxGrid] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@piEmailGroupID 	integer, 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedFilters 	varchar(MAX)	OUTPUT,
	@psHiddenFilters 	varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sParameter				varchar(MAX),
			@sExprName  			varchar(MAX),
			@sBatchJobName			varchar(MAX),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(MAX),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The 9-Box Grid has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCrossTab
			WHERE CrossTabID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					1, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The 9-Box Grid has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The 9-Box Grid has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the 9-Box Grid name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName
				AND CrossTabID <> @piUtilID
				AND CrossTabType = 4
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName AND CrossTabType = 4
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A 9-Box Grid called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = '9-BOX GRID REPORT'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains 9-Box Grid ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END

			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	
		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs

END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSaveNineBoxGrid]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntSaveNineBoxGrid];
GO

CREATE PROCEDURE [dbo].[spASRIntSaveNineBoxGrid] (
	@psName				varchar(255),
	@psDescription		varchar(MAX),
	@piTableID			integer,
	@piSelection		integer,
	@piPicklistID		integer,
	@piFilterID			integer,
	@pfPrintFilter		bit,
	@psUserName			varchar(255),
	@piHColID			integer,
	@psHStart			varchar(100),
	@psHStop			varchar(100),
	@piVColID			integer,
	@psVStart			varchar(100),
	@psVStop			varchar(100),
	@piPColID			integer,
	@psPStart			varchar(100),
	@psPStop			varchar(100),
	@piIType			integer,
	@piIColID			integer,
	@pfPercentage		bit,
	@pfPerPage			bit,
	@pfSuppress			bit,
	@pfUse1000Separator	bit,
	@pfOutputPreview	bit,
	@piOutputFormat		integer,
	@pfOutputScreen		bit,
	@pfOutputPrinter	bit,
	@psOutputPrinterName	varchar(MAX),
	@pfOutputSave		bit,
	@piOutputSaveExisting	integer,
	@pfOutputEmail		bit,
	@piOutputEmailAddr	integer,
	@psOutputEmailSubject	varchar(MAX),
	@psOutputEmailAttachAs	varchar(MAX),
	@psOutputFilename	varchar(MAX),
	@psAccess			varchar(MAX),
	@psJobsToHide		varchar(MAX),
	@psJobsToHideGroups	varchar(MAX),
	@XAxisLabel varchar(255),
	@XAxisSubLabel1 varchar(255),
	@XAxisSubLabel2 varchar(255),
	@XAxisSubLabel3 varchar(255),
	@YAxisLabel varchar(255),
	@YAxisSubLabel1 varchar(255),
	@YAxisSubLabel2 varchar(255),
	@YAxisSubLabel3 varchar(255),
	@Description1 varchar(255),
	@ColorDesc1 varchar(6),
	@Description2 varchar(255),
	@ColorDesc2 varchar(6),
	@Description3 varchar(255),
	@ColorDesc3 varchar(6),
	@Description4 varchar(255),
	@ColorDesc4 varchar(6),
	@Description5 varchar(255),
	@ColorDesc5 varchar(6),
	@Description6 varchar(255),
	@ColorDesc6 varchar(6),
	@Description7 varchar(255),
	@ColorDesc7 varchar(6),
	@Description8 varchar(255),
	@ColorDesc8 varchar(6),
	@Description9 varchar(255),
	@ColorDesc9 varchar(6),
	@piID				integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
			@fIsNew		bit,
			@sTemp		varchar(MAX),
			@iCount		integer,
			@sGroup		varchar(MAX),
			@sAccess	varchar(MAX),
			@sSQL		nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')

	SET @fIsNew = 0

	/* Insert/update the report header. */
	IF (@piID = 0)
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysCrossTab (
			Name, 
			Description, 
			TableID, 
			Selection, 
			PicklistID, 
			FilterID, 
 			PrintFilterHeader, 
 			UserName, 
 			HorizontalColID, 
 			HorizontalStart, 
 			HorizontalStop, 
 			HorizontalStep, 
			VerticalColID, 
			VerticalStart, 
			VerticalStop, 
			VerticalStep, 
			PageBreakColID, 
			PageBreakStart, 
			PageBreakStop, 
			PageBreakStep, 
			IntersectionType, 
			IntersectionColID, 
			Percentage, 
			PercentageofPage, 
			SuppressZeros, 
			ThousandSeparators, 
			OutputPreview, 
			OutputFormat, 
			OutputScreen, 
			OutputPrinter, 
			OutputPrinterName, 
			OutputSave, 
			OutputSaveExisting, 
			OutputEmail, 
			OutputEmailAddr, 
			OutputEmailSubject, 
			OutputEmailAttachAs, 
			OutputFileName,
			CrossTabType,
			XAxisLabel,
			XAxisSubLabel1,
			XAxisSubLabel2,
			XAxisSubLabel3,
			YAxisLabel,
			YAxisSubLabel1,
			YAxisSubLabel2,
			YAxisSubLabel3,
			Description1,
			ColorDesc1,
			Description2,
			ColorDesc2,
			Description3,
			ColorDesc3,
			Description4,
			ColorDesc4,
			Description5,
			ColorDesc5,
			Description6,
			ColorDesc6,
			Description7,
			ColorDesc7,
			Description8,
			ColorDesc8,
			Description9,
			ColorDesc9)
		VALUES (
			@psName,
			@psDescription,
			@piTableID,
			@piSelection,
			@piPicklistID,
			@piFilterID,
			@pfPrintFilter,
			@psUserName,
			@piHColID,
			@psHStart,
			@psHStop,
			0,
			@piVColID,
			@psVStart,
			@psVStop,
			0,
			@piPColID,
			@psPStart,
			@psPStop,
			0,
			@piIType,
			@piIColID,
			@pfPercentage,
			@pfPerPage,
			@pfSuppress,
			@pfUse1000Separator,
			@pfOutputPreview,
			@piOutputFormat,
			@pfOutputScreen,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@pfOutputSave,
			@piOutputSaveExisting,
			@pfOutputEmail,
			@piOutputEmailAddr,
			@psOutputEmailSubject,
			@psOutputEmailAttachAs,
			@psOutputFilename,
			4, -- Nine box grid
			@XAxisLabel,
			@XAxisSubLabel1,
			@XAxisSubLabel2,
			@XAxisSubLabel3,
			@YAxisLabel,
			@YAxisSubLabel1,
			@YAxisSubLabel2,
			@YAxisSubLabel3,
			@Description1,
			@ColorDesc1,
			@Description2,
			@ColorDesc2,
			@Description3,
			@ColorDesc3,
			@Description4,
			@ColorDesc4,
			@Description5,
			@ColorDesc5,
			@Description6,
			@ColorDesc6,
			@Description7,
			@ColorDesc7,
			@Description8,
			@ColorDesc8,
			@Description9,
			@ColorDesc9)

		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(CrossTabID) FROM ASRSysCrossTab
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysCrossTab SET 
			Name = @psName,
			Description = @psDescription,
			TableID = @piTableID,
			Selection = @piSelection,
			PicklistID = @piPicklistID,
			FilterID = @piFilterID,
			PrintFilterHeader = @pfPrintFilter,
			HorizontalColID = @piHColID,
			HorizontalStart = @psHStart,
			HorizontalStop = @psHStop,
			VerticalColID = @piVColID,
			VerticalStart = @psVStart,
			VerticalStop = @psVStop,
			PageBreakColID = @piPColID,
			PageBreakStart = @psPStart,
			PageBreakStop = @psPStop,
			IntersectionType = @piIType,
			IntersectionColID = @piIColID,
			Percentage = @pfPercentage,
			PercentageofPage = @pfPerPage,
			SuppressZeros = @pfSuppress,
			ThousandSeparators = @pfUse1000Separator,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @piOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename,
			XAxisLabel = @XAxisLabel,
			XAxisSubLabel1 = @XAxisSubLabel1,
			XAxisSubLabel2 = @XAxisSubLabel2,
			XAxisSubLabel3 = @XAxisSubLabel3,
			YAxisLabel = @YAxisLabel,
			YAxisSubLabel1 = @YAxisSubLabel1,
			YAxisSubLabel2 = @YAxisSubLabel2,
			YAxisSubLabel3 = @YAxisSubLabel3,
			Description1 = @Description1,
			ColorDesc1 = @ColorDesc1,
			Description2 = @Description2,
			ColorDesc2 = @ColorDesc2,
			Description3 = @Description3,
			ColorDesc3 = @ColorDesc3,
			Description4 = @Description4,
			ColorDesc4 = @ColorDesc4,
			Description5 = @Description5,
			ColorDesc5 = @ColorDesc5,
			Description6 = @Description6,
			ColorDesc6 = @ColorDesc6,
			Description7 = @Description7,
			ColorDesc7 = @ColorDesc7,
			Description8 = @Description8,
			ColorDesc8 = @ColorDesc8,
			Description9 = @Description9,
			ColorDesc9 = @ColorDesc9
		WHERE CrossTabID = @piID
	END

	DELETE FROM ASRSysCrossTabAccess WHERE ID = @piID

	INSERT INTO ASRSysCrossTabAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)

	SET @sTemp = @psAccess
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysCrossTabAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCrossTabAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (35, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 35

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (35, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 35
		END
	END
	
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''
		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' + @psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
	
END

GO

IF EXISTS (SELECT * FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetNineBoxGridDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetNineBoxGridDefinition];
GO

CREATE PROCEDURE [dbo].[spASRIntGetNineBoxGridDefinition] (
		@piReportID 			integer, 
	@psCurrentUser			varchar(255),
	@psAction				varchar(255))
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @psErrorMsg				varchar(MAX) = '',
			@psReportName			varchar(255) = '',
			@psReportOwner			varchar(255) = '',
			@psReportDesc			varchar(MAX) = '',
			@piBaseTableID			integer = 0,
			@piSelection			integer = 0,
			@piPicklistID			integer = 0,
			@psPicklistName			varchar(255) = '',
			@pfPicklistHidden		bit,
			@piFilterID				integer = 0,
			@psFilterName			varchar(255) = '',
			@pfFilterHidden			bit,
			@pfPrintFilterHeader	bit,
			@HColID					integer = 0,
			@HStart					varchar(20) = '',
			@HStop					varchar(20) = '',
			@HStep					varchar(20) = '',
			@VColID					integer = 0,
			@VStart					varchar(20) = '',
			@VStop					varchar(20) = '',
			@VStep					varchar(20) = '',
			@PColID					integer = 0,
			@PStart					varchar(20) = '',
			@PStop					varchar(20) = '',
			@PStep					varchar(20) = '',
			@IType					integer = 0,
			@IColID					integer = 0,
			@Percentage				bit,
			@PerPage				bit,
			@Suppress				bit,
			@Thousand				bit,
			@pfOutputPreview		bit,
			@piOutputFormat			integer = 0,
			@pfOutputScreen			bit,
			@pfOutputPrinter		bit,
			@psOutputPrinterName	varchar(MAX) = '',
			@pfOutputSave			bit,
			@piOutputSaveExisting	integer = 0,
			@pfOutputEmail			bit,
			@piOutputEmailAddr		integer = 0,
			@psOutputEmailName		varchar(MAX) = '',
			@psOutputEmailSubject	varchar(MAX) = '',
			@psOutputEmailAttachAs	varchar(MAX) = '',
			@psOutputFilename		varchar(MAX) = '',
 			@piTimestamp			integer	= 0,
			@XAxisLabel varchar(255) = '',
			@XAxisSubLabel1 varchar(255) = '',
			@XAxisSubLabel2 varchar(255) = '',
			@XAxisSubLabel3 varchar(255) = '',
			@YAxisLabel varchar(255) = '',
			@YAxisSubLabel1 varchar(255) = '',
			@YAxisSubLabel2 varchar(255) = '',
			@YAxisSubLabel3 varchar(255) = '',
			@Description1 varchar(255) = '',
			@ColorDesc1 varchar(6) = '',
			@Description2 varchar(255) = '',
			@ColorDesc2 varchar(6) = '',
			@Description3 varchar(255) = '',
			@ColorDesc3 varchar(6) = '',
			@Description4 varchar(255) = '',
			@ColorDesc4 varchar(6) = '',
			@Description5 varchar(255) = '',
			@ColorDesc5 varchar(6) = '',
			@Description6 varchar(255) = '',
			@ColorDesc6 varchar(6) = '',
			@Description7 varchar(255) = '',
			@ColorDesc7 varchar(6) = '',
			@Description8 varchar(255) = '',
			@ColorDesc8 varchar(6) = '',
			@Description9 varchar(255) = '',
			@ColorDesc9 varchar(6);


	DECLARE	@iCount			integer,
			@sTempHidden	varchar(MAX),
			@sAccess 		varchar(MAX);


	/* Check the report exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = '9-Box Grid has been deleted by another user.'
		RETURN
	END

	SELECT @psReportName = name, @psReportDesc	 = description, @psReportOwner = userName,
		@piBaseTableID = TableID, @piSelection = Selection, @piPicklistID = PicklistID,
		@piFilterID = FilterID,	@pfPrintFilterHeader = PrintFilterHeader, @psReportOwner = userName,
		@HColID = HorizontalColID, @HStart = HorizontalStart, @HStop = HorizontalStop, @HStep = HorizontalStep,
		@VColID = VerticalColID, @VStart = VerticalStart, @VStop = VerticalStop, @VStep = VerticalStep,
		@PColID = PageBreakColID, @PStart = PageBreakStart,	@PStop = PageBreakStop,	@PStep = PageBreakStep,
		@IType = IntersectionType, @IColID = IntersectionColID,	@Percentage = Percentage, @PerPage = PercentageofPage,
		@Suppress = SuppressZeros,@Thousand = ThousandSeparators,
		@pfOutputPreview = OutputPreview, @piOutputFormat = OutputFormat, @pfOutputScreen = OutputScreen,
		@pfOutputPrinter = OutputPrinter, @psOutputPrinterName = OutputPrinterName,
		@pfOutputSave = OutputSave,	@piOutputSaveExisting = OutputSaveExisting,
		@pfOutputEmail = OutputEmail, @piOutputEmailAddr = OutputEmailAddr,
		@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
		@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
		@psOutputFilename = ISNULL(OutputFilename,''),
		@piTimestamp = convert(integer, timestamp),
		@XAxisLabel = XAxisLabel,
		@XAxisSubLabel1 = XAxisSubLabel1,
		@XAxisSubLabel2 = XAxisSubLabel2,
		@XAxisSubLabel3 = XAxisSubLabel3,
		@YAxisLabel = YAxisLabel,
		@YAxisSubLabel1 = YAxisSubLabel1,
		@YAxisSubLabel2 = YAxisSubLabel2,
		@YAxisSubLabel3 = YAxisSubLabel3,
		@Description1 = Description1,
		@ColorDesc1 = ColorDesc1,
		@Description2 = Description2,
		@ColorDesc2 = ColorDesc2,
		@Description3 = Description3,
		@ColorDesc3 = ColorDesc3,
		@Description4 = Description4,
		@ColorDesc4 = ColorDesc4,
		@Description5 = Description5,
		@ColorDesc5 = ColorDesc5,
		@Description6 = Description6,
		@ColorDesc6 = ColorDesc6,
		@Description7 = Description7,
		@ColorDesc7 = ColorDesc7,
		@Description8 = Description8,
		@ColorDesc8 = ColorDesc8,
		@Description9 = Description9,
		@ColorDesc9 = ColorDesc9
	FROM ASRSysCrossTab
	WHERE CrossTabID = @piReportID;

	/* Check the current user can view the report. */
	EXEC spASRIntCurrentUserAccess 	1, @piReportID,	@sAccess OUTPUT;

	IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
		SET @psErrorMsg = '9-Box Grid has been made hidden by another user.';

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
		SET @psErrorMsg = '9-Box Grid has been made read only by another user.';

	IF @psAction = 'copy'
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50);
		SET @psReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access
		FROM ASRSysPicklistName 
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfPicklistHidden = 1;
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfFilterHidden = 1;
		END
	END

	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM ASRSysEmailGroupName
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;
		SET @psOutputEmailName = '';
	END

	SELECT @psErrorMsg AS ErrorMsg, @psReportName AS Name, @psReportOwner AS [Owner], @psReportDesc AS [Description]
		, @piBaseTableID AS [BaseTableID], @piSelection AS SelectionType
		, @piPicklistID AS PicklistID, @psPicklistName AS PicklistName, @pfPicklistHidden AS [IsPicklistHidden]
		, @piFilterID AS FilterID, @psFilterName AS [FilterName], @pfFilterHidden AS [IsFilterHidden]
		, @pfPrintFilterHeader AS [PrintFilterHeader]
		, @HColID AS HorizontalID, @HStart AS HorizontalStart, @HStop AS HorizontalStop, @HStep AS HorizontalIncrement
		, @VColID AS VerticalID, @VStart AS VerticalStart, @VStop AS VerticalStop, @VStep AS VerticalIncrement
		, @PColID AS PageBreakID, @PStart AS PageBreakStart, @PStop AS PageBreakStop, @PStep AS PageBreakIncrement
		, @IType AS IntersectionType, @IColID AS IntersectionID
		, @Percentage AS PercentageOfType, @PerPage AS PercentageOfPage
		, @Suppress	AS SuppressZeros, @Thousand AS [UseThousandSeparators]
		, @pfOutputPreview AS IsPreview, @piOutputFormat AS [Format],	@pfOutputScreen AS [ToScreen]
		, @pfOutputPrinter AS [ToPrinter], @psOutputPrinterName	AS [PrinterName]
		, @pfOutputSave AS [SaveToFile], @piOutputSaveExisting AS [SaveExisting]
		, @pfOutputEmail AS [SendToEmail], @piOutputEmailAddr AS [EmailGroupID], @psOutputEmailName AS [EmailGroupName]
		, @psOutputEmailSubject AS [EmailSubject], @psOutputEmailAttachAs AS [EmailAttachmentName]
		, @psOutputFilename AS [FileName], @piTimestamp AS [Timestamp],
		CASE WHEN @pfPicklistHidden = 1 OR @pfFilterHidden = 1 THEN 'HD' ELSE '' END AS [BaseViewAccess],
		@XAxisLabel AS XAxisLabel,
		@XAxisSubLabel1 AS XAxisSubLabel1,
		@XAxisSubLabel2 AS XAxisSubLabel2,
		@XAxisSubLabel3 AS XAxisSubLabel3,
		@YAxisLabel AS YAxisLabel,
		@YAxisSubLabel1 AS YAxisSubLabel1,
		@YAxisSubLabel2 AS YAxisSubLabel2,
		@YAxisSubLabel3 AS YAxisSubLabel3,
		@Description1 AS Description1,
		@ColorDesc1 AS ColorDesc1,
		@Description2 AS Description2,
		@ColorDesc2 AS ColorDesc2,
		@Description3 AS Description3,
		@ColorDesc3 AS ColorDesc3,
		@Description4 AS Description4,
		@ColorDesc4 AS ColorDesc4,
		@Description5 AS Description5,
		@ColorDesc5 AS ColorDesc5,
		@Description6 AS Description6,
		@ColorDesc6 AS ColorDesc6,
		@Description7 AS Description7,
		@ColorDesc7 AS ColorDesc7,
		@Description8 AS Description8,
		@ColorDesc8 AS ColorDesc8,
		@Description9 AS Description9,
		@ColorDesc9 AS ColorDesc9;
END

GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetLinks]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetLinks];
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[spASRIntGetLinks] 
(
		@plngTableID	integer,
		@plngViewID		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iCount				integer,
		@iUtilType			integer, 
		@iUtilID			integer,
		@iScreenID			integer,
		@iTableID			integer,
		@sTableName			sysname,
		@iTableType			integer,
		@sRealSource		sysname,
		@iChildViewID		integer,
		@sAccess			varchar(MAX),
		@sGroupName			varchar(255),
		@pfPermitted		bit,
		@sActualUserName	sysname,
		@iActualUserGroupID integer,
		@fBaseTableReadable bit,
		@iBaseTableID		integer,
		@sURL				varchar(MAX), 
		@fUtilOK			bit,
		@fDrillDownHidden bit,
		@iLinkType			integer,		-- 0 = Hypertext, 1 = Button, 2 = Dropdown List
		@iElement_Type		integer;		-- 2 = chart

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
	
	IF @plngViewID < 1 
	BEGIN 
		SET @plngViewID = -1;
	END
	SET @fBaseTableReadable = 1;
	
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA'
	BEGIN
		EXEC [dbo].[spASRIntGetActualUserDetails]
			@sActualUserName OUTPUT,
			@sGroupName OUTPUT,
			@iActualUserGroupID OUTPUT;
		
		DECLARE @Phase1 TABLE([ID] INT);
		INSERT INTO @Phase1
			SELECT Object_ID(ASRSysViews.ViewName) 
			FROM ASRSysViews 
			WHERE NOT Object_ID(ASRSysViews.ViewName) IS null
			UNION
			SELECT Object_ID(ASRSysTables.TableName) 
			FROM ASRSysTables 
			WHERE NOT Object_ID(ASRSysTables.TableName) IS null
			UNION
			SELECT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255))
			FROM ASRSysChildViews2
			INNER JOIN ASRSysTables 
				ON ASRSysChildViews2.tableID = ASRSysTables.tableID
			WHERE NOT OBJECT_ID(left('ASRSysCV' + convert(varchar(1000), ASRSysChildViews2.childViewID) 
				+ '#' + replace(ASRSysTables.tableName, ' ', '_')
				+ '#' + replace(@sGroupName, ' ', '_'), 255)) IS null;
		-- Cached view of the sysprotects table
		DECLARE @SysProtects TABLE([ID] int PRIMARY KEY CLUSTERED);
		INSERT INTO @SysProtects
			SELECT p.[ID] 
			FROM ASRSysProtectsCache p
						INNER JOIN SysColumns c ON (c.id = p.id
							AND c.[Name] = 'timestamp'
							AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
							AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) != 0)
							OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
							AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) = 0)))
			WHERE p.UID = @iUserGroupID
				AND p.[ProtectType] IN (204, 205)
				AND p.[Action] = 193			
				AND p.id IN (SELECT ID FROM @Phase1);
		-- Readable tables
		DECLARE @ReadableTables TABLE([Name] sysname PRIMARY KEY CLUSTERED);
		INSERT INTO @ReadableTables
			SELECT OBJECT_NAME(p.ID)
			FROM @SysProtects p;
		
		SET @sRealSource = '';
		IF @plngViewID > 0
		BEGIN
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @plngViewID;
		END
		ELSE
		BEGIN
			SELECT @sRealSource = tableName
			FROM ASRSysTables
			WHERE tableID = @plngTableID;
		END
		SET @fBaseTableReadable = 0
		IF len(@sRealSource) > 0
		BEGIN
			SELECT @iCount = COUNT(*)
			FROM @ReadableTables
			WHERE name = @sRealSource;
		
			IF @iCount > 0
			BEGIN
				SET @fBaseTableReadable = 1;
			END
		END
	END
	DECLARE @Links TABLE([ID]						integer PRIMARY KEY CLUSTERED,
											 [utilityType]	integer,
											 [utilityID]		integer,
											 [screenID]			integer,
											 [LinkType]			integer,
											 [Element_Type]	integer,
											 [DrillDownHidden]				bit);
	INSERT INTO @Links ([ID],[utilityType],[utilityID],[screenID], [LinkType], [Element_Type], [DrillDownHidden])
	SELECT ASRSysSSIntranetLinks.ID,
					ASRSysSSIntranetLinks.utilityType,
					ASRSysSSIntranetLinks.utilityID,
					ASRSysSSIntranetLinks.screenID,
					ASRSysSSIntranetLinks.LinkType,
					ASRSysSSIntranetLinks.Element_Type,
					0
	FROM ASRSysSSIntranetLinks
	WHERE (viewID = @plngViewID
			AND tableid = @plngTableID)
			AND (id NOT IN (SELECT linkid 
								FROM ASRSysSSIHiddenGroups
								WHERE groupName = @sGroupName));
	/* Remove any utility links from the temp table where the utility has been deleted or hidden from the current user.*/
	/* Or if the user does not permission to run them. */	
	DECLARE utilitiesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysSSIntranetLinks.utilityType,
					ASRSysSSIntranetLinks.utilityID,
					ASRSysSSIntranetLinks.screenID,
					ASRSysSSIntranetLinks.LinkType,
					ASRSysSSIntranetLinks.Element_Type
	FROM ASRSysSSIntranetLinks
	WHERE (viewID = @plngViewID
				AND tableid = @plngTableID)
			AND (utilityID > 0 
				OR screenID > 0);
	OPEN utilitiesCursor;
	FETCH NEXT FROM utilitiesCursor INTO @iUtilType, @iUtilID, @iScreenID, @iLinkType, @iElement_Type;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iUtilID > 0
		BEGIN
			SET @fUtilOK = 1	;			
			/* Check if the utility is deleted or hidden from the user. */
			EXECUTE [dbo].[spASRIntCurrentAccessForRole]
								@sGroupName,
								@iUtilType,
								@iUtilID,
								@sAccess	OUTPUT;
			IF @sAccess = 'HD' 
			BEGIN
				/* Report/utility is hidden from the user. */
				--HERE FOR CHARTs **************************************************************************************************************************************
				IF @iElement_Type = 2
				BEGIN
					SET @fUtilOK = 1;				
					SET @fDrillDownHidden = 1;
				END
				ELSE
				BEGIN
					SET @fUtilOK = 0;
				END
			END
			IF @fUtilOK = 1
			BEGIN
				/* Check if the user has system permission to run this type of report/utility. */
				IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA'
				BEGIN
					SELECT @pfPermitted = ASRSysGroupPermissions.permitted
					FROM ASRSysPermissionItems
					INNER JOIN ASRSysPermissionCategories 
					ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 					
							CASE 
								WHEN @iUtilType = 17 THEN 'CALENDARREPORTS'
								WHEN @iUtilType = 9 THEN 'MAILMERGE'
								WHEN @iUtilType = 2 THEN 'CUSTOMREPORTS'
								WHEN @iUtilType = 25 THEN 'WORKFLOW'
								WHEN @iUtilType = 35 THEN 'NINEBOXGRID'
								ELSE ''
							END
					LEFT OUTER JOIN ASRSysGroupPermissions 
					ON ASRSysPermissionItems.itemID = ASRSysGroupPermissions.itemID
						AND ASRSysGroupPermissions.groupName = @sGroupName
					WHERE ASRSysPermissionItems.itemKey = 'RUN';
					IF (@pfPermitted IS null) OR (@pfPermitted = 0)
					BEGIN
						/* User does not have system permission to run this type of report/utility. */
						--HERE FOR CHARTS**************************************************************************************************************************************
						IF @iElement_Type = 2
						BEGIN
							SET @fUtilOK = 1;
							SET @fDrillDownHidden = 1;
						END
						ELSE
						BEGIN
							SET @fUtilOK = 0;
						END
					END
				END
			END
			IF @fUtilOK = 1
			BEGIN
				/* Check if the user has read permission on the report/utility base table or any views on it. */
				SET @iBaseTableID = 0;
				IF @iUtilType = 17 /* Calendar Reports */
				BEGIN
					SELECT @iBaseTableID = baseTable
					FROM ASRSysCalendarReports
					WHERE id = @iUtilID;
				END
				IF @iUtilType = 2 /* Custom Reports */
				BEGIN
					SELECT @iBaseTableID = baseTable
					FROM ASRSysCustomReportsName
					WHERE id = @iUtilID;
				END
				IF @iUtilType = 9 /* Mail Merge */
				BEGIN
					SELECT @iBaseTableID = TableID
					FROM ASRSysMailMergeName
					WHERE MailMergeID = @iUtilID;
				END
				IF @iUtilType = 35 /* 9-Box Grid Reports */
				BEGIN				
					SELECT @iBaseTableID = TableID
					FROM ASRSysCrossTab
					WHERE CrossTabID = @iUtilID
					AND CrossTabType = 4;
				END
				/* Not check required for reports/utilities without a base table.
				OR reports/utilities based on the top-level table if the user has read permission on the current view. */
				IF (@iBaseTableID > 0)
					AND((@fBaseTableReadable = 0)
						OR (@iBaseTableID <> @plngTableID))
				BEGIN
					IF (@iLinkType <> 0) -- Hypertext link
						AND (@fBaseTableReadable = 0)
						AND (@iBaseTableID = @plngTableID)
					BEGIN
						/* The report/utility is based on the top-level table, and the user does NOT have read permission
						on the current view (on which Button & DropdownList links are scoped). */
						SET @fUtilOK = 0;
					END
					ELSE
					BEGIN
						SELECT @iCount = COUNT(p.ID)
						FROM @SysProtects p
						WHERE OBJECT_NAME(p.ID) IN (SELECT ASRSysTables.tableName
							FROM ASRSysTables
							WHERE ASRSysTables.tableID = @iBaseTableID
						UNION 
							SELECT ASRSysViews.viewName
								FROM ASRSysViews
								WHERE ASRSysViews.viewTableID = @iBaseTableID
						UNION
							SELECT
								left('ASRSysCV' 
									+ convert(varchar(1000), ASRSysChildViews2.childViewID) 
									+ '#'
									+ replace(ASRSysTables.tableName, ' ', '_')
									+ '#'
									+ replace(@sGroupName, ' ', '_'), 255)
								FROM ASRSysChildViews2
								INNER JOIN ASRSysTables ON ASRSysChildViews2.tableID = ASRSysTables.tableID
								WHERE ASRSysChildViews2.role = @sGroupName
									AND ASRSysChildViews2.tableID = @iBaseTableID);
						IF @iCount = 0 
						BEGIN
							SET @fUtilOK = 0;
						END
					END
				END
			END
			/* For some reason the user cannot use this report/utility, so remove it from the temp table of links. */
			IF @fUtilOK = 0 
			BEGIN
				DELETE FROM @Links
				WHERE utilityType = @iUtilType
					AND utilityID = @iUtilID;
			END
			IF @fDrillDownHidden = 1
			BEGIN
				UPDATE @Links
				SET DrillDownHidden = 1 
				WHERE utilityType = @iUtilType
					AND utilityID = @iUtilID;
			END
			
		END
		
		IF (@iScreenID > 0) AND (UPPER(LTRIM(RTRIM(SYSTEM_USER))) <> 'SA')
		BEGIN
			/* Do not display the link if the user does not have permission to read the defined view/table for the screen. */
			SELECT @iTableID = ASRSysTables.tableID, 
				@sTableName = ASRSysTables.tableName,
				@iTableType = ASRSysTables.tableType
			FROM ASRSysScreens
						INNER JOIN ASRSysTables 
						ON ASRSysScreens.tableID = ASRSysTables.tableID
			WHERE screenID = @iScreenID;
			SET @sRealSource = '';
			IF @iTableType  = 2
			BEGIN
				SET @iChildViewID = 0;
				/* Child table - check child views. */
				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @iTableID
					AND [role] = @sGroupName;
				
				IF @iChildViewID IS null SET @iChildViewID = 0;
				
				IF (@iChildViewID > 0) AND (@fBaseTableReadable = 1)
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTableName, ' ', '_') +
						'#' + replace(@sGroupName, ' ', '_');
				
					SET @sRealSource = left(@sRealSource, 255);
				END
				ELSE
				BEGIN
					DELETE FROM @Links
					WHERE screenID = @iScreenID;
				END
			END
			ELSE
			BEGIN
				/* Not a child table - must be the top-level table. Check if the user has 'read' permission on the defined view. */
				SET @sRealSource = '';
				IF @plngViewID > 0
				BEGIN
					SELECT @sRealSource = viewName
					FROM ASRSysViews
					WHERE viewID = @plngViewID;
				END
				ELSE
				BEGIN
					SELECT @sRealSource = tableName
					FROM ASRSysTables
					WHERE tableID = @plngTableID;
				END
			END
			IF len(@sRealSource) > 0
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM @ReadableTables
				WHERE name = @sRealSource;
			
				IF @iCount = 0
				BEGIN
					DELETE FROM @Links
					WHERE screenID = @iScreenID;
				END
			END
		END
		FETCH NEXT FROM utilitiesCursor INTO @iUtilType, @iUtilID, @iScreenID, @iLinkType, @iElement_Type;
	END
	CLOSE utilitiesCursor;
	DEALLOCATE utilitiesCursor;
	/* Remove the Workflow links if the URL has not been configured. */
	SELECT @sURL = isnull(settingValue , '')
	FROM ASRSysSystemSettings
	WHERE section = 'MODULE_WORKFLOW'		
		AND settingKey = 'Param_URL';	
	
	
	IF LEN(@sURL) = 0
	BEGIN
		DELETE FROM @Links
		WHERE utilityType = 25;
	END
	SELECT ASRSysSSIntranetLinks.*, 
		CASE 
			WHEN ASRSysSSIntranetLinks.utilityType = 9 THEN ASRSysMailMergeName.TableID
			WHEN ASRSysSSIntranetLinks.utilityType = 2 THEN ASRSysCustomReportsName.baseTable
			WHEN ASRSysSSIntranetLinks.utilityType = 17 THEN ASRSysCalendarReports.baseTable
			WHEN ASRSysSSIntranetLinks.utilityType = 35 THEN ASRSysCrossTab.TableID
			WHEN ASRSysSSIntranetLinks.utilityType = 25 THEN 0
			ELSE null
		END AS [baseTable],
		ASRSysColumns.ColumnName as [Chart_ColumnName],
		tvL.DrillDownHidden as [DrillDownHidden]
	FROM ASRSysSSIntranetLinks
			LEFT OUTER JOIN ASRSysMailMergeName 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysMailMergeName.MailMergeID
				AND ASRSysSSIntranetLinks.utilityType = 9
			LEFT OUTER JOIN ASRSysCalendarReports 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysCalendarReports.ID
				AND ASRSysSSIntranetLinks.utilityType = 17
			LEFT OUTER JOIN ASRSysCrossTab 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysCrossTab.CrossTabID
				AND ASRSysSSIntranetLinks.utilityType = 35
			LEFT OUTER JOIN ASRSysCustomReportsName 
			ON ASRSysSSIntranetLinks.utilityID = ASRSysCustomReportsName.ID
				AND ASRSysSSIntranetLinks.utilityType = 2
			LEFT OUTER JOIN ASRSysColumns
			ON ASRSysSSIntranetLinks.Chart_ColumnID = ASRSysColumns.columnId		
			LEFT OUTER JOIN @Links tvL
			ON ASRSysSSIntranetLinks.ID = tvL.ID
	WHERE ASRSysSSIntranetLinks.ID IN (SELECT ID FROM @Links)
	ORDER BY ASRSysSSIntranetLinks.linkOrder;
	
END

GO



IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntDefUsage]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntDefUsage];
GO
CREATE PROCEDURE [dbo].[sp_ASRIntDefUsage] (
	@intType int, 
	@intID int
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @sExecSQL		nvarchar(MAX),
		@sJobTypeName		varchar(255),
		@sCurrentUser		sysname,
		@sDescription		varchar(MAX),
		@sName				varchar(255), 
		@sUserName			varchar(255), 
		@sAccess			varchar(MAX),
		@fIsBatch			bit,
		@sUtilType			varchar(255),
		@iCompID			integer,
		@iRootExprID		integer,
		@sRoleName			varchar(255),
		@fSysSecMgr			bit,
		@iCount				integer,
		@sActualUserName	sysname,
		@iUserGroupID		integer;
		
	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
	
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;

	SET @sExecSQL = '';
	SET @sCurrentUser = SYSTEM_USER;

	DECLARE @results TABLE([description] varchar(MAX));
	DECLARE @rootExprs TABLE(exprID integer);

	IF @intType = 11 OR @intType = 12
	BEGIN
		/* Create a table of IDs of the expressions that use the given filter or calc. */
		DECLARE expr_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT componentID 
			FROM ASRSysExprComponents
			WHERE calculationID = @intID
				OR filterID = @intID
				OR (fieldSelectionFilter = @intID AND type = 1)
		OPEN expr_cursor
		FETCH NEXT FROM expr_cursor INTO @iCompID
		WHILE (@@fetch_status = 0)
		BEGIN
			execute sp_ASRIntGetRootExpressionIDs @iCompID, @iRootExprID OUTPUT
			IF @iRootExprID > 0
			BEGIN
				INSERT INTO @rootExprs (exprID) VALUES (@iRootExprID)
			END
			FETCH NEXT FROM expr_cursor INTO @iCompID
		END
		CLOSE expr_cursor
		DEALLOCATE expr_cursor
	END

	IF @intType = 1 OR @intType = 2 OR @intType = 9 OR @intType = 17 OR @intType = 35
	BEGIN
		/* Reports & Utilities
		Check for usage in Batch Jobs */
		IF @intType = 1 SET @sJobTypeName = 'CROSS TAB'
		IF @intType = 2 SET @sJobTypeName = 'CUSTOM REPORT'
		IF @intType = 9 SET @sJobTypeName = 'MAIL MERGE' 
		IF @intType = 17 SET @sJobTypeName = 'CALENDAR REPORT'
		IF @intType = 35 SET @sJobTypeName = '9-BOX GRID REPORT'
		
		DECLARE usage_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT DISTINCT ASRSysBatchJobName.Name, 
				ASRSysBatchJobName.UserName, 
				ASRSysBatchJobAccess.Access,
				AsrSysBatchJobName.IsBatch
			FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobDetails.BatchJobNameID = ASRSysBatchJobName.ID
			INNER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.groupname = @sRoleName
			WHERE ASRSysBatchJobDetails.JobType = @sJobTypeName
				AND ASRSysBatchJobDetails.JobID = @intID
		OPEN usage_cursor
		FETCH NEXT FROM usage_cursor INTO @sName, @sUserName, @sAccess, @fIsBatch
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @fIsBatch = 1 BEGIN
				SET @sDescription = 'Batch Job: '
			END ELSE BEGIN
				SET @sDescription = 'Report Pack: '
			END

			IF (@sUserName <> @sCurrentUser)
				AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @sDescription = @sDescription + '&lt;Hidden by ' + @sUserName + '&gt;'
			END
			ELSE
			BEGIN
				SET @sDescription = @sDescription + '''' + @sName + ''''
			END
    
			INSERT INTO @results (description) VALUES (@sDescription)

			FETCH NEXT FROM usage_cursor INTO @sName, @sUserName, @sAccess, @fIsBatch
		END
		CLOSE usage_cursor
		DEALLOCATE usage_cursor

		SELECT @iCount = COUNT(*) 
		FROM [ASRSysSSIntranetLinks]
		WHERE [ASRSysSSIntranetLinks].[utilityID] = @intID
			AND [ASRSysSSIntranetLinks].[utilityType] = @intType
		IF @iCount > 0
		BEGIN
		   	INSERT INTO @results (description) VALUES ('Self-service intranet link')
		END
	END

	IF @intType = 10
	BEGIN
		/* Picklists 
		Check for usage in Cross Tabs, Data Transfers, Globals, Exports, Custom Reports, Calendar Reports and Mail Merges*/
		DECLARE usage_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT DISTINCT 'Cross Tab', 
					ASRSysCrossTab.Name, 
					ASRSysCrossTab.UserName, 
					ASRSysCrossTabAccess.Access
				FROM ASRSysCrossTab
				INNER JOIN ASRSysCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSysCrossTabAccess.ID
					AND ASRSysCrossTabAccess.groupname = @sRoleName					
				WHERE PickListID =@intID
					AND ASRSysCrossTab.CrossTabType <> 4
			UNION
				SELECT DISTINCT '9-Box Grid Report', 
					ASRSysCrossTab.Name, 
					ASRSysCrossTab.UserName, 
					ASRSysCrossTabAccess.Access
				FROM ASRSysCrossTab
				INNER JOIN ASRSysCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSysCrossTabAccess.ID
					AND ASRSysCrossTabAccess.groupname = @sRoleName					
				WHERE PickListID =@intID
					AND ASRSysCrossTab.CrossTabType = 4
			UNION
				SELECT DISTINCT 'Data Transfer',
					ASRSysDataTransferName.Name,
					ASRSysDataTransferName.UserName,
					ASRSysDataTransferAccess.Access
				FROM ASRSysDataTransferName
				INNER JOIN ASRSysDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSysDataTransferAccess.ID
					AND ASRSysDataTransferAccess.groupname = @sRoleName
				WHERE ASRSysDataTransferName.pickListID = @intID
			UNION
				SELECT DISTINCT 'Export',
					ASRSysExportName.Name,
					ASRSysExportName.UserName,
					ASRSysExportAccess.Access
				FROM ASRSysExportName
				INNER JOIN ASRSysExportAccess ON ASRSysExportName.ID = ASRSysExportAccess.ID
					AND ASRSysExportAccess.groupname = @sRoleName
				WHERE ASRSysExportName.pickList = @intID OR ASRSysExportName.Parent1Picklist = @intID OR ASRSysExportName.Parent2Picklist = @intID
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysGlobalFunctions.Type = 'A' THEN 'Global Add'
						WHEN ASRSysGlobalFunctions.Type = 'D' THEN 'Global Delete'
						WHEN ASRSysGlobalFunctions.Type = 'U' THEN 'Global Update'
						ELSE 'Global Function' 
					END, 
					ASRSysGlobalFunctions.Name,
					ASRSysGlobalFunctions.UserName,
					ASRSysGlobalAccess.Access
				FROM ASRSysGlobalFunctions
				INNER JOIN ASRSysGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSysGlobalAccess.ID
					AND ASRSysGlobalAccess.groupname = @sRoleName
				WHERE ASRSysGlobalFunctions.pickListID = @intID
			UNION
				SELECT DISTINCT 'Custom Report', 
					ASRSysCustomReportsName.Name, 
					ASRSysCustomReportsName.UserName, 
					ASRSysCustomReportAccess.Access 
				FROM ASRSysCustomReportsName
				INNER JOIN ASRSysCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSysCustomReportAccess.ID
					AND ASRSysCustomReportAccess.groupname = @sRoleName
				WHERE ASRSysCustomReportsName.PickList = @intID 
					OR ASRSysCustomReportsName.Parent1Picklist = @intID 
					OR ASRSysCustomReportsName.Parent2Picklist = @intID
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysMailMergeName.isLabel = 1 THEN 'Envelopes & Labels'
						ELSE 'Mail Merge' 
					END, 
					ASRSysMailMergeName.Name, 
					ASRSysMailMergeName.UserName, 
					ASRSysMailMergeAccess.Access
				FROM ASRSysMailMergeName 
				INNER JOIN ASRSysMailMergeAccess ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeAccess.ID
					AND ASRSysMailMergeAccess.groupname = @sRoleName
				WHERE PickListID = @intID
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysMatchReportName.matchReportType = 0 THEN 'Match Report'
						WHEN ASRSysMatchReportName.matchReportType = 1 THEN 'Succession Planning'
						WHEN ASRSysMatchReportName.matchReportType = 2 THEN 'Career Progression' 
						ELSE 'Match Report'
					END,
					ASRSysMatchReportName.Name,
					ASRSysMatchReportName.UserName,
					ASRSysMatchReportAccess.Access
				FROM ASRSysMatchReportName
				INNER JOIN ASRSysMatchReportAccess ON ASRSysMatchReportName.matchReportID = ASRSysMatchReportAccess.ID
					AND ASRSysMatchReportAccess.groupname = @sRoleName
				WHERE ASRSysMatchReportName.Table1Picklist = @intID
					OR ASRSysMatchReportName.Table2Picklist = @intID
			UNION
				SELECT DISTINCT 'Calendar Report', 
					ASRSysCalendarReports.Name, 
					ASRSysCalendarReports.UserName, 
					ASRSysCalendarReportAccess.Access
				FROM ASRSysCalendarReports
				INNER JOIN ASRSysCalendarReportAccess ON ASRSysCalendarReports.ID = ASRSysCalendarReportAccess.ID
					AND ASRSysCalendarReportAccess.groupname = @sRoleName
				WHERE ASRSysCalendarReports.PickList = @intID
			UNION
				SELECT DISTINCT 'Record Profile',
					ASRSysRecordProfileName.Name,
					ASRSysRecordProfileName.UserName,
					ASRSysRecordProfileAccess.Access
				FROM ASRSysRecordProfileName
				INNER JOIN ASRSysRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSysRecordProfileAccess.ID
					AND ASRSysRecordProfileAccess.groupname = @sRoleName
				WHERE ASRSysRecordProfileName.pickListID = @intID
			
		OPEN usage_cursor
		FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sDescription = @sUtilType + ': '

			IF (@sUserName <>@sCurrentUser)
				AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @sDescription = @sDescription + '&lt;Hidden by ' + @sUserName + '&gt;'
			END
			ELSE
			BEGIN
				SET @sDescription = @sDescription + '''' + @sName + ''''
			END
    
    			INSERT INTO @results (description) VALUES (@sDescription)

			FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess
		END
		CLOSE usage_cursor
		DEALLOCATE usage_cursor
	END

	IF @intType = 11
	BEGIN
		/* Filters 
		Check for usage in Cross Tabs, Data Transfers, Globals, Exports, Custom Reports and Mail Merges. Also other Filters and Calculations*/
		DECLARE usage_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT DISTINCT 'Calculation', Name, UserName, Access 
				FROM ASRSysExpressions
				WHERE Type = 10
					AND ExprID IN (SELECT exprID FROM @rootExprs)
			UNION
				SELECT DISTINCT 'Cross Tab',
					ASRSysCrossTab.Name,
					ASRSysCrossTab.UserName,
					ASRSysCrossTabAccess.Access
				FROM ASRSysCrossTab
				INNER JOIN ASRSysCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSysCrossTabAccess.ID
					AND ASRSysCrossTabAccess.groupname = @sRoleName
				WHERE ASRSysCrossTab.FilterID = @intID
					AND ASRSysCrossTab.CrossTabType <> 4
			UNION
				SELECT DISTINCT '9-Box Grid Report', 
					ASRSysCrossTab.Name, 
					ASRSysCrossTab.UserName, 
					ASRSysCrossTabAccess.Access
				FROM ASRSysCrossTab
				INNER JOIN ASRSysCrossTabAccess ON ASRSysCrossTab.crossTabID = ASRSysCrossTabAccess.ID
					AND ASRSysCrossTabAccess.groupname = @sRoleName					
				WHERE ASRSysCrossTab.FilterID = @intID
					AND ASRSysCrossTab.CrossTabType = 4
			UNION
				SELECT DISTINCT 'Custom Report', 
					ASRSysCustomReportsName.Name, 
					ASRSysCustomReportsName.UserName, 
					ASRSysCustomReportAccess.Access
				FROM ASRSysCustomReportsName
				LEFT OUTER JOIN ASRSYSCustomReportsChildDetails ON ASRSysCustomReportsName.ID = ASRSYSCustomReportsChildDetails.customReportID
				INNER JOIN ASRSysCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSysCustomReportAccess.ID
					AND ASRSysCustomReportAccess.groupname = @sRoleName
				WHERE ASRSysCustomReportsName.Filter = @intID
					OR ASRSysCustomReportsName.Parent1Filter = @intID
					OR ASRSysCustomReportsName.Parent2Filter = @intID
					OR ASRSYSCustomReportsChildDetails.ChildFilter = @intID
			UNION
				SELECT DISTINCT 'Data Transfer',
					ASRSysDataTransferName.Name,
					ASRSysDataTransferName.UserName,
					ASRSysDataTransferAccess.Access
				FROM ASRSysDataTransferName
				INNER JOIN ASRSysDataTransferAccess ON ASRSysDataTransferName.DataTransferID = ASRSysDataTransferAccess.ID
					AND ASRSysDataTransferAccess.groupname = @sRoleName
				WHERE ASRSysDataTransferName.FilterID = @intID
			UNION
				SELECT DISTINCT 'Export',
					ASRSysExportName.Name,
					ASRSysExportName.UserName,
					ASRSysExportAccess.Access
				FROM ASRSysExportName
				INNER JOIN ASRSysExportAccess ON ASRSysExportName.ID = ASRSysExportAccess.ID
					AND ASRSysExportAccess.groupname = @sRoleName
				WHERE ASRSysExportName.Filter = @intID 
					OR ASRSysExportName.Parent1Filter = @intID
					OR ASRSysExportName.Parent2Filter = @intID
					OR ASRSysExportName.ChildFilter = @intID
			UNION
				SELECT DISTINCT 'Filter', Name, UserName, Access
				FROM ASRSysExpressions
				WHERE Type = 11
					AND ExprID IN (SELECT exprID FROM @rootExprs)
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysGlobalFunctions.Type = 'A' THEN 'Global Add'
						WHEN ASRSysGlobalFunctions.Type = 'D' THEN 'Global Delete'
						WHEN ASRSysGlobalFunctions.Type = 'U' THEN 'Global Update'
						ELSE 'Global Function' 
					END, 
					ASRSysGlobalFunctions.Name,
					ASRSysGlobalFunctions.UserName,
					ASRSysGlobalAccess.Access
				FROM ASRSysGlobalFunctions
				INNER JOIN ASRSysGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSysGlobalAccess.ID
					AND ASRSysGlobalAccess.groupname = @sRoleName
				WHERE ASRSysGlobalFunctions.FilterID = @intID
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysMailMergeName.isLabel = 1 THEN 'Envelopes & Labels'
						ELSE 'Mail Merge' 
					END,
					ASRSysMailMergeName.Name,
					ASRSysMailMergeName.UserName,
					ASRSysMailMergeAccess.Access
				FROM ASRSysMailMergeName
				INNER JOIN ASRSysMailMergeAccess ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeAccess.ID
					AND ASRSysMailMergeAccess.groupname = @sRoleName
				WHERE ASRSysMailMergeName.FilterID = @intID
			UNION
				SELECT DISTINCT
					CASE 
						WHEN ASRSysMatchReportName.matchReportType = 0 THEN 'Match Report'
						WHEN ASRSysMatchReportName.matchReportType = 1 THEN 'Succession Planning' 
						WHEN ASRSysMatchReportName.matchReportType = 2 THEN 'Career Progression' 
						ELSE 'Match Report' 
					END,
					ASRSysMatchReportName.Name,
					ASRSysMatchReportName.UserName,
					ASRSysMatchReportAccess.Access
				FROM ASRSysMatchReportName
				INNER JOIN ASRSysMatchReportAccess ON ASRSysMatchReportName.matchReportID = ASRSysMatchReportAccess.ID
					AND ASRSysMatchReportAccess.groupname = @sRoleName
				WHERE ASRSysMatchReportName.Table1Filter = @intID
					OR ASRSysMatchReportName.Table2Filter = @intID
			UNION
				SELECT DISTINCT 'Calendar Report', 
					ASRSysCalendarReports.Name, 
					ASRSysCalendarReports.UserName, 
					ASRSysCalendarReportAccess.Access
				FROM ASRSysCalendarReports
				LEFT OUTER JOIN ASRSysCalendarReportEvents ON ASRSysCalendarReports.ID = ASRSysCalendarReportEvents.CalendarReportID
				INNER JOIN ASRSysCalendarReportAccess ON ASRSysCalendarReportAccess.ID = ASRSysCalendarReports.ID
					AND ASRSysCalendarReportAccess.groupname = @sRoleName
				WHERE ASRSysCalendarReports.filter = @intID
					OR ASRSysCalendarReportEvents.filterID = @intID
			UNION
				SELECT DISTINCT 'Record Profile',
					ASRSysRecordProfileName.Name,
					ASRSysRecordProfileName.UserName,
					ASRSysRecordProfileAccess.Access
				FROM ASRSysRecordProfileName
				INNER JOIN ASRSysRecordProfileAccess ON ASRSysRecordProfileName.recordProfileID = ASRSysRecordProfileAccess.ID
					AND ASRSysRecordProfileAccess.groupname = @sRoleName
				LEFT OUTER JOIN ASRSYSRecordProfileTables ON ASRSysRecordProfileName.recordProfileID = ASRSYSRecordProfileTables.recordProfileID
				WHERE ASRSysRecordProfileName.FilterID = @intID
					OR ASRSYSRecordProfileTables.FilterID = @intID		

		OPEN usage_cursor
		FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sDescription = @sUtilType + ': '

			IF (@sUserName <>@sCurrentUser)
				AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @sDescription = @sDescription + '&lt;Hidden by ' + @sUserName + '&gt;'
			END
			ELSE
			BEGIN
				SET @sDescription = @sDescription + '''' + @sName + ''''
			END
    
    			INSERT INTO @results (description) VALUES (@sDescription)

			FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess
		END
		CLOSE usage_cursor
		DEALLOCATE usage_cursor
	END

	IF @intType = 12
	BEGIN
		/* Calculation.
		Check for usage in Globals, Exports, Custom Reports and Mail Merges. Also other Filters and Calculations*/
		DECLARE usage_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT DISTINCT 'Calculation', Name, UserName, Access 
				FROM ASRSysExpressions
				WHERE Type = 10
					AND ExprID IN (SELECT exprID FROM @rootExprs)
			UNION
				SELECT DISTINCT 'Calendar Report', 
					ASRSysCalendarReports.Name, 
					ASRSysCalendarReports.UserName, 
					ASRSysCalendarReportAccess.Access
				FROM ASRSysCalendarReports 
				INNER JOIN ASRSysCalendarReportAccess ON ASRSysCalendarReportAccess.ID = ASRSysCalendarReports.ID
					AND ASRSysCalendarReportAccess.groupname = @sRoleName
				WHERE ASRSysCalendarReports.DescriptionExpr =@intID 
					OR ASRSysCalendarReports.StartDateExpr = @intID 
					OR ASRSysCalendarReports.EndDateExpr = @intID
			UNION
				SELECT DISTINCT 'Custom Report', 
					ASRSysCustomReportsName.Name,
					ASRSysCustomReportsName.UserName,
					ASRSysCustomReportAccess.Access
				FROM ASRSysCustomReportsDetails
				INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsDetails.CustomReportID = ASRSysCustomReportsName.ID
				INNER JOIN ASRSysCustomReportAccess ON ASRSysCustomReportsName.ID = ASRSysCustomReportAccess.ID
					AND ASRSysCustomReportAccess.groupname = @sRoleName
				WHERE UPPER(ASRSysCustomReportsDetails.type) = 'E' 
					AND ASRSysCustomReportsDetails.colExprID = @intID
			UNION
				SELECT DISTINCT 'Export',
					ASRSysExportName.Name,
					ASRSysExportName.UserName,
					ASRSysExportAccess.Access
				FROM ASRSysExportDetails
				INNER JOIN ASRSysExportName ON ASRSysExportDetails.ID = ASRSysExportName.ID 
				INNER JOIN ASRSysExportAccess ON ASRSysExportName.ID = ASRSysExportAccess.ID
					AND ASRSysExportAccess.groupname = @sRoleName
				WHERE UPPER(ASRSysExportDetails.type) = 'X' 
					AND ASRSysExportDetails.colExprID = @intID
			UNION
				SELECT DISTINCT 'Filter', Name, UserName, Access
				FROM ASRSysExpressions
				WHERE Type = 11
					AND ExprID IN (SELECT exprID FROM @rootExprs)
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysGlobalFunctions.Type = 'A' THEN 'Global Add'
						WHEN ASRSysGlobalFunctions.Type = 'D' THEN 'Global Delete'
						WHEN ASRSysGlobalFunctions.Type = 'U' THEN 'Global Update'
						ELSE 'Global Function' 
					END, 
					ASRSysGlobalFunctions.Name,
					ASRSysGlobalFunctions.UserName,
					ASRSysGlobalAccess.Access
				FROM ASRSysGlobalItems
				INNER JOIN ASRSysGlobalFunctions ON ASRSysGlobalItems.functionID = ASRSysGlobalFunctions.functionID 
				INNER JOIN ASRSysGlobalAccess ON ASRSysGlobalFunctions.functionID = ASRSysGlobalAccess.ID
					AND ASRSysGlobalAccess.groupname = @sRoleName
				WHERE ASRSysGlobalItems.ValueType = 4 
					AND ASRSysGlobalItems.ExprID = @intID
			UNION
				SELECT DISTINCT 
					CASE 
						WHEN ASRSysMailMergeName.isLabel = 1 THEN 'Envelopes & Labels'
						ELSE 'Mail Merge' 
					END,
					ASRSysMailMergeName.Name,
					ASRSysMailMergeName.UserName,
					ASRSysMailMergeAccess.Access
				FROM ASRSysMailMergeName
				INNER JOIN ASRSysMailMergeColumns ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeColumns.mailMergeID
				INNER JOIN ASRSysMailMergeAccess ON ASRSysMailMergeName.mailMergeID = ASRSysMailMergeAccess.ID
					AND ASRSysMailMergeAccess.groupname = @sRoleName
				WHERE ASRSysMailMergeColumns.ColumnID = @intID
					AND upper(ASRSysMailMergeColumns.type) = 'E'
			
		OPEN usage_cursor
		FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sDescription = @sUtilType + ': '

			IF (@sUserName <>@sCurrentUser)
				AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @sDescription = @sDescription + '&lt;Hidden by ' + @sUserName + '&gt;'
			END
			ELSE
			BEGIN
				SET @sDescription = @sDescription + '''' + @sName + '''';
			END
    
    		INSERT INTO @results (description) VALUES (@sDescription)

			FETCH NEXT FROM usage_cursor INTO @sUtilType, @sName, @sUserName, @sAccess;
		END
		
		CLOSE usage_cursor;
		DEALLOCATE usage_cursor;
	END

	/* Return the usage records. */
	SELECT * FROM @results ORDER BY description;

END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCustomReportDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCustomReportDefinition];
GO
CREATE PROCEDURE [dbo].[spASRIntGetCustomReportDefinition] (
	@piReportID 				integer, 
	@psCurrentUser				varchar(255),
	@psAction					varchar(255))
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iCount				integer,
			@sTempHidden		varchar(MAX),
			@sAccess			varchar(MAX),
			@sTempUsername		varchar(MAX),
			@fSysSecMgr			bit;

	DECLARE @psErrorMsg				varchar(MAX) = '',
		@psReportName				varchar(255) = '',
		@psReportOwner				varchar(255) = '',
		@psReportDesc				varchar(MAX) = '',
		@piBaseTableID				integer = 0,
		@pfAllRecords				bit			,
		@piPicklistID				integer = 0,
		@psPicklistName				varchar(255) = '',
		@pfPicklistHidden			bit			,
		@piFilterID					integer = 0,
		@psFilterName				varchar(255) = '',
		@pfFilterHidden				bit			,
		@piParent1TableID			integer = 0,
		@psParent1Name				varchar(255) = '',
		@piParent1FilterID			integer = 0,
		@psParent1FilterName		varchar(255) = '',
		@pfParent1FilterHidden		bit			,
		@piParent2TableID			integer = 0,
		@psParent2Name				varchar(255) = '',
		@piParent2FilterID			integer = 0,
		@psParent2FilterName		varchar(255) = '',
		@pfParent2FilterHidden		bit,
		@pfSummary					bit,
		@pfPrintFilterHeader		bit,
		@pfOutputPreview			bit,
		@piOutputFormat				integer = 0,
		@pfOutputScreen				bit,
		@pfOutputPrinter			bit,
		@psOutputPrinterName		varchar(MAX) = '',
		@pfOutputSave				bit,
		@piOutputSaveExisting		integer = 0,
		@pfOutputEmail				bit,
		@piOutputEmailAddr			integer = 0,
		@psOutputEmailName			varchar(MAX) = '',
		@psOutputEmailSubject		varchar(MAX) = '',
		@psOutputEmailAttachAs		varchar(MAX) = '',
		@psOutputFilename			varchar(MAX) = '',
		@piTimestamp				integer = 0,
		@pfParent1AllRecords		bit,
		@piParent1PicklistID		integer,
		@psParent1PicklistName		varchar(255) = '',
		@pfParent1PicklistHidden	bit,
		@pfParent2AllRecords		bit,
		@piParent2PicklistID		integer,
		@psParent2PicklistName		varchar(255) = '',
		@pfParent2PicklistHidden	bit,
		@psInfoMsg					varchar(MAX) = '',
		@pfIgnoreZeros				bit;

	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT;
	
	/* Check the report exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysCustomReportsName 
	WHERE ID = @piReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report has been deleted by another user.';
		RETURN;
	END

	SELECT @psReportName = name,
		@psReportDesc	 = description,
		@piBaseTableID = baseTable,
		@pfAllRecords = allRecords,
		@piPicklistID = picklist,
		@piFilterID = filter,
		@piParent1TableID = parent1Table,
		@piParent1FilterID = parent1Filter,
		@piParent2TableID = parent2Table,
		@piParent2FilterID = parent2Filter,
		@pfSummary = summary,
		@pfPrintFilterHeader = printFilterHeader,
		@psReportOwner = userName,
		@pfOutputPreview = OutputPreview,
		@piOutputFormat = OutputFormat,
		@pfOutputScreen = OutputScreen,
		@pfOutputPrinter = OutputPrinter,
		@psOutputPrinterName = OutputPrinterName,
		@pfOutputSave = OutputSave,
		@piOutputSaveExisting = OutputSaveExisting,
		@pfOutputEmail = OutputEmail,
		@piOutputEmailAddr = OutputEmailAddr,
		@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
		@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
		@psOutputFilename = ISNULL(OutputFilename,''),
		@piTimestamp = convert(integer, timestamp),
		@pfParent1AllRecords = parent1AllRecords,
		@piParent1PicklistID = parent1Picklist,
		@pfParent2AllRecords = parent2AllRecords,
		@piParent2PicklistID = parent2Picklist,
		@pfIgnoreZeros = IgnoreZeros
	FROM [dbo].[ASRSysCustomReportsName]
	WHERE ID = @piReportID;

	/* Check the current user can view the report. */
	exec [dbo].[spASRIntCurrentUserAccess]
		2, 
		@piReportID,
		@sAccess OUTPUT;

	IF @fSysSecMgr = 0 
	BEGIN
		IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
		BEGIN
			SET @psErrorMsg = 'report has been made hidden by another user.';
			RETURN;
		END

		IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
		BEGIN
			SET @psErrorMsg = 'report has been made read only by another user.';
			RETURN;
		END
	END
	
	/* Check the report has details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCustomReportsDetails]
		WHERE ASRSysCustomReportsDetails.customReportID = @piReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report contains no details.';
		RETURN;
	END

	/* Check the report has sort order details. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCustomReportsDetails]
	WHERE ASRSysCustomReportsDetails.customReportID = @piReportID
		AND ASRSysCustomReportsDetails.type = 'C'
		AND ASRSysCustomReportsDetails.sortOrderSequence > 0

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'report contains no sort order details.';
		RETURN;
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50);
		SET @psReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access,
			@sTempUsername = username
		FROM [dbo].[ASRSysPicklistName]
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			IF UPPER(@sTempUsername) = UPPER(system_user)
			BEGIN
				SET @pfPicklistHidden = 1;
			END
			ELSE
			BEGIN
				/* Picklist is hidden by another user. Remove it from the definition. */
				IF @fSysSecMgr = 0
				BEGIN
					SET @piPicklistID = 0;
					SET @psPicklistName = '';
					SET @pfPicklistHidden = 0;

					SET @psInfoMsg = @psInfoMsg +
					CASE
						WHEN LEN(@psInfoMsg) > 0 THEN char(10)
						ELSE ''
					END + 'The base table picklist will be removed from this definition as it has been made hidden by another user.';
				END
			END
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access,
			@sTempUsername = username
		FROM [dbo].[ASRSysExpressions]
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			IF UPPER(@sTempUsername) = UPPER(system_user)
			BEGIN
				SET @pfFilterHidden = 1;
			END
			ELSE
			BEGIN
				/* Filter is hidden by another user. Remove it from the definition. */
				IF @fSysSecMgr = 0
				BEGIN
					SET @piFilterID = 0;
					SET @psFilterName = '';
					SET @pfFilterHidden = 0;

					SET @psInfoMsg = @psInfoMsg +
					CASE
						WHEN LEN(@psInfoMsg) > 0 THEN char(10)
						ELSE ''
					END + 'The base table filter will be removed from this definition as it has been made hidden by another user.';
				END
			END
		END
	END

	IF @piParent1TableID > 0 
	BEGIN
		SELECT @psParent1Name = tableName
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @piParent1TableID;

		IF @piParent1PicklistID > 0 
		BEGIN
			SELECT @psParent1PicklistName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysPicklistName]
			WHERE picklistID = @piParent1PicklistID;
	
			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent1PicklistHidden = 1;
				END
				ELSE
				BEGIN
					/* Picklist is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent1PicklistID = 0;
						SET @psParent1PicklistName = '';
						SET @pfParent1PicklistHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent1Name + ''' table picklist will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END

		IF @piParent1FilterID > 0 
		BEGIN
			SELECT @psParent1FilterName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysExpressions]
			WHERE exprID = @piParent1FilterID;

			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent1FilterHidden = 1;
				END
				ELSE
				BEGIN
					/* Filter is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent1FilterID = 0;
						SET @psParent1FilterName = '';
						SET @pfParent1FilterHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent1Name + ''' table filter will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END	
	END

	IF @piParent2TableID > 0 
	BEGIN
		SELECT @psParent2Name = tableName 
		FROM [dbo].[ASRSysTables]
		WHERE tableID = @piParent2TableID;

		IF @piParent2PicklistID > 0 
		BEGIN
			SELECT @psParent2PicklistName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysPicklistName]
			WHERE picklistID = @piParent2PicklistID;
	
			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent2PicklistHidden = 1;
				END
				ELSE
				BEGIN
					/* Picklist is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent2PicklistID = 0;
						SET @psParent2PicklistName = '';
						SET @pfParent2PicklistHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent2Name + ''' table picklist will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END

		IF @piParent2FilterID > 0 
		BEGIN
			SELECT @psParent2FilterName = name,
				@sTempHidden = access,
				@sTempUsername = username
			FROM [dbo].[ASRSysExpressions]
			WHERE exprID = @piParent2FilterID;

			IF UPPER(@sTempHidden) = 'HD'
			BEGIN
				IF UPPER(@sTempUsername) = UPPER(system_user)
				BEGIN
					SET @pfParent2FilterHidden = 1;
				END
				ELSE
				BEGIN
					/* Filter is hidden by another user. Remove it from the definition. */
					IF @fSysSecMgr = 0
					BEGIN
						SET @piParent2FilterID = 0;
						SET @psParent2FilterName = '';
						SET @pfParent2FilterHidden = 0;

						SET @psInfoMsg = @psInfoMsg +
						CASE
							WHEN LEN(@psInfoMsg) > 0 THEN char(10)
							ELSE ''
						END + 'The ''' + @psParent2Name + ''' table filter will be removed from this definition as it has been made hidden by another user.';
					END
				END
			END
		END	
	END

	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM [dbo].[ASRSysEmailGroupName]
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;	
		SET @psOutputEmailName = '';
	END


	-- Definition
	SELECT @psReportName AS name, @psReportDesc AS [Description], @piBaseTableID AS baseTableID, @psReportOwner AS [Owner],
		CASE WHEN @pfAllRecords = 1 THEN 0 ELSE CASE WHEN ISNULL(@piPicklistID, 0) > 0 THEN 1 ELSE 2 END END AS [SelectionType],
		@piPicklistID AS PicklistID, @piFilterID AS FilterID,
		@psPicklistName AS PicklistName, @psFilterName AS FilterName,
		CASE WHEN @piParent1FilterID > 0 THEN 2 ELSE CASE WHEN @piParent1PicklistID > 0 THEN 1 ELSE 0 END END AS [Parent1SelectionType],
		@piParent1TableID AS parent1ID, @psParent1Name AS Parent1Name, @piParent1FilterID AS parent1FilterID, @piParent1PicklistID AS Parent1PicklistID,
		@psParent1FilterName AS Parent1FilterName, @psParent1PicklistName AS Parent1PicklistName, @piParent2PicklistID AS Parent2PicklistID,
		CASE WHEN @piParent2FilterID > 0 THEN 2 ELSE CASE WHEN @piParent2PicklistID > 0 THEN 1 ELSE 0 END END AS [Parent2SelectionType],
		@piParent2TableID AS parent2ID, @psParent2Name AS Parent2Name, @piParent2FilterID AS parent2FilterID, 
		@psParent2FilterName AS Parent2FilterName, @psParent2PicklistName AS Parent2PicklistName,
		@pfSummary AS IsSummary,@pfPrintFilterHeader AS printFilterHeader,
		@pfOutputPreview AS IsPreview, @piOutputFormat AS [Format], @pfOutputScreen AS ToScreen, @pfOutputPrinter AS ToPrinter,
		@psOutputPrinterName AS PrinterName, @pfOutputSave AS SaveToFile, @piOutputSaveExisting AS SaveExisting,
		@pfOutputEmail AS SendToEmail, @piOutputEmailAddr AS EmailGroupID, @psOutputEmailName AS EmailGroupName,
		@psOutputEmailSubject AS EmailSubject, @psOutputEmailAttachAs AS EmailAttachmentName,
		@psOutputFilename AS [Filename], @piTimestamp AS [timestamp],
		@pfParent1AllRecords AS parent1AllRecords, @piParent1PicklistID AS parent1Picklist,
		@pfParent2AllRecords AS parent2AllRecords,@piParent2PicklistID AS parent2Picklist,
		@pfIgnoreZeros AS IgnoreZerosForAggregates,
		CASE WHEN @pfPicklistHidden = 1 OR @pfFilterHidden = 1 THEN 'HD' ELSE '' END AS [BaseViewAccess],
		CASE WHEN @pfParent1PicklistHidden = 1 OR @pfParent1FilterHidden = 1 THEN 'HD' ELSE '' END AS [Parent1ViewAccess],
		CASE WHEN @pfParent2PicklistHidden = 1 OR @pfParent2FilterHidden = 1 THEN 'HD' ELSE '' END AS [Parent2ViewAccess];

	-- Get the definition columns
	SELECT 0 AS [AccessHidden],
		0 AS [IsExpression],
		ASRSysColumns.tableID,
		cd.colExprID AS [id],
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) AS [Name],
		cd.size AS [size],
		cd.dp AS [decimals],
		cd.heading AS Heading,
		ASRSysColumns.DataType,
		ISNULL(cd.avge, 0) AS IsAverage, ISNULL(cd.cnt, 0) AS IsCount, ISNULL(cd.tot, 0) AS IsTotal,
		ISNULL(cd.Hidden, 0) AS IsHidden,	ISNULL(cd.GroupWithNextColumn, 0) AS IsGroupWithNext,
		CASE cd.Repetition WHEN 1 THEN 1 ELSE 0 END AS IsRepeated,
		cd.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails cd
		INNER JOIN ASRSysColumns ON cd.colExprID = ASRSysColumns.columnId
		INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE cd.customReportID = @piReportID
		AND cd.type = 'C'
	UNION
	SELECT CASE 
			WHEN ASRSysExpressions.access = 'HD' THEN 1
			ELSE 0
		END,
		1 AS [IsExpression],
		ASRSysExpressions.tableID,
		cd.colExprID,
		ASRSysTables.TableName  + ' Calc: ' + replace(ASRSysExpressions.name, '_', ' ') AS [Heading],
		cd.size,
		cd.dp,
		cd.heading,
		0 AS [DataType],
		ISNULL(cd.avge, 0) AS IsAverage, ISNULL(cd.cnt, 0) AS IsCount, ISNULL(cd.tot, 0) AS IsTotal,
		ISNULL(cd.Hidden, 0) AS IsHidden,	ISNULL(cd.GroupWithNextColumn, 0) AS IsGroupWithNext,
		CASE cd.Repetition WHEN 1 THEN 1 ELSE 0 END AS IsRepeated,
		cd.sequence AS [sequence]
	FROM ASRSysCustomReportsDetails cd
		INNER JOIN ASRSysExpressions ON cd.colExprID = ASRSysExpressions.exprID
		INNER JOIN ASRSysTables ON ASRSysExpressions.tableID = ASRSysTables.tableID
	WHERE cd.customReportID = @piReportID
		AND cd.type <> 'C';

	-- Orders
	SELECT cd.colExprID AS [ID],
		convert(varchar(MAX), ASRSysTables.tableName + '.' + ASRSysColumns.columnName) as [Name],
		cd.SortOrderSequence AS [Sequence],
		ISNULL(cd.boc, 0) AS [BreakOnChange],
		ISNULL(cd.poc, 0) AS [PageOnChange],
		ISNULL(cd.voc, 0) AS [ValueOnChange],
		ISNULL(cd.srv, 0) AS [SuppressRepeated],
		cd.sortOrder AS [Order],
		ASRSysTables.tableID
	FROM ASRSysCustomReportsDetails cd
	INNER JOIN ASRSysColumns ON cd.colExprID = ASRSysColumns.columnId
	INNER JOIN ASRSysTables ON ASRSysColumns.tableID = ASRSysTables.tableID
	WHERE cd.customReportID = @piReportID
		AND cd.type = 'C'
		AND cd.sortOrderSequence > 0
	ORDER BY cd.SortOrderSequence;

	-- Return the child table information
	SELECT  C.ChildTable AS [TableID],
		T.TableName AS [TableName],
		CASE WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.ExprID, 0) ELSE 0 END AS [FilterID],
		CASE WHEN (X.Access <> 'HD') OR (X.userName = system_user) THEN isnull(X.Name, '') ELSE '' END AS [FilterName],
		isnull(O.OrderID, 0) AS [OrderID],
	  ISNULL(O.Name, '') AS [OrderName],
	  C.ChildMaxRecords AS [Records],
		X.Access AS FilterViewAccess,
		CASE WHEN (X.Access = 'HD') AND (X.userName = system_user) THEN 'Y' ELSE 'N' END AS [FilterHidden],
		CASE WHEN isnull(O.OrderID, 0) <> isnull(C.ChildOrder,0) THEN 'Y' ELSE 'N' END AS [OrderDeleted],
		CASE WHEN isnull(X.ExprID, 0) <> isnull(C.ChildFilter,0) THEN 'Y' ELSE 'N' END AS [FilterDeleted],
		CASE WHEN (X.Access = 'HD') AND (X.userName <> system_user) THEN 'Y' ELSE 'N' END AS [FilterHiddenByOther]
	FROM [dbo].[ASRSysCustomReportsChildDetails] C 
	INNER JOIN [dbo].[ASRSysTables] T ON C.ChildTable = T.TableID 
		LEFT OUTER JOIN [dbo].[ASRSysExpressions] X ON C.ChildFilter = X.ExprID 
		LEFT OUTER JOIN [dbo].[ASRSysOrders] O ON C.ChildOrder = O.OrderID
	WHERE C.CustomReportID = @piReportID
	ORDER BY T.TableName;
	
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetCalendarReportDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetCalendarReportDefinition];
GO
CREATE PROCEDURE [dbo].[spASRIntGetCalendarReportDefinition] (
	@piCalendarReportID 		integer, 
	@psCurrentUser				varchar(255),
	@psAction					varchar(255))
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @psErrorMsg					varchar(MAX) = '',
		@psReportName		varchar(255) = '',
		@psReportOwner		varchar(255) = '',
		@psReportDesc		varchar(MAX) = '',
		@piBaseTableID				integer,
		@pfAllRecords				bit,
		@piPicklistID				integer,
		@psPicklistName				varchar(255) = '',
		@pfPicklistHidden			bit,
		@piFilterID					integer,
		@psFilterName				varchar(255) = '',
		@pfFilterHidden				bit,
		@pfPrintFilterHeader		bit,
		@piDesc1ID					integer,
		@piDesc2ID					integer,
		@piDescExprID				integer,
		@psDescExprName				varchar(255) = '',
		@pfDescCalcHidden			bit,
		@piRegionID					integer,
		@pfGroupByDesc				bit,
		@pfDescSeparator			varchar(255) = '',	
		@piStartType				integer,
		@pdFixedStart				datetime,
		@piStartFrequency			integer,
		@piStartPeriod				integer,
		@piCustomStartID			integer,
		@psCustomStartName			varchar(MAX) = '',
		@pfStartDateCalcHidden		bit,
		@piEndType					integer,
		@pdFixedEnd					datetime,
		@piEndFrequency				integer,
		@piEndPeriod				integer,
		@piCustomEndID				integer,
		@psCustomEndName			varchar(MAX) = '',
		@pfEndDateCalcHidden		bit,
		@pfShadeBHols				bit,
		@pfShowCaptions				bit,
		@pfShadeWeekends			bit,
		@pfStartOnCurrentMonth		bit,
		@pfIncludeWorkingDaysOnly	bit,
		@pfIncludeBHols				bit,
		@pfOutputPreview			bit,
		@piOutputFormat				integer,
		@pfOutputScreen				bit,
		@pfOutputPrinter			bit,
		@psOutputPrinterName		varchar(MAX) = '',
		@pfOutputSave				bit,
		@piOutputSaveExisting		integer		,
		@pfOutputEmail				bit,
		@piOutputEmailAddr			integer,
		@psOutputEmailName			varchar(MAX) = '',
		@psOutputEmailSubject		varchar(MAX) = '',
		@psOutputEmailAttachAs		varchar(MAX) = '',
		@psOutputFilename			varchar(MAX) = '',	
 		@piTimestamp				integer;

	DECLARE	@iCount			integer,
			@sTempHidden	varchar(10),
			@sAccess 		varchar(10);

	SET @psErrorMsg = '';
	SET @psPicklistName = '';
	SET @pfPicklistHidden = 0;
	SET @psFilterName = '';
	SET @pfFilterHidden = 0;
	SET @pfDescCalcHidden = 0;
	SET @pfStartDateCalcHidden = 0;
	SET @pfEndDateCalcHidden = 0;
	
	/* Check the calendar report exists. */
	SELECT @iCount = COUNT(*)
	FROM [dbo].[ASRSysCalendarReports]
	WHERE ID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report has been deleted by another user.';
		RETURN;
	END

	SELECT	@psReportName = name,
					@psReportOwner = userName,
					@psReportDesc = description,
					@piBaseTableID = baseTable,
					@pfAllRecords = allRecords,
					@piPicklistID = picklist,
					@piFilterID = filter,
					@pfPrintFilterHeader = PrintFilterHeader,
					@piDesc1ID = Description1,
					@piDesc2ID = Description2,
					@piDescExprID = DescriptionExpr,
					@piRegionID = Region,
					@pfGroupByDesc = GroupByDesc,
					@pfDescSeparator = DescriptionSeparator,
					@piStartType = StartType,
					@pdFixedStart = FixedStart,
					@piStartFrequency = StartFrequency,
					@piStartPeriod = StartPeriod,
					@piCustomStartID = StartDateExpr,
					@piEndType = EndType,
					@pdFixedEnd = FixedEnd,
					@piEndFrequency = EndFrequency,
					@piEndPeriod = EndPeriod,
					@piCustomEndID = EndDateExpr,
					@pfShadeBHols = ShowBankHolidays,
					@pfShowCaptions = ShowCaptions,
					@pfShadeWeekends = ShowWeekends,
					@pfStartOnCurrentMonth = StartOnCurrentMonth,
					@pfIncludeWorkingDaysOnly	= IncludeWorkingDaysOnly,
					@pfIncludeBHols = IncludeBankHolidays,
					@pfOutputPreview = OutputPreview,
					@piOutputFormat = OutputFormat,
					@pfOutputScreen = OutputScreen,
					@pfOutputPrinter = OutputPrinter,
					@psOutputPrinterName = OutputPrinterName,
					@pfOutputSave = OutputSave,
					@piOutputSaveExisting = OutputSaveExisting,
					@pfOutputEmail = OutputEmail,
					@piOutputEmailAddr = OutputEmailAddr,
					@psOutputEmailSubject = ISNULL(OutputEmailSubject,''),
					@psOutputEmailAttachAs = ISNULL(OutputEmailAttachAs,''),
					@psOutputFilename = ISNULL(OutputFilename,''),
					@piTimestamp = convert(integer, timestamp)
	FROM [dbo].[ASRSysCalendarReports]
	WHERE ID = @piCalendarReportID;

	/* Check the current user can view the calendar report. */
	exec [dbo].[spASRIntCurrentUserAccess]
		17, 
		@piCalendarReportID,
		@sAccess OUTPUT;

	IF (@sAccess = 'HD') AND (@psReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'calendar report has been made hidden by another user.';
		RETURN;
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@psReportOwner <> @psCurrentUser) 
	BEGIN
		SET @psErrorMsg = 'calendar report has been made read only by another user.';
		RETURN;
	END

	/* Check the calendar report has details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCalendarReportEvents]
		WHERE ASRSysCalendarReportEvents.calendarReportID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report contains no details.';
		RETURN;
	END

	/* Check the calendar report has sort order details. */
	SELECT @iCount = COUNT(*)
		FROM [dbo].[ASRSysCalendarReportOrder]
		WHERE ASRSysCalendarReportOrder.calendarReportID = @piCalendarReportID;

	IF @iCount = 0
	BEGIN
		SET @psErrorMsg = 'calendar report contains no sort order details.';
		RETURN;
	END

	IF @psAction = 'copy' 
	BEGIN
		SET @psReportName = left('copy of ' + @psReportName, 50);
		SET @psReportOwner = @psCurrentUser;
	END

	IF @piPicklistID > 0 
	BEGIN
		SELECT @psPicklistName = name,
			@sTempHidden = access
		FROM ASRSysPicklistName 
		WHERE picklistID = @piPicklistID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfPicklistHidden = 1;
		END
	END

	IF @piFilterID > 0 
	BEGIN
		SELECT @psFilterName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piFilterID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfFilterHidden = 1;
		END
	END
	
	IF @piDescExprID > 0 
	BEGIN
		SELECT @psDescExprName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piDescExprID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfDescCalcHidden = 1;
		END
	END
	
	IF @piCustomStartID > 0 
	BEGIN
		SELECT @psCustomStartName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomStartID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfStartDateCalcHidden = 1;
		END
	END
	
	IF @piCustomEndID > 0 
	BEGIN
		SELECT @psCustomEndName = name,
			@sTempHidden = access
		FROM ASRSysExpressions 
		WHERE exprID = @piCustomEndID;

		IF UPPER(@sTempHidden) = 'HD'
		BEGIN
			SET @pfEndDateCalcHidden = 1;
		END
	END


	IF @piOutputEmailAddr > 0
	BEGIN
		SELECT @psOutputEmailName = name,
			@sTempHidden = access
		FROM ASRSysEmailGroupName
		WHERE EmailGroupID = @piOutputEmailAddr;
	END
	ELSE
	BEGIN
		SET @piOutputEmailAddr = 0;
		SET @psOutputEmailName = '';
	END


	-- Definition
	SELECT @psReportName AS name, @psReportDesc AS [Description], @piBaseTableID AS baseTableID, @psReportOwner AS [Owner],
		CASE WHEN @pfAllRecords = 1 THEN 0 ELSE CASE WHEN ISNULL(@piPicklistID, 0) > 0 THEN 1 ELSE 2 END END AS [SelectionType],
		@piPicklistID AS PicklistID, @piFilterID AS FilterID,
		@psPicklistName AS PicklistName, @psFilterName AS FilterName,@pfPrintFilterHeader AS printFilterHeader,
		@piDesc1ID AS Description1ID, @piDesc2ID AS Description2ID, @piDescExprID AS Description3ID, @psDescExprName AS Description3Name,
		@piRegionID AS RegionID, @pfGroupByDesc AS GroupByDescription, @pfDescSeparator AS Separator,		
		@piStartType AS StartType, @pdFixedStart AS StartFixedDate, @piStartFrequency AS StartOffset, @piStartPeriod AS StartOffsetPeriod, @piCustomStartID AS StartCustomID, @psCustomStartName AS StartCustomName,
		@piEndType AS EndType, @pdFixedEnd AS EndFixedDate,	@piEndFrequency AS EndOffset, @piEndPeriod AS EndOffsetPeriod, @piCustomEndID AS EndCustomID,  @psCustomEndName AS EndCustomName,
		@pfShadeBHols AS ShowBankHolidays, @pfShowCaptions AS ShowCaptions,	@pfShadeWeekends AS ShowWeekends, @pfStartOnCurrentMonth AS StartOnCurrentMonth,
		@pfIncludeWorkingDaysOnly AS WorkingDaysOnly, @pfIncludeBHols AS IncludeBankHolidays,
		@pfOutputPreview AS IsPreview, @piOutputFormat AS [Format], @pfOutputScreen AS ToScreen, @pfOutputPrinter AS ToPrinter,
		@psOutputPrinterName AS PrinterName, @pfOutputSave AS SaveToFile, @piOutputSaveExisting AS SaveExisting,
		@pfOutputEmail AS SendToEmail, @piOutputEmailAddr AS EmailGroupID, @psOutputEmailName AS EmailGroupName,
		@psOutputEmailSubject AS EmailSubject, @psOutputEmailAttachAs AS EmailAttachmentName,
		@psOutputFilename AS [Filename], @piTimestamp AS [timestamp],
		CASE WHEN @pfPicklistHidden = 1 OR @pfFilterHidden = 1 THEN 'HD' ELSE '' END AS [BaseViewAccess],
		CASE WHEN @pfDescCalcHidden = 1 THEN 'HD' ELSE '' END AS [Description3ViewAccess],
		CASE WHEN @pfStartDateCalcHidden = 1 THEN 'HD' ELSE '' END AS [StartCustomViewAccess],
		CASE WHEN @pfEndDateCalcHidden = 1 THEN 'HD' ELSE '' END AS [EndCustomViewAccess];

	-- Calendar events definition recordset
	SELECT 
			ID, Name, TableID,
			(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ASRSysCalendarReportEvents.TableID) AS TableName,
			FilterID,
			CASE 
				WHEN ASRSysCalendarReportEvents.FilterID > 0 THEN
					(SELECT ISNULL(ASRSysExpressions.Name,'') FROM ASRSysExpressions WHERE ASRSysExpressions.ExprID = ASRSysCalendarReportEvents.FilterID) 
				ELSE
					''
			END AS FilterName,
			EventStartDateID,
			(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventStartDateID) AS EventStartDateName,			
			EventStartSessionID,
			CASE 
				WHEN EventStartSessionID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventStartSessionID)
				ELSE
					''
			END AS EventStartSessionName,
			CASE WHEN ISNULL(EventDurationID, 0) > 0 THEN 2 ELSE CASE WHEN ISNULL(EventEndDateID, 0) > 0 THEN 1 ELSE 0 END END AS [EventEndType],
			EventEndDateID,
			CASE 
				WHEN EventEndDateID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventEndDateID)
				ELSE ''
			END AS EventEndDateName,
			ASRSysCalendarReportEvents.EventEndSessionID, 
			CASE 
				WHEN ASRSysCalendarReportEvents.EventEndSessionID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventEndSessionID)
				ELSE
					''
			END AS EventEndSessionName,
			EventDurationID,
			CASE 
				WHEN ASRSysCalendarReportEvents.EventDurationID > 0 THEN
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDurationID)
				ELSE 
					''
			END AS EventDurationName,
			LegendType, LegendCharacter,
			CASE 
				WHEN ASRSysCalendarReportEvents.LegendType = 1 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ASRSysCalendarReportEvents.LegendLookupTableID) + 
					'.' +
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.LegendLookupCodeID)
				ELSE
					ASRSysCalendarReportEvents.LegendCharacter
			END LegendTypeName,
			LegendLookupTableID, LegendLookupColumnID, LegendLookupCodeID, LegendEventColumnID, EventDesc1ColumnID,
			CASE 
				WHEN ASRSysCalendarReportEvents.EventDesc1ColumnID > 0 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID = ((SELECT ISNULL(ASRSysColumns.TableID,0) FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc1ColumnID))) + 
					'.' + 
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc1ColumnID)
				ELSE
					''
			END AS EventDesc1ColumnName,
			EventDesc2ColumnID,
			CASE
				WHEN EventDesc2ColumnID > 0 THEN
					(SELECT ISNULL(ASRSysTables.TableName,'') FROM ASRSysTables WHERE ASRSysTables.TableID IN ((SELECT ISNULL(ASRSysColumns.TableID,0) FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc2ColumnID))) + 
					'.' + 
					(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportEvents.EventDesc2ColumnID)
				ELSE
					''
	 		END AS EventDesc2ColumnName,
			EventKey,
			CASE 
				WHEN ASRSysCalendarReportEvents.FilterID > 0 THEN
			  		(SELECT CASE WHEN ASRSysExpressions.Access = 'HD' THEN 'HD' ELSE 'RW' END FROM ASRSysExpressions WHERE ASRSysExpressions.ExprID = ASRSysCalendarReportEvents.FilterID) 
				ELSE
					'RW'
			END AS FilterViewAccess
	FROM ASRSysCalendarReportEvents
	WHERE CalendarReportID = @piCalendarReportID
	ORDER BY ID;

	-- Orders
	SELECT 
		ColumnID AS Id, TableID, 
		(SELECT ISNULL(ASRSysColumns.ColumnName,'') FROM ASRSysColumns WHERE ASRSysColumns.ColumnID = ASRSysCalendarReportOrder.ColumnID) AS [Name],
		OrderSequence AS [Sequence],
		OrderType AS [Order]
	FROM [dbo].[ASRSysCalendarReportOrder]
	WHERE calendarReportID = @piCalendarReportID
	ORDER BY OrderSequence;

END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRGetCalculationsForTable]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRGetCalculationsForTable];
GO

CREATE PROCEDURE dbo.[spASRGetCalculationsForTable](@piTableID as integer)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT ExprID AS ID,
			Name,
			0 AS DataType,
			0 AS Size,
			0 AS Decimals,
			Access,
			Username
	 FROM ASRSysExpressions
		WHERE type = 10 AND (returnType = 0 OR type = 10) AND parentComponentID = 0	AND TableID  = @piTableID
		ORDER BY Name;

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetRecordSelection]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetRecordSelection];
GO

CREATE PROCEDURE [dbo].[spASRIntGetRecordSelection]
(
	@psType		varchar(255),
	@piTableID	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @fSysSecMgr	bit;

	EXEC [dbo].[spASRIntSysSecMgr] @fSysSecMgr OUTPUT

	IF UPPER(@psType) = 'EMAIL'
	BEGIN
		SELECT emailGroupID AS [ID], name, userName, access , [Description]
		FROM ASRSysEmailGroupName 
		ORDER BY [name];
	END

	IF UPPER(@psType) = 'PICKLIST'
	BEGIN
		SELECT picklistid AS ID, name, username, access, [Description]
		FROM [dbo].[ASRSysPicklistName]
		WHERE (tableid = @piTableID)
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END

	IF UPPER(@psType) = 'ORDER'
	BEGIN
			SELECT orderid AS [ID], name, '' AS username, '' AS access , '' AS [Description]
		FROM ASRSysOrders 
		WHERE tableid = @piTableID AND type = 1 
			ORDER BY [name];
	END

	IF UPPER(@psType) = 'FILTER'
	BEGIN
		SELECT exprid AS ID, name, username, access, [Description]
		FROM [dbo].[ASRSysExpressions]
		WHERE tableid = @piTableID 
			AND type = 11 
			AND (returnType = 3 OR type = 10) 
			AND parentComponentID = 0 
			AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
		ORDER BY [name];
	END
	
	IF UPPER(@psType) = 'CALC'
	BEGIN
		IF @piTableID > 0
		BEGIN
			SELECT exprid AS ID, name, username, access, [Description]
			FROM [dbo].[ASRSysExpressions]
			WHERE (tableid = @piTableID)
				AND  type = 10 
				AND (returnType = 0 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
		ELSE
		BEGIN
			SELECT exprid AS ID, name, username, access, [Description]
			FROM [dbo].[ASRSysExpressions] 
			WHERE  type = 18 
				AND (returnType = 4 OR type = 10) 
				AND parentComponentID = 0 
				AND (@fSysSecMgr = 1 OR username = SYSTEM_USER OR Access <> 'HD')
			ORDER BY [name];
		END
	END
END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntDefProperties]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntDefProperties];
GO

CREATE PROCEDURE [dbo].[spASRIntDefProperties] (
	@intType int, 
	@intID int
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @Name	nvarchar(255);

	-- Access details of object
	SELECT CreatedDate, SavedDate, RunDate,
		Createdby, 
		Savedby, 
		Runby 
	FROM [dbo].[ASRSysUtilAccessLog]
	WHERE UtilID = @intID AND [Type] = @intType;

	-- Get usage of this object
	EXEC sp_ASRIntDefUsage @intType, @intID;

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetUtilityName]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityName];
GO

CREATE PROCEDURE [dbo].[spASRIntGetUtilityName] (
	@piUtilityType	integer,
	@plngID			integer,
	@psName			varchar(255)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500);

	SET @sTableName = '';
	SET @psName = '<unknown>';

	IF @piUtilityType IN (11, 12)  -- Calculations and filters
	BEGIN
		SET @sTableName = 'ASRSysExpressions';
		SET @sIDColumnName = 'ExprID';
  END

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sIDColumnName = 'ID';
    END

	IF @piUtilityType = 1 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
    END

	IF @piUtilityType = 35 /* 9-Box Grid Report*/
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sIDColumnName = 'CrossTabID';
	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sIDColumnName = 'ID';
    END
        
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sIDColumnName = 'DataTransferID';
    END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sIDColumnName = 'functionID';
    END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sIDColumnName = 'ID';
    END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sIDColumnName = 'mailMergeID';
    END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sIDColumnName = 'recordProfileID';
    END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sIDColumnName = 'matchReportID';
    END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SET @sTableName = 'ASRSysWorkflows';
		SET @sIDColumnName = 'ID';
	END
      	
	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sName = [' + @sTableName + '].[name]
				FROM [' + @sTableName + ']
				WHERE [' + @sTableName + '].[' + @sIDColumnName + '] = ' + convert(nvarchar(255), @plngID);

		SET @sParamDefinition = N'@sName varchar(255) OUTPUT';
		EXEC sp_executesql @sSQL, @sParamDefinition, @psName OUTPUT;
	END

	IF @psName IS null SET @psName = '<unknown>';
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetEmailAddresses]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetEmailAddresses];
GO

CREATE PROCEDURE [dbo].[spASRIntGetEmailAddresses]
(@baseTableID int)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT convert(char(10),e.emailid) AS [ID], e.name AS [Name]
		FROM ASRSysEmailAddress e
		WHERE e.tableid = @baseTableID OR e.tableid = 0
		ORDER BY e.name;

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRGetMetadata]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRGetMetadata];
GO

CREATE PROCEDURE [dbo].[spASRGetMetadata] (@Username varchar(255))
WITH ENCRYPTION
AS
BEGIN

	SET NOCOUNT ON;

	SELECT TableID, TableName, TableType, DefaultOrderID, RecordDescExprID FROM dbo.ASRSysTables;

	SELECT ColumnID, TableID, ColumnName, DataType, ColumnType, Use1000Separator, ISNULL(DefaultDisplayWidth, 0) AS Size, ISNULL(Size, 0) AS ColumnSize, Decimals, LookupTableID, LookupColumnID FROM dbo.ASRSysColumns;

	SELECT ParentID, ChildID FROM dbo.ASRSysRelations;

	SELECT ModuleKey, ParameterKey, ISNULL(ParameterValue,'') AS ParameterValue, ParameterType FROM dbo.ASRSysModuleSetup;

	SELECT * FROM dbo.ASRSysUserSettings WHERE Username = @Username;

	SELECT functionID, functionName, returnType FROM dbo.ASRSysFunctions;

	SELECT * FROM dbo.ASRSysFunctionParameters ORDER BY functionID, parameterIndex;

	SELECT * FROM dbo.ASRSysOperators;

	SELECT * FROM dbo.ASRSysOperatorParameters ORDER BY OperatorID, parameterIndex;
	
	-- Selected system settings
	SELECT * FROM ASRSysSystemSettings;

END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSaveMailMerge]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntSaveMailMerge];
GO
CREATE PROCEDURE [dbo].[spASRIntSaveMailMerge] (
	@psName				varchar(255),
	@psDescription		varchar(MAX),
	@piTableID			integer,
	@piSelection		integer,
	@piPicklistID		integer,
	@piFilterID			integer,
	@piOutputFormat			integer,
	@pfOutputSave			bit,
	@psOutputFilename		varchar(MAX),
	@piEmailAddrID		integer,
	@psEmailSubject		varchar(MAX),
	@psTemplateFileName	varchar(MAX),
	@pfOutputScreen			bit,
	@psUserName			varchar(255),
	@pfEmailAsAttachment	bit,
	@psEmailAttachmentName	varchar(MAX),
	@pfSuppressBlanks		bit,
	@pfPauseBeforeMerge		bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName	varchar(255),
	@piDocumentMapID			integer,
	@pfManualDocManHeader		bit,	
	@psAccess			varchar(MAX),
	@psJobsToHide		varchar(MAX),
	@psJobsToHideGroups	varchar(MAX),
	@psColumns			varchar(MAX),
	@psColumns2			varchar(MAX),
	@piID				integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sTemp			varchar(MAX),
			@sColumnDefn	varchar(MAX),
			@sColumnParam	varchar(MAX),
			@iSequence		integer,
			@sType			varchar(MAX),
			@iColExprID		integer,
			@sHeading		varchar(MAX),
			@iSize			integer,
			@iDP			integer,
			@fIsNumeric		bit,
			@fAvge			bit,
			@fCnt			bit,
			@fTot			bit,
			@iSortOrderSequence	integer,
			@sSortOrder		varchar(MAX),
			@fBOC			bit,
			@fPOC			bit,
			@fVOC			bit,
			@fSRV			bit,
			@iCount			integer,
			@fIsNew			bit,
			@sGroup			varchar(255),
			@sAccess		varchar(MAX),
			@sSQL			nvarchar(MAX);
	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')
	SET @fIsNew = 0
	/* Insert/update the report header. */
	IF @piID = 0
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysMailMergeName (
			Name, 
			Description, 
			TableID, 
			Selection, 
			PicklistID, 
			FilterID, 
			OutputFormat, 
			OutputSave, 
			OutputFilename, 
			EmailAddrID, 
			EmailSubject, 
			TemplateFileName, 
			OutputScreen, 
			UserName, 
			EMailAsAttachment,
			EmailAttachmentName, 
			SuppressBlanks, 
			PauseBeforeMerge, 
			OutputPrinter,
			OutputPrinterName,
			DocumentMapID,
			ManualDocManHeader,			
			IsLabel, 
			LabelTypeID, 
			PromptStart) 
		VALUES (
			@psName,
			@psDescription,
			@piTableID,
			@piSelection,
			@piPicklistID,
			@piFilterID,
			@piOutputFormat,
			@pfOutputSave,
			@psOutputFilename,
			@piEmailAddrID,
			@psEmailSubject,
			@psTemplateFileName,
			@pfOutputScreen,
			@psUserName,
			@pfEmailAsAttachment,
			@psEmailAttachmentName,
			@pfSuppressBlanks,
			@pfPauseBeforeMerge,
			@pfOutputPrinter,
			@psOutputPrinterName,
			@piDocumentMapID,
			@pfManualDocManHeader,
			0, 
			0, 
			0)
		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(MailMergeID) FROM ASRSysMailMergeName
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSysMailMergeName SET 
			Name = @psName,
			Description = @psDescription,
			TableID = @piTableID,
			Selection = @piSelection,
			PicklistID = @piPicklistID,
			FilterID = @piFilterID,
			OutputFormat = @piOutputFormat,
			OutputSave = @pfOutputSave,
			OutputFilename = @psOutputFilename,
			EmailAddrID = @piEmailAddrID,
			EmailSubject = @psEmailSubject,
			TemplateFileName = @psTemplateFileName,
			OutputScreen = @pfOutputScreen,
			EMailAsAttachment = @pfEmailAsAttachment,
			EmailAttachmentName = @psEmailAttachmentName,
			SuppressBlanks = @pfSuppressBlanks,
			PauseBeforeMerge = @pfPauseBeforeMerge,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			DocumentMapID = @piDocumentMapID,
			ManualDocManHeader = @pfManualDocManHeader,
			IsLabel = 0,
			LabelTypeID = 0,
			PromptStart = 0
		WHERE MailMergeID = @piID
		/* Delete existing report details. */
		DELETE FROM ASRSysMailMergeColumns
		WHERE MailMergeID = @piID
	END
	/* Create the details records. */
	SET @sTemp = @psColumns
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sColumnDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)
			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psColumns2, 1000)
				IF len(@psColumns2) > 1000
				BEGIN
					SET @psColumns2 = SUBSTRING(@psColumns2, 1001, len(@psColumns2) - 1000)
				END
				ELSE
				BEGIN
					SET @psColumns2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sColumnDefn = @sTemp
			SET @sTemp = ''
		END
		/* Rip out the column definition parameters. */
		SET @iSequence = 0
		SET @sType = ''
		SET @iColExprID = 0
		SET @iSize = 0
		SET @iDP = 0
		SET @fIsNumeric = 0
		SET @iSortOrderSequence = 0
		SET @sSortOrder = ''
		SET @fBOC = 0
		SET @fPOC = 0
		SET @fVOC = 0
		SET @fSRV = 0
		SET @iCount = 0
		WHILE LEN(@sColumnDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sColumnDefn) > 0
			BEGIN
				SET @sColumnParam = LEFT(@sColumnDefn, CHARINDEX('||', @sColumnDefn) - 1)
				SET @sColumnDefn = RIGHT(@sColumnDefn, LEN(@sColumnDefn) - CHARINDEX('||', @sColumnDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sColumnParam = @sColumnDefn
				SET @sColumnDefn = ''
			END
			IF @iCount = 0 SET @iSequence = convert(integer, @sColumnParam)
			IF @iCount = 1 SET @sType = @sColumnParam
			IF @iCount = 2 SET @iColExprID = convert(integer, @sColumnParam)
			IF @iCount = 3 SET @iSize = convert(integer, @sColumnParam)
			IF @iCount = 4 SET @iDP = convert(integer, @sColumnParam)
			IF @iCount = 5 SET @fIsNumeric = convert(bit, @sColumnParam)
			IF @iCount = 6 SET @iSortOrderSequence = convert(integer, @sColumnParam)
			IF @iCount = 7 SET @sSortOrder = @sColumnParam
			SET @iCount = @iCount + 1
		END
		INSERT ASRSysMailMergeColumns (MailMergeID,Type, ColumnID, SortOrderSequence, SortOrder, Size, Decimals)
		VALUES (@piID, @sType, @iColExprID, @iSortOrderSequence, @sSortOrder, @iSize, @iDP)
	END
	DELETE FROM ASRSysMailMergeAccess WHERE ID = @piID
	INSERT INTO ASRSysMailMergeAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)
	SET @sTemp = @psAccess
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysMailMergeAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysMailMergeAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END
	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (9, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 9
		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (9, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 9
		END
	END
	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''
		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL
		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')

						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntSaveCustomReport]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntSaveCustomReport];
GO
CREATE PROCEDURE [dbo].[spASRIntSaveCustomReport] (
	@psName						varchar(255),
	@psDescription				varchar(MAX),
	@piBaseTableID				integer,
	@pfAllRecords				bit,
	@piPicklistID				integer,
	@piFilterID					integer,
	@piParent1TableID			integer,
	@piParent1FilterID			integer,
	@piParent2TableID			integer,
	@piParent2FilterID			integer,
	@pfSummary					bit,
	@pfPrintFilterHeader		bit,
	@psUserName					varchar(255),
	@pfOutputPreview			bit,
	@piOutputFormat				integer,
	@pfOutputScreen				bit,
	@pfOutputPrinter			bit,
	@psOutputPrinterName		varchar(MAX),
	@pfOutputSave				bit,
	@piOutputSaveExisting		integer,
	@pfOutputEmail				bit,
	@piOutputEmailAddr			integer,
	@psOutputEmailSubject		varchar(MAX),
	@psOutputEmailAttachAs		varchar(MAX),
	@psOutputFilename			varchar(MAX),
	@pfParent1AllRecords		bit,
	@piParent1Picklist			integer,
	@pfParent2AllRecords		bit,
	@piParent2Picklist			integer,
	@psAccess					varchar(MAX),
	@psJobsToHide				varchar(MAX),
	@psJobsToHideGroups			varchar(MAX),
	@psColumns					varchar(MAX),
	@psColumns2					varchar(MAX),
	@psChildString				varchar(MAX),
	@piID						integer					OUTPUT,
	@pfIgnoreZeros				bit
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sTemp					varchar(MAX),
			@sColumnDefn			varchar(MAX),
			@sColumnParam			varchar(MAX),
			@iSequence				integer,
			@sType					varchar(MAX),
			@iColExprID				integer,
			@sHeading				varchar(MAX),
			@iSize					integer,
			@iDP					integer,
			@fIsNumeric				bit,
			@fAvge					bit,
			@fCnt					bit,
			@fTot					bit,
			@fHidden				bit,
			@fGroupWithNext			bit,
			@iSortOrderSequence		integer,
			@sSortOrder				varchar(MAX),
			@fBOC					bit,
			@fPOC					bit,
			@fVOC					bit,
			@fSRV					bit,
			@fRepetition 			integer,
			@iCount					integer,
			@fIsNew					bit,
			@iChildTableID			integer,
			@iChildFilterID			integer,
			@iChildOrderID			integer,
			@iChildMaxRecords		integer,
			@sChildDefn				varchar(MAX),
			@sChildParam			varchar(MAX),
			@sGroup					varchar(255),
			@sAccess				varchar(MAX),
			@sSQL					nvarchar(MAX);

	/* Clean the input string parameters. */
	IF len(@psJobsToHide) > 0 SET @psJobsToHide = replace(@psJobsToHide, '''', '''''')
	IF len(@psJobsToHideGroups) > 0 SET @psJobsToHideGroups = replace(@psJobsToHideGroups, '''', '''''')

	SET @fIsNew = 0

	/* Insert/update the report header. */
	IF (@piID = 0)
	BEGIN
		/* Creating a new report. */
		INSERT ASRSysCustomReportsName (
			Name, 
			[Description], 
			BaseTable, 
			AllRecords, 
			Picklist, 
			Filter, 
 			Parent1Table, 
 			Parent1Filter, 
 			Parent2Table, 
 			Parent2Filter, 
 			Summary,
 			IgnoreZeros, 
 			PrintFilterHeader, 
 			UserName, 
 			OutputPreview, 
 			OutputFormat, 
 			OutputScreen, 
 			OutputPrinter, 
 			OutputPrinterName, 
 			OutputSave, 
 			OutputSaveExisting, 
 			OutputEmail, 
 			OutputEmailAddr, 
 			OutputEmailSubject, 
 			OutputEmailAttachAs, 
 			OutputFileName, 
 			Parent1AllRecords, 
 			Parent1Picklist, 
 			Parent2AllRecords, 
 			Parent2Picklist)
 		VALUES (
 			@psName,
 			@psDescription,
 			@piBaseTableID,
 			@pfAllRecords,
 			@piPicklistID,
 			@piFilterID,
 			@piParent1TableID,
 			@piParent1FilterID,
 			@piParent2TableID,
 			@piParent2FilterID,
 			@pfSummary,
 			@pfIgnoreZeros,
 			@pfPrintFilterHeader,
 			@psUserName,
 			@pfOutputPreview,
 			@piOutputFormat,
 			@pfOutputScreen,
 			@pfOutputPrinter,
 			@psOutputPrinterName,
 			@pfOutputSave,
 			@piOutputSaveExisting,
 			@pfOutputEmail,
 			@piOutputEmailAddr,
 			@psOutputEmailSubject,
 			@psOutputEmailAttachAs,
 			@psOutputFilename,
 			@pfParent1AllRecords,
 			@piParent1Picklist,
 			@pfParent2AllRecords,
 			@piParent2Picklist
		)

		SET @fIsNew = 1
		/* Get the ID of the inserted record.*/
		SELECT @piID = MAX(ID) FROM ASRSysCustomReportsName
	END
	ELSE
	BEGIN
		/* Updating an existing report. */
		UPDATE ASRSYSCustomReportsName SET 
			Name = @psName,
			Description = @psDescription,
			BaseTable = @piBaseTableID,
			AllRecords = @pfAllRecords,
			Picklist = @piPicklistID,
			Filter = @piFilterID,
			Parent1Table = @piParent1TableID,
			Parent1Filter = @piParent1FilterID,
			Parent2Table = @piParent2TableID,
			Parent2Filter = @piParent2FilterID,
			Summary = @pfSummary,
			IgnoreZeros = @pfIgnoreZeros,
			PrintFilterHeader = @pfPrintFilterHeader,
			OutputPreview = @pfOutputPreview,
			OutputFormat = @piOutputFormat,
			OutputScreen = @pfOutputScreen,
			OutputPrinter = @pfOutputPrinter,
			OutputPrinterName = @psOutputPrinterName,
			OutputSave = @pfOutputSave,
			OutputSaveExisting = @piOutputSaveExisting,
			OutputEmail = @pfOutputEmail,
			OutputEmailAddr = @piOutputEmailAddr,
			OutputEmailSubject = @psOutputEmailSubject,
			OutputEmailAttachAs = @psOutputEmailAttachAs,
			OutputFileName = @psOutputFilename,
			Parent1AllRecords = @pfParent1AllRecords,
			Parent1Picklist = @piParent1Picklist,
			Parent2AllRecords = @pfParent2AllRecords,
			Parent2Picklist = @piParent2Picklist
		WHERE ID = @piID

		/* Delete existing report details. */
		DELETE FROM ASRSysCustomReportsDetails 
		WHERE customReportID = @piID
	END

	/* Create the details records. */
	SET @sTemp = @psColumns

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sColumnDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)

			IF len(@sTemp) <= 7000
			BEGIN
				SET @sTemp = @sTemp + LEFT(@psColumns2, 1000)
				IF len(@psColumns2) > 1000
				BEGIN
					SET @psColumns2 = SUBSTRING(@psColumns2, 1001, len(@psColumns2) - 1000)
				END
				ELSE
				BEGIN
					SET @psColumns2 = ''
				END
			END
		END
		ELSE
		BEGIN
			SET @sColumnDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the column definition parameters. */
		SET @iSequence = 0
		SET @sType = ''
		SET @iColExprID = 0
		SET @sHeading = ''
		SET @iSize = 0
		SET @iDP = 0
		SET @fIsNumeric = 0
		SET @fAvge = 0
		SET @fCnt = 0
		SET @fTot = 0
		SET @fHidden = 0
		SET @fGroupWithNext = 0
		SET @iSortOrderSequence = 0
		SET @sSortOrder = ''
		SET @fBOC = 0
		SET @fPOC = 0
		SET @fVOC = 0
		SET @fSRV = 0
		SET @fRepetition = 0
		SET @iCount = 0
		
		WHILE LEN(@sColumnDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sColumnDefn) > 0
			BEGIN
				SET @sColumnParam = LEFT(@sColumnDefn, CHARINDEX('||', @sColumnDefn) - 1)
				SET @sColumnDefn = RIGHT(@sColumnDefn, LEN(@sColumnDefn) - CHARINDEX('||', @sColumnDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sColumnParam = @sColumnDefn
				SET @sColumnDefn = ''
			END

			IF @iCount = 0 SET @iSequence = convert(integer, @sColumnParam)
			IF @iCount = 1 SET @sType = @sColumnParam
			IF @iCount = 2 SET @iColExprID = convert(integer, @sColumnParam)
			IF @iCount = 3 SET @sHeading = @sColumnParam
			IF @iCount = 4 SET @iSize = convert(integer, @sColumnParam)
			IF @iCount = 5 SET @iDP = convert(integer, @sColumnParam)
			IF @iCount = 6 SET @fIsNumeric = convert(bit, @sColumnParam)
			IF @iCount = 7 SET @fAvge = convert(bit, @sColumnParam)
			IF @iCount = 8 SET @fCnt = convert(bit, @sColumnParam)
			IF @iCount = 9 SET @fTot = convert(bit, @sColumnParam)
			IF @iCount = 10 SET @fHidden = convert(bit, @sColumnParam)
			IF @iCount = 11 SET @fGroupWithNext = convert(bit, @sColumnParam)
			IF @iCount = 12 SET @iSortOrderSequence = convert(integer, @sColumnParam)
			IF @iCount = 13 SET @sSortOrder = @sColumnParam
			IF @iCount = 14 SET @fBOC = convert(bit, @sColumnParam)
			IF @iCount = 15 SET @fPOC = convert(bit, @sColumnParam)
			IF @iCount = 16 SET @fVOC = convert(bit, @sColumnParam)
			IF @iCount = 17 SET @fSRV = convert(bit, @sColumnParam)
			IF @iCount = 18 SET @fRepetition = convert(integer, @sColumnParam)

			SET @iCount = @iCount + 1
		END

		INSERT ASRSysCustomReportsDetails 
			(customReportID, sequence, type, colExprID, heading, size, dp, isNumeric, avge, 
			cnt, tot, hidden, GroupWithNextColumn, 	sortOrderSequence, sortOrder, boc, poc, voc, srv, repetition) 
		VALUES (@piID, @iSequence, @sType, @iColExprID, @sHeading, @iSize, @iDP, @fIsNumeric, @fAvge, 
			@fCnt, @fTot, @fHidden, @fGroupWithNext, @iSortOrderSequence, @sSortOrder, @fBOC, @fPOC, @fVOC, @fSRV, @fRepetition)

	END

	/* Create the table records. */

	IF (@fIsNew = 0)
	BEGIN
		/* Delete existing report child tables. */
		DELETE FROM ASRSysCustomReportsChildDetails 
		WHERE customReportID = @piID
	END

	SET @sTemp = @psChildString

	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX('**', @sTemp) > 0
		BEGIN
			SET @sChildDefn = LEFT(@sTemp, CHARINDEX('**', @sTemp) - 1)
			SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX('**', @sTemp) - 1)
		END
		ELSE
		BEGIN
			SET @sChildDefn = @sTemp
			SET @sTemp = ''
		END

		/* Rip out the column definition parameters. */
		SET @iChildTableID = 0
		SET @iChildFilterID = 0
		SET @iChildOrderID = 0
		SET @iChildMaxRecords = 0
		SET @iCount = 0
		
		WHILE LEN(@sChildDefn) > 0
		BEGIN
			IF CHARINDEX('||', @sChildDefn) > 0
			BEGIN
				SET @sChildParam = LEFT(@sChildDefn, CHARINDEX('||', @sChildDefn) - 1)
				SET @sChildDefn = RIGHT(@sChildDefn, LEN(@sChildDefn) - CHARINDEX('||', @sChildDefn) - 1)
			END
			ELSE
			BEGIN
				SET @sChildParam = @sChildDefn
				SET @sChildDefn = ''
			END

			IF @iCount = 0 SET @iChildTableID = convert(integer, @sChildParam)
			IF @iCount = 1 SET @iChildFilterID = convert(integer, @sChildParam)
			IF @iCount = 2 SET @iChildOrderID = convert(integer, @sChildParam)
			IF @iCount = 3 SET @iChildMaxRecords = convert(integer, @sChildParam)
	
			SET @iCount = @iCount + 1
		END

		INSERT ASRSysCustomReportsChildDetails 
			(customReportID, childtable, childfilter, childorder, childmaxrecords) 
		VALUES (@piID, @iChildTableID, @iChildFilterID, @iChildOrderID, @iChildMaxRecords)

	END

	DELETE FROM ASRSysCustomReportAccess WHERE ID = @piID
	INSERT INTO ASRSysCustomReportAccess (ID, groupName, access)
		(SELECT @piID, sysusers.name,
			CASE
				WHEN (SELECT count(*)
					FROM ASRSysGroupPermissions
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.Name = ASRSysGroupPermissions.groupname
						AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
				ELSE 'HD'
			END
		FROM sysusers
		WHERE sysusers.uid = sysusers.gid
			AND sysusers.name <> 'ASRSysGroup'
			AND sysusers.uid <> 0)

	SET @sTemp = @psAccess
	
	WHILE LEN(@sTemp) > 0
	BEGIN
		IF CHARINDEX(char(9), @sTemp) > 0
		BEGIN
			SET @sGroup = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			SET @sAccess = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
			SET @sTemp = SUBSTRING(@sTemp, CHARINDEX(char(9), @sTemp) + 1, LEN(@sTemp) - (CHARINDEX(char(9), @sTemp)))
	
			IF EXISTS (SELECT * FROM ASRSysCustomReportAccess
				WHERE ID = @piID
				AND groupName = @sGroup
				AND access <> 'RW')
				UPDATE ASRSysCustomReportAccess
					SET access = @sAccess
					WHERE ID = @piID
						AND groupName = @sGroup
		END
	END

	IF (@fIsNew = 1)
	BEGIN
		/* Update the util access log. */
		INSERT INTO ASRSysUtilAccessLog 
			(type, utilID, createdBy, createdDate, createdHost, savedBy, savedDate, savedHost)
		VALUES (2, @piID, system_user, getdate(), host_name(), system_user, getdate(), host_name())
	END
	ELSE
	BEGIN
		/* Update the last saved log. */
		/* Is there an entry in the log already? */
		SELECT @iCount = COUNT(*) 
		FROM ASRSysUtilAccessLog
		WHERE utilID = @piID
			AND type = 2

		IF @iCount = 0 
		BEGIN
			INSERT INTO ASRSysUtilAccessLog
 				(type, utilID, savedBy, savedDate, savedHost)
			VALUES (2, @piID, system_user, getdate(), host_name())
		END
		ELSE
		BEGIN
			UPDATE ASRSysUtilAccessLog 
			SET savedBy = system_user,
				savedDate = getdate(), 
				savedHost = host_name() 
			WHERE utilID = @piID
				AND type = 2
		END
	END

	IF LEN(@psJobsToHide) > 0 
	BEGIN
		SET @psJobsToHideGroups = '''' + REPLACE(SUBSTRING(LEFT(@psJobsToHideGroups, LEN(@psJobsToHideGroups) - 1), 2, LEN(@psJobsToHideGroups)-1), char(9), ''',''') + ''''

		SET @sSQL = 'DELETE FROM ASRSysBatchJobAccess 
			WHERE ID IN (' +@psJobsToHide + ')
				AND groupName IN (' + @psJobsToHideGroups + ')'
		EXEC sp_executesql @sSQL

		SET @sSQL = 'INSERT INTO ASRSysBatchJobAccess
			(ID, groupName, access)
			(SELECT ASRSysBatchJobName.ID, 
				sysusers.name,
				CASE
					WHEN (SELECT count(*)
						FROM ASRSysGroupPermissions
						INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
							AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
							OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
						INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
							AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
						WHERE sysusers.Name = ASRSysGroupPermissions.groupname
							AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
					ELSE ''HD''
				END
			FROM sysusers,
				ASRSysBatchJobName
			WHERE sysusers.uid = sysusers.gid
				AND sysusers.uid <> 0
				AND sysusers.name IN (' + @psJobsToHideGroups + ')
				AND ASRSysBatchJobName.ID IN (' + @psJobsToHide + '))'
		EXEC sp_executesql @sSQL
	END
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntValidateCrossTab]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntValidateCrossTab];
GO
CREATE PROCEDURE [dbo].[spASRIntValidateCrossTab] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@piEmailGroupID 	integer, 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedFilters 	varchar(MAX)	OUTPUT,
	@psHiddenFilters 	varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sParameter				varchar(MAX),
			@sExprName  			varchar(MAX),
			@sBatchJobName			varchar(MAX),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(MAX),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The cross tab has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCrossTab
			WHERE CrossTabID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					1, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The cross tab has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The cross tab has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the cross tab name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName
				AND CrossTabID <> @piUtilID
				AND CrossTabType = 0
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCrossTab
			WHERE name = @psUtilName AND CrossTabType = 0
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A cross tab called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCrossTab ON ASRSysCrossTab.CrossTabID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Cross Tab'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCrossTab.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Cross Tab ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END

			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	
		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntValidateCustomReport]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntValidateCustomReport];
GO
CREATE PROCEDURE [dbo].[spASRIntValidateCustomReport] (
	@psUtilName 				varchar(255), 
	@piUtilID 					integer, 
	@piTimestamp 				integer, 
	@piBasePicklistID			integer, 
	@piBaseFilterID 			integer, 
	@piEmailGroupID 			integer, 
	@piParent1PicklistID		integer, 
	@piParent1FilterID 			integer, 
	@piParent2PicklistID		integer, 
	@piParent2FilterID 			integer, 
	@piChildFilterID 			varchar(100),			/* tab delimited string of child filter ids */ 
	@psCalculations 			varchar(MAX), 
	@psHiddenGroups 			varchar(MAX), 
	@psErrorMsg					varchar(MAX)	OUTPUT,
	@piErrorCode				varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ? */
	@psDeletedCalcs 			varchar(MAX)	OUTPUT, 
	@psHiddenCalcs 				varchar(MAX)	OUTPUT,
	@psDeletedFilters 			varchar(MAX)	OUTPUT,
	@psHiddenFilters 			varchar(MAX)	OUTPUT,
	@psDeletedOrders			varchar(MAX)	OUTPUT,
	@psJobIDsToHide				varchar(MAX)	OUTPUT,
	@psDeletedPicklists 		varchar(MAX)	OUTPUT,
	@psHiddenPicklists 			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp	integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(100),
			@sParameter				varchar(MAX),
			@sExprName  			varchar(255),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount			integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''
	SET @psDeletedOrders = ''
	SET @psDeletedFilters = ''
	SET @psHiddenFilters = ''
	SET @psDeletedPicklists = ''
	SET @psHiddenPicklists = ''

	EXEC spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
 	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysCustomReportsName
		WHERE ID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The report has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysCustomReportsName
			WHERE ID = @piUtilID

			IF (@iTimestamp <>@piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					2, 
					@piUtilID,
					@sAccess	OUTPUT

				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The report has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCustomReportsName
			WHERE name = @psUtilName
				AND ID <> @piUtilID
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSCustomReportsName
			WHERE name = @psUtilName
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A report called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBasePicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBasePicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piBaseFilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piBaseFilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piEmailGroupID > 0)
	BEGIN
		/* Check that the email group exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysEmailGroupName 
		WHERE emailGroupID = @piEmailGroupID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The email group has been deleted by another user.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piParent1PicklistID > 0)
	BEGIN
		/* Check that the Parent1 table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piParent1PicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The first parent table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent1PicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piParent1PicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The first parent table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent1PicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent1FilterID > 0)
	BEGIN
		/* Check that the Parent 1 table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piParent1FilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The parent 1 filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent1FilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piParent1FilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The parent 1 table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent1FilterID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent2PicklistID > 0)
	BEGIN
		/* Check that the Parent1 table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piParent2PicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The second parent table picklist has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedPicklists = @psDeletedPicklists +
			CASE
				WHEN LEN(@psDeletedPicklists) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent2PicklistID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piParent2PicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The second parent table picklist has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenPicklists = @psHiddenPicklists +
				CASE
					WHEN LEN(@psHiddenPicklists) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent2PicklistID)
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piParent2FilterID > 0)
	BEGIN
		/* Check that the Parent 2 table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piParent2FilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The parent 2 filter has been deleted by another user, and will be automatically removed from the report.'
			SET @piErrorCode = 1

			SET @psDeletedFilters = @psDeletedFilters +
			CASE
				WHEN LEN(@psDeletedFilters) > 0 THEN ','
				ELSE ''
			END + convert(varchar(100), @piParent2FilterID)
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piParent2FilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The parent 2 table filter has been made hidden by another user, and will be automatically removed from the report.'
				SET @piErrorCode = 1

				SET @psHiddenFilters = @psHiddenFilters +
				CASE
					WHEN LEN(@psHiddenFilters) > 0 THEN ','
					ELSE ''
				END + convert(varchar(100), @piParent2FilterID)
			END
		END
	END

	/* Check that the selected child filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@piChildFilterID) > 0)
	BEGIN
		SET @sTemp = @piChildFilterID

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the child filters have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedFilters = @psDeletedFilters +
					CASE
						WHEN LEN(@psDeletedFilters) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
					SET @piErrorCode = 1
			 	END
				ELSE
			  	BEGIN
					SELECT @sOwner = userName,
						@sAccess = access
					FROM ASRSysExpressions
					WHERE exprID = convert(integer, @sCurrentID)

					IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
					BEGIN
						SET @psErrorMsg = 
							@psErrorMsg + 
							CASE
								WHEN LEN(@psHiddenFilters) > 0 THEN ''
								ELSE 
									CASE 
										WHEN LEN(@psErrorMsg) > 0 THEN char(13)
										ELSE ''
									END +
									'One or more of the child filters have been made hidden by another user. They will be automatically removed from the report.'
							END
						SET @psHiddenFilters = @psHiddenFilters +
						CASE
							WHEN LEN(@psHiddenFilters) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
						SET @piErrorCode = 1
					END
			  	END
			END
		END
	END

	/* Check that the selected child filters exist and are not hidden. */
	IF (@piErrorCode = 0) AND (LEN(@psDeletedOrders) > 0)
	BEGIN
		SET @sTemp = @psDeletedOrders

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(char(9), @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(char(9), @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(char(9), @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			IF @sCurrentID > 0 
			BEGIN
				SELECT @iCount = COUNT(*)
				FROM ASRSysOrders
				WHERE OrderID = convert(integer, @sCurrentID)

				IF @iCount = 0
				BEGIN
					SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedOrders) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							 'One or more of the child orders have been deleted by another user. They will be automatically removed from the report.'
					END
					SET @psDeletedOrders = @psDeletedOrders +
					CASE
						WHEN LEN(@psDeletedOrders) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
					SET @piErrorCode = 1
			 	END
			END
		END
	END
	
	/* Check that the selected runtime calculations exists. */
	IF (@piErrorCode = 0) AND (LEN(@psCalculations) > 0)
	BEGIN
		SET @sTemp = @psCalculations

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(',', @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(',', @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(',', @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			SELECT @iCount = COUNT(*)
			FROM ASRSysExpressions
			 WHERE exprID = convert(integer, @sCurrentID)

			IF @iCount = 0
			BEGIN
				SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							'One or more runtime calculations have been deleted by another user. They will be automatically removed from the report.'
					END
				SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
				SET @piErrorCode = 1
			END
			ELSE
			BEGIN
				SELECT @sOwner = userName,
					@sAccess = access
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 
						@psErrorMsg + 
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ''
							ELSE 
								CASE 
									WHEN LEN(@psErrorMsg) > 0 THEN char(13)
									ELSE ''
								END +
								'One or more runtime calculations have been made hidden by another user. They will be automatically removed from the report.'
						END
					SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
					SET @piErrorCode = 1
				END
			END
		END
	END
	
	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysCustomReportsName
		WHERE ID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysCustomReportsName.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysCustomReportsName ON ASRSysCustomReportsName.ID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Custom Report'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysCustomReportsName.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Custom Report ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs
	
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntValidateMailMerge]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntValidateMailMerge];
GO
CREATE PROCEDURE [dbo].[spASRIntValidateMailMerge] (
	@psUtilName 		varchar(255), 
	@piUtilID 			integer, 
	@piTimestamp 		integer, 
	@piBasePicklistID	integer, 
	@piBaseFilterID 	integer, 
	@psCalculations 	varchar(MAX), 
	@psHiddenGroups 	varchar(MAX), 
	@psErrorMsg			varchar(MAX)	OUTPUT,
	@piErrorCode		varchar(MAX)	OUTPUT, /* 	0 = no errors, 
								1 = error, 
								2 = definition deleted or made read only by someone else,  but prompt to save as new definition 
								3 = definition changed by someone else, overwrite ?
								4 = saving will cause batch jobs to be made hiiden. Prompt to continue */
	@psDeletedCalcs 	varchar(MAX)	OUTPUT, 
	@psHiddenCalcs 		varchar(MAX)	OUTPUT,
	@psJobIDsToHide		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@iTimestamp				integer,
			@sAccess				varchar(MAX),
			@sOwner					varchar(255),
			@iCount					integer,
			@sCurrentUser			sysname,
			@sTemp					varchar(MAX),
			@sCurrentID				varchar(MAX),
			@sBatchJobName			varchar(255),
			@iBatchJobID			integer,
			@iBatchJobScheduled		integer,
			@sBatchJobRoleToPrompt	varchar(MAX),
			@iNonHiddenCount		integer,
			@sBatchJobUserName		sysname,
			@sJobName				varchar(255),
			@sCurrentUserGroup		sysname,
			@fBatchJobsOK			bit,
			@sScheduledUserGroups	varchar(MAX),
			@sScheduledJobDetails	varchar(MAX),
			@sCurrentUserAccess		varchar(MAX),
			@iOwnedJobCount 		integer,
			@sOwnedJobDetails		varchar(MAX),
			@sOwnedJobIDs			varchar(MAX),
			@sNonOwnedJobDetails	varchar(MAX),
			@sHiddenGroupsList		varchar(MAX),
			@sHiddenGroup			varchar(MAX),
			@fSysSecMgr				bit,
			@sActualUserName		sysname,
			@iUserGroupID			integer;

	SET @fBatchJobsOK = 1
	SET @sScheduledUserGroups = ''
	SET @sScheduledJobDetails = ''
	SET @iOwnedJobCount = 0
	SET @sOwnedJobDetails = ''
	SET @sOwnedJobIDs = ''
	SET @sNonOwnedJobDetails = ''

	SELECT @sCurrentUser = SYSTEM_USER
	SET @psErrorMsg = ''
	SET @piErrorCode = 0
	SET @psDeletedCalcs = ''
	SET @psHiddenCalcs = ''

	exec spASRIntSysSecMgr @fSysSecMgr OUTPUT
	
	IF @piUtilID > 0
	BEGIN
		/* Check if this definition has been changed by another user. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The mail merge has been deleted by another user. Save as a new definition ?'
			SET @piErrorCode = 2
		END
		ELSE
		BEGIN
			SELECT @iTimestamp = convert(integer, timestamp), 
				@sOwner = userName
			FROM ASRSysMailMergeName
			WHERE MailMergeID = @piUtilID

			IF (@iTimestamp <> @piTimestamp)
			BEGIN
				exec spASRIntCurrentUserAccess 
					9, 
					@piUtilID,
					@sAccess	OUTPUT
		
				IF (@sOwner <> @sCurrentUser) AND (@sAccess <> 'RW') AND (@iTimestamp <>@piTimestamp)
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user and is now Read Only. Save as a new definition ?'
					SET @piErrorCode = 2
				END
				ELSE
				BEGIN
					SET @psErrorMsg = 'The mail merge has been amended by another user. Would you like to overwrite this definition ?'
					SET @piErrorCode = 3
				END
			END
			
		END
	END

	IF @piErrorCode = 0
	BEGIN
		/* Check that the report name is unique. */
		IF @piUtilID > 0
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName
				AND MailMergeID <> @piUtilID AND IsLabel = 0
		END
		ELSE
		BEGIN
			SELECT @iCount = COUNT(*) 
			FROM ASRSYSMailMergeName
			WHERE name = @psUtilName AND IsLabel = 0
		END

		IF @iCount > 0 
		BEGIN
			SET @psErrorMsg = 'A mail merge called ''' + @psUtilName + ''' already exists.'
			SET @piErrorCode = 1
		END
	END

	IF (@piErrorCode = 0) AND (@piBasePicklistID > 0)
	BEGIN
		/* Check that the Base table picklist exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysPicklistName 
		WHERE picklistID = @piBasePicklistID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table picklist has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysPicklistName 
			WHERE picklistID = @piBasePicklistID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table picklist has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piBaseFilterID > 0)
	BEGIN
		/* Check that the Base table filter exists. */
		SELECT @iCount = COUNT(*)
		FROM ASRSysExpressions 
		WHERE exprID = @piBaseFilterID

		IF @iCount = 0
		BEGIN
			SET @psErrorMsg = 'The base table filter has been deleted by another user.'
			SET @piErrorCode = 1
		END
		ELSE
		BEGIN
			SELECT @sOwner = userName,
				@sAccess = access
			FROM ASRSysExpressions 
			WHERE exprID = @piBaseFilterID

			IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
			BEGIN
				SET @psErrorMsg = 'The base table filter has been made hidden by another user.'
				SET @piErrorCode = 1
			END
		END
	END

	/* Check that the selected runtime calculations exists. */
	IF (@piErrorCode = 0) AND (LEN(@psCalculations) > 0)
	BEGIN
		SET @sTemp = @psCalculations

		WHILE LEN(@sTemp) > 0
		BEGIN
			IF CHARINDEX(',', @sTemp) > 0
			BEGIN
				SET @sCurrentID = LEFT(@sTemp, CHARINDEX(',', @sTemp) - 1)
				SET @sTemp = RIGHT(@sTemp, LEN(@sTemp) - CHARINDEX(',', @sTemp))
			END
			ELSE
			BEGIN
				SET @sCurrentID = @sTemp
				SET @sTemp = ''
			END
			
			SELECT @iCount = COUNT(*)
			FROM ASRSysExpressions
			 WHERE exprID = convert(integer, @sCurrentID)

			IF @iCount = 0
			BEGIN
				SET @psErrorMsg = 
					@psErrorMsg + 
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ''
						ELSE 
							CASE 
								WHEN LEN(@psErrorMsg) > 0 THEN char(13)
								ELSE ''
							END +
							'One or more runtime calculations have been deleted by another user. They will be automatically removed from the mail merge.'
					END
				SET @psDeletedCalcs = @psDeletedCalcs +
					CASE
						WHEN LEN(@psDeletedCalcs) > 0 THEN ','
						ELSE ''
					END + @sCurrentID
				SET @piErrorCode = 1
			END
			ELSE
			BEGIN
				SELECT @sOwner = userName,
					@sAccess = access
				FROM ASRSysExpressions
				WHERE exprID = convert(integer, @sCurrentID)

				IF (@sOwner <> @sCurrentUser) AND (@sAccess = 'HD') AND (@fSysSecMgr = 0)
				BEGIN
					SET @psErrorMsg = 
						@psErrorMsg + 
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ''
							ELSE 
								CASE 
									WHEN LEN(@psErrorMsg) > 0 THEN char(13)
									ELSE ''
								END +
								'One or more runtime calculations have been made hidden by another user. They will be automatically removed from the mail merge.'
						END
					SET @psHiddenCalcs = @psHiddenCalcs +
						CASE
							WHEN LEN(@psHiddenCalcs) > 0 THEN ','
							ELSE ''
						END + @sCurrentID
						
					SET @piErrorCode = 1
				END
			END
		END
	END

	IF (@piErrorCode = 0) AND (@piUtilID > 0) AND (len(@psHiddenGroups) > 0)
	BEGIN
		SELECT @sOwner = userName
		FROM ASRSysMailMergeName
		WHERE MailMergeID = @piUtilID

		IF (@sOwner = @sCurrentUser) 
		BEGIN
			EXEC spASRIntGetActualUserDetails
				@sActualUserName OUTPUT,
				@sCurrentUserGroup OUTPUT,
				@iUserGroupID OUTPUT

			DECLARE @HiddenGroups TABLE(groupName sysname, groupID integer)
			SET @sHiddenGroupsList = substring(@psHiddenGroups, 2, len(@psHiddenGroups)-2)
			WHILE LEN(@sHiddenGroupsList) > 0
			BEGIN
				IF CHARINDEX(char(9), @sHiddenGroupsList) > 0
				BEGIN
					SET @sHiddenGroup = LEFT(@sHiddenGroupsList, CHARINDEX(char(9), @sHiddenGroupsList) - 1)
					SET @sHiddenGroupsList = RIGHT(@sHiddenGroupsList, LEN(@sHiddenGroupsList) - CHARINDEX(char(9), @sHiddenGroupsList))
				END
				ELSE
				BEGIN
					SET @sHiddenGroup = @sHiddenGroupsList
					SET @sHiddenGroupsList = ''
				END

				INSERT INTO @HiddenGroups (groupName, groupID) (SELECT @sHiddenGroup, uid FROM sysusers WHERE name = @sHiddenGroup)
			END

			DECLARE batchjob_cursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				COUNT (ASRSysBatchJobAccess.Access) AS [nonHiddenCount],
				ASRSysBatchJobName.Username,
				ASRSysMailMergeName.Name AS 'JobName'
	 		FROM ASRSysBatchJobDetails
			INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobName.ID = ASRSysBatchJobDetails.BatchJobNameID 
			INNER JOIN ASRSysMailMergeName ON ASRSysMailMergeName.MailMergeID = ASRSysBatchJobDetails.JobID
			LEFT OUTER JOIN ASRSysBatchJobAccess ON ASRSysBatchJobName.ID = ASRSysBatchJobAccess.ID
				AND ASRSysBatchJobAccess.access <> 'HD'
				AND ASRSysBatchJobAccess.groupName IN (SELECT name FROM sysusers WHERE uid IN (SELECT groupID FROM @HiddenGroups))
				AND ASRSysBatchJobAccess.groupName NOT IN (SELECT sysusers.name
					FROM sysusers
					INNER JOIN ASRSysGroupPermissions ON sysusers.name = ASRSysGroupPermissions.groupName
						AND ASRSysGroupPermissions.permitted = 1
					INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
						AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
						OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
					INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
					WHERE sysusers.uid = sysusers.gid
						AND sysusers.uid <> 0)
			WHERE ASRSysBatchJobDetails.JobType = 'Mail Merge'
				AND ASRSysBatchJobDetails.JobID IN (@piUtilID)
			GROUP BY ASRSysBatchJobName.Name,
				ASRSysBatchJobName.ID,
				convert(integer, ASRSysBatchJobName.scheduled),
				ASRSysBatchJobName.roleToPrompt,
				ASRSysBatchJobName.Username,
				ASRSysMailMergeName.Name

			OPEN batchjob_cursor
			FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
				@iBatchJobID,
				@iBatchJobScheduled,
				@sBatchJobRoleToPrompt,
				@iNonHiddenCount,
				@sBatchJobUserName,
				@sJobName	
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @sCurrentUserAccess = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
								OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER'))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		 						AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN 'RW'
						WHEN ASRSysBatchJobName.userName = system_user THEN 'RW'
						ELSE
							CASE
								WHEN ASRSysBatchJobAccess.access IS null THEN 'HD'
								ELSE ASRSysBatchJobAccess.access
							END
					END 
				FROM sysusers b
				INNER JOIN sysusers a ON b.uid = a.gid
				LEFT OUTER JOIN ASRSysBatchJobAccess ON (b.name = ASRSysBatchJobAccess.groupName
					AND ASRSysBatchJobAccess.id = @iBatchJobID)
				INNER JOIN ASRSysBatchJobName ON ASRSysBatchJobAccess.ID = ASRSysBatchJobName.ID
				WHERE a.Name = @sActualUserName

				IF @sBatchJobUserName = @sOwner
				BEGIN
					/* Found a Batch Job whose owner is the same. */
					IF (@iBatchJobScheduled = 1) AND
						(len(@sBatchJobRoleToPrompt) > 0) AND
						(@sBatchJobRoleToPrompt <> @sCurrentUserGroup) AND
						(CHARINDEX(char(9) + @sBatchJobRoleToPrompt + char(9), @psHiddenGroups) > 0)
					BEGIN
						/* Found a Batch Job which is scheduled for another user group to run. */
						SET @fBatchJobsOK = 0
						SET @sScheduledUserGroups = @sScheduledUserGroups + @sBatchJobRoleToPrompt + '<BR>'

						IF @sCurrentUserAccess = 'HD'
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
						END
						ELSE
						BEGIN
							SET @sScheduledJobDetails = @sScheduledJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
						END
					END
					ELSE
					BEGIN
						IF @iNonHiddenCount > 0 
						BEGIN
							SET @iOwnedJobCount = @iOwnedJobCount + 1
							SET @sOwnedJobDetails = @sOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + ' (Contains Mail Merge ' + @sJobName + ')' + '<BR>'
							SET @sOwnedJobIDs = @sOwnedJobIDs +
								CASE 
									WHEN Len(@sOwnedJobIDs) > 0 THEN ', '
									ELSE ''
								END +  convert(varchar(100), @iBatchJobID)
						END
					END
				END			
				ELSE
				BEGIN
					/* Found a Batch Job whose owner is not the same. */
					SET @fBatchJobsOK = 0
	    
					IF @sCurrentUserAccess = 'HD'
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : <Hidden> by ' + @sBatchJobUserName + '<BR>'
					END
					ELSE
					BEGIN
						SET @sNonOwnedJobDetails = @sNonOwnedJobDetails + 'Batch Job : ' + @sBatchJobName + '<BR>'
					END
				END

				FETCH NEXT FROM batchjob_cursor INTO @sBatchJobName, 
					@iBatchJobID,
					@iBatchJobScheduled,
					@sBatchJobRoleToPrompt,
					@iNonHiddenCount,
					@sBatchJobUserName,
					@sJobName	
			END
			CLOSE batchjob_cursor
			DEALLOCATE batchjob_cursor	

		END
	END

	IF @fBatchJobsOK = 0
	BEGIN
		SET @piErrorCode = 1

		IF Len(@sScheduledJobDetails) > 0 
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden from the following user groups :'  + '<BR><BR>' +
				@sScheduledUserGroups  +
				'<BR>as it is used in the following batch jobs which are scheduled to be run by these user groups :<BR><BR>' +
				@sScheduledJobDetails
		END
		ELSE
		BEGIN
			SET @psErrorMsg = 'This definition cannot be made hidden as it is used in the following batch jobs of which you are not the owner :<BR><BR>' +
				@sNonOwnedJobDetails
	      	END
	END
	ELSE
	BEGIN
	    	IF (@iOwnedJobCount > 0) 
		BEGIN
			SET @piErrorCode = 4
			SET @psErrorMsg = 'Making this definition hidden to user groups will automatically make the following definition(s), of which you are the owner, hidden to the same user groups:<BR><BR>' +
				@sOwnedJobDetails + '<BR><BR>' +
				'Do you wish to continue ?'
		END
	END

	SET @psJobIDsToHide = @sOwnedJobIDs
	
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetPersonnelParameters]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetPersonnelParameters];
GO
CREATE PROCEDURE [dbo].[sp_ASRIntGetPersonnelParameters] (
	@piEmployeeTableID	integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	SET @piEmployeeTableID = 0;

	-- Get the EMPLOYEE table information.
	SELECT @piEmployeeTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_PERSONNEL'
		AND parameterKey = 'Param_TablePersonnel';
	IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0;

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetTrainingBookingParameters]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTrainingBookingParameters];
GO
CREATE PROCEDURE [dbo].[sp_ASRIntGetTrainingBookingParameters] (
	@piEmployeeTableID			integer	OUTPUT,
	@piCourseTableID			integer	OUTPUT,
	@piCourseCancelDateColumnID	integer	OUTPUT,
	@piTBTableID				integer	OUTPUT,
	@pfTBTableSelect			bit		OUTPUT,
	@pfTBTableInsert			bit		OUTPUT,
	@pfTBTableUpdate			bit		OUTPUT,
	@piTBStatusColumnID			integer	OUTPUT,
	@pfTBStatusColumnUpdate		bit		OUTPUT,
	@piTBCancelDateColumnID		integer	OUTPUT,
	@pfTBCancelDateColumnUpdate	bit		OUTPUT,
	@pfTBProvisionalStatusExists	bit	OUTPUT,
	@piWaitListTableID			integer	OUTPUT,
	@pfWaitListTableInsert			bit	OUTPUT,
	@pfWaitListTableDelete			bit	OUTPUT,
	@piWaitListCourseTitleColumnID		integer	OUTPUT,
	@pfWaitListCourseTitleColumnUpdate	bit	OUTPUT,
	@pfWaitListCourseTitleColumnSelect	bit	OUTPUT,
	@piBulkBookingDefaultViewID		integer	OUTPUT,
	@piBulkBookingDefaultOrderID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the given screen's definition and table permission info. */
	DECLARE @fOK			bit,
		@fSysSecMgr			bit,
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@sTempName			sysname,
		@iTempAction		integer,
		@sCommand			nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRealSource		sysname,
		@iStatusCount		integer,
		@iChildViewID		integer,
		@sTBTableName		sysname,
		@sWLTableName		sysname,
		@sActualUserName	sysname;
		
	/* Training Booking information. */
	SET @fOK = 1

	SET @piEmployeeTableID = 0

	SET @piCourseTableID = 0
	SET @piCourseCancelDateColumnID = 0

	SET @piTBTableID = 0
	SET @pfTBTableSelect = 0
	SET @pfTBTableInsert = 0
	SET @pfTBTableUpdate = 0
	SET @piTBStatusColumnID = 0
	SET @pfTBStatusColumnUpdate = 0
	SET @piTBCancelDateColumnID = 0
	SET @pfTBCancelDateColumnUpdate = 0
	SET @pfTBProvisionalStatusExists = 0

	SET @piWaitListTableID = 0
	SET @pfWaitListTableInsert = 0
	SET @pfWaitListTableDelete = 0
	SET @piWaitListCourseTitleColumnID = 0
	SET @pfWaitListCourseTitleColumnUpdate = 0
	SET @pfWaitListCourseTitleColumnSelect = 0

	SET @piBulkBookingDefaultViewID = 0
	
	/* Get the current user's group id. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Check if the current user is a System or Security manager. */
	SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
	FROM ASRSysGroupPermissions
	INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
	WHERE sysusers.uid = @iUserGroupID
	AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
	OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
	AND ASRSysGroupPermissions.permitted = 1
	AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

		/* Get the EMPLOYEE table information. */
		SELECT @piEmployeeTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_EmployeeTable'
		IF @piEmployeeTableID IS NULL SET @piEmployeeTableID = 0

		/* Get the COURSE table information. */
		SELECT @piCourseTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseTable'
		IF @piCourseTableID IS NULL SET @piCourseTableID = 0

		IF @piCourseTableID > 0
		BEGIN
			SELECT @piCourseCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_CourseCancelDate'
			IF @piCourseCancelDateColumnID IS NULL SET @piCourseCancelDateColumnID = 0
		END

		/* Get the TRAINING BOOKING table information. */
		SELECT @piTBTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_TrainBookTable'
		IF @piTBTableID IS NULL SET @piTBTableID = 0


		-- Cached view of the sysprotects table
		DECLARE @SysProtects TABLE([ID]				int,
								   [columns]		varbinary(8000),
								   [Action]			tinyint,
								   [ProtectType]	tinyint)
		INSERT INTO @SysProtects
		SELECT [ID], [Columns], [Action], [ProtectType] FROM ASRSysProtectsCache
			WHERE [UID] = @iUserGroupID AND [Action] IN (193, 195, 196, 197)

		IF @piTBTableID > 0
		BEGIN
			SELECT @sTBTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piTBTableID

			SELECT @piTBStatusColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookStatus'
			IF @piTBStatusColumnID IS NULL SET @piTBStatusColumnID = 0

			SELECT @piTBCancelDateColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_TrainBookCancelDate'
			IF @piTBCancelDateColumnID IS NULL SET @piTBCancelDateColumnID = 0

			SET @sCommand = 'SELECT @iStatusCount = COUNT(*)' +
				' FROM ASRSysColumnControlValues' +
				' WHERE columnID = ' + convert(nvarchar(100), @piTBStatusColumnID) +
				' AND value = ''P'''
			SET @sParamDefinition = N'@iStatusCount integer OUTPUT'
			EXEC sp_executesql @sCommand, @sParamDefinition, @iStatusCount OUTPUT
			IF @iStatusCount > 0 SET @pfTBProvisionalStatusExists = 1

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				/* System/Security managers must have all permissions granted. */
				SET @pfTBTableSelect = 1
				SET @pfTBTableInsert = 1
				SET @pfTBTableUpdate = 1
				SET @pfTBStatusColumnUpdate = 1
				SET @pfTBCancelDateColumnUpdate = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piTBTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN

					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sTBTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (193, 195, 197)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN

						IF @iTempAction = 193
						BEGIN
							SET @pfTBTableSelect = 1
						END
						IF @iTempAction = 195
						BEGIN
							SET @pfTBTableInsert = 1
						END
						IF @iTempAction = 197
						BEGIN
							SET @pfTBTableUpdate = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @tbColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @tbColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piTBTableID
						AND (ASRSysColumns.columnId = @piTBStatusColumnID
							OR ASRSysColumns.columnId = @piTBCancelDateColumnID))
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfTBStatusColumnUpdate = granted

					FROM @tbColumnPermissions
					WHERE columnID = @piTBStatusColumnID
						AND action = 197
					IF @pfTBStatusColumnUpdate IS NULL SET @pfTBStatusColumnUpdate = 0

					SELECT @pfTBCancelDateColumnUpdate = granted
					FROM @tbColumnPermissions
					WHERE columnID = @piTBCancelDateColumnID
						AND action = 197
					IF @pfTBCancelDateColumnUpdate IS NULL SET @pfTBCancelDateColumnUpdate = 0

				END
			END
		END

		/* Get the waiting list table information. */
		SELECT @piWaitListTableID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_WaitListTable'
		IF @piWaitListTableID IS NULL SET @piWaitListTableID = 0

		IF @piWaitListTableID > 0
		BEGIN
			SELECT @sWLTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @piWaitListTableID

			SELECT @piWaitListCourseTitleColumnID = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_WaitListCourseTitle'
			IF @piWaitListCourseTitleColumnID IS NULL SET @piWaitListCourseTitleColumnID = 0

			/* Check what permissions the current user has on the table. */
			IF @fSysSecMgr = 1
			BEGIN
				SET @pfWaitListTableInsert = 1
				SET @pfWaitListTableDelete = 1
				SET @pfWaitListCourseTitleColumnUpdate = 1
				SET @pfWaitListCourseTitleColumnSelect = 1
			END
			ELSE
			BEGIN
				SET @sRealSource = ''

				SELECT @iChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @piWaitListTableID
					AND role = @sUserGroupName
					
				IF @iChildViewID IS null SET @iChildViewID = 0
					
				IF @iChildViewID > 0 
				BEGIN
					SET @sRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iChildViewID) +
						'#' + replace(@sWLTableName, ' ', '_') +
						'#' + replace(@sUserGroupName, ' ', '_')
					SET @sRealSource = left(@sRealSource, 255)

					DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
						SELECT sysobjects.name, p.action
						FROM @SysProtects p
						INNER JOIN sysobjects ON p.id = sysobjects.id
						WHERE p.protectType <> 206
							AND p.action IN (195, 196)
							AND sysobjects.name = @sRealSource

					OPEN tableInfo_cursor
					FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction
					WHILE (@@fetch_status = 0)
					BEGIN
						IF @iTempAction = 195
						BEGIN
							SET @pfWaitListTableInsert = 1
						END
						IF @iTempAction = 196
						BEGIN
							SET @pfWaitListTableDelete = 1
						END
						FETCH NEXT FROM tableInfo_cursor INTO @sTempName, @iTempAction

					END
					CLOSE tableInfo_cursor
					DEALLOCATE tableInfo_cursor
				END

				IF LEN(@sRealSource) > 0
				BEGIN
					/* Check the current user's column permissions. */
					/* Create a temporary table of the column permissions. */
					DECLARE @waitListColumnPermissions TABLE
					(
						columnID	int,
						action		int,		
						granted		bit		
					)

					INSERT INTO @waitListColumnPermissions
					SELECT 
						ASRSysColumns.columnId,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @SysProtects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					INNER JOIN ASRSysColumns ON (syscolumns.name = ASRSysColumns.columnName
						AND ASRSysColumns.tableID = @piWaitListTableID
						AND ASRSysColumns.columnId = @piWaitListCourseTitleColumnID)
					WHERE p.action IN (193, 197)
						AND sysobjects.name = @sRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					SELECT @pfWaitListCourseTitleColumnUpdate = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 197
					IF @pfWaitListCourseTitleColumnUpdate IS NULL SET @pfWaitListCourseTitleColumnUpdate = 0

					SELECT @pfWaitListCourseTitleColumnSelect = granted
					FROM @waitListColumnPermissions
					WHERE columnID =  @piWaitListCourseTitleColumnID
						AND action = 193
					IF @pfWaitListCourseTitleColumnSelect IS NULL SET @pfWaitListCourseTitleColumnSelect = 0

				END
			END
		END

		/* Get the Bulk Booking default view. */
		SELECT @piBulkBookingDefaultViewID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_BulkBookingDefaultView'
		IF @piBulkBookingDefaultViewID IS NULL SET @piBulkBookingDefaultViewID = 0

			/* Get the Bulk Booking default order. */
		SELECT @piBulkBookingDefaultOrderID = convert(integer, parameterValue)
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_EmployeeOrder'
		IF @piBulkBookingDefaultOrderID IS NULL SET @piBulkBookingDefaultOrderID = 0
END
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogRecords] (
	@pfError 						bit 				OUTPUT, 
	@psFilterUser					varchar(MAX),
	@piFilterType					integer,
	@piFilterStatus					integer,
	@piFilterMode					integer,
	@psOrderColumn					varchar(MAX),
	@psOrderOrder					varchar(MAX),
	@piRecordsRequired				integer,
	@pfFirstPage					bit					OUTPUT,
	@pfLastPage						bit					OUTPUT,
	@psAction						varchar(100),
	@piTotalRecCount				integer				OUTPUT,
	@piFirstRecPos					integer				OUTPUT,
	@piCurrentRecCount				integer
)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE	@sRealSource 			sysname,
			@sSelectSQL				varchar(MAX),
			@iTempCount 			integer,
			@sExecString			nvarchar(MAX),
			@sTempExecString		nvarchar(MAX),
			@sTempParamDefinition	nvarchar(500),
			@iCount					integer,
			@iGetCount				integer,
			@sFilterSQL				varchar(MAX),
			@sOrderSQL				varchar(MAX),
			@sReverseOrderSQL		varchar(MAX);
			
	/* Clean the input string parameters. */
	IF len(@psAction) > 0 SET @psAction = replace(@psAction, '''', '''''');
	IF len(@psFilterUser) > 0 SET @psFilterUser = replace(@psFilterUser, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sExecString = '';
	SET @sRealSource = 'ASRSysEventLog';
	SET @psAction = UPPER(@psAction);

	IF (@psAction <> 'MOVEPREVIOUS') AND (@psAction <> 'MOVENEXT') AND (@psAction <> 'MOVELAST') 
		BEGIN
			SET @psAction = 'MOVEFIRST';
		END

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 50;

	/* Construct the filter SQL from ther input parameters. */
	SET @sFilterSQL = '';
	
	SET @sFilterSQL = @sFilterSQL + ' Type NOT IN (23, 24) ';

	IF @psFilterUser <> '-1' 
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' LOWER(username) = ''' + lower(@psFilterUser) + '''';
	END
	IF @piFilterType <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Type = ' + convert(varchar(MAX), @piFilterType) + ' ';
	END
	IF @piFilterStatus <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		SET @sFilterSQL = @sFilterSQL + ' Status = ' + convert(varchar(MAX), @piFilterStatus) + ' ';
	END
	IF @piFilterMode <> -1
	BEGIN
		IF len(@sFilterSQL) > 0 SET @sFilterSQL = @sFilterSQL + ' AND ';
		--SET @sFilterSQL = @sFilterSQL + ' Mode = ' + convert(varchar(MAX), @piFilterMode) + ' ';
		SET @sFilterSQL = @sFilterSQL + 
			CASE @piFilterMode 
				WHEN 1 THEN '[Mode] = 1 AND [ReportPack] = 0'
				WHEN 2 THEN '[ReportPack] = 1'
				WHEN 0 THEN '[Mode] = 0 AND [ReportPack] = 0'
			END 
	END
	
	/* Construct the order SQL from ther input parameters. */
	SET @sOrderSQL = '';
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
					WHEN 1 THEN ''Cross Tab''
					WHEN 2 THEN ''Custom Report''
					WHEN 3 THEN ''Data Transfer''
					WHEN 4 THEN ''Export''
					WHEN 5 THEN ''Global Add''
					WHEN 6 THEN ''Global Delete''
					WHEN 7 THEN ''Global Update''
					WHEN 8 THEN ''Import''
					WHEN 9 THEN ''Mail Merge''
					WHEN 10 THEN ''Diary Delete''
					WHEN 11 THEN ''Diary Rebuild''
					WHEN 12 THEN ''Email Rebuild''
					WHEN 13 THEN ''Standard Report''
					WHEN 14 THEN ''Record Editing''
					WHEN 15 THEN ''System Error''
					WHEN 16 THEN ''Match Report''
					WHEN 17 THEN ''Calendar Report''
					WHEN 18 THEN ''Envelopes & Labels''
					WHEN 19 THEN ''Label Definition''
					WHEN 20 THEN ''Record Profile''
					WHEN 21 THEN ''Succession Planning''
					WHEN 22 THEN ''Career Progression''
					WHEN 25 THEN ''Workflow Rebuild''
					WHEN 35 THEN ''9-Box Grid Report''
					ELSE ''Unknown''
				END ';
	END
	ELSE
	BEGIN
		IF @psOrderColumn = 'Mode'
		BEGIN
			SET @sOrderSQL =	
				' CASE ' + @piFilterMode + '
						WHEN 1 THEN ''Batch''
						WHEN 0 THEN ''Manual''
						WHEN 2 THEN ''Pack''
					END ';
		END
		ELSE 
		BEGIN
			IF @psOrderColumn = 'Status'
			BEGIN
				SET @sOrderSQL =	
					' CASE [Status]
							WHEN 0 THEN ''Pending''
							WHEN 1 THEN ''Cancelled''
							WHEN 2 THEN ''Failed''
							WHEN 3 THEN ''Successful''
							WHEN 4 THEN ''Skipped''
							WHEN 5 THEN ''Error''
							ELSE ''Unknown''
						END ';
			END
			ELSE
			BEGIN
				SET @sOrderSQL = @psOrderColumn;
			END
		END
	END
	
	SET @sReverseOrderSQL = @sOrderSQL;
	if @psOrderOrder = 'DESC'
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' ASC ';
	END
	ELSE
	BEGIN
		SET @sReverseOrderSQL = @sReverseOrderSQL + ' DESC ';
	END

	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder + ' ';


	SET @sSelectSQL = '[DateTime],
					[EndTime],
					IsNull([Duration],-1) AS ''Duration'', 
		 			CASE [Type] 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						WHEN 35 THEN ''9-Box Grid Report''
						ELSE ''Unknown''  
					END + char(9) + 
				 	[Name] + char(9) + 
		 			CASE Status 
						WHEN 0 THEN ''Pending''
					  WHEN 1 THEN ''Cancelled'' 
						WHEN 2 THEN ''Failed'' 
						WHEN 3 THEN ''Successful'' 
						WHEN 4 THEN ''Skipped'' 
						WHEN 5 THEN ''Error''
						ELSE ''Unknown'' 
					END + char(9) +
					CASE 
						WHEN [Mode] = 1 AND ([ReportPack] = 0 OR [ReportPack] IS NULL) THEN ''Batch''
						WHEN [Mode] = 0 AND ([ReportPack] = 0 OR [ReportPack] IS NULL) THEN ''Manual''
						ELSE ''Pack''
				 	END + char(9) + 
					[Username] + char(9) + 
					IsNull(convert(varchar, [BatchJobID]), ''0'') + char(9) +
					IsNull(convert(varchar, [BatchRunID]), ''0'') + char(9) +
					IsNull([BatchName],'''') + char(9) +
					IsNull(convert(varchar, [SuccessCount]),''0'') + char(9) +
					IsNull(convert(varchar, [FailCount]), ''0'') AS EventInfo ';

		
	
	/****************************************************************************************************************************************/
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.ID) FROM ' + @sRealSource;

	IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;
	/****************************************************************************************************************************************/
	
	IF len(@sSelectSQL) > 0 
		BEGIN
			SET @sSelectSQL = @sRealSource + '.ID, ' + @sSelectSQL;
			SET @sExecString = 'SELECT ' ;

			IF @psAction = 'MOVEFIRST'
				BEGIN
					SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
					
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource ;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = 1;
					SET @pfFirstPage = 1;
					SET @pfLastPage = 
					CASE 
						WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
						ELSE 0
					END;
				END
		
			IF (@psAction = 'MOVELAST')
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
					
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')'

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
					IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
					SET @pfFirstPage = 	CASE 
									WHEN @piFirstRecPos = 1 THEN 1
									ELSE 0
								END;
					SET @pfLastPage = 1;

				END

			IF (@psAction = 'MOVENEXT') 
				BEGIN
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
						BEGIN
							SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID ' + 
						' FROM ' + @sRealSource;

					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL;
						END

					SET @sExecString = @sExecString + ')';

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END

					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
					SET @pfFirstPage = 0
					SET @pfLastPage = 	CASE 
									WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
									ELSE 0
								END;
				END

			IF @psAction = 'MOVEPREVIOUS'
				BEGIN	
					SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

					IF @piFirstRecPos <= @piRecordsRequired
						BEGIN
							SET @iGetCount = @piFirstRecPos - 1;
						END
					ELSE
						BEGIN
							SET @iGetCount = @piRecordsRequired;
						END
		
					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;

					SET @sExecString = @sExecString + 
						' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID FROM ' + @sRealSource;
				
					/* Add the filter code. */
					IF len(@sFilterSQL) > 0
						BEGIN
							SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL;
						END
					
					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
					
					SET @sExecString = @sExecString + ')';

					/* Add the reverse order code */
					IF len(@sReverseOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')';
						END
					
					SET @sExecString = @sExecString

					/* Add the order code */
					IF len(@sOrderSQL) > 0 
						BEGIN
							SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL;
						END
		
					/* Set the position variables */
					SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
					IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
					SET @pfFirstPage = CASE WHEN @piFirstRecPos = 1 
															THEN 1
															ELSE 0
														 END;
					SET @pfLastPage = CASE WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount 
															THEN 1
															ELSE 0
														END;
				END

		END

	EXECUTE sp_executeSQL @sExecString;
END

GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogBatchDetails] (
	@piBatchRunID 	integer,
	@piEventID		integer
)
AS
BEGIN

	SET NOCOUNT ON;
	
	DECLARE @sExecString		nvarchar(MAX),
			@sSelectString 		varchar(MAX),
			@sFromString		varchar(MAX),
			@sWhereString		varchar(MAX),
			@sOrderString 		varchar(MAX);

	SET @sSelectString = '';
	SET @sFromString = '';
	SET @sWhereString = '';
	SET @sOrderString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 
		 ID, 
		 DateTime,
		 EndTime,
		 IsNull(Duration,-1) AS Duration,
		 Username,
		 CASE Type 
						WHEN 0 THEN ''Unknown''
						WHEN 1 THEN ''Cross Tab'' 
						WHEN 2 THEN ''Custom Report'' 
						WHEN 3 THEN ''Data Transfer'' 
						WHEN 4 THEN ''Export'' 
						WHEN 5 THEN ''Global Add'' 
						WHEN 6 THEN ''Global Delete'' 
						WHEN 7 THEN ''Global Update'' 
						WHEN 8 THEN ''Import'' 
						WHEN 9 THEN ''Mail Merge'' 
						WHEN 10 THEN ''Diary Delete'' 
						WHEN 11 THEN ''Diary Rebuild''
						WHEN 12 THEN ''Email Rebuild''
						WHEN 13 THEN ''Standard Report''
						WHEN 14 THEN ''Record Editing''
						WHEN 15 THEN ''System Error''
						WHEN 16 THEN ''Match Report''
						WHEN 17 THEN ''Calendar Report''
						WHEN 18 THEN ''Envelopes & Labels''
						WHEN 19 THEN ''Label Definition''
						WHEN 20 THEN ''Record Profile''
						WHEN 21	THEN ''Succession Planning''
						WHEN 22 THEN ''Career Progression''
						WHEN 25 THEN ''Workflow Rebuild''
						WHEN 35 THEN ''9-Box Grid Report''
						ELSE ''Unknown''  
		 END AS Type,
		 Name,
		 CASE Mode 
			WHEN 1 THEN ''Batch''
			WHEN 0 THEN ''Manual''
			ELSE ''Unknown''
		 END AS Mode, 
		 CASE Status 
				WHEN 0 THEN ''Pending''
		   	WHEN 1 THEN ''Cancelled'' 
				WHEN 2 THEN ''Failed'' 
				WHEN 3 THEN ''Successful'' 
				WHEN 4 THEN ''Skipped'' 
				WHEN 5 THEN ''Error''
				ELSE ''Unknown'' 
		 END AS Status,
		 IsNull(BatchName,'''') AS BatchName,
		 IsNull(convert(varchar,SuccessCount), ''N/A'') AS SuccessCount,
		 IsNull(convert(varchar,FailCount), ''N/A'') AS FailCount,
		 IsNull(convert(varchar,BatchJobID), ''N/A'') AS BatchJobID,
		 IsNull(convert(varchar,BatchRunID), ''N/A'') AS BatchRunID';

	SET @sFromString = ' FROM ASRSysEventLog ';

	IF @piBatchRunID > 0
		BEGIN
			SET @sWhereString = ' WHERE BatchRunID = ' + convert(varchar, @piBatchRunID);
		END
	ELSE
		BEGIN
			SET @sWhereString = ' WHERE ID = ' + convert(varchar, @piEventID);
		END

	SET @sOrderString = ' ORDER BY DateTime ASC ';

	SET @sExecString = @sSelectString + @sFromString + @sWhereString + @sOrderString;

	-- Run generated statement
	EXEC sp_executeSQL @sExecString;
	
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetEventLogEmailInfo]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].spASRIntGetEventLogEmailInfo;
GO

CREATE PROCEDURE [dbo].[spASRIntGetEventLogEmailInfo] (
	@psSelectedIDs	varchar(MAX),
	@psSubject		varchar(MAX) OUTPUT,
	@psOrderColumn	varchar(MAX),
	@psOrderOrder	varchar(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE	@sSelectString 	nvarchar(MAX),
			@sOrderSQL		varchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');
	IF len(@psOrderColumn) > 0 SET @psOrderColumn = replace(@psOrderColumn, '''', '''''');
	IF len(@psOrderOrder) > 0 SET @psOrderOrder = replace(@psOrderOrder, '''', '''''');

	SELECT @psSubject = IsNull(SettingValue,'<<Unknown Customer>>') + ' - Event Log' 
	FROM ASRSysSystemSettings 
	WHERE Lower(Section) = 'licence' 
		AND Lower(SettingKey) = 'customer name';

	SET @sSelectString = '';

	/* create SELECT statment string */
	SET @sSelectString = 'SELECT 	A.ID, 
		A.Name, 
		A.DateTime,
		A.EndTime,
		IsNull(A.Duration,-1) AS Duration, 
		A.Username, 
		CASE A.Mode 
			WHEN 1 THEN ''Batch'' 
			ELSE ''Manual'' 
		END AS ''Mode'', 
		CASE A.Status 
			WHEN 0 THEN ''Pending''
		  WHEN 1 THEN ''Cancelled'' 
			WHEN 2 THEN ''Failed'' 
			WHEN 3 THEN ''Successful'' 
			WHEN 4 THEN ''Skipped'' 
			WHEN 5 THEN ''Error''
			ELSE ''Unknown'' 
		END AS Status, 
		CASE A.Type 
			WHEN 0 THEN ''Unknown''
			WHEN 1 THEN ''Cross Tab'' 
			WHEN 2 THEN ''Custom Report'' 
			WHEN 3 THEN ''Data Transfer'' 
			WHEN 4 THEN ''Export'' 
			WHEN 5 THEN ''Global Add'' 
			WHEN 6 THEN ''Global Delete'' 
			WHEN 7 THEN ''Global Update'' 
			WHEN 8 THEN ''Import'' 
			WHEN 9 THEN ''Mail Merge'' 
			WHEN 10 THEN ''Diary Delete'' 
			WHEN 11 THEN ''Diary Rebuild''
			WHEN 12 THEN ''Email Rebuild''
			WHEN 13 THEN ''Standard Report''
			WHEN 14 THEN ''Record Editing''
			WHEN 15 THEN ''System Error''
			WHEN 16 THEN ''Match Report''
			WHEN 17 THEN ''Calendar Report''
			WHEN 18 THEN ''Envelopes & Labels''
			WHEN 19 THEN ''Label Definition''
			WHEN 20 THEN ''Record Profile''
			WHEN 21	THEN ''Succession Planning''
			WHEN 22 THEN ''Career Progression''
			WHEN 25 THEN ''Workflow Rebuild''
			WHEN 35 THEN ''9-Box Grid Report''
			ELSE ''Unknown''  
		END AS Type,
		CASE 
			WHEN A.SuccessCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.SuccessCount)
		END AS SuccessCount,
		CASE
			WHEN A.FailCount IS NULL THEN ''N/A''
			ELSE CONVERT(varchar, A.FailCount)
		END AS FailCount,
		A.BatchName AS BatchName,
		A.BatchJobID AS BatchJobID,
		A.BatchRunID AS BatchRunID,
		B.Notes, 
		B.ID AS ''DetailsID'' ,
		(SELECT count(ID) 
			FROM ASRSysEventLogDetails C 
			WHERE C.EventLogID = A.ID) as ''count''
		FROM ASRSysEventLog A
		LEFT OUTER JOIN ASRSysEventLogDetails B
			ON A.ID = B.EventLogID
		WHERE A.ID IN (' + @psSelectedIDs + ')';

	SET @sOrderSQL = '';
	
	IF @psOrderColumn = 'Type'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Type] 
				WHEN 1 THEN ''Cross Tab''
				WHEN 2 THEN ''Custom Report''
				WHEN 3 THEN ''Data Transfer''
				WHEN 4 THEN ''Export''
				WHEN 5 THEN ''Global Add''
				WHEN 6 THEN ''Global Delete''
				WHEN 7 THEN ''Global Update''
				WHEN 8 THEN ''Import''
				WHEN 9 THEN ''Mail Merge''
				WHEN 10 THEN ''Diary Delete''
				WHEN 11 THEN ''Diary Rebuild''
				WHEN 12 THEN ''Email Rebuild''
				WHEN 13 THEN ''Standard Report''
				WHEN 14 THEN ''Record Editing''
				WHEN 15 THEN ''System Error''
				WHEN 16 THEN ''Match Report''
				WHEN 17 THEN ''Calendar Report''
				WHEN 18 THEN ''Envelopes & Labels''
				WHEN 19 THEN ''Label Definition''
				WHEN 20 THEN ''Record Profile''
				WHEN 21 THEN ''Succession Planning''
				WHEN 22 THEN ''Career Progression''
				WHEN 25 THEN ''Workflow Rebuild''
				WHEN 35 THEN ''9-Box Grid Report''
				ELSE ''Unknown''
			END ';
	END

	IF @psOrderColumn = 'Mode'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Mode] 
				WHEN 1 THEN ''Batch''
				WHEN 0 THEN ''Manual''
				ELSE ''Unknown''
			END ';
	END
	
	IF @psOrderColumn = 'Status'
	BEGIN
		SET @sOrderSQL = 
			' CASE [Status] 
				WHEN 0 THEN ''Pending''
				WHEN 1 THEN ''Cancelled''
				WHEN 2 THEN ''Failed''
				WHEN 3 THEN ''Successful''
				WHEN 4 THEN ''Skipped''
				WHEN 5 THEN ''Error''
				ELSE ''Unknown''
			END ';
	END
	
	IF len(@sOrderSQL) = 0
	BEGIN
		SET @sOrderSQL = @psOrderColumn;
	END
	
	SET @sOrderSQL = @sOrderSQL + ' ' + @psOrderOrder;

	IF LEN(LTRIM(RTRIM(@sOrderSQL))) > 0 
	BEGIN
		SET @sSelectString = @sSelectString + ' ORDER BY ' + @sOrderSQL;
	END

	EXEC sp_executeSQL @sSelectString;
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntGetExpressionDefinition]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition];
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetExpressionDefinition] (
	@piExprID		integer,
	@psAction		varchar(100),
	@psErrMsg		varchar(MAX)	OUTPUT,
	@piTimestamp	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the defintions of each component and expression in the given expression. */
	DECLARE @sExprIDs		varchar(MAX),
		@sComponentIDs		varchar(MAX),
		@sTempExprIDs		varchar(MAX),
		@sTempComponentIDs	varchar(MAX),
		@sCurrentUser		sysname,
		@iCount				integer,
		@sOwner				varchar(255),
		@sAccess			varchar(MAX),
		@iBaseTableID		integer,
		@sBaseTableID		varchar(100),
		@fSysSecMgr			bit,
		@sExecString		nvarchar(MAX);
	
	SET @psErrMsg = '';
	SET @sCurrentUser = SYSTEM_USER;

	/* Check the expressions exists. */
	SELECT @iCount = COUNT(*)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @iCount = 0
	BEGIN
		SET @psErrMsg = 'expression has been deleted by another user.';
		RETURN;
	END

	SELECT @sOwner = userName,
		@sAccess = access,
		@iBaseTableID = tableID,
		@piTimestamp = convert(integer, timestamp)
	FROM ASRSysExpressions
	WHERE exprID = @piExprID;

	IF @sAccess <> 'RW'
	BEGIN
		exec spASRIntSysSecMgr @fSysSecMgr OUTPUT;
	
		IF @fSysSecMgr = 1 SET @sAccess = 'RW';
	END
	
	IF @iBaseTableID IS null 
	BEGIN
		SET @sBaseTableID = '0';
	END
	ELSE
	BEGIN
		SET @sBaseTableID = convert(varchar(100), @iBaseTableID);
	END

	/* Check the current user can view the expression. */
	IF (@sAccess = 'HD') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made hidden by another user.';
		RETURN;
	END

	IF (@psAction <> 'view') AND (@psAction <> 'copy') AND (@sAccess = 'RO') AND (@sOwner <> @sCurrentUser) 
	BEGIN
		SET @psErrMsg = 'expression has been made read only by another user.';
		RETURN;
	END

	SET @sExprIDs = convert(varchar(MAX), @piExprID);
	SET @sComponentIDs = '0';

	/* Get a list of the components and sub-expressions in the given expression. */
	exec sp_ASRIntGetSubExpressionsAndComponents @piExprID, @sTempExprIDs OUTPUT, @sTempComponentIDs OUTPUT;

	IF len(@sTempExprIDs) > 0 SET @sExprIDs = @sExprIDs + ',' + @sTempExprIDs;
	IF len(@sTempComponentIDs) > 0 SET @sComponentIDs = @sComponentIDs + ',' + @sTempComponentIDs;

	SET @sExecString = 'SELECT
		''C'' as [type],
		ASRSysExprComponents.componentID AS [id],
		convert(varchar(100), ASRSysExprComponents.componentID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.exprID)+ char(9) +
		convert(varchar(100), ASRSysExprComponents.type)+ char(9) +
		CASE WHEN ASRSysExprComponents.fieldColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldPassBy IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldPassBy) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionRecord IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionRecord) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionLine IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionLine) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionOrderID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionOrderID) END + char(9) +
		CASE WHEN ASRSysExprComponents.fieldSelectionFilter IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.fieldSelectionFilter) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionID) END + char(9) +
		CASE WHEN ASRSysExprComponents.calculationID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.calculationID) END + char(9) +
		CASE WHEN ASRSysExprComponents.operatorID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.operatorID) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueType) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueCharacter IS null THEN '''' ELSE ASRSysExprComponents.valueCharacter END + char(9) +
		CASE WHEN ASRSysExprComponents.valueNumeric IS null THEN '''' ELSE convert(varchar(100), convert(numeric(38, 2), ASRSysExprComponents.valueNumeric)) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueLogic IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueLogic) END + char(9) +
		CASE WHEN ASRSysExprComponents.valueDate IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.valueDate, 101) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDescription IS null THEN '''' ELSE ASRSysExprComponents.promptDescription END + char(9) +
		CASE WHEN ASRSysExprComponents.promptMask IS null THEN '''' ELSE ASRSysExprComponents.promptMask END + char(9) +
		CASE WHEN ASRSysExprComponents.promptSize IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptSize) END + char(9) +
		CASE WHEN ASRSysExprComponents.promptDecimals IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDecimals) END + char(9) +
		CASE WHEN ASRSysExprComponents.functionReturnType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.functionReturnType) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupTableID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupTableID) END + char(9) +
		CASE WHEN ASRSysExprComponents.lookupColumnID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.lookupColumnID) END + char(9) +
		CASE WHEN ASRSysExprComponents.filterID IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.filterID) END + char(9) +
		CASE WHEN ASRSysExprComponents.expandedNode IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.expandedNode) END + char(9) + 
		CASE WHEN ASRSysExprComponents.promptDateType IS null THEN '''' ELSE convert(varchar(100), ASRSysExprComponents.promptDateType) END + char(9) + 
		CASE 
			WHEN ASRSysExprComponents.type = 1 THEN fldtabs.tablename + 
				CASE 
					WHEN (ASRSysExprComponents.fieldPassBy = 2) OR (ASRSysExprComponents.fieldSelectionRecord <> 5) then '' : '' + fldcols.columnname
					ELSE ''''
				END +
				CASE 
					WHEN ASRSysExprComponents.fieldPassBy = 2 then ''''
					ELSE
						CASE 
							WHEN fldrelations.parentID IS null THEN ''''
							ELSE
								CASE 
									WHEN ASRSysExprComponents.fieldSelectionRecord = 1 THEN '' (first record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 2 THEN '' (last record''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 3 THEN '' (line '' + convert(varchar(100), ASRSysExprComponents.fieldSelectionLine)
									WHEN ASRSysExprComponents.fieldSelectionRecord = 4 THEN '' (total''
									WHEN ASRSysExprComponents.fieldSelectionRecord = 5 THEN '' (record count''
									ELSE '' (''
								END +
								CASE 
									WHEN fldorders.name IS null THEN ''''
									ELSE '', order by '''''' + fldorders.name + ''''''''
								END  +
								CASE 
									WHEN fldfilters.name IS null then ''''
									ELSE '', filter by '''''' + fldfilters.name + ''''''''
								END + 
								'')''
						END
				END
			WHEN ASRSysExprComponents.type = 2 THEN ASRSysFunctions.functionName
			WHEN ASRSysExprComponents.type = 3 THEN calcexprs.name
			WHEN ASRSysExprComponents.type = 5 THEN ASRSysOperators.name
			WHEN ASRSysExprComponents.type = 10 THEN filtexprs.name
			ELSE ''''
		END + char(9) +
		CASE WHEN fldcols.tableID IS null THEN '''' ELSE convert(varchar(100), fldcols.tableID) END + char(9) + 
		CASE WHEN fldorders.name IS null THEN '''' ELSE fldorders.name END + char(9) + 
		CASE WHEN fldfilters.name IS null THEN '''' ELSE fldfilters.name END
		AS [definition]
	FROM ASRSysExprComponents
	LEFT OUTER JOIN ASRSysExpressions calcexprs ON ASRSysExprComponents.calculationID = calcexprs.exprID
	LEFT OUTER JOIN ASRSysExpressions filtexprs ON ASRSysExprcomponents.filterID = filtexprs.exprID
	LEFT OUTER JOIN ASRSysColumns fldcols ON ASRSysExprComponents.FieldColumnID = fldcols.columnID
	LEFT OUTER JOIN ASRSysTables fldtabs ON fldcols.tableID = fldtabs.tableID
	LEFT OUTER JOIN ASRSysFunctions ON ASRSysExprComponents.functionID = asrsysfunctions.functionID 
	LEFT OUTER JOIN ASRSysOperators ON ASRSysExprComponents.operatorID = asrsysoperators.operatorID 
	LEFT OUTER JOIN ASRSysRelations fldrelations ON (ASRSysExprComponents.fieldTableID = fldrelations.childID and fldrelations.parentID = ' + @sBaseTableID + ')
	LEFT OUTER JOIN ASRSysOrders fldorders ON ASRSysExprComponents.fieldSelectionOrderID = fldorders.orderID
	LEFT OUTER JOIN ASRSysExpressions fldfilters ON ASRSysExprComponents.fieldSelectionFilter = fldfilters.exprID	
	WHERE ASRSysExprComponents.componentID IN (' + @sComponentIDs + ')
	UNION
	SELECT 	
		''E'' as [type],
		ASRSysExpressions.exprID AS [id],
		convert(varchar(100), ASRSysExpressions.exprID)+ char(9) +
		ASRSysExpressions.name + char(9) +
		convert(varchar(100), ASRSysExpressions.tableID) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnType) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnSize) + char(9) +
		convert(varchar(100), ASRSysExpressions.returnDecimals) + char(9) +
		convert(varchar(100), ASRSysExpressions.type) + char(9) +
		convert(varchar(100), ASRSysExpressions.parentComponentID) + char(9) +
		ASRSysExpressions.userName + char(9) +
		ASRSysExpressions.access + char(9) +
		CASE WHEN ASRSysExpressions.description IS null THEN '''' ELSE ASRSysExpressions.description END + char(9) +
		convert(varchar(100), convert(integer, ASRSysExpressions.timestamp)) + char(9) + 
		convert(varchar(100), isnull(ASRSysExpressions.viewInColour, 0)) + char(9) +
		convert(varchar(100), isnull(ASRSysExpressions.expandedNode, 0)) AS [definition]
	FROM ASRSysExpressions
	WHERE ASRSysExpressions.exprID IN (' + @sExprIDs + ')
	ORDER BY [id]';
	
	EXECUTE sp_EXecuteSQL @sExecString;
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntCurrentUserAccess]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntCurrentUserAccess];
GO

CREATE PROCEDURE [dbo].[spASRIntCurrentUserAccess] (
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@sRoleName			varchar(255),
		@sActualUserName	sysname,
		@iActualUserGroupID	integer,
		@fEnabled			bit

	SET @sTableName = '';
	SET @psAccess = 'HD';

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iActualUserGroupID OUTPUT;
					
	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 OR @piUtilityType = 35 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @sRoleName + '''';

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntCurrentAccessForRole]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntCurrentAccessForRole];
GO

CREATE PROCEDURE [dbo].[spASRIntCurrentAccessForRole] (
	@psRoleName		sysname,
	@piUtilityType	integer,
	@plngID			integer,
	@psAccess		varchar(2)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@sTableName			sysname,
		@sAccessTableName	sysname,
		@sIDColumnName		sysname,
		@sSQL				nvarchar(MAX),
		@sParamDefinition	nvarchar(500),
		@fEnabled			bit;

	SET @sTableName = '';
	SET @psAccess = 'HD';

	IF @piUtilityType = 0 /* Batch Job */
	BEGIN
		SET @sTableName = 'ASRSysBatchJobName';
		SET @sAccessTableName = 'ASRSysBatchJobAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 17 /* Calendar Report */
	BEGIN
		SET @sTableName = 'ASRSysCalendarReports';
		SET @sAccessTableName = 'ASRSysCalendarReportAccess';
		SET @sIDColumnName = 'ID';
 	END

	IF @piUtilityType = 1 OR @piUtilityType = 35 /* Cross Tab */
	BEGIN
		SET @sTableName = 'ASRSysCrossTab';
		SET @sAccessTableName = 'ASRSysCrossTabAccess';
		SET @sIDColumnName = 'CrossTabID';
 	END
    
	IF @piUtilityType = 2 /* Custom Report */
	BEGIN
		SET @sTableName = 'ASRSysCustomReportsName';
		SET @sAccessTableName = 'ASRSysCustomReportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
    
	IF @piUtilityType = 3 /* Data Transfer */
	BEGIN
		SET @sTableName = 'ASRSysDataTransferName';
		SET @sAccessTableName = 'ASRSysDataTransferAccess';
		SET @sIDColumnName = 'DataTransferID';
 	END
    
	IF @piUtilityType = 4 /* Export */
	BEGIN
		SET @sTableName = 'ASRSysExportName';
		SET @sAccessTableName = 'ASRSysExportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 5) OR (@piUtilityType = 6) OR (@piUtilityType = 7) /* Globals */
	BEGIN
		SET @sTableName = 'ASRSysGlobalFunctions';
		SET @sAccessTableName = 'ASRSysGlobalAccess';
		SET @sIDColumnName = 'functionID';
 	END
    
	IF (@piUtilityType = 8) /* Import */
	BEGIN
		SET @sTableName = 'ASRSysImportName';
		SET @sAccessTableName = 'ASRSysImportAccess';
		SET @sIDColumnName = 'ID';
 	END
    
	IF (@piUtilityType = 9) OR (@piUtilityType = 18) /* Label or Mail Merge */
	BEGIN
		SET @sTableName = 'ASRSysMailMergeName';
		SET @sAccessTableName = 'ASRSysMailMergeAccess';
		SET @sIDColumnName = 'mailMergeID';
 	END
    
	IF (@piUtilityType = 20) /* Record Profile */
	BEGIN
		SET @sTableName = 'ASRSysRecordProfileName';
		SET @sAccessTableName = 'ASRSysRecordProfileAccess';
		SET @sIDColumnName = 'recordProfileID';
 	END
    
	IF (@piUtilityType = 14) OR (@piUtilityType = 23) OR (@piUtilityType = 24) /* Match Report, Succession, Career */
	BEGIN
		SET @sTableName = 'ASRSysMatchReportName';
		SET @sAccessTableName = 'ASRSysMatchReportAccess';
		SET @sIDColumnName = 'matchReportID';
 	END

	IF (@piUtilityType = 25) /* Workflow */
	BEGIN
		SELECT @fEnabled = enabled
		FROM [dbo].[ASRSysWorkflows]
		WHERE ID = @plngID;
		
		IF @fEnabled = 1
		BEGIN
			SET @psAccess = 'RW';
		END
	END

	IF len(@sTableName) > 0
	BEGIN
		SET @sSQL = 'SELECT @sValue = 
					CASE
						WHEN (SELECT count(*)
							FROM ASRSysGroupPermissions
							INNER JOIN ASRSysPermissionItems ON (ASRSysGroupPermissions.itemID  = ASRSysPermissionItems.itemID
								AND (ASRSysPermissionItems.itemKey = ''SYSTEMMANAGER''
								OR ASRSysPermissionItems.itemKey = ''SECURITYMANAGER''))
							INNER JOIN ASRSysPermissionCategories ON (ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
								AND ASRSysPermissionCategories.categoryKey = ''MODULEACCESS'')
							WHERE b.Name = ASRSysGroupPermissions.groupname
								AND ASRSysGroupPermissions.permitted = 1) > 0 THEN ''RW''
						WHEN ' + @sTableName + '.userName = system_user THEN ''RW''
						ELSE
							CASE
								WHEN ' + @sAccessTableName + '.access IS null THEN ''HD''
								ELSE ' + @sAccessTableName + '.access 
							END
						END
					FROM sysusers b
					INNER JOIN sysusers a ON b.uid = a.gid
					LEFT OUTER JOIN ' + @sAccessTableName + ' ON (b.name = ' + @sAccessTableName + '.groupName
						AND ' + @sAccessTableName + '.id = ' + convert(nvarchar(100), @plngID) + ')
					INNER JOIN ' + @sTableName + ' ON ' + @sAccessTableName + '.ID = ' + @sTableName + '.' + @sIDColumnName + '
					WHERE b.Name = ''' + @psRoleName + ''''

		SET @sParamDefinition = N'@sValue varchar(MAX) OUTPUT';
		EXEC sp_executesql @sSQL,  @sParamDefinition, @psAccess OUTPUT;
	END

	IF @psAccess IS null SET @psAccess = 'HD';
END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetExprFunctions]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetExprFunctions];
GO

CREATE PROCEDURE [dbo].[spASRIntGetExprFunctions] (
	@piTableID 		integer,
	@pbAbsenceEnabled	bit
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of tab-delimited runtime function definitions ;
	<function id><tab><function name><tab><function category> */
	DECLARE @iTemp 					integer,
		@iPersonnelTableID		integer,
		@iHierarchyTableID		integer,
		@iPostAllocationTableID	integer,
		@iIdentifyingColumnID	integer,
		@iReportsToColumnID		integer,
		@iLoginColumnID			integer,
		@iSecondLoginColumnID	integer,
		@fIsPostSubOfOK			bit = 0,
		@fIsPostSubOfUserOK		bit = 0,
		@fIsPersSubOfOK			bit = 0,
		@fIsPersSubOfUserOK		bit = 0,
		@fHasPostSubOK			bit = 0,
		@fHasPostSubUserOK		bit = 0,
		@fHasPersSubOK			bit = 0,
		@fHasPersSubUserOK		bit = 0,
		@fPostBased				bit = 0, 
		@sSQLVersion			integer,
		@fBaseTablePersonnelOK	bit = 0;
	
	SELECT @iPersonnelTableID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_PERSONNEL' 
		AND parameterKey = 'Param_TablePersonnel';

	SELECT @iHierarchyTableID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_HIERARCHY' 
		AND parameterKey = 'Param_TableHierarchy';

	SELECT @iIdentifyingColumnID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_HIERARCHY' 
		AND parameterKey = 'Param_FieldIdentifier';

	SELECT @iReportsToColumnID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_HIERARCHY' 
		AND parameterKey = 'Param_FieldReportsTo';

	SELECT @iPostAllocationTableID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_HIERARCHY' 
		AND parameterKey = 'Param_TablePostAllocation';

	SELECT @iLoginColumnID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_PERSONNEL' 
		AND parameterKey = 'Param_FieldsLoginName';

	SELECT @iSecondLoginColumnID = convert(integer, isnull(parameterValue, '0'))
	FROM ASRSysModuleSetup 
	WHERE moduleKey = 'MODULE_PERSONNEL' 
		AND parameterKey = 'Param_FieldsSecondLoginName';

	IF (@iLoginColumnID = 0) AND (@iSecondLoginColumnID > 0)
	BEGIN
		SET @iLoginColumnID = @iSecondLoginColumnID;
		SET @iSecondLoginColumnID = 0;
	END

	IF @iPersonnelTableID <> @iHierarchyTableID SET @fPostBased = 1;
	IF @iPersonnelTableID = @piTableID 
	BEGIN
		IF (@iIdentifyingColumnID > 0) AND
			(@iReportsToColumnID > 0) AND
			((@fPostBased = 0) OR (@iPersonnelTableID > 0)) AND
			((@fPostBased = 0) OR (@iPostAllocationTableID > 0)) 
		BEGIN
			SET @fIsPersSubOfOK = 1;
			SET @fHasPersSubOK = 1;
		END
		IF (@iIdentifyingColumnID > 0) AND
			(@iReportsToColumnID > 0) AND
			(@iPersonnelTableID > 0) AND
			(@iLoginColumnID > 0) AND
			((@fPostBased = 0) OR (@iPostAllocationTableID > 0)) 
		BEGIN
			SET @fIsPersSubOfUserOK = 1;
			SET @fHasPersSubUserOK = 1;
		END
	END
				
	IF @iHierarchyTableID = @piTableID 
	BEGIN
		IF (@iIdentifyingColumnID > 0) AND
			(@iReportsToColumnID > 0) AND
			(@fPostBased = 1)
		BEGIN
			SET @fIsPostSubOfOK = 1;
			SET @fHasPostSubOK = 1;
		END
		IF (@iIdentifyingColumnID > 0) AND
			(@iReportsToColumnID > 0) AND
			(@iPersonnelTableID > 0) AND
			(@iLoginColumnID > 0) AND
			(@fPostBased = 1) AND
			(@iPostAllocationTableID > 0)
		BEGIN
			SET @fIsPostSubOfUserOK = 1;
			SET @fHasPostSubUserOK = 1;
		END
	END
	IF @iPersonnelTableID = @piTableID 
	BEGIN
		SET @fBaseTablePersonnelOK = 1;
	END
	ELSE
	BEGIN
		SELECT @iTemp = COUNT(*)
		FROM ASRSysRelations
		WHERE parentID = @iPersonnelTableID
			AND childID = @piTableID;
		IF @iTemp > 0
		BEGIN
			SET @fBaseTablePersonnelOK = 1;
		END
	END

	SELECT 
		convert(varchar(255), functionID) + char(9) +
		functionName + 
		CASE 
			WHEN len(shortcutKeys) > 0 THEN ' ' + shortcutKeys
			ELSE ''
		END + char(9) +
		category AS [definitionString]
	FROM ASRSysFunctions
	WHERE (runtime = 1 OR UDF = 1)
		AND ((functionID <> 65) OR (@fIsPostSubOfOK = 1))
		AND ((functionID <> 66) OR (@fIsPostSubOfUserOK = 1))
		AND ((functionID <> 67) OR (@fIsPersSubOfOK = 1))
		AND ((functionID <> 68) OR (@fIsPersSubOfUserOK = 1))
		AND ((functionID <> 69) OR (@fHasPostSubOK = 1))
		AND ((functionID <> 70) OR (@fHasPostSubUserOK = 1))
		AND ((functionID <> 71) OR (@fHasPersSubOK = 1))
		AND ((functionID <> 72) OR (@fHasPersSubUserOK = 1))
		AND ((functionID <> 30) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 46) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 47) OR (@fBaseTablePersonnelOK = 1))
		AND ((functionID <> 73) OR ((@fBaseTablePersonnelOK = 1) AND (@pbAbsenceEnabled = 1)));
END
GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[sp_ASRIntValidateTrainingBooking]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[sp_ASRIntValidateTrainingBooking];
GO

CREATE PROCEDURE [dbo].[sp_ASRIntValidateTrainingBooking] (
	@piResultCode		varchar(MAX) OUTPUT,
	@piEmpRecID		integer,
	@piCourseRecID		integer,
	@psBookingStatus	varchar(MAX),
	@piTBRecID		integer,
	@psCourseOverbooked integer OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Perform the Training Booking validation on the given insert/update SQL string.
	Return codes are :
		@piResultCode = '000' - completely valid
		If non-zero then the result code is composed as abc,
		where a is the result of the PRE-REQUISITES check
			b is the result of the AVAILABILITY check
			c is the result of the OVERLAPPED BOOKING check.
		the values of which can be :
			0 if the check PASSED
			1 if the check FAILED and CANNOT be overridden
			2 if the check FAILED but CAN be overridden

	The psCourseOverbooked parameter returns if the course is overbooked
	*/
	DECLARE	@fIncludeProvisionals	bit,
		@sIncludeProvisionals	varchar(MAX),
		@iCount					integer,
		@iResult				integer,
		@iTemp					integer,
		@piResultOverlapping   integer = 0,
		@piResultPrerequisites	integer = 0,
		@piResultUnavailability	integer = 0;

	SET @piResultCode = '';
	SET @psCourseOverbooked = 0;

	IF (@piCourseRecID > 0) AND ((@psBookingStatus = 'B') OR (@psBookingStatus = 'P'))
	BEGIN  
		SELECT @sIncludeProvisionals = parameterValue
		FROM ASRSysModuleSetup
		WHERE moduleKey = 'MODULE_TRAININGBOOKING'
			AND parameterKey = 'Param_CourseIncludeProvisionals'
		IF @sIncludeProvisionals IS NULL SET @sIncludeProvisionals = 'FALSE'
		IF @sIncludeProvisionals = 'FALSE'
		BEGIN
			SET @sIncludeProvisionals = 0
		END
		ELSE
		BEGIN
			SET @sIncludeProvisionals = 1
		END

		/* Only check that the selected course is not fully booked if the new booking is included in the number booked. */
		IF (@fIncludeProvisionals = 1) OR (@psBookingStatus = 'B') 
		BEGIN
			/* Check if the overbooking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverbooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverbooking @piCourseRecID, @piTBRecID, 1, @iResult OUTPUT
				SET @psCourseOverbooked = @iResult -- @iResult = 1 -> Course fully booked (error). @iResult = 2 -> Course fully booked (over-rideable by the user).
			END
		END
      
		IF @piEmpRecID > 0
		BEGIN
			/* Check that the employee has satisfied the pre-requisite criteria for the selected course. */
			/* First check if the pre-requisite table is configured. If not, we do not need to do the pre-req check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_PreReqTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the pre-req stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckPreRequisites')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckPreRequisites @piCourseRecID, @piEmpRecID, @iResult OUTPUT
					SET @piResultPrerequisites = @iResult -- @iResult = 1 -> Pre-requisites not satisfied (error). @iResult = 2 -> Pre-requisites not satisfied (over-rideable by the user). 
				END
			END

			/* Check that the employee is available for the selected course. */
			/* First check if the unavailability table is configured. If not, we do not need to do the unavailability check. */
			SELECT @iTemp = convert(integer, parameterValue)
			FROM ASRSysModuleSetup
			WHERE moduleKey = 'MODULE_TRAININGBOOKING'
				AND parameterKey = 'Param_UnavailTable'
			IF @iTemp IS NULL SET @iTemp = 0

			IF @iTemp > 0 
			BEGIN
				/* Check if the unavailability stored procedure exists. */
				SELECT @iCount = COUNT(*) 
				FROM sysobjects
				WHERE id = object_id('sp_ASR_TBCheckUnavailability')
					AND sysstat & 0xf = 4

				IF @iCount > 0
				BEGIN
					exec sp_ASR_TBCheckUnavailability @piCourseRecID, @piEmpRecID, @iResult OUTPUT
					SET @piResultUnavailability = @iResult -- @iResult = 1 -> Employee unavailable (error). @iResult = 2 -> Employee unavailable (over-rideable by the user).
				END
			END

			/* Check if the overlapped booking stored procedure exists. */
			SELECT @iCount = COUNT(*) 
			FROM sysobjects
			WHERE id = object_id('sp_ASR_TBCheckOverlappedBooking')
				AND sysstat & 0xf = 4

			IF @iCount > 0
			BEGIN
				exec sp_ASR_TBCheckOverlappedBooking @piCourseRecID, @piEmpRecID, @piTBRecID, @iResult OUTPUT
				SET @piResultOverlapping = @iResult -- @iResult = 1 -> Overlapped booking (error). @iResult = 2 -> Overlapped booking (over-rideable by the user). 
			END
		END
		SET @piResultCode = CONVERT(VARCHAR(1), @piResultPrerequisites) + CONVERT(VARCHAR(1), @piResultUnavailability) + CONVERT(VARCHAR(1), @piResultOverlapping)
	END
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetColumnControlValues]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetColumnControlValues];
GO

CREATE PROCEDURE [dbo].[spASRIntGetColumnControlValues]
	@ColumnIDs nvarchar(100)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @sql nvarchar(MAX);

	SET @sql = 'SELECT columnID, Value, sequence FROM ASRSysColumnControlValues WHERE columnID IN (' + @ColumnIDs + ')'
	EXECUTE sp_executeSQL @sql;
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetFindRecords]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetFindRecords];
GO

CREATE PROCEDURE [dbo].[spASRIntGetFindRecords] (
	@pfError 				bit 			OUTPUT, 
	@pfSomeSelectable 		bit 			OUTPUT, 
	@pfSomeNotSelectable 	bit 			OUTPUT, 
	@psRealSource			varchar(255)	OUTPUT,
	@pfInsertGranted		bit				OUTPUT,
	@pfDeleteGranted		bit				OUTPUT,
	@piTableID 				integer, 
	@piViewID 				integer, 
	@piOrderID 				integer, 
	@piParentTableID		integer,
	@piParentRecordID		integer,
	@psFilterDef			varchar(MAX),
	@piRecordsRequired		integer,
	@pfFirstPage			bit				OUTPUT,
	@pfLastPage				bit				OUTPUT,
	@psLocateValue			varchar(MAX),
	@piColumnType			integer			OUTPUT,
	@piColumnSize			integer			OUTPUT,
	@piColumnDecimals		integer			OUTPUT,
	@psAction				varchar(255),
	@piTotalRecCount		integer			OUTPUT,
	@piFirstRecPos			integer			OUTPUT,
	@piCurrentRecCount		integer,
	@psDecimalSeparator		varchar(255),
	@psLocaleDateFormat		varchar(255),
	@RecordID				integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the find records for the current user, given the table/view and order IDs.
		@pfError = 1 if errors occured in getting the find records. Else 0.
		@pfSomeSelectable = 1 if some find columns were selectable. Else 0.
		@pfSomeNotSelectable = 1 if some find columns were NOT selectable. Else 0.
		@piTableID = the ID of the table on which the find is based.
		@piViewID = the ID of the view on which the find is based.
		@piOrderID = the ID of the order we are using.
		@piParentTableID = the ID of the parent table.
		@piParentRecordID = the ID of the associated record in the parent table.
	*/
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iDataType 			integer,
		@iTempAction		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(5),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@iCount				integer,
		@iGetCount			integer,
		@iSize				integer,
		@iDecimals			integer,
		@bUse1000Separator	bit,
		@sActualLoginName	varchar(250),
		@iIndex1			integer,
		@iIndex2			integer,
		@iIndex3			integer,
		@iColumnID			integer,
		@iOperatorID		integer,
		@sValue				varchar(MAX),
		@sFilterSQL			nvarchar(MAX),
		@sTempLocateValue	varchar(MAX),
		@sSubFilterSQL		nvarchar(MAX),
		@bBlankIfZero		bit,
		@sTempFilterString	varchar(MAX),
		@sJoinSQL			nvarchar(max),
		@psOriginalAction		varchar(255),
		@sThousandColumns		varchar(255),
		@sBlankIfZeroColumns	varchar(255),
		@sTableOrViewName varchar(255);

	DECLARE @FindDefinition TABLE(tableID integer, columnID integer, columnName nvarchar(255), tableName nvarchar(255)
									, ascending bit, type varchar(1), datatype integer, controltype integer, size integer, decimals integer, Use1000Separator bit, BlankIfZero bit, Editable bit
									, LookupTableID integer, LookupColumnID integer, LookupFilterColumnID integer, LookupFilterValueID integer, SpinnerMinimum smallint, SpinnerMaximum smallint, SpinnerIncrement smallint
									, DefaultValue varchar(max), Mask varchar(max), DefaultValueExprID int
									)

	DECLARE @OriginalColumns TABLE(columnID integer, columnName nvarchar(255))

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''');
	/* Initialise variables. */
	SET @pfError = 0;
	SET @pfSomeSelectable = 0;
	SET @pfSomeNotSelectable = 0;
	SET @sDESCstring = ' DESC';
	SET @fFirstColumnAsc = 1;
	SET @sFirstColCode = '';
	SET @piColumnSize = 0;
	SET @piColumnDecimals = 0;
	SET @bUse1000Separator = 0;
	SET @bBlankIfZero = 0;
	SET @sThousandColumns = '';
	SET @sTableOrViewName = '';
	SET @sBlankIfZeroColumns = '';

	SET @sRealSource = '';
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @sReverseOrderSQL = '';
	SET @fSelectDenied = 0;
	SET @sExecString = '';
	SET @sFilterSQL = '';
	SET @sTempLocateValue = '';
	
	SET @psOriginalAction = @psAction;
	
	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000;
	SET @psAction = UPPER(@psAction);
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE') AND 
		(@psAction <> 'LOCATEID')
	BEGIN
		SET @psAction = 'MOVEFIRST';
	END
	
	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualLoginName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;
		
	-- Create a temporary view of the sysprotects table
	DECLARE @SysProtects TABLE([ID] int, Columns varbinary(8000)
								, [Action] tinyint
								, ProtectType tinyint);
	INSERT INTO @SysProtects
	SELECT p.[ID], p.[Columns], p.[Action], p.ProtectType FROM ASRSysProtectsCache p WHERE p.UID = @iUserGroupID;
	
	-- Create a temporary table to hold the tables/views that need to be joined.
	DECLARE @JoinParents TABLE(tableViewName sysname, tableID integer);

	-- Create a temporary table of the 'select' column permissions for all tables/views used in the order.
	DECLARE @ColumnPermissions TABLE(tableID integer,
								tableViewName	sysname,
								columnName	sysname,
								selectGranted	bit,
								updateGranted	bit);
								
	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM [dbo].[ASRSysTables]
		WHERE ASRSysTables.tableID = @piTableID;
	
	IF (@sTableName IS NULL) 
	BEGIN 
		SET @pfError = 1;
		RETURN;
	END
	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM [dbo].[ASRSysChildViews2]
		WHERE tableID = @piTableID
			AND role = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END
	SET @psRealSource = @sRealSource;
	
	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	IF len(@psFilterDef)> 0 
	BEGIN
		WHILE charindex('	', @psFilterDef) > 0
		BEGIN
			SET @sSubFilterSQL = '';
			SET @iIndex1 = charindex('	', @psFilterDef);
			SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1);
			SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1);
				
			SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1));
			SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1));
			SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1);
			
			SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3);
			SELECT @iDataType = dataType,
				@sColumnName = columnName
			FROM [dbo].[ASRSysColumns]
			WHERE columnID = @iColumnID;
							
			SET @sColumnName = @sRealSource + '.' + @sColumnName;
			IF (@iDataType = -7) 
			BEGIN
				/* Logic column (must be the equals operator).	*/
				SET @sSubFilterSQL = @sColumnName + ' = ';
			
				IF UPPER(@sValue) = 'TRUE'
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '1';
				END
				ELSE
				BEGIN
					SET @sSubFilterSQL = @sSubFilterSQL + '0';
				END
			END
			
			IF ((@iDataType = 2) OR (@iDataType = 4)) 
			BEGIN
				/* Numeric/Integer column. */
				/* Replace the locale decimal separator with '.' for SQL's benefit. */
				SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.');
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equals. */
					SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
        
				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
				IF (@iOperatorID = 6) 
				BEGIN
					/* Less than.*/
					SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue;
					IF convert(float, @sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
					END
				END
			END
			IF (@iDataType = 11) 
			BEGIN
				/* Date column. */
				IF LEN(@sValue) > 0
				BEGIN
					/* Convert the locale date into the SQL format. */
					/* Note that the locale date has already been validated and formatted to match the locale format. */
					SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat);
					SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat);
					SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat);
						
					SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex3, 4);
				END

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					IF LEN(@sValue) > 0 
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
					END
				END

				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + '''';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
					END
				END
				
				IF (@iOperatorID = 6)
				BEGIN
					/* Less than. */
					IF LEN(@sValue) > 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
				END
			END
			
			IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
			BEGIN
				/* Character/Working Pattern column. */
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + '''';
					END
				END
				
				IF (@iOperatorID = 2) 
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 7)
				BEGIN
					/* Contains */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%''';
					END
				END
				
				IF (@iOperatorID = 8) 
				BEGIN
					/* Does Not Contain. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%''';
					END
				END
			END
			
			IF LEN(@sSubFilterSQL) > 0
			BEGIN
				/* Add the filter code for this grid record into the complete filter code. */
				IF LEN(@sFilterSQL) > 0
				BEGIN
					SET @sFilterSQL = @sFilterSQL + ' AND (';
				END
				ELSE
				BEGIN
					SET @sFilterSQL = @sFilterSQL + '(';
				END
				SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')';
			END
		END
	END
	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT ASRSysColumns.tableID
		FROM [dbo].[ASRSysOrderItems]
		INNER JOIN ASRSysColumns ON ASRSysOrderItems.columnID = ASRSysColumns.columnID
		WHERE ASRSysOrderItems.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				MAX(CASE WHEN [protectType] IN (204, 205) AND [action] = 193 THEN 1	ELSE 0 END) AS selectGranted,
				MAX(CASE WHEN [protectType] IN (204, 205) AND [action] = 197 THEN 1	ELSE 0 END) AS updateGranted
			FROM @sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.action IN (193, 197)
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			GROUP BY syscolumns.name,[protectType];
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				MAX(CASE WHEN [protectType] IN (204, 205) AND [action] = 193 THEN 1	ELSE 0 END) AS selectGranted,
				MAX(CASE WHEN [protectType] IN (204, 205) AND [action] = 197 THEN 1	ELSE 0 END) AS updateGranted
			FROM @sysprotects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE p.action IN (193, 197)
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			GROUP BY sysobjects.name, syscolumns.name,[protectType];

		END
		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	INSERT @FindDefinition
		SELECT c.tableID,
			o.columnID, 
			c.columnName,
	    	t.tableName,
			o.ascending,
			o.type,
			c.dataType,
			c.controltype,
			c.size,
			c.decimals,
			c.Use1000Separator,
			c.BlankIfZero,
			CASE WHEN ISNULL(o.Editable, 0) = 0 OR ISNULL(c.readonly, 1) = 1 THEN 0 ELSE 1 END,
			ISNULL(c.LookupTableID, 0) AS LookupTableID,
			ISNULL(c.LookupColumnID, 0) AS LookupColumnID,
			ISNULL(c.LookupFilterColumnID, 0) AS LookupFilterColumnID,
			ISNULL(c.LookupFilterValueID, 0) AS LookupFilterValueID,
			c.SpinnerMinimum,
			c.SpinnerMaximum,
			c.SpinnerIncrement,
			c.defaultvalue AS DefaultValue,
			c.Mask,
			c.dfltvalueexprid as DefaultValueExprID
		FROM [dbo].[ASRSysOrderItems] o
		INNER JOIN ASRSysColumns c ON o.columnID = c.columnID
		INNER JOIN ASRSysTables t ON c.tableID = t.tableID
		WHERE o.orderID = @piOrderID
		ORDER BY o.sequence;

	
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableID, columnID, columnName, tableName, ascending, type, datatype, size, decimals, Use1000Separator, BlankIfZero FROM @FindDefinition;


	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iSize, @iDecimals, @bUse1000Separator, @bBlankIfZero;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END
	WHILE (@@fetch_status = 0)
	BEGIN

		SET @fSelectGranted = 0;
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName;
				
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					IF @iDataType = -4 OR @iDataType = -3
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						'RTRIM(SUBSTRING(CONVERT(VARCHAR(max),' + @sRealSource + '.' + @sColumnName + '), 11, 69)) AS [' + @sColumnName + ']';
					END
					ELSE
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName;

					END

					SET @sSelectSQL = @sSelectSQL + @sTempString;
					INSERT INTO @OriginalColumns VALUES(@iColumnID, @sColumnName)
					SET @sThousandColumns = @sThousandColumns + convert(varchar(1),@bUse1000Separator);
					SET @sBlankIfZeroColumns = @sBlankIfZeroColumns + convert(varchar(1),@bBlankIfZero);
					
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @piColumnSize = @iSize;
						SET @piColumnDecimals = @iDecimals;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName;
						IF (@psAction = 'LOCATEID')
						BEGIN
							IF @piColumnType = 11 /* Date column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = isnull(convert(varchar(MAX), ' + @sRealSource + '.' + @sColumnName + ', 101), '''')';
							END
							ELSE
							IF @piColumnType = -7 /* Logic column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = convert(varchar(MAX), isnull(' + @sRealSource + '.' + @sColumnName + ', 0))';
							END
							ELSE IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = convert(varchar(MAX), isnull(' + @sRealSource + '.' + @sColumnName + ', 0))';
							END
							ELSE
							BEGIN
								SET @sTempExecString = 'SELECT @sTempLocateValue = replace(isnull(' + @sRealSource + '.' + @sColumnName + ', ''''), '''''''', '''''''''''')' ;
							END
							
							SET @sTempExecString = @sTempExecString
								+ ' FROM ' + @sRealSource
								+ ' WHERE ' + @sRealSource + '.ID = ' + @psLocateValue;
							SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
							EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
						END
					END
					
					SET @sOrderSQL = @sOrderSQL + CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1;
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName;
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					IF @iDataType = -4 OR @iDataType = -3
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						'RTRIM(SUBSTRING(CONVERT(VARCHAR(max),' + @sRealSource + '.' + @sColumnName + '), 11, 69)) AS [' + @sColumnName + ']';						
					END
					ELSE
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + @sColumnTableName + '.' + @sColumnName;
					END

					SET @sSelectSQL = @sSelectSQL + @sTempString;
					INSERT INTO @OriginalColumns VALUES(@iColumnID, @sColumnName)
					
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @piColumnSize = @iSize;
						SET @piColumnDecimals = @iDecimals;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName;
						IF (@psAction = 'LOCATEID')
						BEGIN
							SET @sTempLocateValue = '';
						END
					END
					SET @sOrderSQL = @sOrderSQL + CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;
				END
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @JoinParents
				WHERE tableViewName = @sColumnTableName;
				
				IF @iTempCount = 0
				BEGIN
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = '';
				
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
					SELECT tableViewName
					FROM @ColumnPermissions
					WHERE tableID = @iColumnTableId
						AND tableViewName <> @sColumnTableName
						AND columnName = @sColumnName
						AND selectGranted = 1;
						
				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE';
					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewname = @sViewName;
					
					IF @iTempCount = 0
					BEGIN
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId);
					END
					FETCH NEXT FROM viewCursor INTO @sViewName;
				END

				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +	' ELSE NULL END';
					IF @sType = 'F'
					BEGIN
					/* Find column. */
					IF @iDataType = -4 OR @iDataType = -3
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						'RTRIM(SUBSTRING(CONVERT(VARCHAR(max),' + @sRealSource + '.' + @sColumnName + '), 11, 69)) AS [' + @sColumnName + ']';						
					END
					ELSE
					BEGIN
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END;
					END
					
					SET @sSelectSQL = @sSelectSQL + @sTempString;
						
					SET @sTempString = ' AS [' + @sColumnName + ']';
					SET @sSelectSQL = @sSelectSQL + @sTempString;
					INSERT INTO @OriginalColumns VALUES(@iColumnID, @sColumnName)
						
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType;
							SET @piColumnSize = @iSize;
							SET @piColumnDecimals = @iDecimals;
							SET @fFirstColumnAsc = @fAscending;
							SET @sFirstColCode = @sSubString;
							IF (@psAction = 'LOCATEID')
							BEGIN
								SET @sTempLocateValue = '';
							END
						END
						SET @sOrderSQL = @sOrderSQL + CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END;
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1;
				END	
			END
		END
		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iSize, @iDecimals, @bUse1000Separator, @bBlankIfZero;
	END

	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	IF @psAction = 'LOCATEID'
	BEGIN
		SET @psAction = 'LOCATE';
		SET @psLocateValue = @sTempLocateValue;
	END
	
	/* Set the flags that show if no order columns could be selected, or if only some of them could be selected. */
	SET @pfSomeSelectable = CASE WHEN (len(@sSelectSQL) > 0) THEN 1 ELSE 0 END;
	SET @pfSomeNotSelectable = @fSelectDenied;

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID';

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL;
		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL);
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', ';
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', ';
			END
			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1);
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex);
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring;
	END
	
	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;
	IF @piParentTableID > 0 
	BEGIN
		SET @sTempExecString = @sTempExecString + 
			' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
		IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' AND ' + @sFilterSQL;
	END
	ELSE
	BEGIN
		IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;
	END
	
	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;

	SET @piTotalRecCount = @iCount;
	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID, CONVERT(int, ' + @sRealSource + '.Timestamp) AS [Timestamp]';
		SET @sSelectSQL = @sSelectSQL + @sTempString;
		INSERT INTO @OriginalColumns VALUES(0, 'ID') -- We don't need the ID
		INSERT INTO @OriginalColumns VALUES(0, 'Timestamp') -- We don't need the ID

		SET @sExecString = 'SELECT ' 
		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
			SET @sExecString = @sExecString + @sTempString;
		END
	
		SET @sTempString = @sSelectSQL + ' FROM ' + @sRealSource;
		SET @sExecString = @sExecString + @sTempString;

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @JoinParents;
		
		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		
		CLOSE joinCursor;
		DEALLOCATE joinCursor;
		
		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'MOVENEXT') 
		BEGIN
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END
		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1;
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString;

		END
		/* Add the filter code. */
		IF @piParentTableID > 0 
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
			SET @sExecString = @sExecString + @sTempString;
				
			IF len(@sFilterSQL) > 0
			BEGIN
				SET @sTempString = ' AND ' + @sFilterSQL;
				SET @sExecString = @sExecString + @sTempString;
			END
		END
		ELSE
		BEGIN
			IF len(@sFilterSQL) > 0
			BEGIN
				SET @sTempString = ' WHERE ' + @sFilterSQL;
				SET @sExecString = @sExecString + @sTempString;
			END
		END
		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END
		IF (@psAction = 'LOCATE')
		BEGIN
			SET @sLocateCode = '';
			IF (@piParentTableID > 0) OR (len(@sFilterSQL) > 0) 
			BEGIN
				SET @sLocateCode = @sLocateCode + ' AND (' + @sFirstColCode;
			END
			ELSE
			BEGIN
				SET @sLocateCode = @sLocateCode + ' WHERE (' + @sFirstColCode;
			END;
			
			SET @sJoinSQL = '';
			DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT tableViewName, 
				tableID
			FROM @JoinParents;
			OPEN joinCursor;
			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @sJoinSQL = @sJoinSQL + 
					' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
				FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
			END;
			
			CLOSE joinCursor;
			DEALLOCATE joinCursor;

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = replace(isnull(' + @sFirstColCode + ', ''''), '''''''', '''''''''''')' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL						
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ''' + @sTempLocateValue + '''';
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL';
						
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' <= ''' + @sTempLocateValue + '''';
					END;
				END
			END
			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = isnull(convert(varchar(MAX),' + @sFirstColCode + ', 101), '''')' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL						
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						IF len(@sTempLocateValue) > 0
						BEGIN
							SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ''' + @sTempLocateValue + '''';
						END
					END;
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						IF len(@sTempLocateValue) > 0
						BEGIN
							SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ''' + @sTempLocateValue + '''';
						END
					END;
				END
			END
			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = convert(varchar(MAX), isnull(' + @sFirstColCode + ', 0))' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL	
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL	;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;
				
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ' + 
							CASE
								WHEN @sTempLocateValue = 'True' THEN '1'
								ELSE '0'
							END;
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ' + 
							CASE
								WHEN @sTempLocateValue = 'True' THEN '1'
								ELSE '0'
							END;
					END;
				END
			END
			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @psOriginalAction = 'LOCATEID'	
				BEGIN
					SET @sTempExecString = 'SELECT TOP 1 @sTempLocateValue = convert(varchar(MAX), isnull(' + @sFirstColCode + ', 0))' 
						+ ' FROM ' + @sRealSource
						+ @sJoinSQL	
						+ ' WHERE ' + @sRealSource + '.ID IN (' 
						+ '     SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID'
						+ '     FROM ' + @sRealSource
						+ @sJoinSQL;

					SET @sTempFilterString = '';
					IF @piParentTableID > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);						
					IF LEN(@sFilterSQL) > 0
					BEGIN
						IF LEN(@sTempFilterString) > 0
							SET @sTempFilterString = @sTempFilterString + ' AND ' + @sFilterSQL	;
						ELSE
							SET @sTempFilterString = @sTempFilterString + ' WHERE ' + @sFilterSQL	;

						SET @sTempExecString = @sTempExecString + @sTempFilterString;
					END;
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sReverseOrderSQL + ')';
					SET @sTempExecString = @sTempExecString +  ' ORDER BY ' + @sOrderSQL ;

					SET @sTempParamDefinition = N'@sTempLocateValue varchar(MAX) OUTPUT';
					EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sTempLocateValue OUTPUT;
				END;

				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue;
					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
					
					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' > ' + @sTempLocateValue;
					END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL';

					IF @psOriginalAction = 'LOCATEID'	
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' < ' + @sTempLocateValue ;
					END;
				END
			END
			SET @sLocateCode = @sLocateCode + ')';
			SET @sTempString = @sLocateCode;
			SET @sExecString = @sExecString + @sTempString;
		END

		/* Add the ORDER BY code to the find record selection string if required. */
		IF (@RecordID = -1) BEGIN --Return all records
			SET @sTempString = ' ORDER BY ' + @sOrderSQL;
		END ELSE BEGIN --Return only the requested record
			IF charindex(' WHERE ', @sExecString) > 0 BEGIN --A WHERE clause may have been added for the filtering of records
				SET @sTempString = ' AND '
			END ELSE BEGIN
				SET @sTempString = ' WHERE '
			END

			SET @sTempString = @sTempString + @sRealSource + '.ID = ' + CONVERT(varchar(100), @RecordID) + ' ORDER BY ' + @sOrderSQL;
		END

		SET @sExecString = @sExecString + @sTempString;
				
	END

	/* Check if the user has insert or delete permission on the table. */
	SET @pfInsertGranted = 0;
	SET @pfDeleteGranted = 0;
	IF LEN(@sRealSource) > 0
	BEGIN
		DECLARE tableInfo_cursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT p.action
		FROM @sysprotects p
		INNER JOIN sysobjects ON p.id = sysobjects.id
		WHERE p.protectType <> 206
			AND ((p.action = 195) OR (p.action = 196))
			AND sysobjects.name = @sRealSource;
			
		OPEN tableInfo_cursor;
		FETCH NEXT FROM tableInfo_cursor INTO @iTempAction;
		WHILE (@@fetch_status = 0)
		BEGIN
			IF @iTempAction = 195
			BEGIN
				SET @pfInsertGranted = 1;
			END
			ELSE
			BEGIN
				SET @pfDeleteGranted = 1;
			END
			FETCH NEXT FROM tableInfo_cursor INTO @iTempAction;
		END
		
		CLOSE tableInfo_cursor;
		DEALLOCATE tableInfo_cursor;
		
	END
	
	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1;
		SET @pfFirstPage = 1;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
		SET @pfFirstPage = 0;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 1;
	END
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @JoinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		
		CLOSE joinCursor;
		DEALLOCATE joinCursor;
		
		IF @piParentTableID > 0 
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' WHERE ' + @sRealSource + '.ID_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
			IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' AND ' + @sFilterSQL;
		END
		ELSE
		BEGIN
			IF len(@sFilterSQL) > 0	SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL;
		END
		
		SET @sTempExecString = @sTempExecString + @sLocateCode;
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT;
		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1;
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1;
		END
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	
	-- Return a recordset of the required columns in the required order from the given table/view.
	IF (@pfSomeSelectable = 1)
	BEGIN
		IF @piViewID <>0 BEGIN
			SELECT @sTableOrViewName = ViewName FROM tbsys_views WHERE ViewID = @piViewID
		END ELSE IF @piTableID <> 0 BEGIN
			SELECT @sTableOrViewName = TableName FROM tbsys_tables WHERE TableID = @piTableID
		END

		SELECT @sBlankIfZeroColumns AS BlankIfZeroColumns
			, @sThousandColumns AS ThousandColumns, @sTableOrViewName AS TableOrViewName

		EXECUTE sp_executeSQL @sExecString;

		SELECT f.tableID, f.columnID, f.columnName, f.ascending, f.type, f.datatype, f.controltype, f.size, f.decimals, f.Use1000Separator, f.BlankIfZero
			 , CASE WHEN f.Editable = 1 AND p.updateGranted = 1 THEN 1 ELSE 0 END AS updateGranted
			 , LookupTableID, LookupColumnID, LookupFilterColumnID, LookupFilterValueID
			 ,SpinnerMinimum, SpinnerMaximum, SpinnerIncrement, DefaultValue, Mask, DefaultValueExprID
			FROM @FindDefinition f
				INNER JOIN @ColumnPermissions p ON p.columnName = f.columnName
			WHERE f.[type] = 'F';

		SELECT columnID, columnName FROM @OriginalColumns ORDER BY columnName
	END

END


GO


IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntShowOutOfOfficeHyperlink]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntShowOutOfOfficeHyperlink];
GO

CREATE PROCEDURE [dbo].[spASRIntShowOutOfOfficeHyperlink]	
	(
		@piTableID		integer,
		@piViewID		integer,
		@pfDisplayHyperlink	bit 	OUTPUT
	)
	AS
	BEGIN

		SET NOCOUNT ON;

		SELECT @pfDisplayHyperlink = WFOutOfOffice
			FROM ASRSysSSIViews
			WHERE (TableID = @piTableID) 
				AND (ViewID = @piViewID);

		SELECT @pfDisplayHyperlink = ISNULL(@pfDisplayHyperlink, 0);

	END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntTrackSession]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntTrackSession];
GO

CREATE PROCEDURE dbo.[spASRIntTrackSession](
	@IISServer nvarchar(255),
	@SessionID nvarchar(255),
	@UserName nvarchar(255),
	@SecurityGroup varchar(255),
	@HostName varchar(255),
	@WebArea varchar(20),
	@TrackType tinyint)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @LoginTime	datetime = GETDATE();

	-- Current user tracking
	MERGE INTO ASRSysCurrentSessions AS Target 
	USING (VALUES 
		(@IISServer, @SessionID, @UserName, @HostName, @WebArea) 
	) AS Source (IISServer, SessionID, Username, HostName, WebArea) 
		ON Target.SessionID = Source.SessionID
	WHEN MATCHED AND @TrackType = 1 THEN 
		UPDATE SET webArea = @WebArea, Username = @UserName, HostName = @HostName, IISServer = @IISServer
	WHEN MATCHED AND @TrackType IN (2, 3, 4, 5, 6, 8) THEN
		DELETE
	WHEN NOT MATCHED BY TARGET AND @TrackType = 1 THEN 
		INSERT (IISServer, SessionID, Username, HostName, WebArea)
		VALUES (@IISServer, @SessionID, @UserName, @HostName, @WebArea);

	-- Track in audit log
	IF @TrackType <> 5
		INSERT INTO [dbo].[ASRSysAuditAccess]	(DateTimeStamp, UserGroup, UserName, ComputerName, HRProModule, Action) 
			VALUES (@LoginTime, @SecurityGroup, @UserName, @HostName, @WebArea
				, CASE @TrackType
					WHEN 1 THEN 'Log In'
					WHEN 2 THEN 'Log Out'
					WHEN 3 THEN 'Forced Log Out'
					WHEN 8 THEN 'Insufficient Licence'
					ELSE 'Session Timeout'
				END);

END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetSetting]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetSetting];
GO

CREATE PROCEDURE [dbo].[spASRIntGetSetting] (
	@psSection		varchar(MAX),
	@psKey			varchar(MAX),
	@psDefault		varchar(MAX),
	@pfUserSetting	bit,
	@psResult		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return the required user or system setting. */
	DECLARE	@iCount	integer;

	IF @pfUserSetting = 1
	BEGIN
		SELECT @iCount = COUNT(userName)
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER
			AND section = @psSection		
			AND settingKey = @psKey;

		SELECT @psResult = settingValue 
		FROM ASRSysUserSettings
		WHERE userName = SYSTEM_USER
			AND section = @psSection		
			AND settingKey = @psKey;
	END
	ELSE
	BEGIN
		SELECT @iCount = COUNT(settingKey)
		FROM ASRSysSystemSettings
		WHERE section = @psSection		
			AND settingKey = @psKey;

		SELECT @psResult = settingValue 
		FROM ASRSysSystemSettings
		WHERE section = @psSection		
			AND settingKey = @psKey;
	END

	IF @iCount = 0
	BEGIN
		SET @psResult = @psDefault;	
	END
END
GO

IF EXISTS (SELECT *	FROM dbo.sysobjects	WHERE id = object_id(N'[dbo].[spASRIntGetStandardReportDates]') AND xtype in (N'P'))
	DROP PROCEDURE [dbo].[spASRIntGetStandardReportDates];
GO

CREATE PROCEDURE [dbo].[spASRIntGetStandardReportDates] (
	@piReportType 		integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the prompted values for the given utililty. */
	DECLARE	@sComponents			varchar(MAX),
			@vDateID				varchar(100),
			@iStartDateID			integer,
			@iEndDateID				integer,
			@iStartDateComponentID	integer,
			@iEndDateComponentID	integer;

	/* Create a temp table to hold the propmted value details. */
	DECLARE @promptedValues TABLE(
		componentID			integer,
		promptDescription	varchar(255),
		valueType			integer,
		promptMask			varchar(255),
		promptSize			integer,
		promptDecimals		integer,
		valueCharacter		varchar(255),
		valueNumeric		float,
		valueLogic			bit,
		valueDate			datetime,
		promptDateType		integer, 
		fieldColumnID		integer,
		StartEndType		varchar(5)
	)

	-- Absence Breakdown	
	IF @piReportType = 15
	BEGIN
		EXEC dbo.spASRIntGetSetting 'AbsenceBreakdown', 'Start Date', 0, 0, @vDateID OUTPUT;
		SET @iStartDateID = convert(integer,@vDateID);

		EXEC dbo.spASRIntGetSetting 'AbsenceBreakdown', 'End Date', 0, 0, @vDateID OUTPUT;
		SET @iEndDateID = convert(integer,@vDateID);
	END

	-- Bradford Factor
	IF @piReportType = 16
	BEGIN
		EXEC dbo.spASRIntGetSetting 'BradfordFactor', 'Start Date', 0, 0, @vDateID OUTPUT;
		SET @iStartDateID = convert(integer,@vDateID);

		EXEC dbo.spASRIntGetSetting 'BradfordFactor', 'End Date', 0, 0, @vDateID OUTPUT;
		SET @iEndDateID = convert(integer,@vDateID);
	END

	/* Start Date prompted value. */		
	IF @iStartDateID > 0
	BEGIN
		EXEC sp_ASRIntGetFilterPromptedValues @iStartDateID, @sComponents OUTPUT
		SET @iStartDateComponentID = @sComponents

		INSERT INTO @promptedValues
			(componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID,StartEndType)
		(SELECT componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID,'start'
			FROM ASRSysExprComponents
			WHERE componentID = @iStartDateComponentID)
	END

	/* End Date prompted value. */
	IF @iEndDateID > 0
	BEGIN
		EXEC sp_ASRIntGetFilterPromptedValues @iEndDateID, @sComponents OUTPUT
		SET @iEndDateComponentID = @sComponents

		INSERT INTO @promptedValues
			(componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID,StartEndType)
		(SELECT componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID,'end'
			FROM ASRSysExprComponents
			WHERE componentID = @iEndDateComponentID)
	END


	SELECT DISTINCT * 
	FROM @promptedValues
	ORDER BY startEndType DESC;
	
END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetUtilityPromptedValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetUtilityPromptedValues]
GO

CREATE PROCEDURE [dbo].[spASRIntGetUtilityPromptedValues] (
	@piUtilType 	integer,
	@piUtilID 		integer,
	@piRecordID 	integer
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the prompted values for the given utililty. */
	DECLARE	@iBaseFilter		integer,
			@iParent1Filter		integer,
			@iParent2Filter		integer,
			@iChildFilter		integer,
			@iEventFilter		integer,
			@iStartDateCalc		integer,
			@iEndDateCalc		integer,
			@iDescCalc			integer,
			@iLoop				integer,
			@iFilterID			integer,
			@iCalcID			integer,
			@iComponentID		integer,
			@sComponents		varchar(MAX),
			@sAllComponents		varchar(MAX),
			@iIndex				integer;
	
	SET @sAllComponents = '';

	IF @piRecordID IS null SET @piRecordID = 0;

	/* Create a temp table to hold the propmted value details. */
	DECLARE @promptedValues TABLE(
		componentID			integer,
		promptDescription	varchar(255),
		valueType			integer,
		promptMask			varchar(255),
		promptSize			integer,
		promptDecimals		integer,
		valueCharacter		varchar(255),
		valueNumeric		float,
		valueLogic			bit,
		valueDate			datetime,
		promptDateType		integer, 
		fieldColumnID		integer);


	IF @piUtilType = 1 OR @piUtilType = 35
	BEGIN
		/* Cross Tabs. */
		SELECT @iFilterID = filterid
		FROM ASRSysCrossTab
		WHERE CrossTabID = @piUtilID

		IF (NOT @iFilterID IS NULL) AND (@iFilterID > 0)
		BEGIN
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFilterID, @sAllComponents OUTPUT
		END		
	END

	IF @piUtilType = 11
	BEGIN
		IF (NOT @piUtilID IS NULL) AND (@piUtilID > 0)
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @piUtilID, @sAllComponents OUTPUT;
	END

	IF @piUtilType = 15 OR @piUtilType = 16
	BEGIN
		/* Standard report (Absence Calendar or Bradford Factor) */
		IF (NOT @piUtilID IS NULL) AND (@piUtilID > 0)
		BEGIN
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @piUtilID, @sAllComponents OUTPUT
		END		
	END



	IF @piUtilType = 2 OR @piUtilType = 9
	BEGIN

		IF @piUtilType = 2
		BEGIN
			/* Custom Reports. */

			/* Get the IDs of the filters used in the report. */
			SELECT @iBaseFilter = filter, 
				@iParent1Filter = parent1Filter, 
				@iParent2Filter = parent2Filter /*, 
				@iChildFilter = childFilter*/
			FROM [dbo].[ASRSysCustomReportsName]
			WHERE ID = @piUtilID

			IF @piRecordID <> 0
			BEGIN
				SET @iBaseFilter = 0
			END
			
			/* Get the prompted values used in the Base and Parent table filters. */
			SET @iLoop = 0
			WHILE @iLoop < 3
			BEGIN
				IF @iLoop = 0 SET @iFilterID = @iBaseFilter
				IF @iLoop = 1 SET @iFilterID = @iParent1Filter
				IF @iLoop = 2 SET @iFilterID = @iParent2Filter
				--IF @iLoop = 3 SET @iFilterID = @iChildFilter

				IF (NOT @iFilterID IS NULL) AND (@iFilterID > 0)
				BEGIN
					EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFilterID, @sComponents OUTPUT

					IF LEN(@sComponents) > 0
					BEGIN
						SET @sAllComponents = @sAllComponents + 
							CASE
								WHEN LEN(@sAllComponents) > 0 THEN ','
								ELSE ''
							END + 
							@sComponents
					END
				END

				SET @iLoop = @iLoop + 1
			END		

			/* Get the promted values used in the Child table filters. */
			DECLARE childs_cursor CURSOR LOCAL FAST_FORWARD FOR
				
			SELECT childFilter
			FROM [dbo].[ASRSysCustomReportsChildDetails]
			WHERE CustomReportID = @piUtilID

			OPEN childs_cursor
			FETCH NEXT FROM childs_cursor INTO @iChildFilter
			WHILE (@@fetch_status = 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iChildFilter, @sComponents OUTPUT
		
				IF LEN(@sComponents) > 0
				BEGIN
					SET @sAllComponents = @sAllComponents + 
						CASE
							WHEN LEN(@sAllComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents
				END
				FETCH NEXT FROM childs_cursor INTO @iChildFilter
			END
			CLOSE childs_cursor
			DEALLOCATE childs_cursor


			/* Get the prompted values used in the runtime calcs in the report. */
			DECLARE calcs_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT colExprID 
				FROM [dbo].[ASRSysCustomReportsDetails]
				WHERE customReportID = @piUtilID
					AND type = 'E'

		END

		IF @piUtilType = 9
		BEGIN
			/* Mail Merge. */

			/* Get the IDs of the filters used in the report. */
			SELECT @iFilterID = filterID
			FROM [dbo].[ASRSysMailMergeName]
			WHERE MailMergeID = @piUtilID

			IF @piRecordID <> 0
			BEGIN
				SET @iFilterID = 0
			END

			IF (NOT @iFilterID IS NULL) AND (@iFilterID > 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFilterID, @sAllComponents OUTPUT
			END		

			/* Get the prompted values used in the runtime calcs in the report. */
			DECLARE calcs_cursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT ColumnID 
				FROM [dbo].[ASRSysMailMergeColumns]
				WHERE MailMergeID = @piUtilID
					AND type = 'E'
		END


		OPEN calcs_cursor
		FETCH NEXT FROM calcs_cursor INTO @iCalcID
		WHILE (@@fetch_status = 0)
		BEGIN
			EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iCalcID, @sComponents OUTPUT
		
			IF LEN(@sComponents) > 0
			BEGIN
				SET @sAllComponents = @sAllComponents + 
					CASE
						WHEN LEN(@sAllComponents) > 0 THEN ','
						ELSE ''
					END + 
					@sComponents
			END
			FETCH NEXT FROM calcs_cursor INTO @iCalcID
		END
		CLOSE calcs_cursor
		DEALLOCATE calcs_cursor
	END

	IF @piUtilType = 17
		BEGIN
			/* Calendar Reports. */

			/* Get the IDs of the filters used in the report. */
			SELECT @iBaseFilter = filter, 
						 @iStartDateCalc = StartDateExpr, 
			 			 @iEndDateCalc = EndDateExpr,
						 @iDescCalc = DescriptionExpr
			FROM ASRSysCalendarReports
			WHERE ID = @piUtilID
				
			IF @piRecordID = 0
			BEGIN
				/* Get the prompted values used in the Base table filter. */
				SET @iFilterID = @iBaseFilter

				IF (NOT @iFilterID IS NULL) AND (@iFilterID > 0)
				BEGIN
					EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iFilterID, @sComponents OUTPUT

					IF LEN(@sComponents) > 0
					BEGIN
						SET @sAllComponents = @sAllComponents + 
							CASE
								WHEN LEN(@sAllComponents) > 0 THEN ','
								ELSE ''
							END + 
							@sComponents
					END
				END
			END
			
			/* Get the prompted values used in the Report Start Date Calculation. */
			SET @iCalcID = @iStartDateCalc

			IF (NOT @iCalcID IS NULL) AND (@iCalcID > 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iCalcID, @sComponents OUTPUT

				IF LEN(@sComponents) > 0
				BEGIN
					SET @sAllComponents = @sAllComponents + 
						CASE
							WHEN LEN(@sAllComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents
				END
			END		

			/* Get the prompted values used in the Report End Date Calculation. */
			SET @iCalcID = @iEndDateCalc

			IF (NOT @iCalcID IS NULL) AND (@iCalcID > 0)
			BEGIN
				EXEC [dbo].[sp_ASRIntGetFilterPromptedValues] @iCalcID, @sComponents OUTPUT

				IF LEN(@sComponents) > 0
				BEGIN
					SET @sAllComponents = @sAllComponents + 
						CASE
							WHEN LEN(@sAllComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents
				END
			END		

			/* Get the prompted values used in the Report Description Calculation. */
			SET @iCalcID = @iDescCalc

			IF (NOT @iCalcID IS NULL) AND (@iCalcID > 0)
			BEGIN
				EXEC sp_ASRIntGetFilterPromptedValues @iCalcID, @sComponents OUTPUT

				IF LEN(@sComponents) > 0
				BEGIN
					SET @sAllComponents = @sAllComponents + 
						CASE
							WHEN LEN(@sAllComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents
				END
			END		

			/* Get the promted values used in the Event table filters. */
			DECLARE events_cursor CURSOR LOCAL FAST_FORWARD FOR
				
			SELECT FilterID
			FROM ASRSysCalendarReportEvents
			WHERE CalendarReportID = @piUtilID

			OPEN events_cursor
			FETCH NEXT FROM events_cursor INTO @iEventFilter
			WHILE (@@fetch_status = 0)
			BEGIN
				EXEC sp_ASRIntGetFilterPromptedValues @iEventFilter, @sComponents OUTPUT
		
				IF LEN(@sComponents) > 0
				BEGIN
					SET @sAllComponents = @sAllComponents + 
						CASE
							WHEN LEN(@sAllComponents) > 0 THEN ','
							ELSE ''
						END + 
						@sComponents
				END
				FETCH NEXT FROM events_cursor INTO @iEventFilter
			END
			CLOSE events_cursor
			DEALLOCATE events_cursor
			
	END
		
		
	/* We now have a string of all of the prompted value components that are used in the filters and calculations. */
	WHILE LEN(@sAllComponents) > 0 
	BEGIN
		/* Get the individual component IDs from the comma-delimited string. */
		SET @iIndex = CHARINDEX(',', @sAllComponents)

		IF @iIndex > 0 
		BEGIN
			SET @iComponentID = convert(integer, SUBSTRING(@sAllComponents, 1, @iIndex - 1))
			SET @sAllComponents = SUBSTRING(@sAllComponents, @iIndex + 1, LEN(@sAllComponents) - @iIndex)
		END
		ELSE
		BEGIN
			/* No comma, must be dealing with the last component in the list. */
			SET @iComponentID = convert(integer, @sAllComponents)
			SET @sAllComponents = ''
		END

		/* Get the parameters of the prompted values. */
		INSERT INTO @promptedValues
			(componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID)
		(SELECT componentID, promptDescription, valueType, promptMask, promptSize, promptDecimals, valueCharacter, valueNumeric, valueLogic, valueDate, promptDateType, fieldColumnID
			FROM ASRSysExprComponents
			WHERE componentID = @iComponentID)
	END

	SELECT DISTINCT * 
	FROM @promptedValues
END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetCustomReportDetails]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetCustomReportDetails]
GO

CREATE PROCEDURE [dbo].[spASRIntGetCustomReportDetails] (@piCustomReportID integer)
AS
BEGIN

	SET NOCOUNT ON;

	SELECT d.*, ISNULL(c.Use1000separator,0) AS Use1000separator
			, ISNULL(c.columnname,'') AS [columnname]
			, ISNULL(t.tableid,0) AS [tableid]
			, ISNULL(t.tablename,'') AS [tablename]
			, CASE c.datatype WHEN 11 THEN 1 ELSE 0 END AS [IsDateColumn]
			, CASE c.datatype WHEN -7 THEN 1 ELSE 0 END AS [IsBooleanColumn]
			, ISNULL(c.datatype,0) AS [DataType]
		FROM ASRSysCustomReportsDetails d
		LEFT JOIN ASRSysColumns c ON c.columnid = d.ColExprID And d.Type = 'C'
		LEFT JOIN ASRSysTables t ON c.tableid = t.tableid
	WHERE CustomReportID = @piCustomReportID ORDER BY [Sequence];

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetMailMergeDS]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetMailMergeDS]
GO

CREATE PROCEDURE [dbo].[spASRIntGetMailMergeDS](@id AS integer)
AS
BEGIN

	SET NOCOUNT ON;

	-- Definition
	SELECT m.*, t.TableName, t.RecordDescExprID
		FROM ASRSysMailMergeName m
		JOIN ASRSYSTables t ON (t.TableID = m.TableID) WHERE MailMergeID = @id;

	-- Columns
	SELECT 0 AS [IsExpression],  c.ColumnID AS ColExpId
		, t.TableID AS [tableid], t.Tablename AS [TableName], c.ColumnName AS [Name]
		, c.DataType AS [Type], m.Size, m.Decimals, c.Use1000Separator
	FROM ASRSysMailMergeColumns m
		INNER JOIN ASRSysColumns c ON (c.ColumnID = m.ColumnID) 
		INNER JOIN ASRSysTables t ON (t.TableID = c.TableID) WHERE m.Type = 'C' AND m.MailMergeID = @id
	UNION    
	SELECT 1 AS [IsExpression], e.ExprID AS [ColExpId],  0 AS [TableID]
		, 'Calculation_' AS [Table], e.Name AS [Name]
		, e.ReturnType as [Type], m.Size, m.Decimals, 0 AS [Use1000Separator]
	FROM ASRSysMailMergeColumns m
		LEFT OUTER JOIN ASRSysExpressions e ON (e.ExprID = m.ColumnID)
		WHERE m.Type = 'E' AND m.MailMergeID = @id
	ORDER BY [TableName], [Name];

	-- Sort Order
	SELECT t.TableID, t.TableName, c.ColumnID AS ColExpId, c.ColumnName AS [Name], mc.SortOrder 
		FROM ASRSysMailMergeColumns mc
		INNER JOIN ASRSysColumns c ON mc.ColumnID = c.ColumnID
		INNER JOIN ASRSysTables t ON c.TableID = t.TableID
		WHERE mc.MailMergeID = @id AND SortOrderSequence > 0
	ORDER BY SortOrderSequence;

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetLookupFindRecords2]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetLookupFindRecords2]
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupFindRecords2] (
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@piLookupColumnID 	integer,
	@piRecordsRequired	integer,
	@pfFirstPage		bit		OUTPUT,
	@pfLastPage			bit		OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer		OUTPUT,
	@piColumnSize		integer		OUTPUT,
	@piColumnDecimals	integer		OUTPUT,
	@psAction			varchar(MAX),
	@piTotalRecCount	integer		OUTPUT,
	@piFirstRecPos		integer		OUTPUT,
	@piCurrentRecCount	integer,
	@psFilterValue		varchar(MAX),
	@piCallingColumnID	integer,
	@piLookupColumnGridNumber	integer		OUTPUT,
	@pfOverrideFilter	bit
)
AS
BEGIN
	/* Return a recordset of the link find records for the current user, given the table/view and order IDs.
		@piTableID = the ID of the table on which the find is based.
		@piViewID = the ID of the view on which the find is based.
		@piOrderID = the ID of the order we are using.
		@pfError = 1 if errors occured in getting the find records. Else 0.
	*/
	
	SET NOCOUNT ON;
	
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@iDataType 			integer,
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(5),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@iGetCount			integer,
		@iColSize			integer,
		@iColDecs			integer,
		@fLookupColumnDone	bit,
		@sLookupColumnName	sysname,
		@iLookupTableID		integer,
		@iLookupColumnType	integer,
		@iLookupColumnSize	integer,
		@iLookupColumnDecimals integer,
		@iCount2			integer,
		@sFilterSQL			nvarchar(MAX),
		@sColumnTemp		sysname,
		@iLookupFilterColumnID	integer,
		@iLookupFilterOperator	integer,
		@iLookupFilterColumnDataType	integer,
		@sActualUserName	sysname;

	/* Initialise variables. */
	SET @sRealSource = ''
	SET @sSelectSQL = ''
	SET @sOrderSQL = ''
	SET @fSelectDenied = 0
	SET @sExecString = ''
	SET @sDESCstring = ' DESC'
	SET @fFirstColumnAsc = 1
	SET @sFirstColCode = ''
	SET @sReverseOrderSQL = ''
	SET @fLookupColumnDone = 0
	SET @piLookupColumnGridNumber = 0
	SET @sFilterSQL = ''

	/* Clean the input string parameters. */
	IF len(@psFilterValue) > 0 SET @psFilterValue = replace(@psFilterValue, '''', '''''')
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''')
	
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST'
	END

	/* Get the column name. */
	SELECT @sLookupColumnName = ASRSysColumns.columnName,
		@iLookupTableID = ASRSysColumns.tableID,
		@iLookupColumnType = ASRSysColumns.dataType,
		@iLookupColumnSize = ASRSysColumns.size,
		@iLookupColumnDecimals = ASRSysColumns.decimals
	FROM ASRSysColumns
	WHERE ASRSysColumns.columnId = @piLookupColumnID

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		RETURN
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID;

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	/* Create the lookup filter string. NB. We already know that the user has SELECT permission on this from the spASRIntGetLookupViews stored procedure.*/
	SELECT @iLookupFilterColumnID = ASRSysColumns.LookupFilterColumnID,
		@iLookupFilterOperator = ASRSysColumns.LookupFilterOperator
	FROM ASRSysColumns
	WHERE ASRSysColumns.columnId = @piCallingColumnID

	IF (@iLookupFilterColumnID > 0) and (@pfOverrideFilter = 0)
	BEGIN
		SELECT @sColumnTemp = ASRSysColumns.columnName,
			@iLookupFilterColumnDataType = ASRSysColumns.dataType
		FROM ASRSysColumns
		WHERE ASRSysColumns.columnId = @iLookupFilterColumnID

		SELECT @iCount = COUNT(*)
		FROM @columnPermissions
		WHERE columnName = @sColumnTemp
			AND selectGranted = 1

		IF @iCount > 0 AND @psFilterValue <> ''
		BEGIN
			IF @iLookupFilterColumnDataType = -7 /* Boolean */
			BEGIN
				SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' = '
					+ CASE
						WHEN UPPER(@psFilterValue) = 'TRUE' THEN '1'
						WHEN UPPER(@psFilterValue) = 'FALSE' THEN '0'
						ELSE @psFilterValue
					END
					+ ') '
			END
			ELSE
			BEGIN
				IF (@iLookupFilterColumnDataType = 2) OR (@iLookupFilterColumnDataType = 4) /* Numeric, Integer */
				BEGIN
					IF @iLookupFilterOperator = 1 /* Equals */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' = ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) = 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 2 /* NOT Equal To */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <> ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) = 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' AND (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null) '
						END
					END

					IF @iLookupFilterOperator = 3 /* Is At Most */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <= ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) >= 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 4 /* Is At Least */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' >= ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) <= 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 5 /* Is More Than */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' > ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) < 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 6 /* Is Less Than */
					BEGIN
						SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' < ' + @psFilterValue + ') '
						IF convert(float, @psFilterValue) > 0
						BEGIN
							SET @sFilterSQL = @sFilterSQL +
								' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
						END
					END
				END
				ELSE
				BEGIN
					IF (@iLookupFilterColumnDataType = 11) /* Date */
					BEGIN
						IF @iLookupFilterOperator = 7 /* On */
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' = ''' + @psFilterValue + ''') '
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
							END
						END

						IF @iLookupFilterOperator = 8 /* NOT On */
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <> ''' + @psFilterValue + ''') ' +
									' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null) '
							END
						END

						IF @iLookupFilterOperator = 12 /* On OR Before*/
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <= ''' + @psFilterValue + ''') ' +
									' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
							END
						END

						IF @iLookupFilterOperator = 11 /* On OR After*/
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' >= ''' + @psFilterValue + ''') ' 
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null)' +
									' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null)'
							END
						END

						IF @iLookupFilterOperator = 9 /* After*/
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' > ''' + @psFilterValue + ''') ' 
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null)'
							END
						END

						IF @iLookupFilterOperator = 10 /* Before*/
						BEGIN
							IF len(@psFilterValue) = 10
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' < ''' + @psFilterValue + ''') ' +
									' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
							END
							ELSE
							BEGIN
								SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null)' +
									' AND (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null)'
							END
						END
					END
					ELSE
					BEGIN
						IF (@iLookupFilterColumnDataType = 12) OR (@iLookupFilterColumnDataType = -3) OR (@iLookupFilterColumnDataType = -1) /* varchar, working patter, photo*/
						BEGIN
							IF @iLookupFilterOperator = 14 /* Is */
							BEGIN
								IF len(@psFilterValue) = 0
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' = '''') ' +
										' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS null) '
								END
								ELSE
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' = ''' + @psFilterValue + ''') '
								END
							END

							IF @iLookupFilterOperator = 16 /* Is NOT*/
							BEGIN
								IF len(@psFilterValue) = 0
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <> '''') ' +
										' AND (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null) '
								END
								ELSE
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' <> ''' + @psFilterValue + ''') '
								END
							END

							IF @iLookupFilterOperator = 13 /* Contains*/
							BEGIN
								IF len(@psFilterValue) = 0
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null) ' +
										' OR (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null) '
								END
								ELSE
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' LIKE ''%' + @psFilterValue + '%'') '
								END
							END

							IF @iLookupFilterOperator = 15 /* Does NOT Contain*/
							BEGIN
								IF len(@psFilterValue) = 0
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' IS null) ' +
										' AND (' + @sRealSource + '.' + @sColumnTemp  + ' IS NOT null) '
								END
								ELSE
								BEGIN
									SET @sFilterSQL = '(' + @sRealSource + '.' + @sColumnTemp  + ' NOT LIKE ''%' + @psFilterValue + '%'') '
								END
							END
						END
					END
				END
			END
		END
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 

	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending, oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		RETURN
	END
	SET @iCount2 = 0

	WHILE (@@fetch_status = 0) OR (@fLookupColumnDone = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF (@@fetch_status <> 0)
		BEGIN
			SET @iColumnTableId = @iLookupTableID
			SET @iColumnId = @piLookupColumnID
			SET @sColumnName = @sLookupColumnName
			SET @sColumnTableName = @sTableName
			SET @fAscending = 1
			SET @sType = 'F'
			SET @iDataType = @iLookupColumnType
			SET @iColSize = @iLookupColumnSize
			SET @iColDecs = @iLookupColumnDecimals
		END

		IF (@iColumnId  = @piLookupColumnID ) AND (@sType = 'F')
		BEGIN
			SET @fLookupColumnDone = 1
			SET @piLookupColumnGridNumber = @iCount2
		END

		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN

					/* Find column. */
					SET @sSelectSQL = @sSelectSQL + 
						CASE 
							WHEN len(@sSelectSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName
					SET @iCount2 = @iCount2 + 1
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sSelectSQL = @sSelectSQL + 
						CASE 
							WHEN len(@sSelectSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName
					SET @iCount2 = @iCount2 + 1
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)

				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE'

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +
						' ELSE NULL END'

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sSubString = @sSubString +
							' AS [' + @sColumnName + ']'

						SET @sSelectSQL = @sSelectSQL + 
							CASE 
								WHEN len(@sSelectSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END
						SET @iCount2 = @iCount2 + 1
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType
							SET @piColumnSize = @iColSize
							SET @piColumnDecimals = @iColDecs
							SET @fFirstColumnAsc = @fAscending
							SET @sFirstColCode = @sSubString
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END				
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID'

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL

		SET @iLastCharIndex = 0
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL)
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', '
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', '
			END

			SET @iLastCharIndex = @iCharIndex
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1)
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex)
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring

	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource

	IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	IF len(@sSelectSQL) > 0 
	BEGIN
		SET @sSelectSQL = @sSelectSQL + ',' + @sRealSource + '.ID'
		SET @sExecString = 'SELECT ' 

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' '
		END
		SET @sExecString = @sExecString + @sSelectSQL + 
			' FROM ' + @sRealSource

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sExecString = @sExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @sExecString = @sExecString + 
				' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END
			SET @sExecString = @sExecString + 
				' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource

			SET @sExecString = @sExecString + 
				' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired  - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
		END
		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END
			SET @sExecString = @sExecString + 
				' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource

			SET @sExecString = @sExecString + 
				' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
		END

		IF len(@sFilterSQL) > 0 SET @sExecString = @sExecString + ' WHERE ' + @sFilterSQL

		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL + ')'
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')'
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			IF len(@sFilterSQL) > 0 
			BEGIN
				SET @sLocateCode = ' AND (' + @sFirstColCode 
			END
			ELSE
			BEGIN
				SET @sLocateCode = ' WHERE (' + @sFirstColCode 
			END

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL'
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL'
					END
					ELSE
					BEGIN

						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL'
				END

			END

			SET @sLocateCode = @sLocateCode + ')'
			SET @sExecString = @sExecString + @sLocateCode
		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL
	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1
		SET @pfFirstPage = 1
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount
		SET @pfFirstPage = 0
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 1
	END

	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF len(@sFilterSQL) > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterSQL

		SET @sTempExecString = @sTempExecString + @sLocateCode

		SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (len(@sExecString) > 0)
	BEGIN
		EXEC sp_executeSQL @sExecString;
	END
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntInsertNewRecord]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntInsertNewRecord]
GO

CREATE PROCEDURE [dbo].[spASRIntInsertNewRecord]
(
	@piNewRecordID	integer	OUTPUT,
	@FromRecordID integer,
	@piTableID integer,
	@psInsertDef		nvarchar(MAX),
	@errorMessage	nvarchar(MAX) OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON;

	-- Check database status before saving
	EXEC dbo.spASRDatabaseStatus @errorMessage OUTPUT;
	IF LEN(@errorMessage) > 0 RETURN;
	
	DECLARE
		@sTempString	nvarchar(MAX),
		@sInsertString	nvarchar(MAX),
		@iTemp			integer,
		@iCounter		integer = 0,
		@iIndex1		integer,
		@iIndex2		integer,
		@iIndex3		integer,
		@sColumnID		varchar(255),
		@sValue			varchar(MAX),
		@sColumnList	varchar(MAX),
		@sValueList		varchar(MAX) = '',
		@iCopiedRecordID	integer,
		@iDataType		integer,
		@sColumnName	varchar(255),
		@sRealSource	sysname,
		@sMask			varchar(255),
		@iOLEType		integer,
		@fCopyImageData	bit;

	SET @iIndex1 = charindex(CHAR(9), @psInsertDef);
	SET @iIndex2 = charindex(CHAR(9), @psInsertDef, @iIndex1+1);
	SET @iIndex3 = charindex(CHAR(9), @psInsertDef, @iIndex2+1);

	SET @sRealSource = replace(LEFT(@psInsertDef, @iIndex1-1), '''', '''''');
	SET @sValue = replace(SUBSTRING(@psInsertDef, @iIndex1+1, @iIndex2-@iIndex1-1), '''', '''''');
	SET @fCopyImageData = convert(bit, @sValue);
	SET @sValue = replace(SUBSTRING(@psInsertDef, @iIndex2+1, @iIndex3-@iIndex2-1), '''', '''''');

	SET @psInsertDef = SUBSTRING(@psInsertDef, @iIndex3+1, LEN(@psInsertDef) - @iIndex3);

	SET @sColumnList = 'INSERT ' + convert(varchar(255), @sRealSource) + ' (';


	WHILE charindex(CHAR(9), @psInsertDef) > 0
	BEGIN
		SET @iIndex1 = charindex(CHAR(9), @psInsertDef);
		SET @iIndex2 = charindex(CHAR(9), @psInsertDef, @iIndex1+1);

		SET @sColumnID = replace(LEFT(@psInsertDef, @iIndex1-1), '''', '''''');
		SET @sValue = replace(SUBSTRING(@psInsertDef, @iIndex1+1, @iIndex2-@iIndex1-1), '''', '''''');

		IF LEFT(@sColumnID, 3) = 'ID_'
		BEGIN
			SET @sColumnName = @sColumnID;
		END
		ELSE
		BEGIN
			SELECT @sColumnName = columnName,
				@iDataType = dataType,
				@sMask = mask
			FROM ASRSysColumns
			WHERE columnId = convert(integer, @sColumnID);

			-- Date
			IF (@iDataType = 11 AND @sValue <> 'null') SET @sValue = '''' + @sValue + '''';

			-- Character
			IF (@iDataType = 12 AND (LEN(@sMask) = 0 OR @sValue <> 'null')) SET @sValue = '''' + @sValue + '''';

			-- WorkingPattern
			IF (@iDataType = -1) SET @sValue = '''' + @sValue + '''';

			-- Photo / OLE
			IF (@iDataType = -3 OR @iDataType = -4)
			BEGIN
				SET @iOLEType = convert(integer, LEFT(@sValue, 1));
				SET @sValue = SUBSTRING(@sValue, 2, LEN(@sValue) - 1);
				IF (@iOLEType < 2) SET @sValue = '''' + @sValue + '''';
			END
		END

		SET @sTempString =
			CASE
				WHEN @iCounter > 0 THEN ','
				ELSE ''
			END
			+ convert(varchar(255), @sColumnName);

		SET @sColumnList = @sColumnList + @sTempString;
		SET @sTempString =
			CASE
				WHEN @iCounter > 0 THEN ','
				ELSE ''
			END
			+ CASE
				WHEN @fCopyImageData = 1 THEN REPLACE(convert(varchar(MAX), @sValue), '''', '''''')
				ELSE convert(varchar(MAX), @sValue)
			END;

		SET @sValueList = @sValueList + @sTempString;
		SET @iCounter = @iCounter + 1;
		SET @psInsertDef = SUBSTRING(@psInsertDef, @iIndex2+1, LEN(@psInsertDef) - @iIndex2);
	END

	IF @fCopyImageData = 1
	BEGIN
		SET @sInsertString = @sColumnList + ')'
			+ ' EXECUTE(''SELECT ' + @sValueList
			+ ' FROM ' + convert(varchar(255), @sRealSource)
			+ ' WHERE id = ' + convert(varchar(255), @iCopiedRecordID) + ''')';
	END
	ELSE
	BEGIN
		SET @sInsertString = @sColumnList + ')' + ' VALUES(' + @sValueList + ')';
	END

	-- Run the constructed SQL INSERT string
	EXECUTE sp_executesql @sInsertString;	

	-- Get the most recent inserted key
	SELECT @piNewRecordID = convert(int,convert(varbinary(4),CONTEXT_INFO()));

	-- Copy any child data
	DECLARE @sParamDefinition nvarchar(MAX);
	SET @sParamDefinition = N'@iParentTableID integer, @iNewRecordID integer, @iOriginalRecordID integer';
	EXECUTE sp_executesql N'spASRCopyChildRecords @iParentTableID, @iNewRecordID, @iOriginalRecordID', @sParamDefinition
		, @iParentTableID = @piTableID
		, @iNewRecordID = @piNewRecordID
		, @iOriginalRecordID = @FromRecordID;

END

GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[spASRIntSaveComponent]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntSaveComponent]
GO

CREATE PROCEDURE dbo.spASRIntSaveComponent(
	@componentID integer,
	@expressionID integer,
	@type tinyint,
	@calculationID integer = 0,
	@filterID integer = 0,
	@functionID integer = 0,
	@operatorID integer = 0,
	@valueType tinyint = 0,
	@valueCharacter varchar(255) = '',
	@valueNumeric float = 0,
	@valueLogic bit = 0,
	@valuedate datetime = null,
	@LookupTableID integer = 0,
	@LookupColumnID integer = 0,
	@fieldTableID integer = 0,
	@fieldColumnID integer = 0,
	@fieldPassBy tinyint = 0,
	@fieldSelectionRecord tinyint = 0,
	@fieldSelectionLine integer = 0,
	@fieldSelectionOrderID integer = 0,
	@fieldSelectionFilter integer = 0,
	@promptDescription varchar(255) = '',
	@promptSize smallint = 0,
	@promptDecimals smallint = 0,
	@promptMask varchar(255) = '',
	@promptDateType integer = 0)
AS
BEGIN 

	SET NOCOUNT ON;

	INSERT INTO ASRSysExprComponents (componentID, exprID, [type]
					, calculationID, filterID, FunctionID, operatorID
					, ValueType, ValueCharacter, ValueNumeric, ValueLogic, ValueDate
					, LookupTableID, LookupColumnID
					, fieldTableID, fieldColumnID, fieldPassBy, fieldSelectionRecord, fieldSelectionLine, fieldSelectionOrderID, fieldSelectionFilter
					, promptDescription, promptSize, promptDecimals, promptMask, promptDateType)
				VALUES (@componentID, @expressionID, @type
					, @calculationID, @filterID, @functionID, @operatorID
					, @valueType, @valueCharacter, @valueNumeric, @valueLogic, @valuedate
					, @LookupTableID, @LookupColumnID
					, @fieldTableID, @fieldColumnID, @fieldPassBy, @fieldSelectionRecord, @fieldSelectionLine, @fieldSelectionOrderID, @fieldSelectionFilter
					, @promptDescription,	@promptSize, @promptDecimals, @promptMask, @promptDateType);

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[spASRIntSaveExpression]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntSaveExpression]
GO

CREATE PROCEDURE dbo.spASRIntSaveExpression (
	@expressionID integer = 0 OUTPUT,
	@name varchar(255),
	@TableID integer,
	@returnType integer,
	@returnSize integer,
	@returnDecimals integer,
	@type integer,
	@parentComponentID integer,
	@Username varchar(50) = '',
	@access varchar(2) = '',
	@description varchar(255) = '')
AS
BEGIN

	SET NOCOUNT ON;

	IF @expressionID = 0
	BEGIN

		-- Keep a manual record of allocated IDs in case users in SYS MGR have created expressions but not yet saved changes
		SELECT @expressionID = ISNULL([SettingValue], 1) FROM [asrsyssystemsettings] WHERE [Section] = 'AUTOID' AND [SettingKey] = 'expressions';
		IF @expressionID = 1
			INSERT ASRSysSystemSettings([Section], [SettingKey], [SettingValue]) VALUES ('AUTOID', 'ExprID', 1);	
		ELSE
		BEGIN
			SET @expressionID = @expressionID + 1;
			UPDATE ASRSysSystemSettings SET [SettingValue] = @expressionID WHERE [Section] ='AUTOID' AND [SettingKey] = 'expressions';
		END

		INSERT ASRSysExpressions (exprID, name, TableID, returnType, returnSize, returnDecimals, [type], parentComponentID, Username, access, [description])
			VALUES(@expressionID, @name, @TableID, @returnType, @returnSize, @returnDecimals, @type, @parentComponentID, @Username, @access, @description);
	END
	ELSE
	BEGIN
		UPDATE ASRSysExpressions SET name = @name, TableID = @TableID, returnType = @returnType, returnSize = @returnSize, returnDecimals = @returnDecimals,
				[type] = @type, parentComponentID = @parentComponentID, Username = @Username, access = @access, [description] = @description
					WHERE ExprID = @expressionID;
	END

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetRecord]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetRecord]
GO

CREATE PROCEDURE [dbo].[spASRIntGetRecord] (
	@piRecordID			integer 		OUTPUT,
	@piRecordCount		integer 		OUTPUT,
	@piRecordPosition	integer 		OUTPUT,
	@psFilterDef 		varchar(MAX),
	@psAction	 		varchar(100),
	@piParentTableID	integer,
	@piParentRecordID	integer,
	@psDecimalSeparator	varchar(100),
	@psLocaleDateFormat	varchar(100),
	@piScreenID 		integer,
	@piViewID 			integer,
	@piOrderID			integer
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iRecordID 				integer, 
		@iRecordCount 				integer,
		@iRecordPosition 			integer,
		@sCommand					nvarchar(MAX),
		@sLongCommand				nvarchar(MAX),
		@sParamDefinition			nvarchar(500),
		@sSubCommand				nvarchar(MAX),
		@sSubParamDefinition		nvarchar(500),
		@sPositionCommand			nvarchar(MAX),
		@sTemp						nvarchar(MAX),
		@sMoveCommand				nvarchar(MAX),
		@sReverseOrderSQL			varchar(MAX),
		@sRelevantOrderSQL			varchar(MAX),
		@sRemainingSQL				varchar(MAX),
		@iCharIndex					integer,
		@iLastCharIndex				integer,
		@sDESCstring				varchar(5),
		@fPositionKnown				bit,
		@sPreviousWhere				varchar(MAX),
		@sOrderItem					varchar(MAX),
		@sOrderColumn				varchar(MAX),
		@sOrderTable				varchar(MAX),
		@iDotIndex 					integer,
		@iDataType					integer,
		@fBitValue					bit,
		@sVarCharValue				varchar(MAX),
		@iIntValue					integer,
		@dblNumValue				float,
		@dtDateValue				datetime,
		@iSpaceIndex 				integer,
		@fDescending				integer,
		@fAddedToPositionString		bit,
		@fAddedToMoveString			bit,
		@sSubString 				varchar(MAX),
		@sPositionSQL				nvarchar(MAX),
		@sFromSQL					varchar(MAX),
		@sRealSource				varchar(MAX),
		@iIndex1					integer,
		@iIndex2					integer,
		@iIndex3					integer,
		@iColumnID					integer,
		@iOperatorID				integer,
		@sValue						varchar(MAX),
		@sFilterSQL					nvarchar(MAX),
		@sSubFilterSQL				nvarchar(MAX),
		@sColumnName 				sysname,
		@sTableViewName				sysname,
		@iJoinTableID				integer,
		@sFromDef					varchar(MAX),
		@sSelectSQL					nvarchar(MAX),
		@sExecuteSQL				nvarchar(MAX),
		@sOrderSQL 					varchar(MAX);

	exec [dbo].[spASRIntGetScreenStrings]
		@piScreenID,
		@piViewID,
		@sSelectSQL output,
		@sFromDef output,
		@sOrderSQL output,
		@piOrderID output;

	SET @sFilterSQL = '';
	SET @sPositionCommand = '';
	SET @fPositionKnown = 0;
	SET @sDESCstring = ' DESC';
	SET @iRecordID = @piRecordID;
	SET @fAddedToPositionString = 0;
	SET @fAddedToMoveString = 0;
	SET @iIndex1 = charindex('	', @sFromDef);
	SET @sRealSource = replace(LEFT(@sFromDef, @iIndex1-1), '''', '''''');
	SET @sFromSQL = @sRealSource;
	SET @sFromDef = SUBSTRING(@sFromDef, @iIndex1+1, LEN(@sFromDef) - @iIndex1);

	WHILE charindex('	', @sFromDef) > 0
	BEGIN
		SET @iIndex1 = charindex('	', @sFromDef);
		SET @iIndex2 = charindex('	', @sFromDef, @iIndex1+1);
				
		SET @sTableViewName = replace(LEFT(@sFromDef, @iIndex1-1), '''', '''''');
		SET @iJoinTableID = convert(integer, SUBSTRING(@sFromDef, @iIndex1+1, @iIndex2-@iIndex1-1));
				
		SET @sFromDef = SUBSTRING(@sFromDef, @iIndex2+1, LEN(@sFromDef) - @iIndex2);
		SET @sFromSQL = @sFromSQL + 
			' LEFT OUTER JOIN ' + convert(varchar(255), @sTableViewName) + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + convert(varchar(255), @sTableViewName) + '.ID';

	END



	IF len(@psFilterDef)> 0 
	BEGIN
		WHILE charindex('	', @psFilterDef) > 0
		BEGIN
			SET @sSubFilterSQL = '';
			SET @iIndex1 = charindex('	', @psFilterDef);
			SET @iIndex2 = charindex('	', @psFilterDef, @iIndex1+1);
			SET @iIndex3 = charindex('	', @psFilterDef, @iIndex2+1);
				
			SET @iColumnID = convert(integer, LEFT(@psFilterDef, @iIndex1-1));
			SET @iOperatorID = convert(integer, SUBSTRING(@psFilterDef, @iIndex1+1, @iIndex2-@iIndex1-1));
			SET @sValue = SUBSTRING(@psFilterDef, @iIndex2+1, @iIndex3-@iIndex2-1);
			SET @psFilterDef = SUBSTRING(@psFilterDef, @iIndex3+1, LEN(@psFilterDef) - @iIndex3);

			SELECT @iDataType = dataType,
				@sColumnName = columnName
			FROM ASRSysColumns
			WHERE columnID = @iColumnID;
							
			SET @sColumnName = @sRealSource + '.' + @sColumnName;

			IF (@iDataType = -7) 
			BEGIN
				/* Logic column (must be the equals operator).	*/
				SET @sSubFilterSQL = @sColumnName + ' = ';
			
				IF UPPER(@sValue) = 'TRUE'
					SET @sSubFilterSQL = @sSubFilterSQL + '1';
				ELSE
					SET @sSubFilterSQL = @sSubFilterSQL + '0';
			END

			IF ((@iDataType = 2) OR (@iDataType = 4)) 
			BEGIN
				/* Numeric/Integer column. */
				/* Replace the locale decimal separator with '.' for SQL's benefit. */
				SET @sValue = REPLACE(@sValue, @psDecimalSeparator, '.');

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equals. */
					SET @sSubFilterSQL = @sColumnName + ' = ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <> ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' AND ' + @sColumnName + ' IS NOT NULL';
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' <= ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				END
        
				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					SET @sSubFilterSQL = @sColumnName + ' >= ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				END
				
				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					SET @sSubFilterSQL = @sColumnName + ' > ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				END
				
				IF (@iOperatorID = 6) 
				BEGIN
					/* Less than.*/
					SET @sSubFilterSQL = @sColumnName + ' < ' + @sValue;
					IF convert(float, @sValue) = 0
						SET @sSubFilterSQL = @sSubFilterSQL + ' OR ' + @sColumnName + ' IS NULL';
				END
			END

			IF (@iDataType = 11) 
			BEGIN
				/* Date column. */
				IF LEN(@sValue) > 0
				BEGIN
					/* Convert the locale date into the SQL format. */
					/* Note that the locale date has already been validated and formatted to match the locale format. */
					SET @iIndex1 = CHARINDEX('mm', @psLocaleDateFormat);
					SET @iIndex2 = CHARINDEX('dd', @psLocaleDateFormat);
					SET @iIndex3 = CHARINDEX('yyyy', @psLocaleDateFormat);
						
					SET @sValue = SUBSTRING(@sValue, @iIndex1, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex2, 2) + '/' 
						+ SUBSTRING(@sValue, @iIndex3, 4);
				END

				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) > 0
						SET @sSubFilterSQL = @sColumnName + ' = ''' + @sValue + '''';
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
				END

				IF (@iOperatorID = 2)
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) > 0
						SET @sSubFilterSQL = @sColumnName + ' <> ''' + @sValue + ''''
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
				END

				IF (@iOperatorID = 3) 
				BEGIN
					/* Less than or Equal To. */
					IF LEN(@sValue) > 0 
						SET @sSubFilterSQL = @sColumnName + ' <= ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NULL';
				END

				IF (@iOperatorID = 4) 
				BEGIN
					/* Greater than or Equal To. */
					IF LEN(@sValue) > 0
						SET @sSubFilterSQL = @sColumnName + ' >= ''' + @sValue + ''''
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
				END

				IF (@iOperatorID = 5) 
				BEGIN
					/* Greater than. */
					IF LEN(@sValue) > 0
						SET @sSubFilterSQL = @sColumnName + ' > ''' + @sValue + '''';
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NOT NULL';
				END

				IF (@iOperatorID = 6)
				BEGIN
					/* Less than. */
					IF LEN(@sValue) > 0
						SET @sSubFilterSQL = @sColumnName + ' < ''' + @sValue + ''' OR ' + @sColumnName + ' IS NULL';
					ELSE
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
				END
			END
			
			IF ((@iDataType <> -7) AND (@iDataType <> 2) AND (@iDataType <> 4) AND (@iDataType <> 11)) 
			BEGIN
				/* Character/Working Pattern column. */
				IF (@iOperatorID = 1) 
				BEGIN
					/* Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' = '''' OR ' + @sColumnName + ' IS NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''' + @sValue + '''';
					END
				END
				
				IF (@iOperatorID = 2) 
				BEGIN
					/* Not Equal To. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' <> '''' AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sValue = replace(@sValue, '*', '%');
						SET @sValue = replace(@sValue, '?', '_');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''' + @sValue + '''';
					END
				END

				IF (@iOperatorID = 7)
				BEGIN
					/* Contains */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL OR ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' LIKE ''%' + @sValue + '%''';
					END
				END

				IF (@iOperatorID = 8) 
				BEGIN
					/* Does Not Contain. */
					IF LEN(@sValue) = 0
					BEGIN
						SET @sSubFilterSQL = @sColumnName + ' IS NULL AND ' + @sColumnName + ' IS NOT NULL';
					END
					ELSE
					BEGIN
						/* Replace the standard * and ? characters with the SQL % and _ characters. */
						SET @sValue = replace(@sValue, '''', '''''');
						SET @sSubFilterSQL = @sColumnName + ' NOT LIKE ''%' + @sValue + '%''';
					END
				END
			END
			
			IF LEN(@sSubFilterSQL) > 0
			BEGIN
				/* Add the filter code for this grid record into the complete filter code. */
				IF LEN(@sFilterSQL) > 0
					SET @sFilterSQL = @sFilterSQL + ' AND (';
				ELSE
					SET @sFilterSQL = @sFilterSQL + '(';
					
				SET @sFilterSQL = @sFilterSQL + @sSubFilterSQL + ')';
			END
		END
	END

	IF (@psAction = 'LOAD') AND (@piRecordID = 0) SET @psAction = 'MOVEFIRST';

	IF (@psAction = 'LOAD') AND (@piRecordID > 0) 
	BEGIN
		/* Check the required record is still in the recordset. */
		SET @sSubCommand = 'SELECT @iValue = ' + @sRealSource + '.ID ' + 
			' FROM ' + @sRealSource +
			' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @piRecordID);
		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sSubCommand = @sSubCommand + 
				' AND ' + @sFilterSQL;
		END
		SET @sSubParamDefinition = N'@iValue integer OUTPUT';
		EXEC sp_executesql @sSubCommand,  @sSubParamDefinition, @iIntValue OUTPUT;
		
		IF @iIntValue IS NULL 
			SET @psAction = 'MOVEFIRST';

	END

	/* Create the reverse order SQL if required. */
	SET @sReverseOrderSQL = '';
	IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVEPREVIOUS')
	BEGIN
		SET @sRemainingSQL = @sOrderSQL;
		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(', ', @sOrderSQL);
		WHILE @iCharIndex > 0 
		BEGIN
			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', ';
			ELSE
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', ';

			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(', ', @sOrderSQL, @iLastCharIndex + 1);
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex);
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring;
	END

	/* Get the record count of the required recordset. */	
	SET @sCommand = 'SELECT @recordCount = COUNT(id)' +
		' FROM ' + @sRealSource;

	IF @piParentTableID > 0
	BEGIN
		SET @sCommand = @sCommand +
			' WHERE ' + @sRealSource + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
		IF len(@sFilterSQL) > 0
			SET @sCommand = @sCommand + ' AND ' + @sFilterSQL;
	END
	ELSE
	BEGIN
		IF len(@sFilterSQL) > 0
			SET @sCommand = @sCommand + ' WHERE ' + @sFilterSQL;
	END

	SET @sParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sCommand,  @sParamDefinition, @iRecordCount OUTPUT;

	SET @piRecordCount = @iRecordCount;
	
	/* Get the required record ID and record position values if we're moving to the first or last records. */
	IF (@psAction = 'MOVEFIRST') OR (@psAction = 'MOVELAST')
	BEGIN
		SET @fPositionKnown = 1;
		SET @sLongCommand = 'SELECT TOP 1 @recordID = ' + @sRealSource + '.id' + ' FROM ' + @sFromSQL;
		IF @piParentTableID > 0
		BEGIN
			SET @sLongCommand = @sLongCommand +
				' WHERE ' + @sRealSource + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID);
			IF len(@sFilterSQL) > 0
				SET @sLongCommand = @sLongCommand +	' AND ' + @sFilterSQL;
		END
		ELSE
		BEGIN
			IF len(@sFilterSQL) > 0
				SET @sLongCommand = @sLongCommand +	' WHERE ' + @sFilterSQL;
		END

		SET @sLongCommand = @sLongCommand +
			' ORDER BY ' + 
			CASE 
				WHEN @psAction = 'MOVEFIRST' THEN @sOrderSQL
				ELSE @sReverseOrderSQL
			END;

		SET @sParamDefinition = N'@recordID integer OUTPUT';
		EXEC sp_executesql @sLongCommand,  @sParamDefinition, @iRecordID OUTPUT;

		IF @iRecordID IS NULL 
		BEGIN
			SET @iRecordID = 0;
		END
		SET @iRecordPosition = 
			CASE
				WHEN (@psAction = 'MOVEFIRST') AND (@iRecordCount > 0) THEN 1
				ELSE @iRecordCount
			END
	END
	
	/* Get the required record ID and record position values if we're moving to the next or previous records. */
	IF (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
	BEGIN

		SET @sMoveCommand = 'SELECT TOP 1 @recordID = ' + @sRealSource + '.id' +
			' FROM ' + @sFromSQL + 
			' WHERE ';

		IF @piParentTableID > 0
		BEGIN
			SET @sTemp = @sRealSource + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID) + ' AND ';
			SET @sMoveCommand = @sMoveCommand + @sTemp;
		END

		IF len(@sFilterSQL) > 0
		BEGIN
			SET @sTemp = @sFilterSQL + ' AND ';
			SET @sMoveCommand = @sMoveCommand + @sTemp;
		END		

		SET @sRelevantOrderSQL = CASE WHEN @psAction = 'MOVENEXT' THEN @sOrderSQL ELSE @sReverseOrderSQL END;
		SET @sPreviousWhere = '';
		SET @sTemp = 	'(';
		SET @sMoveCommand = @sMoveCommand + @sTemp;

		/* Get the order column values for the current record. */
		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(', ', @sRelevantOrderSQL);

		WHILE @iCharIndex > 0 
		BEGIN
			SET @fDescending = 
				CASE
					WHEN UPPER(SUBSTRING(@sRelevantOrderSQL, @iCharIndex - LEN(@sDESCstring), len(@sDESCstring))) = @sDESCstring THEN 1
					ELSE 0
				END
			SET @sOrderItem = SUBSTRING(@sRelevantOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1- (@fDescending * LEN(@sDESCstring)) - @iLastCharIndex);
			SET @iDotIndex = CHARINDEX('.', @sOrderItem);
			SET @sOrderTable = LTRIM(LEFT(@sOrderItem, @iDotIndex - 1));
			SET @iSpaceIndex = CHARINDEX(' ', REVERSE(@sOrderTable));

			IF @iSpaceIndex > 0 
				SET @sOrderTable = SUBSTRING(@sOrderTable, LEN(@sOrderTable) - @iSpaceIndex + 2, @iSpaceIndex - 1);

			SET @sOrderColumn = RTRIM(SUBSTRING(@sOrderItem, @iDotIndex + 1, LEN(@sOrderItem) - @iDotIndex));
			SET @iSpaceIndex = CHARINDEX(' ', @sOrderColumn);

			IF @iSpaceIndex > 0 
				SET @sOrderColumn = SUBSTRING(@sOrderColumn, 1, @iSpaceIndex - 1);

			/* Get the data type of the order. */
			SELECT @iDataType = xtype
			FROM syscolumns
			WHERE name = @sOrderColumn
				AND id = (SELECT id FROM sysobjects WHERE name = @sOrderTable);

			IF @iDataType = 104	/* bit */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @fValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@fValue bit OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @fBitValue OUTPUT;

				IF @fBitValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = ' OR ('  + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0
							SET @sTemp = '(' + @sOrderItem + ' > ' + convert(varchar(2), @fBitValue) + ')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ' + convert(varchar(2), @fBitValue) + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(2), @fBitValue) + ')';
					END
					ELSE
					BEGIN
						IF @fDescending = 0
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(2), @fBitValue) + '))';
						ELSE
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(2), @fBitValue) + ') OR ('  + @sOrderItem + ' IS NULL)))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(2), @fBitValue) + ')';
					END
				END
			END

			IF @iDataType = 167	/* varchar */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @sValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@sValue varchar(MAX) OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @sVarCharValue OUTPUT;

				IF @sVarCharValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = '(' + @sOrderItem + ' > ''' + REPLACE(@sVarCharValue, '''', '''''')  + ''')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ''' + REPLACE(@sVarCharValue, '''', '''''')  + ''') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ''' + REPLACE(@sVarCharValue, '''', '''''') + ''')';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ''' +REPLACE(@sVarCharValue, '''', '''''') + '''))';
						ELSE
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ''' +REPLACE(@sVarCharValue, '''', '''''') + ''') OR ('  + @sOrderItem + ' IS NULL)))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ''' + REPLACE(@sVarCharValue, '''', '''''') + ''')';
					END
				END
			END

			IF @iDataType = 56	/* integer */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @iValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@iValue integer OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @iIntValue OUTPUT;

				IF @iIntValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = '(' + @sOrderItem + ' > ' + convert(varchar(200), @iIntValue)  + ')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ' + convert(varchar(200), @iIntValue)  + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(200), @iIntValue) + ')'		;
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(200), @iIntValue) + '))';
						ELSE
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(200), @iIntValue) + ') OR ('  + @sOrderItem + ' IS NULL)))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(200), @iIntValue) + ')';
					END
				END
			END

			IF @iDataType = 108	/* numeric */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @dblValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@dblValue float OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @dblNumValue OUTPUT;

				IF @dblNumValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = '(' + @sOrderItem + ' > ' + convert(varchar(200), @dblNumValue)  + ')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ' + convert(varchar(200), @dblNumValue)  + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(200), @dblNumValue) + ')';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(200), @dblNumValue) + '))';
						ELSE
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(200), @dblNumValue) + ') OR ('  + @sOrderItem + ' IS NULL)))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(200), @dblNumValue) + ')';
					END
				END
			END

			IF @iDataType = 61	/* datetime */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @dtValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@dtValue datetime OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @dtDateValue OUTPUT;

				IF @dtDateValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
						BEGIN
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';
							SET @sMoveCommand = @sMoveCommand + @sTemp;
							SET @fAddedToMoveString = 1;
						END
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = '(' + @sOrderItem + ' > ''' + convert(varchar(50), @dtDateValue, 121)  + ''')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ''' + convert(varchar(50), @dtDateValue, 121)  + ''') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ''' + convert(varchar(50), @dtDateValue, 121) + ''')';
					END
					ELSE
					BEGIN
						IF @fDescending = 0 
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ''' + convert(varchar(50), @dtDateValue, 121) + '''))';
						ELSE
							SET @sTemp = ' OR (' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ''' + convert(varchar(50), @dtDateValue, 121) + ''') OR ('  + @sOrderItem + ' IS NULL)))';

						SET @sMoveCommand = @sMoveCommand + @sTemp;
						SET @fAddedToMoveString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ''' + convert(varchar(50), @dtDateValue, 121) + ''')';
					END
				END
			END
	
			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(', ', @sRelevantOrderSQL, @iLastCharIndex + 1);
			SET @sRemainingSQL = SUBSTRING(@sRelevantOrderSQL, @iLastCharIndex + 2, len(@sRelevantOrderSQL) - @iLastCharIndex);
		END

		/* Add on the ID condition. */
		IF (@psAction = 'MOVENEXT')
		BEGIN
			IF LEN(@sPreviousWhere) = 0
			BEGIN
				SET @sTemp = '(' + @sRealSource + '.id > ' + convert(varchar(255), @iRecordID)  + ')';
			END
			ELSE
			BEGIN
				IF @fAddedToMoveString = 0
					SET @sTemp = ' (' + @sPreviousWhere + ' AND (' + @sRealSource + '.id > ' + convert(varchar(255), @iRecordID) + '))';
				ELSE
					SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sRealSource + '.id > ' + convert(varchar(255), @iRecordID) + '))';
			END
		END
		ELSE
		BEGIN
			IF LEN(@sPreviousWhere) = 0
			BEGIN
				SET @sTemp = '(' + @sRealSource + '.id < ' + convert(varchar(255), @iRecordID)  + ')';
			END
			ELSE
			BEGIN
				IF @fAddedToMoveString = 0
					SET @sTemp = ' (' + @sPreviousWhere + ' AND (' + @sRealSource + '.id < ' + convert(varchar(255), @iRecordID) + '))';
				ELSE
					SET @sTemp = ' OR (' + @sPreviousWhere + ' AND (' + @sRealSource + '.id < ' + convert(varchar(255), @iRecordID) + '))';
			END
		END

		SET @sTemp = @sTemp + ')';
		SET @sMoveCommand = @sMoveCommand + @sTemp;
		SET @fAddedToMoveString = 1;
		SET @sTemp = ' ORDER BY ' + @sRelevantOrderSQL;
		SET @sMoveCommand = @sMoveCommand + @sTemp;
		SET @fAddedToMoveString = 1;

		SET @sParamDefinition = N'@recordID integer OUTPUT';
		EXEC sp_executesql @sMoveCommand,  @sParamDefinition, @iRecordID OUTPUT;

		IF @iRecordID IS NULL 
			SET @iRecordID = 0;
			
	END

	IF @fPositionKnown = 0
	BEGIN

		/* Calculate the current record's position. */																		 
		SET @sPositionCommand = 'SELECT @recordPosition = COUNT(' + @sRealSource + '.id)' +
			' FROM ' + @sFromSQL + 
			' WHERE ';

		IF @piParentTableID > 0
		BEGIN
			SET @sPositionCommand = @sPositionCommand +
				'(' + @sRealSource + '.id_' + convert(varchar(100), @piParentTableID) + ' = ' + convert(varchar(100), @piParentRecordID) + ') AND '
		END

		IF len(@sFilterSQL) > 0
			SET @sPositionCommand = @sPositionCommand + '(' + @sFilterSQL + ') AND ';

		SET @sPositionCommand = @sPositionCommand + '(';
		SET @sPreviousWhere = '';

		/* Get the order column values for the current record. */
		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(', ', @sOrderSQL);

		WHILE @iCharIndex > 0 
		BEGIN
			SET @fDescending = CASE
					WHEN UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring THEN 1
					ELSE 0
				END
			SET @sOrderItem = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - (@fDescending * LEN(@sDESCstring)) - @iLastCharIndex)
			SET @iDotIndex = CHARINDEX('.', @sOrderItem)
			SET @sOrderTable = LTRIM(LEFT(@sOrderItem, @iDotIndex - 1))
			SET @iSpaceIndex = CHARINDEX(' ', REVERSE(@sOrderTable))

			IF @iSpaceIndex > 0 
			BEGIN
				SET @sOrderTable = SUBSTRING(@sOrderTable, LEN(@sOrderTable) - @iSpaceIndex + 2, @iSpaceIndex - 1)
			END

			SET @sOrderColumn = RTRIM(SUBSTRING(@sOrderItem, @iDotIndex + 1, LEN(@sOrderItem) - @iDotIndex))
			SET @iSpaceIndex = CHARINDEX(' ', @sOrderColumn)

			IF @iSpaceIndex > 0 
			BEGIN
				SET @sOrderColumn = SUBSTRING(@sOrderColumn, 1, @iSpaceIndex - 1)
			END

			/* Get the data type of the order. */
			SELECT @iDataType = xtype
			FROM syscolumns
			WHERE name = @sOrderColumn
				AND id = (SELECT id FROM sysobjects WHERE name = @sOrderTable)

			IF @iDataType = 104	/* bit */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @fValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID)
				SET @sSubParamDefinition = N'@fValue bit OUTPUT'
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @fBitValue OUTPUT

				IF @fBitValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = 	'(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'('  + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';

							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1
							SET @sTemp = 	'(' + @sOrderItem + ' > ' + convert(varchar(MAX), @fBitValue) + ')';
						ELSE
							SET @sTemp = 	'((' + @sOrderItem + ' < ' + convert(varchar(MAX), @fBitValue) + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(MAX), @fBitValue) + ')';
					END
					ELSE
					BEGIN
						IF @fDescending = 1
						BEGIN
							SET @sTemp = 	CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(MAX), @fBitValue) + '))';
						END
						ELSE
						BEGIN
							SET @sTemp =CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(MAX), @fBitValue) + ') OR ('  + @sOrderItem + ' IS NULL)))';
						END

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(MAX), @fBitValue) + ')';
					END
				END
			END

			IF @iDataType = 167	/* varchar */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @sValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID)
				SET @sSubParamDefinition = N'@sValue varchar(MAX) OUTPUT'
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @sVarCharValue OUTPUT

				IF @sVarCharValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = 	'(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';

							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)'
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1
							SET @sTemp = 	'(' + @sOrderItem + ' > ''' + REPLACE(@sVarCharValue, '''', '''''')  + ''')';
						ELSE
							SET @sTemp = 	'((' + @sOrderItem + ' < ''' + REPLACE(@sVarCharValue, '''', '''''')  + ''') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ''' + REPLACE(@sVarCharValue, '''', '''''') + ''')';
					END
					ELSE
					BEGIN
						IF @fDescending = 1
						BEGIN
							SET @sTemp = 	CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ''' +REPLACE(@sVarCharValue, '''', '''''') + '''))'
						END
						ELSE
						BEGIN
							SET @sTemp = 	CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ''' +REPLACE(@sVarCharValue, '''', '''''') + ''') OR ('  + @sOrderItem + ' IS NULL)))'
						END

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ''' + REPLACE(@sVarCharValue, '''', '''''') + ''')';

					END
				END
			END

			IF @iDataType = 56	/* integer */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @iValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@iValue integer OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @iIntValue OUTPUT;

				IF @iIntValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = 	'(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END
						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';

							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1
							SET @sTemp = 	'(' + @sOrderItem + ' > ' + convert(varchar(MAX), @iIntValue)  + ')';
						ELSE
							SET @sTemp = 	'((' + @sOrderItem + ' < ' + convert(varchar(MAX), @iIntValue)  + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(MAX), @iIntValue) + ')';
					END
					ELSE
					BEGIN
						IF @fDescending = 1
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(MAX), @iIntValue) + '))';
						END
						ELSE
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(MAX), @iIntValue) + ') OR ('  + @sOrderItem + ' IS NULL)))'
						END

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(MAX), @iIntValue) + ')';
					END
				END
			END

			IF @iDataType = 108	/* numeric */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @dblValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@dblValue float OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @dblNumValue OUTPUT;

				IF @dblNumValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';

							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1
							SET @sTemp = 	'(' + @sOrderItem + ' > ' + convert(varchar(200), @dblNumValue)  + ')';
						ELSE
							SET @sTemp = 	'((' + @sOrderItem + ' < ' + convert(varchar(200), @dblNumValue)  + ') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ' + convert(varchar(200), @dblNumValue) + ')';
						
					END
					ELSE
					BEGIN
						IF @fDescending = 1
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ' + convert(varchar(200), @dblNumValue) + '))';
						END
						ELSE
						BEGIN
							SET @sTemp = CASE
									WHEN @fAddedToPositionString = 0 THEN ''
									ELSE ' OR '
								END + 
								'(' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ' + convert(varchar(200), @dblNumValue) + ') OR ('  + @sOrderItem + ' IS NULL)))';
						END

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ' + convert(varchar(MAX), @dblNumValue) + ')';
					END
				END
			END

			IF @iDataType = 61	/* datetime */
			BEGIN
				SET @sLongCommand = 'SELECT TOP 1 @dtValue = ' + @sOrderItem +
					' FROM ' + @sFromSQL +
					' WHERE ' + @sRealSource + '.id = ' + convert(varchar(100), @iRecordID);
				SET @sSubParamDefinition = N'@dtValue datetime OUTPUT';
				EXEC sp_executesql @sLongCommand,  @sSubParamDefinition, @dtDateValue OUTPUT;

				IF @dtDateValue IS NULL
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = '(NOT ' + @sOrderItem + ' IS NULL)';
							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = '(' + @sOrderItem + ' IS NULL)';
					END
					ELSE
					BEGIN
						IF @fDescending = 1 
						BEGIN
							SET @sTemp = CASE
								WHEN @fAddedToPositionString = 0 THEN ''
								ELSE ' OR '
							END + 
							'(' + @sPreviousWhere + ' AND (NOT' + @sOrderItem + ' IS NULL))';

							SET @sPositionCommand = @sPositionCommand + @sTemp;
							SET @fAddedToPositionString = 1;
						END

						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' IS NULL)';
					END
				END
				ELSE
				BEGIN
					IF LEN(@sPreviousWhere) = 0
					BEGIN
						IF @fDescending = 1
							SET @sTemp = '(' + @sOrderItem + ' > ''' + convert(varchar(50), @dtDateValue, 121)  + ''')';
						ELSE
							SET @sTemp = '((' + @sOrderItem + ' < ''' + convert(varchar(50), @dtDateValue, 121)  + ''') OR ('  + @sOrderItem + ' IS NULL))';

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = '(' + @sOrderItem + ' = ''' + convert(varchar(50), @dtDateValue, 121) + ''')';
					END
					ELSE
					BEGIN
						IF @fDescending = 1
						BEGIN
							SET @sTemp = CASE
								WHEN @fAddedToPositionString = 0 THEN ''
								ELSE ' OR '
							END + 
							'(' + @sPreviousWhere + ' AND (' + @sOrderItem + ' > ''' + convert(varchar(50), @dtDateValue, 121) + '''))';
						END
						ELSE
						BEGIN
							SET @sTemp = CASE
								WHEN @fAddedToPositionString = 0 THEN ''
								ELSE ' OR '
							END + 
							'(' + @sPreviousWhere + ' AND ((' + @sOrderItem + ' < ''' + convert(varchar(50), @dtDateValue, 121) + ''') OR ('  + @sOrderItem + ' IS NULL)))';
						END

						SET @sPositionCommand = @sPositionCommand + @sTemp;
						SET @fAddedToPositionString = 1;
						SET @sPreviousWhere = @sPreviousWhere + ' AND (' + @sOrderItem + ' = ''' + convert(varchar(50), @dtDateValue, 121) + ''')';
					END
				END
			END

			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(', ', @sOrderSQL, @iLastCharIndex + 1);
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 2, len(@sOrderSQL) - @iLastCharIndex);
		END

		/* Add on the ID condition. */
		IF LEN(@sPreviousWhere) = 0
		BEGIN
			SET @sTemp = '((' + @sRealSource + '.id < ' + convert(varchar(255), @iRecordID)  + ') OR ('  + @sRealSource + '.id IS NULL))';
		END
		ELSE
		BEGIN
			SET @sTemp = CASE
				WHEN @fAddedToPositionString = 0 THEN ''
				ELSE ' OR '
			END + 
			'(' + @sPreviousWhere + ' AND ((' + @sRealSource + '.id < ' + convert(varchar(100), @iRecordID) + ') OR ('  + @sRealSource + '.id IS NULL)))';
		END

		SET @sTemp = @sTemp + ')';
		SET @sPositionCommand = @sPositionCommand + @sTemp;
		SET @fAddedToPositionString = 1;

		SET @sParamDefinition = N'@recordPosition integer OUTPUT';
		EXEC sp_executesql @sPositionCommand, @sParamDefinition, @iRecordPosition OUTPUT;

		SET @iRecordPosition = @iRecordPosition + 1;
	END

	/* Set the output parameter values. */
	SET @piRecordID = @iRecordID;
	SET @piRecordPosition = @iRecordPosition;

	/* Return the required record. */
	SET @sExecuteSQL = 'SELECT ' + @sSelectSQL
		+ ' FROM ' + @sFromSQL
		+ ' WHERE ' + @sRealSource + '.id = '
		+ convert(varchar(10), @iRecordID);
	EXEC sp_executesql @sExecuteSQL;

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetAddFromWaitingListRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetAddFromWaitingListRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetAddFromWaitingListRecords] (
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@piCourseRecordID	integer,
	@pfError 			bit 			OUTPUT,
	@piRecordsRequired	integer,
	@pfFirstPage		bit				OUTPUT,
	@pfLastPage			bit				OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer			OUTPUT,
	@psAction			varchar(255),
	@piTotalRecCount	integer			OUTPUT,
	@piFirstRecPos		integer			OUTPUT,
	@piCurrentRecCount	integer,
	@psErrorMessage		varchar(MAX)	OUTPUT,
	@piColumnSize		integer			OUTPUT,
	@piColumnDecimals	integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@iDataType 			integer,
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(5),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@fWhereDone			bit,
		@iWLCourseTitleColumnID	integer,
		@sWLCourseTitleColumnName	sysname,
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@iWLOverrideColumnID	integer,
		@sWLOverrideColumnName	sysname,
		@iGetCount			integer,
		@sCourseTitle		varchar(MAX),
		@iCourseTableID		integer,
		@iCourseRecordID	integer,
		@iWLTableID			integer,
		@sWLTableName		sysname,
		@sWLRealSource		varchar(255),
		@sCourseSource		sysname,
		@iColSize			integer,
		@iColDecs			integer,
		@sActualUserName	sysname;

	/* Initialise variables. */
	SET @pfError = 0;
	SET @psErrorMessage = '';
	SET @sRealSource = '';
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @fSelectDenied = 0;
	SET @sExecString = '';
	SET @sDESCstring = ' DESC';
	SET @fFirstColumnAsc = 1;
	SET @sFirstColCode = '';
	SET @sReverseOrderSQL = '';
	SET @fWhereDone = 0;

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the current course title. */
	/* Get the Course table id. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0;

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle'
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0;
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID;
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = '';

	/* Get the @sCourseTitle value for the given course record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		
	OPEN courseSourceCursor;
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(255), @piCourseRecordID);
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT;

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource;
	END
	CLOSE courseSourceCursor;
	DEALLOCATE courseSourceCursor;

	IF @sCourseTitle IS null
	BEGIN
		SET @pfError = 1;
		SET @psErrorMessage = 'Unable to read the course title from the current Course record.';
		RETURN		
	END

	/* Get the WL table real source. */
	/* NB. To reach this point we have already checked that the user has 'read' permission on the Training Booking - Status column. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iWLTableID;

	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle';
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0;
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID;
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = '';

	SELECT @iWLOverrideColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListOverRideColumn';
	IF @iWLOverrideColumnID IS NULL SET @iWLOverrideColumnID = 0;

	IF @iWLOverrideColumnID > 0 
	BEGIN
		SELECT @sWLOverrideColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLOverrideColumnID;
	END
	IF @sWLOverrideColumnName IS NULL SET @sWLOverrideColumnName = '';

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND [role] = @sUserGroupName;
	IF @iChildViewID IS null SET @iChildViewID = 0;
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_');
		SET @sWLRealSource = left(@sWLRealSource, 255);
	END

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000;
	SET @psAction = UPPER(@psAction);
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST';
	END

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID;

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND [role] = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems  oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/*Get the permissions for the override column if it has been set*/
	IF @iWLOverrideColumnID > 0 
	BEGIN
		INSERT INTO @columnPermissions
		SELECT 
			@iWLTableID,
			@sWLRealSource,
			syscolumns.name,
			CASE protectType
				WHEN 205 THEN 1
				WHEN 204 THEN 1
				ELSE 0
			END 
		FROM sysprotects
		INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
		INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
		WHERE sysprotects.uid = @iUserGroupID
			AND sysprotects.action = 193 
			AND syscolumns.name <> 'timestamp'
			AND sysobjects.name = @sWLRealSource
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

		/* Get the select permission on the column. */
		SELECT @fSelectGranted = selectGranted
		FROM @columnPermissions
		WHERE tableViewName = @sWLRealSource
			AND columnName = @sWLOverrideColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1
		BEGIN
			/* The user DOES have SELECT permission on the column in the current table/view. */
			/* Find column. */
			SET @sTempString = CASE 
					WHEN (len(@sSelectSQL) > 0) THEN ',' 
					ELSE '' 
				END + 
				@sWLRealSource + '.' + @sWLOverrideColumnName;				
			SET @sSelectSQL = @sSelectSQL + @sTempString;

			/* Override Column. */
			IF len(@sOrderSQL) = 0 
			BEGIN
				SET @fAscending = 1;
				SELECT 
					@iDataType = ASRSysColumns.dataType,
					@iColSize = ASRSysColumns.size,
					@iColDecs = ASRSysColumns.decimals
				FROM ASRSysColumns 
				WHERE ASRSysColumns.columnId = @iWLOverrideColumnID;

				SET @piColumnType = @iDataType;
				SET @fFirstColumnAsc = @fAscending;
				SET @sFirstColCode = @sWLRealSource + '.' + @sWLOverrideColumnName;
				SET @piColumnSize = @iColSize;
				SET @piColumnDecimals = @iColDecs;
			END
			SET @sOrderSQL = @sOrderSQL + 
			CASE 
				WHEN len(@sOrderSQL) > 0 THEN ',' 
				ELSE '' 
			END + 
			@sWLRealSource + '.' + @sWLOverrideColumnName +
			CASE 
				WHEN @fAscending = 0 THEN ' DESC' 
				ELSE '' 
			END		
		END			
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID,	oi.columnID, c.columnName, t.tableName,	oi.ascending,	oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName;
					SET @sSelectSQL = @sSelectSQL + @sTempString;

				END
				ELSE
				BEGIN
					/* Order column. */

					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName;
						SET @piColumnSize = @iColSize;
						SET @piColumnDecimals = @iColDecs;
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;		
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1;
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName;
					SET @sSelectSQL = @sSelectSQL + @sTempString;
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType;
						SET @fFirstColumnAsc = @fAscending;
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName;
						SET @piColumnSize = @iColSize;
						SET @piColumnDecimals = @iColDecs;
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END;
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName;

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = '';

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1;

				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE';

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName;

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId);
					END

					FETCH NEXT FROM viewCursor INTO @sViewName;
				END
				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +	' ELSE NULL END';

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END;
						SET @sSelectSQL = @sSelectSQL + @sTempString;
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType;
							SET @fFirstColumnAsc = @fAscending;
							SET @sFirstColCode = @sSubString;
							SET @piColumnSize = @iColSize;
							SET @piColumnDecimals = @iColDecs;
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END;		
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1;
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs;
	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID';

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL;

		SET @iLastCharIndex = 0;
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL);
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', ';
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', ';
			END

			SET @iLastCharIndex = @iCharIndex;
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1);
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex);
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring;
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource +
		' INNER JOIN ' + @sWLRealSource +
		' ON (' + @sRealSource + '.id = ' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) +
		' AND ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + ''')';
	SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT;
	SET @piTotalRecCount = @iCount;

	IF (len(@sSelectSQL) > 0)
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID';
		SET @sSelectSQL = @sSelectSQL + @sTempString;

		SET @sExecString = 'SELECT ';

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE'
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' ';
			SET @sExecString = @sExecString + @sTempString;
		END
		
		SET @sTempString = @sSelectSQL;
		SET @sExecString = @sExecString + @sTempString;

		SET @sTempString = ' FROM ' + @sWLRealSource;
		SET @sExecString = @sExecString + @sTempString;

		SET @sTempString = ' INNER JOIN ' + @sRealSource +
			' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
			' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + ''''
		SET @sExecString = @sExecString + @sTempString;

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, tableID
			FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @fWhereDone = 1;
			
			SET @sTempString = ' AND ' + @sWLRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sWLRealSource + '.ID' +
				' FROM ' + @sWLRealSource;
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' INNER JOIN ' + @sRealSource +
				' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
				' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + '''';
			SET @sExecString = @sExecString + @sTempString;

		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			SET @fWhereDone = 1
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1);
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END

			SET @sTempString = ' AND ' + @sWLRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sWLRealSource + '.ID' +
				' FROM ' + @sWLRealSource;
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' INNER JOIN ' + @sRealSource +
				' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
				' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + '''';
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' AND ' + @sWLRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sWLRealSource + '.ID' +
				' FROM ' + @sWLRealSource;
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' INNER JOIN ' + @sRealSource +
				' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
				' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + '''';
			SET @sExecString = @sExecString + @sTempString;

		END

		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			SET @fWhereDone = 1;
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1;
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;		
			END

			SET @sTempString = ' AND ' + @sWLRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sWLRealSource + '.ID' +
				' FROM ' + @sWLRealSource;
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' INNER JOIN ' + @sRealSource +
				' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
				' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + '''';
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' AND ' + @sWLRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sWLRealSource + '.ID' +
				' FROM ' + @sWLRealSource;
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' INNER JOIN ' + @sRealSource +
				' ON (' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) + '=' + @sRealSource + '.id)' +
				' WHERE ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + '=''' + replace(@sCourseTitle,'''','''''') + '''';
			SET @sExecString = @sExecString + @sTempString;
		END

		/* Add the filter code. */

		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			SET @fWhereDone = 1;
			SET @sLocateCode = ' AND (' + @sFirstColCode;

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL';
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue;

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL';
				END
			END

			SET @sLocateCode = @sLocateCode + ')';
			SET @sTempString = @sLocateCode;
			SET @sExecString = @sExecString + @sTempString;

		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL;
		SET @sExecString = @sExecString + @sTempString;

	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1;
		SET @pfFirstPage = 1;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
		SET @pfFirstPage = 0;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 1;
	END

	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource + 
			' INNER JOIN ' + @sWLRealSource +
			' ON (' + @sRealSource + '.id = ' + @sWLRealSource + '.id_' + convert(nvarchar(255), @piTableID) +
			' AND ' + @sWLRealSource + '.' + @sWLCourseTitleColumnName + ' = ''' + replace(@sCourseTitle,'''','''''') + ''')';
			
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, tableID
		FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		SET @sTempExecString = @sTempExecString + @sLocateCode;

		SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT;

		IF @iTemp <=0 

		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1;
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1;
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END;
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (len(@sExecString) > 0)
	BEGIN
		EXECUTE sp_executeSQL @sExecString;
	END
END

GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetBookCourseRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetBookCourseRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetBookCourseRecords] (
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@piWLRecordID		integer,
	@pfError 			bit 		OUTPUT,
	@piRecordsRequired	integer,
	@pfFirstPage		bit			OUTPUT,
	@pfLastPage			bit			OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer		OUTPUT,
	@psAction			varchar(255),
	@piTotalRecCount	integer		OUTPUT,
	@piFirstRecPos		integer		OUTPUT,
	@piCurrentRecCount	integer,
	@piColumnSize		integer		OUTPUT,
	@piColumnDecimals	integer		OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@iDataType 			integer,
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(4),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@fWhereDone			bit,
		@iWLCourseTitleColumnID		integer,
		@sWLCourseTitleColumnName	sysname,
		@iCourseTitleColumnID		integer,
		@sCourseTitleColumnName		sysname,
		@iCourseStartDateColumnID	integer,
		@sCourseStartDateColumnName	sysname,
		@sCourseCancelDateColumnID	integer,
		@sCourseCancelDateColumnName	sysname,
		@iGetCount					integer,
		@sCourseTitle				varchar(MAX),
		@iWLTableID					integer,
		@sWLTableName				sysname,
		@sWLRealSource				varchar(255),
		@iColSize					integer,
		@iColDecs					integer,
		@sActualUserName			sysname;

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sRealSource = '';
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @fSelectDenied = 0;
	SET @sExecString = '';
	SET @sDESCstring = ' DESC';
	SET @fFirstColumnAsc = 1;
	SET @sFirstColCode = '';
	SET @sReverseOrderSQL = '';
	SET @fWhereDone = 0;

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''');

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the course title from the given WL record. */
	/* NB. To reach this point we have already checked that the user has 'read' permission on the Waiting List - Course Title column. */
	SELECT @iWLTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListTable';
	IF @iWLTableID IS NULL SET @iWLTableID = 0;

	SELECT @sWLTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iWLTableID;
	
	SELECT @iWLCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_WaitListCourseTitle'
	IF @iWLCourseTitleColumnID IS NULL SET @iWLCourseTitleColumnID = 0
	
	IF @iWLCourseTitleColumnID > 0 
	BEGIN
		SELECT @sWLCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iWLCourseTitleColumnID
	END
	IF @sWLCourseTitleColumnName IS NULL SET @sWLCourseTitleColumnName = ''

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iWLTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sWLRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sWLTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sWLRealSource = left(@sWLRealSource, 255)
	END

	SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sWLCourseTitleColumnName +
		' FROM ' + @sWLRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piWLRecordID)
	SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle'
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = ''

	SELECT @iCourseStartDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseStartDate'
	IF @iCourseStartDateColumnID IS NULL SET @iCourseStartDateColumnID = 0

	IF @iCourseStartDateColumnID > 0 
	BEGIN
		SELECT @sCourseStartDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseStartDateColumnID
	END
	IF @sCourseStartDateColumnName IS NULL SET @sCourseStartDateColumnName = ''

	/* Get Cancel date Column*/
	SELECT @sCourseCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelDate'
	IF @sCourseCancelDateColumnID IS NULL SET @sCourseCancelDateColumnID = 0
	IF @sCourseCancelDateColumnID > 0 
	BEGIN
		SELECT @sCourseCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @sCourseCancelDateColumnID
	END
	IF @sCourseCancelDateColumnName IS NULL SET @sCourseCancelDateColumnName = ''

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST'
	END

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
		FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseTitleColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseStartDateColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending, oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
		
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString

				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE'

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +
						' ELSE NULL END'

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END
						SET @sSelectSQL = @sSelectSQL + @sTempString

					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType
							SET @fFirstColumnAsc = @fAscending
							SET @sFirstColCode = @sSubString
							SET @piColumnSize = @iColSize
							SET @piColumnDecimals = @iColDecs
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END				
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID'

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL

		SET @iLastCharIndex = 0
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL)
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', '
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', '
			END

			SET @iLastCharIndex = @iCharIndex
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1)
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex)
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource +
		' WHERE (' +
		@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND '	+
		@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101))) AND ' + 
		@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL'

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	IF (len(@sSelectSQL) > 0)
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID'
		SET @sSelectSQL = @sSelectSQL + @sTempString

		SET @sExecString = 'SELECT ' 

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' '
			SET @sExecString = @sExecString + @sTempString
		END
		
		SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents;

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'
			SET @sExecString = @sExecString + @sTempString

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @fWhereDone = 1

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			SET @fWhereDone = 1
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END
			
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

		END

		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			SET @fWhereDone = 1
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired				
			END
			
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

		END

		/* Add the filter code. */
		SET @sTempString = ' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND '	+
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101))) AND ' +
			@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL'
		SET @sExecString = @sExecString + @sTempString

		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			SET @fWhereDone = 1
			SET @sLocateCode = ' AND (' + @sFirstColCode 

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL'
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL'
				END
			END

			SET @sLocateCode = @sLocateCode + ')'

			SET @sTempString = @sLocateCode
			SET @sExecString = @sExecString + @sTempString

		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL
		SET @sExecString = @sExecString + @sTempString

	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1
		SET @pfFirstPage = 1
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount
		SET @pfFirstPage = 0
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 1
	END
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource + 
			' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND '	+
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101))) AND ' +
			@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL'
			
		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents;

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		SET @sTempExecString = @sTempExecString + @sLocateCode
			
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (len(@sExecString) > 0)
	BEGIN
		EXECUTE sp_executeSQL @sExecString;
	END
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetBulkBookingRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetBulkBookingRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetBulkBookingRecords] (
	@psSelectionType	varchar(MAX),
	@piSelectionID		integer,
	@psSelectedIDs		varchar(MAX),
	@psPromptSQL		varchar(MAX),
	@psErrorMessage		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the required 'employee' table records. */
	DECLARE
		@iUserGroupID			integer,
		@sUserGroupName			sysname,
		@iID					integer,
		@iEmployeeTableID		integer,
		@iTableType				integer,
		@sTableName				sysname,
		@sEmpRealSource			sysname,
		@iChildViewID			integer,
		@iTemp					integer,
		@sTemp					varchar(MAX),
		@sActualUserName		sysname,
		@sExecString			nvarchar(MAX),
		@sTempString			varchar(MAX),
		@iColumnCount			integer,
		@iOrderID				integer,
		@sSubSQL				varchar(MAX),
		@sJoinViews				varchar(MAX),
		@sSubViews				varchar(MAX),
		@sJoinTables			varchar(MAX),
		@fDelegateSelect		bit,
		@sWhereSQL				varchar(MAX),
		@iTempTableType			integer,
		@sTempTableName			sysname,
		@iTempTableID 			integer,
		@sTempRealSource		sysname,
		@sColumnName 			sysname,
		@iDataType 				integer,
		@iTableID 				integer,
		@fSelectGranted 		bit,
		@iIndex					integer,
		@iViewID				integer, 
		@sViewName				sysname,
		@iTempID				integer;
		
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');

	SET @sJoinViews = ','
	SET @sJoinTables = ',';
	SET @fDelegateSelect = 0;
	SET @sWhereSQL = '';

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	/* Get the EMPLOYEE table information. */
	SELECT @iEmployeeTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable';
	IF @iEmployeeTableID IS NULL SET @iEmployeeTableID = 0;

	SELECT @iOrderID = defaultOrderID, 
		@iTableType = tableType,
		@sTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iEmployeeTableID;

	/* Get the real source of the employee table. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sEmpRealSource = @sTableName;
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iEmployeeTableID
			AND [role] = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sEmpRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sEmpRealSource = left(@sEmpRealSource, 255);
		END
	END	
	
	SET @sExecString = 'SELECT ';
	SET @iColumnCount = 0;

	/* Create a temporary table to hold the find columns that the user can see. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID, t.tableType, t.tableName
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	INNER JOIN ASRSysTables t ON c.tableID = t.tableID
	WHERE oi.orderID = @iOrderID
		AND oi.type = 'F';

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName 
					FROM ASRSysViews 
					WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTempTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sTempRealSource = left(@sTempRealSource, 255);

				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					CASE protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND syscolumns.name <> 'timestamp'
					AND sysobjects.name =@sTempRealSource
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	END
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.columnName, c.dataType, c.tableID, t.tableType, t.tableName
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
			AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the real source of the employee table. */
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			SET @sTempRealSource = @sTempTableName;
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sTempRealSource = left(@sTempRealSource, 255);
			END
		END	

		SELECT @fSelectGranted = selectGranted
		FROM @columnPermissions
		WHERE tableID = @iTableID
			AND tableViewName = @sTempRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1
		BEGIN
			/* Add the column code to the 'select' string. */
			SET @sTempString = CASE 
					WHEN @iColumnCount > 0 THEN ','
					ELSE ''
				END +
				@sTempRealSource + '.' + @sColumnName;
			SET @sExecString = @sExecString + @sTempString;
			SET @iColumnCount = @iColumnCount + 1;
				
			IF @iTableID = @iEmployeeTableID
			BEGIN
				SET @fDelegateSelect = 1;
			END 
			ELSE
			BEGIN
				/* Add the table to the list of join tables if required. */
				SELECT @iIndex = CHARINDEX(',' + @sTempRealSource + ',', @sJoinTables);
				IF @iIndex = 0 SET @sJoinTables = @sJoinTables + @sTempRealSource + ',';
			END
		END
		ELSE
		BEGIN
			/* The column CANNOT be read from the Delegate table, or directly from a parent table.
			Try to read it from the views on the table. */
			SET @sSubViews = ',';

			DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT viewID,
				viewName
			FROM ASRSysViews
			WHERE viewTableID = @iTableID;

			OPEN viewsCursor;
			FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @fSelectGranted = 0;

				SELECT @fSelectGranted = selectGranted
				FROM @columnPermissions
				WHERE tableID = @iTableID
					AND tableViewName = @sViewName
					AND columnName = @sColumnName;

				IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

				IF @fSelectGranted = 1	
				BEGIN
					/* Add the view to the list of join views if required. */
					SELECT @iIndex = CHARINDEX(',' + @sViewName + ',', @sJoinViews);
					IF @iIndex = 0 SET @sJoinViews = @sJoinViews + @sViewName + ',';

					SET @sSubViews = @sSubViews + @sViewName + ',';
				END

				FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			END
			CLOSE viewsCursor;
			DEALLOCATE viewsCursor;

			IF len(@sSubViews) > 1
			BEGIN
				SET @sSubSQL = '';

				WHILE len(@sSubViews) > 1
				BEGIN
					SELECT @iIndex = charindex(',', @sSubViews, 2);
					SET @sViewName = substring(@sSubViews, 2, @iIndex - 2);
					SET @sSubViews = substring(@sSubViews, @iIndex, len(@sSubViews) -@iIndex + 1);

					IF len(@sSubSQL) > 0 SET @sSubSQL = @sSubSQL + ',';
					SET @sSubSQL = @sSubSQL + @sViewName + '.' + @sColumnName;
				END

				SET @sSubSQL = 'COALESCE(' + @sSubSQL + ') AS [' + @sColumnName + ']';
                
				/* Add the column code to the 'select' string. */
				SET @sTempString = CASE 
						WHEN @iColumnCount > 0 THEN ','
						ELSE ''
					END +
					@sSubSQL;

				SET @sExecString = @sExecString + @sTempString;
				SET @iColumnCount = @iColumnCount + 1;
			END
		END

		FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName;
	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	/* Add the ID column. */
	SET @iColumnCount = @iColumnCount + 1;
	SET @sTempString = ',' +
		@sEmpRealSource + '.id' +
		' FROM ' + @sEmpRealSource;
	SET @sExecString = @sExecString + @sTempString;
        
	/* Join any other tables and views that are used. */
	WHILE len(@sJoinTables) > 1
	BEGIN
		SELECT @iIndex = charindex(',', @sJoinTables, 2);
		SET @sTableName = substring(@sJoinTables, 2, @iIndex - 2);
		SET @sJoinTables = substring(@sJoinTables, @iIndex, len(@sJoinTables) -@iIndex + 1);

		SELECT @iTempID = tableID
		FROM ASRSysTables
		WHERE tableName = @sTableName;

		SET @sTempString = ' LEFT OUTER JOIN ' + @sTableName +
			' ON ' + @sEmpRealSource + '.ID_' + convert(varchar(8000), @iTempID) + ' = ' + @sTableName + '.ID';
		SET @sExecString = @sExecString + @sTempString;

	END

	WHILE len(@sJoinViews) > 1
	BEGIN
		SELECT @iIndex = charindex(',', @sJoinViews, 2);
		SET @sViewName = substring(@sJoinViews, 2, @iIndex - 2);
		SET @sJoinViews = substring(@sJoinViews, @iIndex, len(@sJoinViews) -@iIndex + 1);

		SELECT @iTempID = viewTableID
		FROM ASRSysViews
		WHERE viewName = @sViewName;

		IF @iTempID = @iEmployeeTableID
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sViewName +
				' ON ' + @sEmpRealSource + '.ID = ' + @sViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;

			IF @fDelegateSelect = 0
			BEGIN
				SET @sWhereSQL = @sWhereSQL + 
					CASE
						WHEN len(@sWhereSQL) > 0 THEN ' OR ('
						ELSE '('
					END +
					@sEmpRealSource + '.ID IN (SELECT ID FROM ' + @sViewName +  '))';
			END
		END
		ELSE
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sViewName +
				' ON ' + @sEmpRealSource + '.ID_' + convert(varchar(8000), @iTempID) + ' = ' + @sViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;
		END
	END

	IF len(@sWhereSQL) > 0
	BEGIN
		SET @sTempString = ' WHERE (' + @sWhereSQL + ')';
		SET @sExecString = @sExecString + @sTempString;
	END
	
	/* Get the list of selected IDs. */
	
	IF len(@psSelectedIDs) = 0 SET @psSelectedIDs = '0';
	
	IF UPPER(@psSelectionType) = 'PICKLIST'
	BEGIN
		DECLARE picklistCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT recordID
		FROM ASRSysPicklistItems
		WHERE picklistID = @piSelectionID;
	
		OPEN picklistCursor;
		FETCH NEXT FROM picklistCursor INTO @iID;

		WHILE (@@fetch_status = 0)
		BEGIN
			SET @psSelectedIDs = @psSelectedIDs + ',' + convert(varchar(255), @iID);
			FETCH NEXT FROM picklistCursor INTO @iID;
		END
		CLOSE picklistCursor;
		DEALLOCATE picklistCursor;
	END
	
	/* Get the required find records. */
	SET @sTempString = CASE
			WHEN (charindex(' WHERE ', @sExecString) > 0) THEN ' AND ('
			ELSE ' WHERE ('
		END +
		'(' + @sEmpRealSource + '.id IN (' + @psSelectedIDs + '))';
		
	SET @sExecString = @sExecString + @sTempString;

	IF (UPPER(@psSelectionType) = 'FILTER') AND (len(@psPromptSQL) > 0)
	BEGIN
		SET @sTempString = ' OR (' + 
			convert(varchar(255), @sEmpRealSource) + '.id IN (' + @psPromptSQL + '))';
		SET @sExecString = @sExecString + @sTempString;

	END

	SET @sTempString = ') ORDER BY 1';
	SET @sExecString = @sExecString + @sTempString;
		
	/* Count the number of commas before the ' FROM ' to see how many columns are in the select statement. */
	SET @iTemp = 2;
	WHILE @iTemp <= @iColumnCount
	BEGIN
		SET @sTempString = ',' + convert(varchar(8000), @iTemp);
		SET @sExecString = @sExecString + @sTempString;
		SET @iTemp = @iTemp + 1;
	END

	-- Return generated SQL	
	EXEC sp_executeSQL @sExecString;
	
END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTransferCourseRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTransferCourseRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTransferCourseRecords] (
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@psCourseTitle 		varchar(MAX),
	@piCourseRecordID	integer,
	@pfError 			bit 		OUTPUT,
	@piRecordsRequired	integer,
	@pfFirstPage		bit			OUTPUT,
	@pfLastPage			bit			OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer		OUTPUT,
	@psAction			varchar(255),
	@piTotalRecCount	integer		OUTPUT,
	@piFirstRecPos		integer		OUTPUT,
	@piCurrentRecCount	integer,
	@piColumnSize		integer		OUTPUT,
	@piColumnDecimals	integer		OUTPUT
)
AS
BEGIN
	/* Return a recordset of the link find records for the current user, given the table/view and order IDs.
		@piTableID = the ID of the table on which the find is based.
		@piViewID = the ID of the view on which the find is based.
		@piOrderID = the ID of the order we are using.
		@pfError = 1 if errors occured in getting the find records. Else 0.
	*/
	SET NOCOUNT ON;
	
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@iDataType 			integer,
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(4),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@fWhereDone			bit,
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@iCourseStartDateColumnID	integer,
		@sCourseStartDateColumnName	sysname,
		@sCourseCancelDateColumnID	integer,
		@sCourseCancelDateColumnName	sysname,
		@iGetCount			integer,
		@iColSize			integer,
		@iColDecs			integer,
		@sActualUserName	sysname;

	/* Initialise variables. */
	SET @pfError = 0
	SET @sRealSource = ''
	SET @sSelectSQL = ''
	SET @sOrderSQL = ''
	SET @fSelectDenied = 0
	SET @sExecString = ''
	SET @sDESCstring = ' DESC'
	SET @fFirstColumnAsc = 1
	SET @sFirstColCode = ''
	SET @sReverseOrderSQL = ''
	SET @fWhereDone = 0

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''')
	IF len(@psCourseTitle) > 0 SET @psCourseTitle = replace(@psCourseTitle, '''', '''''')

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle'
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = ''

	SELECT @iCourseStartDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseStartDate'
	IF @iCourseStartDateColumnID IS NULL SET @iCourseStartDateColumnID = 0

	IF @iCourseStartDateColumnID > 0 
	BEGIN
		SELECT @sCourseStartDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseStartDateColumnID
	END
	IF @sCourseStartDateColumnName IS NULL SET @sCourseStartDateColumnName = ''

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST'
	END

	/* Get Cancel date Column*/
	SELECT @sCourseCancelDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseCancelDate'
	IF @sCourseCancelDateColumnID IS NULL SET @sCourseCancelDateColumnID = 0
	IF @sCourseCancelDateColumnID > 0 
	BEGIN
		SELECT @sCourseCancelDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @sCourseCancelDateColumnID
	END
	IF @sCourseCancelDateColumnName IS NULL SET @sCourseCancelDateColumnName = ''

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseTitleColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseStartDateColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending, oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
	
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE'

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +
						' ELSE NULL END'

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END
						SET @sSelectSQL = @sSelectSQL + @sTempString
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType
							SET @fFirstColumnAsc = @fAscending
							SET @sFirstColCode = @sSubString
							SET @piColumnSize = @iColSize
							SET @piColumnDecimals = @iColDecs
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE

								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END				
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID'

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL

		SET @iLastCharIndex = 0
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL)
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', '
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', '
			END

			SET @iLastCharIndex = @iCharIndex
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1)
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex)
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource +
		' WHERE (' +
		@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + @psCourseTitle + ''' AND '	+
		@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
		@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL AND ' + 
		@sRealSource + '.id <> ' + convert(nvarchar(100), @piCourseRecordID) + ')'

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	IF (len(@sSelectSQL) > 0)
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID'
		SET @sSelectSQL = @sSelectSQL + @sTempString

		SET @sExecString = 'SELECT ' 

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' '
			SET @sExecString = @sExecString + @sTempString
		END

		SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'
			SET @sExecString = @sExecString + @sTempString

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @fWhereDone = 1

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			SET @fWhereDone = 1
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			SET @fWhereDone = 1

			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired				
			END
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		/* Add the filter code. */
		SET @sTempString = ' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + @psCourseTitle + ''' AND '	+
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
			@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL AND ' + 
			@sRealSource + '.id <> ' + convert(nvarchar(100), @piCourseRecordID) + ')'
		SET @sExecString = @sExecString + @sTempString

		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			SET @fWhereDone = 1
			SET @sLocateCode = ' AND (' + @sFirstColCode 

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL'
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL'
				END
			END

			SET @sLocateCode = @sLocateCode + ')'

			SET @sTempString = @sLocateCode
			SET @sExecString = @sExecString + @sTempString
		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL
		SET @sExecString = @sExecString + @sTempString
	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1
		SET @pfFirstPage = 1
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount
		SET @pfFirstPage = 0
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 1
	END
	
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource 

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		SET @sTempExecString = @sTempExecString + 
			' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + @psCourseTitle + ''' AND '	+
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
			@sRealSource + '.' + @sCourseCancelDateColumnName + ' IS NULL AND ' + 
			@sRealSource + '.id <> ' + convert(nvarchar(100), @piCourseRecordID) + ')' + @sLocateCode
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (len(@sExecString) > 0)
	BEGIN
		EXECUTE sp_executeSQL @sExecString;
	END
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetDefaultOrderColumns]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetDefaultOrderColumns]
GO


CREATE PROCEDURE [dbo].[sp_ASRIntGetDefaultOrderColumns] (
	@piTableID				integer,
	@psErrorMsg 			varchar(max)	OUTPUT,
	@ps1000SeparatorCols 	varchar(8000)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the 'employee' table find columns that the user has 'read' permission on. */
	DECLARE 
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iOrderID			integer,
		@sColumnName 		sysname,
		@iDataType 			integer,
		@iTableID 			integer,
		@iCount				integer,
		@sTemp				sysname,
		@iIndex				integer,
		@sRealSource		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@iTempTableType		integer,
		@sTempTableName		sysname,
		@iChildViewID		integer,
		@sTempRealSource	sysname,
		@iViewID			integer, 
		@sViewName			sysname,
		@iTempID			integer,
		@sActualUserName	sysname,
		@iTempTableID 		integer,
		@fSelectGranted 	bit,
		@bUse1000Separator	bit,
		@fSomeReadable		bit,
		@fViewReadable		bit;

	SET @psErrorMsg = '';
	SET @ps1000SeparatorCols = '';
	SET @fSomeReadable = 0;

	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @iOrderID = defaultOrderID, 
		@iTableType = tableType,
		@sTableName = tableName
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @piTableID;

	/* Get the real source of the employee table. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sRealSource = @sTableName;
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM [dbo].[ASRSysChildViews2]
		WHERE tableID = @piTableID
			AND [role] = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(CONVERT(varchar(255),@sTableName), ' ', '_') +
				'#' + replace(CONVERT(varchar(255),@sUserGroupName), ' ', '_')
			SET @sRealSource = left(CONVERT(varchar(255),@sRealSource), 255);
		END
	END	
	
	/* Create a temporary table to hold the find columns that the user can see. */
	DECLARE @findColumns TABLE
		(columnName	sysname,
		dataType	integer)	

	DECLARE @columnPermissions TABLE
		(tableID		integer,
		tableViewName	sysname,
		columnName	sysname,
		selectGranted	bit);

	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT DISTINCT c.tableID, t.tableType, t.tableName
		FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON c.tableID = t.tableID
		WHERE oi.orderID = @iOrderID
			AND oi.type = 'F';

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName 
					FROM ASRSysViews 
					WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @iTempTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(500), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sTempRealSource = left(@sTempRealSource, 255);

				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					CASE protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND syscolumns.name <> 'timestamp'
					AND sysobjects.name =@sTempRealSource
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.columnName, c.dataType, c.tableID, t.tableType, t.tableName, c.Use1000Separator
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName, @bUse1000Separator;

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @psErrorMsg = 'Unable to read the table''s default order.';
		RETURN;
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		/* Get the real source of the table. */
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			SET @sTempRealSource = @sTempTableName;
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM [dbo].[ASRSysChildViews2]
			WHERE tableID = @iTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(CONVERT(varchar(255),@sTempTableName), ' ', '_') +
					'#' + replace(CONVERT(varchar(255),@sUserGroupName), ' ', '_');
				SET @sTempRealSource = left(CONVERT(varchar(8000),@sTempRealSource), 255);
			END
		END	

		SELECT @fSelectGranted = selectGranted
		FROM @columnPermissions
		WHERE tableID = @iTableID
			AND tableViewName = @sTempRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
		
		IF @fSelectGranted = 1
		BEGIN
			SET @fSomeReadable = 1;

			SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
				CASE
					WHEN @bUse1000Separator = 1 THEN '1'
					ELSE '0'
				END;

			INSERT INTO @findColumns (columnName, dataType) VALUES (@sColumnName, @iDataType);
		END
		ELSE
		BEGIN
			/* The column CANNOT be read from the table, or directly from a parent table.
			Try to read it from the views on the table. */
			SET @fViewReadable = 0;

			DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT viewID,
				viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewTableID = @iTableID;

			OPEN viewsCursor;
			FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @fSelectGranted = selectGranted
				FROM @columnPermissions
				WHERE tableID = @iTableID
					AND tableViewName = @sViewName
					AND columnName = @sColumnName;

				IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

				IF @fSelectGranted = 1	
				BEGIN
					SET @fViewReadable = 1;
				END

				FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			END
			CLOSE viewsCursor;
			DEALLOCATE viewsCursor;

			IF @fViewReadable = 1
			BEGIN
				INSERT INTO @findColumns (columnName, dataType) VALUES (@sColumnName, @iDataType);

				SET @fSomeReadable = 1;

				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END;
			END
		END

		FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName, @bUse1000Separator;

	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	IF @fSomeReadable = 0
	BEGIN
		/* Flag to the user that they cannot see any of the find columns. */
		SET @psErrorMsg = 'You do not have permission to read the table''s find columns.';
	END
	ELSE
	BEGIN
		/* Add the ID column. */
		INSERT INTO @findColumns (columnName, dataType) VALUES ('ID', 4);
	END

	SELECT * FROM @findColumns;
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetLinkFindRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].sp_ASRIntGetLinkFindRecords
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetLinkFindRecords]
	(
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@pfError 			bit 					OUTPUT,
	@piRecordsRequired	integer,
	@pfFirstPage		bit						OUTPUT,
	@pfLastPage			bit						OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer					OUTPUT,
	@psAction			varchar(100),
	@piTotalRecCount	integer					OUTPUT,
	@piFirstRecPos		integer					OUTPUT,
	@piCurrentRecCount	integer,
	@psExcludedIDs		varchar(MAX),
	@piColumnSize		integer					OUTPUT,
	@piColumnDecimals	integer					OUTPUT
	)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the link find records for the current user, given the table/view and order IDs.
		@piTableID = the ID of the table on which the find is based.
		@piViewID = the ID of the view on which the find is based.
		@piOrderID = the ID of the order we are using.
		@pfError = 1 if errors occured in getting the find records. Else 0.
	*/
	DECLARE 
		@iUserGroupID			integer,
		@sUserGroupName			sysname,
		@iTableType				integer,
		@sTableName				sysname,
		@sRealSource 			sysname,
		@iChildViewID 			integer,
		@iTempTableID 			integer,
		@iColumnTableID			integer,
		@iColumnID 				integer,
		@sColumnName 			sysname,
		@sColumnTableName		sysname,
		@fAscending 			bit,
		@sType	 				varchar(10),
		@iDataType 				integer,
		@fSelectGranted 		bit,
		@sSelectSQL				varchar(MAX),
		@sOrderSQL 				varchar(MAX),
		@sExecString			nvarchar(MAX),
		@sTempString			varchar(MAX),
		@fSelectDenied			bit,
		@iTempCount 			integer,
		@sSubString				varchar(MAX),
		@sViewName 				varchar(255),
		@sTableViewName 		sysname,
		@iJoinTableID 			integer,
		@iTemp					integer,
		@sRemainingSQL			varchar(MAX),
		@iLastCharIndex			integer,
		@iCharIndex 			integer,
		@sDESCstring			varchar(5),
		@sTempExecString		nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc		bit,
		@sFirstColCode			varchar(MAX),
		@sLocateCode			varchar(MAX),
		@sReverseOrderSQL 		varchar(MAX),
		@iCount					integer,
		@iGetCount				integer,
		@iColSize				integer,
		@iColDecs				integer,
		@sActualUserName		sysname;

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''');
	IF len(@psExcludedIDs) > 0 SET @psExcludedIDs = replace(@psExcludedIDs, '''', '''''');

	/* Initialise variables. */
	SET @pfError = 0;
	SET @sRealSource = '';
	SET @sSelectSQL = '';
	SET @sOrderSQL = '';
	SET @fSelectDenied = 0;
	SET @sExecString = '';
	SET @sDESCstring = ' DESC';
	SET @fFirstColumnAsc = 1;
	SET @sFirstColCode = '';
	SET @sReverseOrderSQL = '';
	IF len(@psExcludedIDs) = 0 SET @psExcludedIDs = '0';
	
	/* Get the current user's group ID. */
	EXEC [DBO].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST';
	END

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM [dbo].[ASRSysTables]
	WHERE ASRSysTables.tableID = @piTableID;

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM [dbo].[ASRSysViews]
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM [dbo].[ASRSysChildViews2]
		WHERE tableID = @piTableID
			AND role = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1;
		RETURN;
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID		integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID		integer,
		tableViewName	sysname,
		columnName	sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 

	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending, oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.datatype <> -3 AND c.datatype <> -4
	ORDER BY oi.sequence

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN

		SET @pfError = 1
		RETURN
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName;
					SET @sSelectSQL = @sSelectSQL + @sTempString;
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName;
					SET @sSelectSQL = @sSelectSQL + @sTempString;
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)

				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = '';

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1;

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE';

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName;

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId);
					END

					FETCH NEXT FROM viewCursor INTO @sViewName;
				END
				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +	' ELSE NULL END';

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END;
						SET @sSelectSQL = @sSelectSQL + @sTempString;
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType
							SET @piColumnSize = @iColSize
							SET @piColumnDecimals = @iColDecs
							SET @fFirstColumnAsc = @fAscending
							SET @sFirstColCode = @sSubString
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END				
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID'

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL

		SET @iLastCharIndex = 0
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL)
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', '
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', '
			END

			SET @iLastCharIndex = @iCharIndex
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1)
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex)
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring

	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;
	IF @psExcludedIDs <> '0' SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID NOT IN (' + @psExcludedIDs + ')';

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	IF (len(@sSelectSQL) > 0)
	BEGIN
	
		SET @sTempString = ',' + @sRealSource + '.ID';
		SET @sSelectSQL = @sSelectSQL + @sTempString;
		SET @sExecString = 'SELECT ';

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE'
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(MAX), @piRecordsRequired) + ' ';
			SET @sExecString = @sExecString + @sTempString;
		END

		SET @sExecString = @sExecString + @sSelectSQL + ' FROM ' + @sRealSource;

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';
			SET @sExecString = @sExecString + @sTempString;

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +	' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired  - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END
		
		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1;
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired;
			END

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
				
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource;
			SET @sExecString = @sExecString + @sTempString;
		END

		IF @psExcludedIDs <> '0' 
		BEGIN
			SET @sTempString = ' WHERE ' + @sRealSource + '.ID NOT IN (' + @psExcludedIDs + ')';
			SET @sExecString = @sExecString + @sTempString;
		END
		
		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')';
			SET @sExecString = @sExecString + @sTempString;
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			IF @psExcludedIDs <> '0'
			BEGIN
				SET @sLocateCode = ' AND (' + @sFirstColCode;
			END
			ELSE
			BEGIN
				SET @sLocateCode = ' WHERE (' + @sFirstColCode;
			END

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL';
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + '''';
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL';
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END;
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue;

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL';
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL';
				END

			END

			SET @sLocateCode = @sLocateCode + ')';
			SET @sTempString = @sLocateCode;
			SET @sExecString = @sExecString + @sTempString;
			
		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL;
		SET @sExecString = @sExecString + @sTempString;
		
	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1;
		SET @pfFirstPage = 1;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount;
		SET @pfFirstPage = 0;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount;
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END;
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1;
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1;
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
		SET @pfLastPage = 1;
	END

	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource;

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents;

		OPEN joinCursor;
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID';

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
		END
		CLOSE joinCursor;
		DEALLOCATE joinCursor;

		IF @psExcludedIDs <> '0' SET @sTempExecString = @sTempExecString + ' WHERE ' + @sRealSource + '.ID NOT IN (' + @psExcludedIDs + ')';
		SET @sTempExecString = @sTempExecString + @sLocateCode;

		SET @sTempParamDefinition = N'@recordCount integer OUTPUT';
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT;

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1;
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1;
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END;
			
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END;
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (LEN(@sExecString) > 0)
		EXECUTE sp_executeSQL @sExecString;

END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetOrderSQL]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetOrderSQL]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetOrderSQL] (
	@piScreenID 	integer,
	@piViewID 		integer,
	@piOrderID		integer,
	@psFromDef		varchar(MAX) OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iScreenTableID		integer,
		@iScreenTableType	integer,
		@sScreenTableName	varchar(255),
		@fSysSecMgr			bit,
		@sRealSource 		varchar(255),
		@sParentSource		varchar(255),
		@iChildViewID 		integer,
		@sJoinCode 			varchar(MAX),
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@iTempCount 		integer,
		@sViewName 			varchar(255),
		@fAscending 		bit,
		@sTableViewName 	varchar(255),
		@iJoinTableID 		integer,
		@sParentRealSource	varchar(255),
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@sActualUserName	sysname;

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the table type and name. */
	SELECT @iScreenTableID = ASRSysScreens.tableID,
		@iScreenTableType = ASRSysTables.tableType,
		@sScreenTableName = ASRSysTables.tableName
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID

	/* Check if the current user is a System or Security manager. */
	IF UPPER(LTRIM(RTRIM(SYSTEM_USER))) = 'SA'
	BEGIN
		SET @fSysSecMgr = 1
	END
	ELSE
	BEGIN	

		SELECT @fSysSecMgr = CASE WHEN count(*) > 0 THEN 1 ELSE 0 END
		FROM ASRSysGroupPermissions
		INNER JOIN ASRSysPermissionItems ON ASRSysGroupPermissions.itemID = ASRSysPermissionItems.itemID
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		INNER JOIN sysusers ON ASRSysGroupPermissions.groupName = sysusers.name
		WHERE sysusers.uid = @iUserGroupID
			AND (ASRSysPermissionItems.itemKey = 'SYSTEMMANAGER'
			OR ASRSysPermissionItems.itemKey = 'SECURITYMANAGER')
			AND ASRSysGroupPermissions.permitted = 1
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'
	END

	/* Get the real source of the given screen's table/view. */
	IF @iScreenTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID	
		END
		ELSE
		BEGIN
			/* RealSource is the table. */	
			SET @sRealSource = @sScreenTableName
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iScreenTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sScreenTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	/* Initialise the select and order parameters. */
	SET @psFromDef = ''
	SET @sJoinCode = ''

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		granted			bit);

	/* Loop through the controls used in the screen, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID
	FROM ASRSysControls
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0
	UNION
	SELECT DISTINCT c.tableID 
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.type = 'O' AND oi.orderID = @piOrderID 

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @fSysSecMgr =1
		BEGIN
			IF @iTempTableID = @iScreenTableID
			BEGIN
				/* Base table - use the real source. */
				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					@sRealSource,
					ASRSysColumns.columnName,
					1
				FROM ASRSysColumns
				WHERE ASRSysColumns.tableID = @iTempTableID
			END
			ELSE
			BEGIN
				/* Parent of the base table - get permissions for the table, and any associated views. */
				SELECT @iParentTableType = tableType,
					@sParentSource = tableName
				FROM ASRSysTables
				WHERE tableID = @iTempTableID

				IF @iParentTableType <> 2 
				BEGIN
					/* ie. top-level or lookup */
					INSERT INTO @columnPermissions
					SELECT 
						@iTempTableID,
						@sParentSource,
						ASRSysColumns.columnName,
						1
					FROM ASRSysColumns
					WHERE ASRSysColumns.tableID = @iTempTableID
				END	
				ELSE
				BEGIN
					/* RealSource is the child view on the table which is derived from full access on the table's parents. */	
					SELECT @iChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @iTempTableID
						AND role = @sUserGroupName
						
					IF @iChildViewID IS null SET @iChildViewID = 0
						
					IF @iChildViewID > 0 
					BEGIN
						SET @sParentSource = 'ASRSysCV' + 
							convert(varchar(1000), @iChildViewID) +
							'#' + replace(@sParentSource, ' ', '_') +
							'#' + replace(@sUserGroupName, ' ', '_')
						SET @sParentSource = left(@sParentSource, 255)
					END

					INSERT INTO @columnPermissions
					SELECT 
						@iTempTableID,
						@sParentSource,
						ASRSysColumns.columnName,
						1
					FROM ASRSysColumns
					WHERE ASRSysColumns.tableID = @iTempTableID
				END
			END
		END
		ELSE
		BEGIN
			IF @iTempTableID = @iScreenTableID
			BEGIN
				/* Base table - use the real source. */
				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					@sRealSource,
					syscolumns.name,
					CASE protectType
						WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND syscolumns.name <> 'timestamp'
					AND sysobjects.name = @sRealSource
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			END
			ELSE
			BEGIN
				/* Parent of the base table - get permissions for the table, and any associated views. */
				SELECT @iParentTableType = tableType,
					@sParentTableName = tableName
				FROM ASRSysTables
				WHERE tableID = @iTempTableID

				IF @iParentTableType <> 2 
				BEGIN
					/* ie. top-level or lookup */
					INSERT INTO @columnPermissions
					SELECT 
						@iTempTableID,
						sysobjects.name,
						syscolumns.name,
						CASE protectType
						        	WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM sysprotects
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.action = 193
						AND syscolumns.name <> 'timestamp'
						AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @iTempTableID 
							UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				END	
				ELSE
				BEGIN
					/* Get permitted child view on the parent table. */
					SELECT @iChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @iTempTableID
						AND role = @sUserGroupName
						
					IF @iChildViewID IS null SET @iChildViewID = 0
						
					IF @iChildViewID > 0 
					BEGIN
						SET @sParentRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iChildViewID) +
							'#' + replace(@sParentTableName, ' ', '_') +
							'#' + replace(@sUserGroupName, ' ', '_')
						SET @sParentRealSource = left(@sParentRealSource, 255)

						INSERT INTO @columnPermissions
						SELECT 
							@iTempTableID,
							@sParentRealSource,
							syscolumns.name,
							CASE protectType
								WHEN 205 THEN 1
								WHEN 204 THEN 1
								ELSE 0
							END 
						FROM sysprotects
						INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
						INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
						WHERE sysprotects.uid = @iUserGroupID
							AND sysprotects.action = 193 
							AND syscolumns.name <> 'timestamp'
							AND sysobjects.name = @sParentRealSource
							AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
							OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
							AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
					END
				END
			END
		END
		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	/* Create a temporary table of the column info for all columns used in the screen controls. */
	/* Populate the temporary table with info for all columns used in the screen controls. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID, 
		ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @iColumnTableID <> @iScreenTableID
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableID
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1 

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewName = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableID)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor
			END
		END

		FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor

	/* Create the order string. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID	AND oi.type = 'O'
			AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @iColumnTableId = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Create the FROM code. */
	SET @psFromDef = @sRealSource + '	'
	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName, 
		tableID
	FROM @joinParents

	OPEN joinCursor
	FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psFromDef = @psFromDef + @sTableViewName + '	' + convert(varchar(100), @iJoinTableID) + '	'

		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
	END
	CLOSE joinCursor
	DEALLOCATE joinCursor

END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetScreenControlsString2]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetScreenControlsString2]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetScreenControlsString2] (
	@piScreenID 	integer,
	@piViewID 		integer,
	@psSelectSQL	varchar(MAX) OUTPUT,
	@psFromDef		varchar(MAX) OUTPUT,
	@piOrderID		integer	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@iScreenTableID		integer,
		@iScreenTableType	integer,
		@sScreenTableName	varchar(255),
		@iScreenOrderID 	integer,
		@sRealSource 		varchar(255),
		@iChildViewID 		integer,
		@sJoinCode 			varchar(MAX),
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@fUpdateGranted 	bit,
		@sSelectString 		varchar(MAX),
		@iTempCount 		integer,
		@sViewName 			varchar(255),
		@fAscending 		bit,
		@sTableViewName 	varchar(255),
		@iJoinTableID 		integer,
		@sParentRealSource	varchar(255),
		@iParentChildViewID	integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iColumnType		integer,
		@iLinkTableID		integer,
		@lngPermissionCount	integer,
		@iLinkChildViewID	integer,
		@sLinkRealSource	varchar(255),
		@sLinkTableName		varchar(255),
		@iLinkTableType		integer,
		@sNewBit			varchar(max),
		@iID				integer,
		@iCount				integer,
		@iUserType			integer,
		@sRoleName			sysname,
		@iEmployeeTableID	integer,
		@sActualUserName	sysname,
		@AppName varchar(50),
		@ItemKey varchar(20);

	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;


	DECLARE @SysProtects TABLE([ID] int, Columns varbinary(8000)
								, [Action] tinyint
								, ProtectType tinyint)
	INSERT INTO @SysProtects
	SELECT p.[ID], p.[Columns], p.[Action], p.ProtectType FROM ASRSysProtectsCache p
		INNER JOIN SysColumns c ON (c.id = p.id
			AND c.[Name] = 'timestamp'
			AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
			AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) != 0)
			OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
			AND (convert(int,substring(p.columns,c.colid/8+1,1))&power(2,c.colid&7)) = 0)))
		WHERE p.UID = @iUserGroupID
			AND [ProtectType] IN (204, 205)
			AND [Action] IN (193, 197);


	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @JoinParents TABLE(tableViewName	sysname,
								tableID		integer);

	/* Create a temporary table of the column permissions for all tables/views used in the screen. */
	DECLARE @ColumnPermissions TABLE(tableID		integer,
										tableViewName	sysname,
										columnName	sysname,
										action		int,		
										granted		bit);


	/* Get the table type and name. */
	SELECT @iScreenTableID = ASRSysScreens.tableID,
		@iScreenTableType = ASRSysTables.tableType,
		@sScreenTableName = ASRSysTables.tableName,
		@iScreenOrderID = 
				CASE 
					WHEN ASRSysScreens.orderID > 0 THEN ASRSysScreens.orderID
					ELSE ASRSysTables.defaultOrderID 
				END
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID;

	IF @iScreenOrderID IS NULL SET @iScreenOrderID = 0;

	IF @piOrderID <= 0 SET @piOrderID = @iScreenOrderID;

	/* Get the real source of the given screen's table/view. */
	IF @iScreenTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			/* RealSource is the table. */	
			SET @sRealSource = @sScreenTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iScreenTableID
			AND role = @sRoleName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sScreenTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	/* Initialise the select and order parameters. */
	SET @psSelectSQL = '';
	SET @psFromDef = '';
	SET @sJoinCode = '';

	/* Loop through the tables used in the screen, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID
	FROM ASRSysControls
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0
	UNION
	SELECT DISTINCT c.tableID 
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.type = 'O' 
		AND oi.orderID = @piOrderID;

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @iScreenTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @ColumnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				p.action,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN sysobjects ON p.id = sysobjects.id
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			SELECT @iParentTableType = tableType,
				@sParentTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @iTempTableID

			IF @iParentTableType <> 2 /* ie. top-level or lookup */
			BEGIN
				INSERT INTO @ColumnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					p.[action],
					CASE p.protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @sysprotects p
				INNER JOIN sysobjects ON p.id = sysobjects.id
				INNER JOIN syscolumns ON p.id = syscolumns.id
				WHERE syscolumns.name <> 'timestamp'
					AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @iTempTableID 
						UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			END
			ELSE
			BEGIN
				/* Get permitted child view on the parent table. */
				SELECT @iParentChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @iTempTableID
					AND role = @sRoleName
					
				IF @iParentChildViewID IS null SET @iParentChildViewID = 0
					
				IF @iParentChildViewID > 0 
				BEGIN
					SET @sParentRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iParentChildViewID) +
						'#' + replace(@sParentTableName, ' ', '_') +
						'#' + replace(@sRoleName, ' ', '_')
					SET @sParentRealSource = left(@sParentRealSource, 255)

					INSERT INTO @ColumnPermissions
					SELECT 
						@iTempTableID,
						@sParentRealSource,
						syscolumns.name,
						p.[action],
						CASE p.protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @sysprotects p
					INNER JOIN sysobjects ON p.id = sysobjects.id
					INNER JOIN syscolumns ON p.id = syscolumns.id
					WHERE syscolumns.name <> 'timestamp'
						AND sysobjects.name = @sParentRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
				END
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	SET @iUserType = 1

	/*Ascertain application name in order to select by correct item key  */
	SELECT @AppName = APP_NAME()
	IF @AppName = 'OPENHR SELF-SERVICE INTRANET'
	BEGIN
		SET @ItemKey = 'SSINTRANET'
	END
	ELSE
	BEGIN
		SET @ItemKey = 'INTRANET'
	END

	SELECT @iID = ASRSysPermissionItems.itemID
	FROM ASRSysPermissionItems
	INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
	WHERE ASRSysPermissionItems.itemKey = @ItemKey
		AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS'

	IF @iID IS NULL SET @iID = 0
	IF @iID > 0
	BEGIN
		/* The permission does exist in the current version so check if the user is granted this permission. */
		SELECT @iCount = count(ASRSysGroupPermissions.itemID)
		FROM ASRSysGroupPermissions 
		WHERE ASRSysGroupPermissions.itemID = @iID
			AND ASRSysGroupPermissions.groupName = @sRoleName
			AND ASRSysGroupPermissions.permitted = 1
			
		IF @iCount > 0
		BEGIN
			SET @iUserType = 0
		END
	END

	/* Get the EMPLOYEE table information. */
	SELECT @iEmployeeTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_PERSONNEL'
		AND parameterKey = 'Param_TablePersonnel'
	IF @iEmployeeTableID IS NULL SET @iEmployeeTableID = 0

	/* Create a temporary table of the column info for all columns used in the screen controls. */
	DECLARE @columnInfo TABLE
	(
		columnID	integer,
		selectGranted	bit,
		updateGranted	bit
	)

	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID, 
		ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType,
		ASRSysColumns.columnType,
		ASRSysColumns.linkTableID
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE screenID = @piScreenID
	AND ASRSysControls.columnID > 0

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
		SET @fUpdateGranted = 0

		IF @iColumnTableID = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193

			/* Get the update permission on the column. */
			SELECT @fUpdateGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 197

			/* If the column is a link column, ensure that the link table can be seen. */
			IF (@fUpdateGranted = 1) AND (@iColumnType = 4)
			BEGIN
				SELECT @sLinkTableName = tableName,
					@iLinkTableType = tableType
				FROM ASRSysTables
				WHERE tableID = @iLinkTableID

				IF @iLinkTableType = 1
				BEGIN
					/* Top-level table. */
					SELECT @lngPermissionCount = COUNT(sysprotects.uid)
					FROM sysprotects
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.action = 193
						AND sysprotects.protectType <> 206
						AND syscolumns.name <> 'timestamp'
						AND syscolumns.name <> 'ID'
						AND sysobjects.name = @sLinkTableName
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))

					IF @lngPermissionCount = 0 
					BEGIN
						/* No permission on the table itself check the views. */
						SELECT @lngPermissionCount = COUNT(ASRSysViews.viewTableID)
						FROM ASRSysViews
						INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
						INNER JOIN sysprotects ON sysobjects.id = sysprotects.id  
						WHERE ASRSysViews.viewTableID = @iLinkTableID
							AND sysprotects.uid = @iUserGroupID
							AND sysprotects.action = 193
							AND sysprotects.protecttype <> 206

						IF @lngPermissionCount = 0 SET @fUpdateGranted = 0
					END
				END
				ELSE
				BEGIN
					/* Child/history table. */
					SELECT @iLinkChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @iLinkTableID
						AND role = @sRoleName
						
					IF @iLinkChildViewID IS null SET @iLinkChildViewID = 0
						
					IF @iLinkChildViewID > 0 
					BEGIN
						SET @sLinkRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iLinkChildViewID) +
							'#' + replace(@sLinkTableName, ' ', '_') +
							'#' + replace(@sRoleName, ' ', '_')
						SET @sLinkRealSource = left(@sLinkRealSource, 255)
					END

					SELECT @lngPermissionCount = COUNT(sysobjects.name)
					FROM sysprotects 
					INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
					WHERE sysprotects.uid = @iUserGroupID
						AND sysprotects.protectType <> 206
						AND sysprotects.action = 193
						AND sysobjects.name = @sLinkRealSource
		
					IF @lngPermissionCount = 0 SET @fUpdateGranted = 0
				END
			END

			IF @fSelectGranted = 1 
			BEGIN
				/* Get the select string for the column. */
				IF len(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';
			
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(255), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193;

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				IF len(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';
	
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sColumnTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sColumnTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
			
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewName = @sColumnTableName;

				IF @iTempCount = 0
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
					
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sSelectString = '';

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableID
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND action = 193
					AND granted = 1;

				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)

				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1;

					IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';
	
					IF @iColumnDataType = 11 /* Date */
					BEGIN
						 /* Date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
					END
					ELSE
					BEGIN
						 /* Non-date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
					END

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
						FROM @JoinParents
						WHERE tableViewName = @sViewName;

					IF @iTempCount = 0
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableID);

					FETCH NEXT FROM viewCursor INTO @sViewName;
				END
				CLOSE viewCursor;
				DEALLOCATE viewCursor;

				IF len(@sSelectString) > 0
				BEGIN
					SET @sSelectString = @sSelectString +
						' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';

					IF len(@psSelectSQL) > 0 
						SET @psSelectSQL = @psSelectSQL + ',';

					SET @psSelectSQL = @psSelectSQL + @sSelectString;
				END
			END

			/* Reset the update permission on the column. */
			SET @fUpdateGranted = 0
		END

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0
		IF @fUpdateGranted IS NULL SET @fUpdateGranted = 0

		IF (@iUserType = 1) 
			AND (@iScreenTableType = 1)
			AND (@iScreenTableID <> @iEmployeeTableID)
		BEGIN
			SET @fUpdateGranted = 0
		END

		INSERT INTO @columnInfo (columnID, selectGranted, updateGranted)
			VALUES (@iColumnId, @fSelectGranted, @fUpdateGranted)

		FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID
	END
	CLOSE columnsCursor
	DEALLOCATE columnsCursor

	/* Create the order string. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID	AND oi.type = 'O'
			AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		IF @iColumnTableId = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @ColumnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @JoinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @ColumnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND action = 193
					AND granted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @JoinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the id and timestamp columns to the select string. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT ASRSysColumns.columnId, 
		ASRSysColumns.columnName
	FROM ASRSysColumns
	WHERE tableID = @iScreenTableID
		AND columnType = 3

	OPEN columnsCursor
	FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName
	WHILE (@@fetch_status = 0)
	BEGIN
		IF len(@psSelectSQL) > 0 
			SET @psSelectSQL = @psSelectSQL + ',';

		SET @sNewBit = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
		SET @psSelectSQL = @psSelectSQL + @sNewBit;

		FETCH NEXT FROM columnsCursor INTO @iColumnID, @sColumnName;
	END
	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;

	SET @sNewBit = ', CONVERT(integer, ' + @sRealSource + '.TimeStamp) AS timestamp ';
	SET @psSelectSQL = @psSelectSQL + @sNewBit;

	/* Create the FROM code. */
	SET @psFromDef = @sRealSource + '	'
	DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT tableViewName, tableID
		FROM @JoinParents;

	OPEN joinCursor;
	FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @psFromDef = @psFromDef + @sTableViewName + '	' + convert(varchar(100), @iJoinTableID) + '	';
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID;
	END
	CLOSE joinCursor;
	DEALLOCATE joinCursor;

	SELECT
		convert(varchar(MAX), case when ASRSysControls.pageNo IS null then '' else ASRSysControls.pageNo end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.tableID IS null then '' else ASRSysControls.tableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.columnID IS null then '' else ASRSysControls.columnID end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.controlType IS null then '' else ASRSysControls.controlType end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.topCoord IS null then '' else ASRSysControls.topCoord end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.leftCoord IS null then '' else ASRSysControls.leftCoord end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.height IS null then '' else ASRSysControls.height end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.width IS null then '' else ASRSysControls.width end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.caption IS null then '' else ASRSysControls.caption end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.backColor IS null then '' else ASRSysControls.backColor end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.foreColor IS null then '' else ASRSysControls.foreColor end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontName IS null then '' else ASRSysControls.fontName end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontSize IS null then '' else ASRSysControls.fontSize end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontBold IS null then '' else ASRSysControls.fontBold end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontItalic IS null then '' else ASRSysControls.fontItalic end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontStrikethru IS null then '' else ASRSysControls.fontStrikethru end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.fontUnderline IS null then '' else ASRSysControls.fontUnderline end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.displayType IS null then '' else ASRSysControls.displayType end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.tabIndex IS null then '' else ASRSysControls.tabIndex end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.borderStyle IS null then '' else ASRSysControls.borderStyle end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.alignment IS null then '' else ASRSysControls.alignment end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnName IS null then '' else ASRSysColumns.columnName end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnType IS null then '' else ASRSysColumns.columnType end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.datatype IS null then '' else ASRSysColumns.datatype end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.defaultValue IS null then '' else ASRSysColumns.defaultValue end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.size IS null then '' else convert(nvarchar(max),ASRSysColumns.size) end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.decimals IS null then '' else ASRSysColumns.decimals end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.lookupTableID IS null then '' else ASRSysColumns.lookupTableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.lookupColumnID IS null then '' else ASRSysColumns.lookupColumnID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerMinimum IS null then '' else ASRSysColumns.spinnerMinimum end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerMaximum IS null then '' else ASRSysColumns.spinnerMaximum end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.spinnerIncrement IS null then '' else ASRSysColumns.spinnerIncrement end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.mandatory IS null then '' else ASRSysColumns.mandatory end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.uniquechecktype IS null then '' when ASRSysColumns.uniquechecktype <> 0 then 1 else 0 end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.convertcase IS null then '' else ASRSysColumns.convertcase end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.mask IS null then '' else rtrim(ASRSysColumns.mask) end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.blankIfZero IS null then '' else ASRSysColumns.blankIfZero end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.multiline IS null then '' else ASRSysColumns.multiline end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.alignment IS null then '' else ASRSysColumns.alignment end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.dfltValueExprID IS null then '' else ASRSysColumns.dfltValueExprID end) + char(9) +
		convert(varchar(MAX), case when isnull(ASRSysColumns.readOnly,0) = 1 then 1 else CASE WHEN ASRSysColumns.tableid = @iScreenTableID THEN 0 ELSE 1 END end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.statusBarMessage IS null then '' else ASRSysColumns.statusBarMessage end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkTableID IS null then '' else ASRSysColumns.linkTableID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkOrderID IS null then '' else ASRSysColumns.linkOrderID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.linkViewID IS null then '' else ASRSysColumns.linkViewID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.Afdenabled IS null then '' else ASRSysColumns.Afdenabled end) + char(9) +
		convert(varchar(MAX), case when ASRSysTables.TableName IS null then '' else ASRSysTables.TableName end) + char(9) +
		convert(varchar(MAX), case when ci.selectGranted IS null then '' else ci.selectGranted end) + char(9) +
		convert(varchar(MAX), case when ci.updateGranted IS null then '' else ci.updateGranted end) + char(9) +
		'' + char(9) +
		convert(varchar(MAX), case when ASRSysControls.pictureID IS null then '' else ASRSysControls.pictureID end)+ char(9) +
		convert(varchar(MAX), case when ASRSysColumns.trimming IS null then '' else ASRSysColumns.trimming end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.Use1000Separator IS null then '' else ASRSysColumns.Use1000Separator end) + char(9) +	
		convert(varchar(MAX), case when ASRSysColumns.lookupFilterColumnID IS null then '' else ASRSysColumns.lookupFilterColumnID end) + char(9) +	
		convert(varchar(MAX), case when ASRSysColumns.LookupFilterValueID IS null then '' else ASRSysColumns.LookupFilterValueID end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.OLEType IS null then '' else ASRSysColumns.OLEType end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.MaxOLESizeEnabled IS null then '' else ASRSysColumns.MaxOLESizeEnabled end) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.MaxOLESize IS null then '' else ASRSysColumns.MaxOLESize end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateTo IS null then '' else ASRSysControls.NavigateTo end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateIn IS null then '' else ASRSysControls.NavigateIn end) + char(9) +
		convert(varchar(MAX), case when ASRSysControls.NavigateOnSave IS null then '' else ASRSysControls.NavigateOnSave end) + char(9) +
		convert(varchar(MAX), case when isnull(ASRSysControls.readOnly,0) = 1 then 1 else 0 end)
		AS [controlDefinition],
		ASRSysControls.pageNo AS [pageNo],
		ASRSysControls.controlLevel AS [controlLevel],
		ASRSysControls.tabIndex AS [tabIndex]
	FROM ASRSysControls
	LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
	LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	LEFT OUTER JOIN @columnInfo ci ON ASRSysColumns.columnId = ci.columnID
	WHERE screenID = @piScreenID
	UNION
	SELECT 
		convert(varchar(MAX), -1) + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnId IS null then '' else ASRSysColumns.columnId end)  + char(9) +
		convert(varchar(MAX), case when ASRSysColumns.columnName IS null then '' else ASRSysColumns.columnName end) 
		AS [controlDefinition],
		0 AS [pageNo],
		0 AS [controlLevel],
		0 AS [tabIndex]
	FROM ASRSysColumns
	WHERE tableID = @iScreenTableID
		AND columnType = 3
	ORDER BY [pageNo],
		[controlLevel] DESC, 
		[tabIndex];

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetSelectedPicklistRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetSelectedPicklistRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetSelectedPicklistRecords]
	(
	@psSelectionType		varchar(255),
	@piSelectionID			integer,
	@psSelectedIDs			varchar(MAX),
	@psPromptSQL			varchar(MAX),
	@piTableID				integer,
	@psErrorMessage			varchar(MAX)	OUTPUT,
	@piExpectedRecords		integer			OUTPUT
	)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iID				integer,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource		sysname,
		@sColumnName 		sysname,
		@iDataType 			integer,
		@iTableID 			integer,
		@iChildViewID		integer,
		@sTempRealSource	sysname,
		@iTemp				integer,
		@sTemp				varchar(MAX),
		@sSubViews			varchar(MAX),
		@sSQL 				nvarchar(MAX),
		@sPositionParamDefinition 	nvarchar(500),
		@sActualUserName	sysname,
		@sSelectSQL2		varchar(MAX),
		@sSelectSQL3		varchar(MAX),
		@sSelectSQL5		varchar(MAX),
		@sSelectSQL			varchar(MAX),
		@sFromSQL			varchar(MAX),
		@iOrderID			integer,
		@sJoinTables		varchar(MAX),
		@sJoinViews			varchar(MAX),
		@sWhereSQL			varchar(MAX),
		@fBaseSelect		bit,
		@iTempTableType		integer,
		@sTempTableName		sysname,
		@iTempTableID 		integer,
		@fSelectGranted 	bit,
		@iIndex				integer,
		@iViewID			integer, 
		@sViewName			sysname,
		@iTempID			integer,
		@sSubSQL			varchar(MAX),
		@sExecuteSQL		nvarchar(MAX);
	
	/* Clean the input string parameters. */
	IF len(@psSelectedIDs) > 0 SET @psSelectedIDs = replace(@psSelectedIDs, '''', '''''');

	SET @sSelectSQL = '';
	SET @sSelectSQL2 = '';
	SET @sSelectSQL3 = '';
	SET @sSelectSQL5 = '';
		
	SET @sJoinTables = ',';
	SET @sJoinViews = ',';
	SET @sWhereSQL = '';
	SET @fBaseSelect = 0;
	SET @sFromSQL = '';
	
	/* Get the current user's group ID. */
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT;

	SELECT @iOrderID = defaultOrderID, 
		@iTableType = tableType,
		@sTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @piTableID;

	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sRealSource = @sTableName;
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(CONVERT(varchar(255),@sTableName), ' ', '_') +
				'#' + replace(CONVERT(varchar(255),@sUserGroupName), ' ', '_');
			SET @sRealSource = left(CONVERT(varchar(255),@sRealSource), 255);
		END
	END	

	SET @sSelectSQL = '';

	/* Create a temporary table to hold the find columns that the user can see. */
	DECLARE @columnPermissions TABLE
		(tableID		integer,
		tableViewName	sysname,
		columnName	sysname,
		selectGranted	bit);

	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID, t.tableType, t.tableName
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	INNER JOIN ASRSysTables t ON c.tableID= t.tableID
	WHERE oi.orderID = @iOrderID
		AND oi.type = 'F';

	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName 
					FROM ASRSysViews 
					WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTempTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sTempRealSource = left(@sTempRealSource, 255);

				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					CASE protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND syscolumns.name <> 'timestamp'
					AND sysobjects.name =@sTempRealSource
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName;
	END
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.columnName, c.dataType, c.tableID, t.tableType, t.tableName
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
		AND c.datatype <> -3 AND c.datatype <> -4
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;

		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			SET @sTempRealSource = @sTempTableName;
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND [role] = @sUserGroupName;
				
			IF @iChildViewID IS null SET @iChildViewID = 0;
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_');
				SET @sTempRealSource = left(@sTempRealSource, 255);
			END
		END	

		SELECT @fSelectGranted = selectGranted
		FROM @columnPermissions
		WHERE tableID = @iTableID
			AND tableViewName = @sTempRealSource
			AND columnName = @sColumnName;

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

		IF @fSelectGranted = 1
		BEGIN
			/* Add the column code to the 'select' string. */
			SET @sSelectSQL = @sSelectSQL +
				CASE 
					WHEN len(@sSelectSQL) > 0 THEN ','
					ELSE ''
				END +
				@sTempRealSource + '.' + @sColumnName;

			IF @iTableID = @piTableID
			BEGIN
				SET @fBaseSelect = 1;
			END 
			ELSE
			BEGIN
				/* Add the table to the list of join tables if required. */
				SELECT @iIndex = CHARINDEX(',' + @sTempRealSource + ',', @sJoinTables);
				IF @iIndex = 0 SET @sJoinTables = @sJoinTables + @sTempRealSource + ',';
			END
		END
		ELSE
		BEGIN
			/* The column CANNOT be read from the Delegate table, or directly from a parent table.
			Try to read it from the views on the table. */
			SET @sSubViews = ',';

			DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT viewID,
				viewName
			FROM ASRSysViews
			WHERE viewTableID = @iTableID;

			OPEN viewsCursor;
			FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			WHILE (@@fetch_status = 0)
			BEGIN
				SET @fSelectGranted = 0

				SELECT @fSelectGranted = selectGranted
				FROM @columnPermissions
				WHERE tableID = @iTableID
					AND tableViewName = @sViewName
					AND columnName = @sColumnName;

				IF @fSelectGranted IS NULL SET @fSelectGranted = 0;

				IF @fSelectGranted = 1	
				BEGIN
					/* Add the view to the list of join views if required. */
					SELECT @iIndex = CHARINDEX(',' + @sViewName + ',', @sJoinViews);
					IF @iIndex = 0 SET @sJoinViews = @sJoinViews + @sViewName + ',';

					SET @sSubViews = @sSubViews + @sViewName + ',';
				END

				FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName;
			END
			CLOSE viewsCursor;
			DEALLOCATE viewsCursor;

			IF len(@sSubViews) > 1
			BEGIN
				SET @sSubSQL = '';

				WHILE len(@sSubViews) > 1
				BEGIN
					SELECT @iIndex = charindex(',', @sSubViews, 2);
					SET @sViewName = substring(@sSubViews, 2, @iIndex - 2);
					SET @sSubViews = substring(@sSubViews, @iIndex, len(@sSubViews) -@iIndex + 1);

					IF len(@sSubSQL) > 0 SET @sSubSQL = @sSubSQL + ',';
					SET @sSubSQL = @sSubSQL + @sViewName + '.' + @sColumnName;
				END

				SET @sSubSQL = 'COALESCE(' + @sSubSQL + ', NULL) AS [' + @sColumnName + ']';
                
				/* Add the column code to the 'select' string. */
				SET @sSelectSQL = @sSelectSQL +
					CASE 
						WHEN len(@sSelectSQL) > 0 THEN ','
						ELSE ''
					END +
					@sSubSQL;
			END
		END

		FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName;
	END
	
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	/* Add the ID column. */
	SET @sFromSQL = ' FROM ' + @sRealSource;
        
	/* Join any other tables and views that are used. */
	WHILE len(@sJoinTables) > 1
	BEGIN
		SELECT @iIndex = charindex(',', @sJoinTables, 2);
		SET @sTableName = substring(@sJoinTables, 2, @iIndex - 2);
		SET @sJoinTables = substring(@sJoinTables, @iIndex, len(@sJoinTables) -@iIndex + 1);

		SELECT @iTempID = tableID
		FROM ASRSysTables
		WHERE tableName = @sTableName;

		SET @sFromSQL = @sFromSQL + 		
			' LEFT OUTER JOIN ' + @sTableName +
			' ON ' + @sRealSource + '.ID_' + convert(varchar(255), @iTempID) + ' = ' + @sTableName + '.ID';
	END

	WHILE len(@sJoinViews) > 1
	BEGIN
		SELECT @iIndex = charindex(',', @sJoinViews, 2);
		SET @sViewName = substring(@sJoinViews, 2, @iIndex - 2);
		SET @sJoinViews = substring(@sJoinViews, @iIndex, len(@sJoinViews) -@iIndex + 1);

		SELECT @iTempID = viewTableID
		FROM ASRSysViews
		WHERE viewName = @sViewName;

		IF @iTempID = @piTableID
		BEGIN
			SET @sFromSQL = @sFromSQL + 		
				' LEFT OUTER JOIN ' + @sViewName +
				' ON ' + @sRealSource + '.ID = ' + @sViewName + '.ID';

			IF @fBaseSelect = 0
			BEGIN
				SET @sWhereSQL = @sWhereSQL + 
					CASE
						WHEN len(@sWhereSQL) > 0 THEN ' OR ('
						ELSE '('
					END +
					@sRealSource + '.ID IN (SELECT ID FROM ' + @sViewName +  '))';
			END
		END
		ELSE
		BEGIN
			SET @sFromSQL = @sFromSQL + 		
				' LEFT OUTER JOIN ' + @sViewName +
				' ON ' + @sRealSource + '.ID_' + convert(varchar(255), @iTempID) + ' = ' + @sViewName + '.ID';
		END
	END

	IF len(@sWhereSQL) > 0
	BEGIN
		SET @sFromSQL = @sFromSQL + 
			' WHERE (' + @sWhereSQL + ')'	;
	END
	
	/* Get the list of selected IDs. */
	IF len(@psSelectedIDs) = 0 SET @psSelectedIDs = '0';

	/* PICKLIST = gets the items from the original definition */
	IF UPPER(@psSelectionType) = 'PICKLIST'
	BEGIN
		SET @psSelectedIDs = ' (SELECT recordID FROM ASRSysPicklistItems WHERE picklistID = ' + CONVERT(varchar(255), @piSelectionID) + ') ';
	END
		
	/* ALLRECORDS = gets all the remaining records */
	IF UPPER(@psSelectionType) <> 'ALLRECORDS'
	BEGIN
		/* Get the required find records. */
		SET @sSelectSQL2 = @sSelectSQL2 +
			CASE
				WHEN charindex(' WHERE ', @sFromSQL) > 0 THEN ' AND ('
				ELSE ' WHERE ('
			END +
			'(' + CONVERT(varchar(255), @sRealSource) + '.id IN (' ;
						
		SET @sSelectSQL3 = @psSelectedIDs;
		SET @sSelectSQL5 = @sSelectSQL5 + ')))';
	END

	/* FILTER = gets all the filtered records that are not yet selected */
	IF (UPPER(@psSelectionType) = 'FILTER') AND (len(@psPromptSQL) > 0)
	BEGIN
		SET @sSelectSQL5 = @sSelectSQL5 + ' OR (' + 
			CONVERT(varchar(255), @sRealSource) + '.id IN (' + @psPromptSQL + '))';
	END
	

	/* Add the 'order by part. */
	SET @sSelectSQL5 = @sSelectSQL5 +
		' ORDER BY 1';
		
	/* Count the number of commas before the ' FROM ' to see how many columns are in the select statement. */
	SELECT @iTemp = CHARINDEX(' FROM ', @sFromSQL);
	SET @sTemp = SUBSTRING(@sFromSQL, 1, @iTemp);
	SET @iTemp = 2;
	WHILE charindex(',', @sTemp) > 0
	BEGIN
		SET @sSelectSQL5 = @sSelectSQL5 +
			',' + convert(varchar(MAX), @iTemp);
		SET @sTemp = substring(@sTemp, charindex(',', @sTemp)+1, len(@sTemp) - charindex(',', @sTemp));
		SET @iTemp = @iTemp + 1;
	END
	
	SET @piExpectedRecords = 0;
	IF UPPER(@psSelectionType) = 'ALL'
	BEGIN
		SET @sSQL = 'SELECT @recordPosition = COUNT(ID)' +
			' FROM ' + CONVERT(varchar(255), @sRealSource) +
			' WHERE ID IN(' + @psSelectedIDs + ')';
		SET @sPositionParamDefinition = N'@recordPosition integer OUTPUT';
		EXEC sp_executesql @sSQL, @sPositionParamDefinition, @piExpectedRecords OUTPUT;
	END

	SET @sExecuteSQL = 'SELECT ' + @sSelectSQL + ',' +
		@sRealSource + '.id ' + @sFromSQL +
		@sSelectSQL2 + @sSelectSQL3 + @sSelectSQL5;

	-- Execute the generated string
	EXECUTE sp_executeSQL @sExecuteSQL;

END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTBEmployeeColumns]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTBEmployeeColumns]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTBEmployeeColumns] (
	@psErrorMsg 			varchar(MAX)	OUTPUT,
	@ps1000SeparatorCols 	varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the 'employee' table find columns that the user has 'read' permission on. */
	DECLARE 
		@iUserGroupID		integer,
		@sUserGroupName		sysname,
		@iEmployeeTableID	integer,
		@iOrderID			integer,
		@sColumnName 		sysname,
		@iDataType 			integer,
		@iTableID 			integer,
		@iCount				integer,
		@sTemp				sysname,
		@iIndex				integer,
		@sEmpRealSource		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@iTempTableType		integer,
		@sTempTableName		sysname,
		@iChildViewID		integer,
		@sTempRealSource	sysname,
		@iViewID			integer, 
		@sViewName			sysname,
		@iTempID			integer,
		@sActualUserName	sysname,
		@iTempTableID 		integer,
		@fSelectGranted 	bit,
		@bUse1000Separator	bit,
		@fSomeReadable		bit,
		@fViewReadable		bit;

	SET @psErrorMsg = ''
	SET @ps1000SeparatorCols = ''
	SET @fSomeReadable = 0
	
	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the EMPLOYEE table information. */
	SELECT @iEmployeeTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmployeeTableID IS NULL SET @iEmployeeTableID = 0

	SELECT @iOrderID = defaultOrderID, 
		@iTableType = tableType,
		@sTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iEmployeeTableID

	/* Get the real source of the employee table. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		SET @sEmpRealSource = @sTableName
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iEmployeeTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sEmpRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sEmpRealSource = left(@sEmpRealSource, 255)
		END
	END	
	
	/* Create a temporary table to hold the find columns that the user can see. */
	DECLARE @findColumns TABLE(
		columnName		sysname,
		dataType		integer);

	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID, t.tableType, t.tableName
	FROM ASRSysOrderItems oi 
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON c.tableID = t.tableID
	WHERE oi.orderID = @iOrderID
		AND oi.type = 'F';

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName 
					FROM ASRSysViews 
					WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
					AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTempTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sTempRealSource = left(@sTempRealSource, 255)

				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					sysobjects.name,
					syscolumns.name,
					CASE protectType
					        	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM sysprotects
				INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
				INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
				WHERE sysprotects.uid = @iUserGroupID
					AND sysprotects.action = 193 
					AND syscolumns.name <> 'timestamp'
					AND sysobjects.name =@sTempRealSource
						AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
						AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
			END
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID, @iTempTableType, @sTempTableName
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.columnName, c.dataType, c.tableID, t.tableType, t.tableName, c.Use1000Separator
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName, @bUse1000Separator

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @psErrorMsg = 'Unable to read the Employee table default order.'
		RETURN
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0

		/* Get the real source of the employee table. */
		IF @iTempTableType <> 2 /* ie. top-level or lookup */
		BEGIN
			SET @sTempRealSource = @sTempTableName
		END
		ELSE
		BEGIN
			SELECT @iChildViewID = childViewID
			FROM ASRSysChildViews2
			WHERE tableID = @iTableID
				AND role = @sUserGroupName
				
			IF @iChildViewID IS null SET @iChildViewID = 0
				
			IF @iChildViewID > 0 
			BEGIN
				SET @sTempRealSource = 'ASRSysCV' + 
					convert(varchar(1000), @iChildViewID) +
					'#' + replace(@sTempTableName, ' ', '_') +
					'#' + replace(@sUserGroupName, ' ', '_')
				SET @sTempRealSource = left(@sTempRealSource, 255)
			END
		END	

		SELECT @fSelectGranted = selectGranted
		FROM @columnPermissions
		WHERE tableID = @iTableID
			AND tableViewName = @sTempRealSource
			AND columnName = @sColumnName

		IF @fSelectGranted IS NULL SET @fSelectGranted = 0

		IF @fSelectGranted = 1
		BEGIN
			SET @fSomeReadable = 1

			SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
				CASE
					WHEN @bUse1000Separator = 1 THEN '1'
					ELSE '0'
				END

			INSERT INTO @findColumns (columnName, dataType) VALUES (@sColumnName, @iDataType)
		END
		ELSE
		BEGIN
			/* The column CANNOT be read from the Delegate table, or directly from a parent table.
			Try to read it from the views on the table. */
			SET @fViewReadable = 0

			DECLARE viewsCursor CURSOR LOCAL FAST_FORWARD FOR 
			SELECT viewID,
				viewName
			FROM ASRSysViews
			WHERE viewTableID = @iTableID

			OPEN viewsCursor
			FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName
			WHILE (@@fetch_status = 0)
			BEGIN
				SELECT @fSelectGranted = selectGranted
				FROM @columnPermissions
				WHERE tableID = @iTableID
					AND tableViewName = @sViewName
					AND columnName = @sColumnName

				IF @fSelectGranted IS NULL SET @fSelectGranted = 0

				IF @fSelectGranted = 1	
				BEGIN
					SET @fViewReadable = 1
				END

				FETCH NEXT FROM viewsCursor INTO @iViewID, @sViewName
			END
			CLOSE viewsCursor
			DEALLOCATE viewsCursor

			IF @fViewReadable = 1
			BEGIN
				INSERT INTO @findColumns (columnName, dataType) VALUES (@sColumnName, @iDataType)

				/* Add the column code to the 'select' string. */
				SET @fSomeReadable = 1

				SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
					CASE
						WHEN @bUse1000Separator = 1 THEN '1'
						ELSE '0'
					END
			END
		END

		FETCH NEXT FROM orderCursor INTO @sColumnName, @iDataType, @iTableID, @iTempTableType, @sTempTableName, @bUse1000Separator
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	IF @fSomeReadable = 0
	BEGIN
		/* Flag to the user that they cannot see any of the find columns. */
		SET @psErrorMsg = 'You do not have permission to read the Employee table find columns.'
	END
	ELSE
	BEGIN
		/* Add the ID column. */
		INSERT INTO @findColumns (columnName, dataType) VALUES ('ID', 4)
	END

	SELECT * FROM @findColumns;
	
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTransferBookingRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTransferBookingRecords]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTransferBookingRecords] (
	@piTableID 			integer, 
	@piViewID 			integer, 
	@piOrderID 			integer,
	@piTBRecordID		integer,
	@pfError 			bit 			OUTPUT,
	@piRecordsRequired	integer,
	@pfFirstPage		bit				OUTPUT,
	@pfLastPage			bit				OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer			OUTPUT,
	@psAction			varchar(255),
	@piTotalRecCount	integer			OUTPUT,
	@piFirstRecPos		integer			OUTPUT,
	@piCurrentRecCount	integer,
	@psErrorMessage		varchar(MAX)	OUTPUT,
	@piColumnSize		integer			OUTPUT,
	@piColumnDecimals	integer			OUTPUT,
	@psStatus			varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @iUserGroupID	integer,
		@sUserGroupName		sysname,
		@iTableType			integer,
		@sTableName			sysname,
		@sRealSource 		sysname,
		@iChildViewID 		integer,
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		sysname,
		@sColumnTableName 	sysname,
		@fAscending 		bit,
		@sType	 			varchar(10),
		@iDataType 			integer,
		@fSelectGranted 	bit,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sExecString		nvarchar(MAX),
		@sTempString		varchar(MAX),
		@fSelectDenied		bit,
		@iTempCount 		integer,
		@sSubString			varchar(MAX),
		@sViewName 			varchar(255),
		@sTableViewName 	sysname,
		@iJoinTableID 		integer,
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sDESCstring		varchar(4),
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@fFirstColumnAsc	bit,
		@sFirstColCode		varchar(MAX),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@fWhereDone			bit,
		@iTBStatusColumnID	integer,
		@sTBStatusColumnName	sysname,
		@iCourseTitleColumnID	integer,
		@sCourseTitleColumnName	sysname,
		@iCourseStartDateColumnID	integer,
		@sCourseStartDateColumnName	sysname,
		@iGetCount			integer,
		@sCourseTitle		varchar(MAX),
		@sStatus			varchar(MAX),
		@iEmpTableID		integer,
		@iCourseTableID		integer,
		@iEmpRecordID		integer,
		@iCourseRecordID	integer,
		@iTBTableID			integer,
		@sTBRealSource		varchar(255),
		@sCourseSource		sysname,
		@iColSize			integer,
		@iColDecs			integer,
		@sTBTableName		sysname,
		@sActualUserName	sysname

	/* Initialise variables. */
	SET @pfError = 0
	SET @psErrorMessage = ''
	SET @sRealSource = ''
	SET @sSelectSQL = ''
	SET @sOrderSQL = ''
	SET @fSelectDenied = 0
	SET @sExecString = ''
	SET @sDESCstring = ' DESC'
	SET @fFirstColumnAsc = 1
	SET @sFirstColCode = ''
	SET @sReverseOrderSQL = ''
	SET @fWhereDone = 0

	/* Clean the input string parameters. */
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''')

	/* Get the current user's group ID. */
	EXEC spASRIntGetActualUserDetails
		@sActualUserName OUTPUT,
		@sUserGroupName OUTPUT,
		@iUserGroupID OUTPUT

	/* Get the employee table id. */
	SELECT @iEmpTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_EmployeeTable'
	IF @iEmpTableID IS NULL SET @iEmpTableID = 0

	/* Get the Course table id. */
	SELECT @iCourseTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTable'
	IF @iCourseTableID IS NULL SET @iCourseTableID = 0

	/* Get the status, employee id and course id from the given TB record. */
	/* NB. To reach this point we have already checked that the user has 'read' permission on the Training Booking - Status column. */
	SELECT @iTBTableID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookTable'
	IF @iTBTableID IS NULL SET @iTBTableID = 0

	SELECT @sTBTableName = tableName
	FROM ASRSysTables
	WHERE tableID = @iTBTableID
	
	SELECT @iTBStatusColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_TrainBookStatus'
	IF @iTBStatusColumnID IS NULL SET @iTBStatusColumnID = 0
	
	IF @iTBStatusColumnID > 0 
	BEGIN
		SELECT @sTBStatusColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iTBStatusColumnID
	END
	IF @sTBStatusColumnName IS NULL SET @sTBStatusColumnName = ''

	SELECT @iChildViewID = childViewID
	FROM ASRSysChildViews2
	WHERE tableID = @iTBTableID
		AND role = @sUserGroupName
		
	IF @iChildViewID IS null SET @iChildViewID = 0
		
	IF @iChildViewID > 0 
	BEGIN
		SET @sTBRealSource = 'ASRSysCV' + 
			convert(varchar(1000), @iChildViewID) +
			'#' + replace(@sTBTableName, ' ', '_') +
			'#' + replace(@sUserGroupName, ' ', '_')
		SET @sTBRealSource = left(@sTBRealSource, 255)
	END

	SET @sTempExecString = 'SELECT @sStatus = ' + @sTBStatusColumnName + 
		', @iEmpRecordID = id_' + convert(nvarchar(100), @iEmpTableID) +
		', @iCourseRecordID = id_' + convert(nvarchar(100), @iCourseTableID) +
		' FROM ' + @sTBRealSource +
		' WHERE id = ' + convert(nvarchar(100), @piTBRecordID)
	SET @sTempParamDefinition = N'@sStatus varchar(255) OUTPUT, @iEmpRecordID integer OUTPUT, @iCourseRecordID integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sStatus OUTPUT, @iEmpRecordID OUTPUT,	@iCourseRecordID OUTPUT

	SET @psStatus = @sStatus
	
	/* We can only transfer 'Booked' and 'Provisionally Booked' records that have valid course and employee records. */
	IF (ltrim(rtrim(upper(@sStatus))) <> 'B') AND (ltrim(rtrim(upper(@sStatus))) <> 'P')
	BEGIN
		SET @pfError = 1
		SET @psErrorMessage = 'Training booking records can only be transferred if they have ''Booked'''

		SELECT @iCount = COUNT(*)
		FROM ASRSysColumnControlValues
		WHERE columnID = @iTBStatusColumnID
			AND upper(value) = 'P'
		
		IF @iCount > 0
		BEGIN
			SET @psErrorMessage = @psErrorMessage + ' or ''Provisional'''
		END

		SET @psErrorMessage = @psErrorMessage + ' status.'
		RETURN
	END
	ELSE
	BEGIN
		IF (@iEmpRecordID <= 0) OR (@iEmpRecordID IS null)
		BEGIN
			SET @pfError = 1
			SET @psErrorMessage = 'The selected Training Booking record has no associated Employee record.'
			RETURN
		END
		ELSE
		BEGIN
			IF (@iCourseRecordID <= 0) OR (@iCourseRecordID IS null)
			BEGIN
				SET @pfError = 1
				SET @psErrorMessage = 'The selected Training Booking record has no associated Course record.'
				RETURN
			END	
		END
	END
	
	SELECT @iCourseTitleColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseTitle'
	IF @iCourseTitleColumnID IS NULL SET @iCourseTitleColumnID = 0
	
	IF @iCourseTitleColumnID > 0 
	BEGIN
		SELECT @sCourseTitleColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseTitleColumnID
	END
	IF @sCourseTitleColumnName IS NULL SET @sCourseTitleColumnName = ''

	SELECT @iCourseStartDateColumnID = convert(integer, parameterValue)
	FROM ASRSysModuleSetup
	WHERE moduleKey = 'MODULE_TRAININGBOOKING'
		AND parameterKey = 'Param_CourseStartDate'
	IF @iCourseStartDateColumnID IS NULL SET @iCourseStartDateColumnID = 0

	IF @iCourseStartDateColumnID > 0 
	BEGIN
		SELECT @sCourseStartDateColumnName = columnName
		FROM ASRSysColumns
		WHERE columnID = @iCourseStartDateColumnID
	END
	IF @sCourseStartDateColumnName IS NULL SET @sCourseStartDateColumnName = ''

	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST'
	END

	/* Get the table type and name. */
	SELECT @iTableType = ASRSysTables.tableType,
		@sTableName = ASRSysTables.tableName
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @piTableID

	/* Get the real source of the given table/view. */
	IF @iTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN	
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID
		END
		ELSE
		BEGIN
			SET @sRealSource = @sTableName
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @piTableID
			AND role = @sUserGroupName
			
		IF @iChildViewID IS null SET @iChildViewID = 0
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sTableName, ' ', '_') +
				'#' + replace(@sUserGroupName, ' ', '_')
			SET @sRealSource = left(@sRealSource, 255)
		END
	END

	IF len(@sRealSource) = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create a temporary table to hold the tables/views that need to be joined. */
	DECLARE @joinParents TABLE(
		tableViewName	sysname,
		tableID			integer);

	/* Create a temporary table of the 'select' column permissions for all tables/views used in the order. */
	DECLARE @columnPermissions TABLE(
		tableID			integer,
		tableViewName	sysname,
		columnName		sysname,
		selectGranted	bit);

	/* Loop through the tables used in the order, getting the column permissions for each one. */
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT c.tableID
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.orderID = @piOrderID

	OPEN tablesCursor
	FETCH NEXT FROM tablesCursor INTO @iTempTableID
	WHILE (@@fetch_status = 0)
	BEGIN
		IF @iTempTableID = @piTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name = @sRealSource
				AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
				AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				sysobjects.name,
				syscolumns.name,
				CASE protectType
				        	WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM sysprotects
			INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
			INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
			WHERE sysprotects.uid = @iUserGroupID
				AND sysprotects.action = 193 
				AND syscolumns.name <> 'timestamp'
				AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
					ASRSysTables.tableID = @iTempTableID 
					UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
			AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
			OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
			AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
		END

		FETCH NEXT FROM tablesCursor INTO @iTempTableID
	END
	CLOSE tablesCursor
	DEALLOCATE tablesCursor

	/* Get the @sCourseTitle value for the given TB record. */
	DECLARE courseSourceCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT sysobjects.name
	FROM sysprotects
	INNER JOIN sysobjects ON sysprotects.id = sysobjects.id
	INNER JOIN syscolumns ON sysprotects.id = syscolumns.id
	WHERE sysprotects.uid = @iUserGroupID
		AND sysprotects.action = 193 
		AND (sysprotects.protectType = 205 OR sysprotects.protectType = 204)
		AND syscolumns.name = @sCourseTitleColumnName
		AND sysobjects.name IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE 
			ASRSysTables.tableID = @iCourseTableID 
			UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iCourseTableID)
		AND (((convert(tinyint,substring(sysprotects.columns,1,1))&1) = 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
		OR ((convert(tinyint,substring(sysprotects.columns,1,1))&1) != 0
		AND (convert(int,substring(sysprotects.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0))
	OPEN courseSourceCursor
	FETCH NEXT FROM courseSourceCursor INTO @sCourseSource
	WHILE (@@fetch_status = 0) AND (@sCourseTitle IS null)
	BEGIN
		SET @sTempExecString = 'SELECT @sCourseTitle = ' + @sCourseTitleColumnName + 
			' FROM ' + @sCourseSource +
			' WHERE id = ' + convert(nvarchar(100), @iCourseRecordID)
		SET @sTempParamDefinition = N'@sCourseTitle varchar(MAX) OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @sCourseTitle OUTPUT

		FETCH NEXT FROM courseSourceCursor INTO @sCourseSource
	END
	CLOSE courseSourceCursor
	DEALLOCATE courseSourceCursor

	IF @sCourseTitle IS null
	BEGIN
		SET @pfError = 1
		SET @psErrorMessage = 'Unable to read the course title from the associated Course record.'
		RETURN		
	END

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseTitleColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	SET @fSelectGranted = 0
	SELECT @fSelectGranted = selectGranted
	FROM @columnPermissions
	WHERE tableViewName = @sRealSource
		AND columnName = @sCourseStartDateColumnName
	IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	IF @fSelectGranted = 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending, oi.type, c.dataType, c.size, c.decimals
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @piOrderID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs

	/* Check if the order exists. */
	IF  @@fetch_status <> 0
	BEGIN
		SET @pfError = 1
		RETURN
	END

	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0
		
		IF @iColumnTableId = @piTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0

			IF @fSelectGranted = 1
			BEGIN
				/* The user DOES have SELECT permission on the column in the current table/view. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString
				END
				ELSE
				BEGIN
					/* Order column. */

					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sRealSource + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sRealSource + '.' + @sColumnName +
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END
			END
			ELSE
			BEGIN
				/* The user does NOT have SELECT permission on the column in the current table/view. */
				SET @fSelectDenied = 1
			END	
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */

			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = selectGranted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName

			IF @fSelectGranted IS NULL SET @fSelectGranted = 0
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* The user DOES have SELECT permission on the column in the parent table. */
				IF @sType = 'F'
				BEGIN
					/* Find column. */
					SET @sTempString = CASE 
							WHEN (len(@sSelectSQL) > 0) THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName
					SET @sSelectSQL = @sSelectSQL + @sTempString
				END
				ELSE
				BEGIN
					/* Order column. */
					IF len(@sOrderSQL) = 0 
					BEGIN
						SET @piColumnType = @iDataType
						SET @fFirstColumnAsc = @fAscending
						SET @sFirstColCode = @sColumnTableName + '.' + @sColumnName
						SET @piColumnSize = @iColSize
						SET @piColumnDecimals = @iColDecs
					END

					SET @sOrderSQL = @sOrderSQL + 
						CASE 
							WHEN len(@sOrderSQL) > 0 THEN ',' 
							ELSE '' 
						END + 
						@sColumnTableName + '.' + @sColumnName + 
						CASE 
							WHEN @fAscending = 0 THEN ' DESC' 
							ELSE '' 
						END				
				END

				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
				WHERE tableViewName = @sColumnTableName

				IF @iTempCount = 0
				BEGIN
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID)
				END
			END
			ELSE	
			BEGIN
				SET @sSubString = ''

				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND selectGranted = 1

				OPEN viewCursor
				FETCH NEXT FROM viewCursor INTO @sViewName
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sSubString) = 0 SET @sSubString = 'CASE'

					SET @sSubString = @sSubString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName 
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
					WHERE tableViewname = @sViewName

					IF @iTempCount = 0
					BEGIN
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId)
					END

					FETCH NEXT FROM viewCursor INTO @sViewName
				END
				CLOSE viewCursor
				DEALLOCATE viewCursor

				IF len(@sSubString) > 0
				BEGIN
					SET @sSubString = @sSubString +
						' ELSE NULL END'

					IF @sType = 'F'
					BEGIN
						/* Find column. */
						SET @sTempString = CASE 
								WHEN (len(@sSelectSQL) > 0) THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END
						SET @sSelectSQL = @sSelectSQL + @sTempString
					END
					ELSE
					BEGIN
						/* Order column. */
						IF len(@sOrderSQL) = 0 
						BEGIN
							SET @piColumnType = @iDataType
							SET @fFirstColumnAsc = @fAscending
							SET @sFirstColCode = @sSubString
							SET @piColumnSize = @iColSize
							SET @piColumnDecimals = @iColDecs
						END

						SET @sOrderSQL = @sOrderSQL + 
							CASE 
								WHEN len(@sOrderSQL) > 0 THEN ',' 
								ELSE '' 
							END + 
							CASE
								WHEN @iDataType = 11 THEN 'convert(datetime, ' + @sSubString + ')'
								ELSE @sSubString 
							END + 
							CASE 
								WHEN @fAscending = 0 THEN ' DESC' 
								ELSE '' 
							END				
					END
				END
				ELSE
				BEGIN
					/* The user does NOT have SELECT permission on the column any of the parent views. */
					SET @fSelectDenied = 1
				END	
			END
		END

		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending, @sType, @iDataType, @iColSize, @iColDecs
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Add the ID column to the order string. */
	SET @sOrderSQL = @sOrderSQL + 
		CASE WHEN len(@sOrderSQL) > 0 THEN ',' ELSE '' END + 
		@sRealSource + '.ID'

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sRemainingSQL = @sOrderSQL

		SET @iLastCharIndex = 0
		SET @iCharIndex = CHARINDEX(',', @sOrderSQL)
		WHILE @iCharIndex > 0 
		BEGIN
 			IF UPPER(SUBSTRING(@sOrderSQL, @iCharIndex - LEN(@sDESCstring), LEN(@sDESCstring))) = @sDESCstring
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - LEN(@sDESCstring) - @iLastCharIndex) + ', '
			END
			ELSE
			BEGIN
				SET @sReverseOrderSQL = @sReverseOrderSQL + SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, @iCharIndex - 1 - @iLastCharIndex) + @sDESCstring + ', '
			END

			SET @iLastCharIndex = @iCharIndex
			SET @iCharIndex = CHARINDEX(',', @sOrderSQL, @iLastCharIndex + 1)
	
			SET @sRemainingSQL = SUBSTRING(@sOrderSQL, @iLastCharIndex + 1, LEN(@sOrderSQL) - @iLastCharIndex)
		END
		SET @sReverseOrderSQL = @sReverseOrderSQL + @sRemainingSQL + @sDESCstring
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource +
		' WHERE (' +
		@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND ' +
		@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
		@sRealSource + '.id <> ' + convert(nvarchar(100), @iCourseRecordID) + ')'

	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	IF (len(@sSelectSQL) > 0) 
	BEGIN
		SET @sTempString = ',' + @sRealSource + '.ID'
		SET @sSelectSQL = @sSelectSQL + @sTempString

		SET @sExecString = 'SELECT ' 

		IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
		BEGIN
			SET @sTempString = 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' '
			SET @sExecString = @sExecString + @sTempString
		END
		
		SET @sTempString = @sSelectSQL + ' FROM ' + @sRealSource
		SET @sExecString = @sExecString + @sTempString

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempString = ' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'
			SET @sExecString = @sExecString + @sTempString

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor

		IF (@psAction = 'MOVELAST')
		BEGIN
			SET @fWhereDone = 1

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		IF @psAction = 'MOVENEXT' 
		BEGIN
			SET @fWhereDone = 1
			IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
			BEGIN
				SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired
			END

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		IF @psAction = 'MOVEPREVIOUS'
		BEGIN
			SET @fWhereDone = 1
			IF @piFirstRecPos <= @piRecordsRequired
			BEGIN
				SET @iGetCount = @piFirstRecPos - 1
			END
			ELSE
			BEGIN
				SET @iGetCount = @piRecordsRequired				
			END

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString

			SET @sTempString = ' WHERE ' + @sRealSource + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sRealSource + '.ID' +
				' FROM ' + @sRealSource
			SET @sExecString = @sExecString + @sTempString
		END

		/* Add the filter code. */
		SET @sTempString = ' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND ' +
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
			@sRealSource + '.id <> ' + convert(nvarchar(100), @iCourseRecordID) + ')'
		SET @sExecString = @sExecString + @sTempString

		IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
		BEGIN
			SET @sTempString = ' ORDER BY ' + @sReverseOrderSQL + ')'
			SET @sExecString = @sExecString + @sTempString
		END

		IF (@psAction = 'LOCATE')
		BEGIN
			SET @fWhereDone = 1
			SET @sLocateCode = ' AND (' + @sFirstColCode 

			IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''

					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + 
						@sFirstColCode + ' LIKE ''' + @psLocateValue + '%'' OR ' + @sFirstColCode + ' IS NULL'
				END

			END

			IF @piColumnType = 11 /* Date column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sFirstColCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''
					END
				END
				ELSE
				BEGIN
					IF len(@psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' IS NULL'
					END
					ELSE
					BEGIN
						SET @sLocateCode = @sLocateCode + ' <= ''' + @psLocateValue + ''' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
			END

			IF @piColumnType = -7 /* Logic column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + 
						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + 

						CASE
							WHEN @psLocateValue = 'True' THEN '1'
							ELSE '0'
						END
				END
			END

			IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
			BEGIN
				IF @fFirstColumnAsc = 1
				BEGIN
					SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue

					IF convert(float, @psLocateValue) = 0
					BEGIN
						SET @sLocateCode = @sLocateCode + ' OR ' + @sFirstColCode + ' IS NULL'
					END
				END
				ELSE
				BEGIN
					SET @sLocateCode = @sLocateCode + ' <= ' + @psLocateValue + ' OR ' + @sFirstColCode + ' IS NULL'
				END
			END

			SET @sLocateCode = @sLocateCode + ')'

			SET @sTempString = @sLocateCode
			SET @sExecString = @sExecString + @sTempString
		END

		/* Add the ORDER BY code to the find record selection string if required. */
		SET @sTempString = ' ORDER BY ' + @sOrderSQL
		SET @sExecString = @sExecString + @sTempString
	END

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1
		SET @pfFirstPage = 1
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount
		SET @pfFirstPage = 0
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 1
	END
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sRealSource + '.id) FROM ' + @sRealSource

		DECLARE joinCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT tableViewName, 
			tableID
		FROM @joinParents

		OPEN joinCursor
		FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		WHILE (@@fetch_status = 0)
		BEGIN
			SET @sTempExecString = @sTempExecString + 
				' LEFT OUTER JOIN ' + @sTableViewName + ' ON ' + @sRealSource + '.ID_' + convert(varchar(100), @iJoinTableID) + ' = ' + @sTableViewName + '.ID'

			FETCH NEXT FROM joinCursor INTO @sTableViewName, @iJoinTableID
		END
		CLOSE joinCursor
		DEALLOCATE joinCursor
		
		SET @sTempExecString = @sTempExecString + 
			' WHERE (' +
			@sRealSource + '.' + @sCourseTitleColumnName + ' = ''' + replace(@sCourseTitle, '''', '''''') + ''' AND ' +
			@sRealSource + '.' + @sCourseStartDateColumnName + ' >= convert(datetime,convert(varchar(10),getdate(),101)) AND ' +
			@sRealSource + '.id <> ' + convert(nvarchar(100), @iCourseRecordID) + ')' + @sLocateCode

		SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	IF (len(@sExecString) > 0)
	BEGIN
		EXECUTE sp_executeSQL @sExecString;
	END
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_ASRIntGetTableOrders]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sp_ASRIntGetTableOrders]
GO

CREATE PROCEDURE [dbo].[sp_ASRIntGetTableOrders] (
	@piTableID 		integer, 
	@piViewID 		integer)
AS
BEGIN

	SET NOCOUNT ON;
	
	/* Return a recordset of the orders for the current table/view and order IDs.
		@piTableID = the ID of the table on which the order is based.
		@piViewID = the ID of the view on which the order is based.
	*/

	IF @piViewID > 0 
	BEGIN
		SELECT DISTINCT o.name AS Name, o.OrderID
		FROM ASRSysOrders o
			INNER JOIN ASRSysOrderItems oi ON o.OrderID = oi.orderID
			INNER JOIN ASRSysViewColumns vc ON oi.columnID = vc.columnID
		WHERE o.tableID = @piTableID
			AND o.[type] = 1 AND vc.inView = 1 AND oi.[type] = 'O' AND vc.viewID = @piViewID
		ORDER BY o.name;
	END
	ELSE
	BEGIN
		SELECT name AS Name, orderID
		FROM ASRSysOrders
		WHERE tableID= @piTableID
			AND ASRSysOrders.[type] = 1
		ORDER BY name;
	END
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetScreenStrings]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetScreenStrings]
GO

CREATE PROCEDURE [dbo].[spASRIntGetScreenStrings] (
	@piScreenID 	integer,
	@piViewID 		integer,
	@psSelectSQL	nvarchar(MAX)	OUTPUT,
	@psFromDef		varchar(MAX)	OUTPUT,
	@psOrderSQL		varchar(MAX)	OUTPUT,
	@piOrderID		integer			OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of strings describing of the controls in the given screen. */
	DECLARE @iUserGroupID	integer,
		@iScreenTableID		integer,
		@iScreenTableType	integer,
		@sScreenTableName	varchar(255),
		@iScreenOrderID 	integer,
		@sRealSource 		varchar(255),
		@iChildViewID 		integer,
		@sJoinCode 			varchar(MAX),
		@iTempTableID 		integer,
		@iColumnTableID 	integer,
		@iColumnID 			integer,
		@sColumnName 		varchar(255),
		@sColumnTableName 	varchar(255),
		@iColumnDataType	integer,
		@fSelectGranted 	bit,
		@fUpdateGranted 	bit,
		@sSelectString 		varchar(MAX),
		@iTempCount 		integer,
		@sViewName 			varchar(255),
		@fAscending 		bit,
		@sOrderString 		varchar(MAX),
		@sTableViewName 	varchar(255),
		@iJoinTableID 		integer,
		@sParentRealSource	varchar(255),
		@iParentChildViewID	integer,
		@iParentTableType	integer,
		@sParentTableName	sysname,
		@iColumnType		integer,
		@iLinkTableID		integer,
		@lngPermissionCount	integer,
		@iLinkChildViewID	integer,
		@sLinkRealSource	varchar(255),
		@sLinkTableName		varchar(255),
		@iLinkTableType		integer,
		@sNewBit			varchar(MAX),
		@iID				integer,
		@iCount				integer,
		@iUserType			integer,
		@sRoleName			sysname,
		@sActualUserName	sysname;
		
	EXEC [dbo].[spASRIntGetActualUserDetails]
		@sActualUserName OUTPUT,
		@sRoleName OUTPUT,
		@iUserGroupID OUTPUT;
		
	/* Get the table type and name. */
	SELECT @iScreenTableID = ASRSysScreens.tableID,
		@iScreenTableType = ASRSysTables.tableType,
		@sScreenTableName = ASRSysTables.tableName,
		@iScreenOrderID = 
				CASE 
					WHEN ASRSysScreens.orderID > 0 THEN ASRSysScreens.orderID
					ELSE ASRSysTables.defaultOrderID 
				END
	FROM ASRSysScreens
	INNER JOIN ASRSysTables ON ASRSysScreens.tableID = ASRSysTables.tableID
	WHERE ASRSysScreens.ScreenID = @piScreenID;
	
	IF @iScreenOrderID IS NULL SET @iScreenOrderID = 0;
	
	IF @piOrderID <= 0 SET @piOrderID = @iScreenOrderID;
	
	/* Get the real source of the given screen's table/view. */
	IF @iScreenTableType <> 2 /* ie. top-level or lookup */
	BEGIN
		IF @piViewID > 0 
		BEGIN
			/* RealSource is the view. */	
			SELECT @sRealSource = viewName
			FROM ASRSysViews
			WHERE viewID = @piViewID;
		END
		ELSE
		BEGIN
			/* RealSource is the table. */	
			SET @sRealSource = @sScreenTableName;
		END 
	END
	ELSE
	BEGIN
		SELECT @iChildViewID = childViewID
		FROM ASRSysChildViews2
		WHERE tableID = @iScreenTableID
			AND role = @sRoleName;
			
		IF @iChildViewID IS null SET @iChildViewID = 0;
			
		IF @iChildViewID > 0 
		BEGIN
			SET @sRealSource = 'ASRSysCV' + 
				convert(varchar(1000), @iChildViewID) +
				'#' + replace(@sScreenTableName, ' ', '_') +
				'#' + replace(@sRoleName, ' ', '_');
			SET @sRealSource = left(@sRealSource, 255);
		END
	END

	/* Initialise the select and order parameters. */
	SET @psSelectSQL = '';
	SET @psFromDef = '';
	SET @psOrderSQL = '';
	SET @sJoinCode = '';
	
	-- Create a temporary table to hold the tables/views that need to be joined.
	DECLARE @JoinParents TABLE(tableViewName sysname, tableID int);
	
	-- Create a temporary table of the column permissions for all tables/views used in the screen.
	DECLARE @columnPermissions TABLE(tableID integer,
					tableViewName	sysname,
					columnName		sysname,
					action			int,		
					granted			bit);

	-- Temporary view of the sysprotects
	DECLARE @SysProtects TABLE ([ID] int,
					action tinyint,
					protecttype tinyint,
					columns varbinary(8000));
	INSERT INTO @SysProtects
	SELECT DISTINCT p.[ID], p.[Action], p.[ProtectType], p.[Columns]
		FROM sys.sysprotects p
		WHERE (p.[Action] = 193 OR p.[Action] = 197)
			AND [uid] = @iUserGroupID;

	-- Loop through the tables used in the screen, getting the column permissions for each one.
	DECLARE tablesCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID
	FROM ASRSysControls
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0
	UNION
	SELECT DISTINCT c.tableID 
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	WHERE oi.type = 'O' AND oi.orderID = @piOrderID;
	
	OPEN tablesCursor;
	FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	WHILE (@@fetch_status = 0)
	BEGIN

		IF @iTempTableID = @iScreenTableID
		BEGIN
			/* Base table - use the real source. */
			INSERT INTO @columnPermissions
			SELECT 
				@iTempTableID,
				@sRealSource,
				syscolumns.name,
				p.action,
				CASE protectType
					WHEN 205 THEN 1
					WHEN 204 THEN 1
					ELSE 0
				END 
			FROM @SysProtects p
			INNER JOIN syscolumns ON p.id = syscolumns.id
			WHERE syscolumns.name <> 'timestamp'
				AND OBJECT_NAME(p.ID) = @sRealSource
				AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
				OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
				AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
		END
		ELSE
		BEGIN
			/* Parent of the base table - get permissions for the table, and any associated views. */
			SELECT @iParentTableType = tableType,
				@sParentTableName = tableName
			FROM ASRSysTables
			WHERE tableID = @iTempTableID;
			
			IF @iParentTableType <> 2 /* ie. top-level or lookup */
			BEGIN

				INSERT INTO @columnPermissions
				SELECT 
					@iTempTableID,
					OBJECT_NAME(p.ID),
					syscolumns.name,
					p.action,
					CASE protectType
					   	WHEN 205 THEN 1
						WHEN 204 THEN 1
						ELSE 0
					END 
				FROM @SysProtects p
				INNER JOIN syscolumns ON p.id = syscolumns.id
				WHERE syscolumns.name <> 'timestamp'
					AND OBJECT_NAME(p.id) IN (SELECT ASRSysTables.tableName FROM ASRSysTables WHERE ASRSysTables.tableID = @iTempTableID 
						UNION SELECT ASRSysViews.viewName FROM ASRSysViews WHERE ASRSysViews.viewTableID = @iTempTableID)
					AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
					OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
					AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
			END
			ELSE
			BEGIN

				/* Get permitted child view on the parent table. */
				SELECT @iParentChildViewID = childViewID
				FROM ASRSysChildViews2
				WHERE tableID = @iTempTableID
					AND role = @sRoleName;
					
				IF @iParentChildViewID IS null SET @iParentChildViewID = 0;
					
				IF @iParentChildViewID > 0 
				BEGIN
					SET @sParentRealSource = 'ASRSysCV' + 
						convert(varchar(1000), @iParentChildViewID) +
						'#' + replace(@sParentTableName, ' ', '_') +
						'#' + replace(@sRoleName, ' ', '_');
					SET @sParentRealSource = left(@sParentRealSource, 255);
					INSERT INTO @columnPermissions
					SELECT 
						@iTempTableID,
						@sParentRealSource,
						syscolumns.name,
						p.action,
						CASE protectType
							WHEN 205 THEN 1
							WHEN 204 THEN 1
							ELSE 0
						END 
					FROM @sysprotects p
					INNER JOIN syscolumns ON p.id = syscolumns.id
					WHERE syscolumns.name <> 'timestamp'
						AND OBJECT_NAME(p.ID) = @sParentRealSource
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));

				END
			END
		END
		FETCH NEXT FROM tablesCursor INTO @iTempTableID;
	END
	
	CLOSE tablesCursor;
	DEALLOCATE tablesCursor;

	SET @iUserType = 1;
	
	SELECT @iID = ASRSysPermissionItems.itemID
		FROM ASRSysPermissionItems
		INNER JOIN ASRSysPermissionCategories ON ASRSysPermissionItems.categoryID = ASRSysPermissionCategories.categoryID
		WHERE ASRSysPermissionItems.itemKey = 'INTRANET'
			AND ASRSysPermissionCategories.categoryKey = 'MODULEACCESS';
			
	IF @iID IS NULL SET @iID = 0;
	IF @iID > 0
	BEGIN
		/* The permission does exist in the current version so check if the user is granted this permission. */
		SELECT @iCount = count(*)
		FROM ASRSysGroupPermissions 
		WHERE ASRSysGroupPermissions.itemID = @iID
			AND ASRSysGroupPermissions.groupName = @sRoleName
			AND ASRSysGroupPermissions.permitted = 1;
			
		IF @iCount > 0 SET @iUserType = 0;

	END
	/* Create a temporary table of the column info for all columns used in the screen controls. */
	/* Populate the temporary table with info for all columns used in the screen controls. */
	/* Create the select string for getting the column values. */
	DECLARE columnsCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT DISTINCT ASRSysControls.tableID, 
		ASRSysControls.columnID, 
		ASRSysColumns.columnName, 
		ASRSysTables.tableName,
		ASRSysColumns.dataType,
		ASRSysColumns.columnType,
		ASRSysColumns.linkTableID
	FROM ASRSysControls
		LEFT OUTER JOIN ASRSysTables ON ASRSysControls.tableID = ASRSysTables.tableID 
		LEFT OUTER JOIN ASRSysColumns ON ASRSysColumns.tableID = ASRSysControls.tableID AND ASRSysColumns.columnId = ASRSysControls.columnID
	WHERE screenID = @piScreenID
		AND ASRSysControls.columnID > 0;
	
	OPEN columnsCursor;
	FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID;	
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
		SET @fUpdateGranted = 0;
		IF @iColumnTableID = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193;
				
			/* Get the update permission on the column. */
			SELECT @fUpdateGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 197;

			/* If the column is a link column, ensure that the link table can be seen. */
			IF (@fUpdateGranted = 1) AND (@iColumnType = 4)
			BEGIN
				SELECT @sLinkTableName = tableName,
					@iLinkTableType = tableType
				FROM ASRSysTables
				WHERE tableID = @iLinkTableID;
				
				IF @iLinkTableType = 1
				BEGIN
					/* Top-level table. */
					SELECT @lngPermissionCount = COUNT(*)
					FROM @sysprotects p
					INNER JOIN syscolumns ON p.id = syscolumns.id
					WHERE p.action = 193
						AND p.protectType <> 206
						AND syscolumns.name <> 'timestamp'
						AND syscolumns.name <> 'ID'
						AND OBJECT_NAME(p.ID) = @sLinkTableName
						AND (((convert(tinyint,substring(p.columns,1,1))&1) = 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) != 0)
						OR ((convert(tinyint,substring(p.columns,1,1))&1) != 0
						AND (convert(int,substring(p.columns,sysColumns.colid/8+1,1))&power(2,sysColumns.colid&7)) = 0));
						
					IF @lngPermissionCount = 0 
					BEGIN
						/* No permission on the table itself check the views. */
						SELECT @lngPermissionCount = COUNT(*)
						FROM ASRSysViews
						INNER JOIN sysobjects ON ASRSysViews.viewName = sysobjects.name
						INNER JOIN @sysprotects p ON sysobjects.id = p.id  
						WHERE ASRSysViews.viewTableID = @iLinkTableID
							AND p.action = 193
							AND p.protecttype <> 206;
						IF @lngPermissionCount = 0 SET @fUpdateGranted = 0;
					END
				END
				ELSE
				BEGIN
					/* Child/history table. */
					SELECT @iLinkChildViewID = childViewID
					FROM ASRSysChildViews2
					WHERE tableID = @iLinkTableID
						AND role = @sRoleName;
						
					IF @iLinkChildViewID IS null SET @iLinkChildViewID = 0;
						
					IF @iLinkChildViewID > 0 
					BEGIN
						SET @sLinkRealSource = 'ASRSysCV' + 
							convert(varchar(1000), @iLinkChildViewID) +
							'#' + replace(@sLinkTableName, ' ', '_') +
							'#' + replace(@sRoleName, ' ', '_');
						SET @sLinkRealSource = left(@sLinkRealSource, 255);
					END
					SELECT @lngPermissionCount = COUNT(p.ID)
					FROM @sysprotects p 
					WHERE p.protectType <> 206
						AND p.action = 193
						AND OBJECT_NAME(p.ID) = @sLinkRealSource;
		
					IF @lngPermissionCount = 0 SET @fUpdateGranted = 0;
				END
			END

			IF @fSelectGranted = 1 
			BEGIN
				/* Get the select string for the column. */
				IF LEN(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';
			
				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sRealSource + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sRealSource + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193;
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN

				/* Column COULD be read directly from the parent table. */
				IF len(@psSelectSQL) > 0 
					SET @psSelectSQL = @psSelectSQL + ',';

				IF @iColumnDataType = 11 /* Date */
				BEGIN
					 /* Date */
					SET @sNewBit = 'convert(varchar(10), ' + @sColumnTableName + '.' + @sColumnName + ', 101) AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				ELSE
				BEGIN
					 /* Non-date */
					SET @sNewBit = @sColumnTableName + '.' + @sColumnName + ' AS [' + convert(varchar(100), @iColumnID) + ']';
					SET @psSelectSQL = @psSelectSQL + @sNewBit;
				END
				
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @JoinParents
					WHERE tableViewName = @sColumnTableName;
					
				IF @iTempCount = 0
					INSERT INTO @JoinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
					
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sSelectString = '';
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
					SELECT tableViewName
					FROM @columnPermissions
					WHERE tableID = @iColumnTableID
						AND tableViewName <> @sColumnTableName
						AND columnName = @sColumnName
						AND action = 193
						AND granted = 1;
						
				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					SET @fSelectGranted = 1;
					IF len(@sSelectString) = 0 SET @sSelectString = 'CASE';
	
					IF @iColumnDataType = 11 /* Date */
					BEGIN
						 /* Date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN convert(varchar(10), ' + @sViewName + '.' + @sColumnName + ', 101)';
					END
					ELSE
					BEGIN
						 /* Non-date */
						SET @sSelectString = @sSelectString +
							' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
					END

					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
						WHERE tableViewName = @sViewName;
						
					IF @iTempCount = 0
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableID);

					FETCH NEXT FROM viewCursor INTO @sViewName;
				END

				CLOSE viewCursor;
				DEALLOCATE viewCursor;
				
				IF len(@sSelectString) > 0
				BEGIN
					SET @sSelectString = @sSelectString +
						' ELSE NULL END AS [' + convert(varchar(100), @iColumnID) + ']';
					IF len(@psSelectSQL) > 0 SET @psSelectSQL = @psSelectSQL + ',';
					SET @psSelectSQL = @psSelectSQL + @sSelectString;
				END
			END
		END
		FETCH NEXT FROM columnsCursor INTO @iColumnTableID, @iColumnID, @sColumnName, @sColumnTableName, @iColumnDataType, @iColumnType, @iLinkTableID;
	END

	CLOSE columnsCursor;
	DEALLOCATE columnsCursor;
	
	/* Create the order string. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
		SELECT c.tableID, oi.columnID, c.columnName, t.tableName, oi.ascending
		FROM ASRSysOrderItems oi
			INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
			INNER JOIN ASRSysTables t ON t.tableID = c.tableID
		WHERE oi.orderID = @piOrderID AND oi.type = 'O'
			AND c.dataType <> -4 AND c.datatype <> -3
		ORDER BY oi.sequence;
		
	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @fSelectGranted = 0;
		IF @iColumnTableId = @iScreenTableID
		BEGIN
			/* Base table. */
			/* Get the select permission on the column. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableViewName = @sRealSource
				AND columnName = @sColumnName
				AND action = 193;
			IF @fSelectGranted = 1
			BEGIN
				/* Get the order string for the column. */
				IF len(@psOrderSQL) > 0 SET @psOrderSQL = @psOrderSQL + ', ';
				SET @psOrderSQL = @psOrderSQL + @sRealSource + '.' + @sColumnName + CASE WHEN @fAscending = 0 THEN ' DESC' ELSE '' END;
			END
		END
		ELSE
		BEGIN
			/* Parent of the base table. */
			/* Get the select permission on the column. */
			/* Check if the column is selectable directly from the table. */
			SELECT @fSelectGranted = granted
			FROM @columnPermissions
			WHERE tableID = @iColumnTableId
				AND tableViewName = @sColumnTableName
				AND columnName = @sColumnName
				AND action = 193;
			IF @fSelectGranted IS NULL SET @fSelectGranted = 0;
	
			IF @fSelectGranted = 1 
			BEGIN
				/* Column COULD be read directly from the parent table. */
				/* Get the order string for the column. */
				IF len(@psOrderSQL) > 0 
					SET @psOrderSQL = @psOrderSQL + ', ';
				SET @psOrderSQL = @psOrderSQL + @sColumnTableName + '.' + @sColumnName + CASE WHEN @fAscending = 0 THEN ' DESC' ELSE '' END;
				
				/* Add the table to the array of tables/views to join if it has not already been added. */
				SELECT @iTempCount = COUNT(tableViewName)
				FROM @joinParents
					WHERE tableViewName = @sColumnTableName;
					
				IF @iTempCount = 0
					INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sColumnTableName, @iColumnTableID);
					
			END
			ELSE	
			BEGIN
				/* Column could NOT be read directly from the parent table, so try the views. */
				SET @sOrderString = ''
				DECLARE viewCursor CURSOR LOCAL FAST_FORWARD FOR 
				SELECT tableViewName
				FROM @columnPermissions
				WHERE tableID = @iColumnTableId
					AND tableViewName <> @sColumnTableName
					AND columnName = @sColumnName
					AND action = 193
					AND granted = 1;
					
				OPEN viewCursor;
				FETCH NEXT FROM viewCursor INTO @sViewName;
				WHILE (@@fetch_status = 0)
				BEGIN
					/* Column CAN be read from the view. */
					IF len(@sOrderString) = 0 SET @sOrderString = 'CASE';
					SET @sOrderString = @sOrderString +
						' WHEN NOT ' + @sViewName + '.' + @sColumnName + ' IS NULL THEN ' + @sViewName + '.' + @sColumnName;
		
					/* Add the view to the array of tables/views to join if it has not already been added. */
					SELECT @iTempCount = COUNT(tableViewName)
					FROM @joinParents
						WHERE tableViewname = @sViewName;
						
					IF @iTempCount = 0
						INSERT INTO @joinParents (tableViewName, tableID) VALUES(@sViewName, @iColumnTableId);
						
					FETCH NEXT FROM viewCursor INTO @sViewName;
				END

				CLOSE viewCursor;
				DEALLOCATE viewCursor;
				
				IF len(@sOrderString) > 0
				BEGIN
					SET @sOrderString = @sOrderString +	' ELSE NULL END';
					IF len(@psOrderSQL) > 0 
						SET @psOrderSQL = @psOrderSQL + ', ';

					SET @psOrderSQL = @psOrderSQL + @sOrderString + CASE WHEN @fAscending = 0 THEN ' DESC' ELSE '' END;
				END
			END
		END
		FETCH NEXT FROM orderCursor INTO @iColumnTableId, @iColumnId, @sColumnName, @sColumnTableName, @fAscending;
	END
	
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

	
	-- Add the ID column to the order string.
	IF LEN(@psOrderSQL) > 0 SET @psOrderSQL = @psOrderSQL + ', ';
	SET @psOrderSQL = @psOrderSQL + @sRealSource + '.ID';

	-- Add columns from the screen.
	SELECT @psSelectSQL = @psSelectSQL 
		+ CASE LEN(@psSelectSQL) WHEN 0 THEN '' ELSE ', ' END
		+ @sRealSource + '.' + [columnName]	+ ' AS [' + convert(varchar(10), [ColumnID]) + ']'
	FROM ASRSysColumns
	WHERE tableID = @iScreenTableID
		AND columnType = 3;

	-- Add timestamp to the select statement.
	SET @psSelectSQL = @psSelectSQL + ', CONVERT(integer, ' + @sRealSource + '.TimeStamp) AS timestamp ';

	-- Create the FROM code.
	SET @psFromDef = @sRealSource + '	';
	SELECT @psFromDef = @psFromDef + tableViewName + '	'
		+ convert(varchar(10), tableID) + '	'
	FROM @joinParents;

END
GO

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetLookupFindRecords]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetLookupFindRecords]
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupFindRecords] (
	@piLookupColumnID 	integer,
	@piRecordsRequired	integer,
	@pfFirstPage		bit			OUTPUT,
	@pfLastPage			bit			OUTPUT,
	@psLocateValue		varchar(MAX),
	@piColumnType		integer		OUTPUT,
	@piColumnSize		integer		OUTPUT,
	@piColumnDecimals	integer		OUTPUT,
	@psAction			varchar(255),
	@piTotalRecCount	integer		OUTPUT,
	@piFirstRecPos		integer		OUTPUT,
	@piCurrentRecCount	integer,
	@psFilterValue		varchar(MAX),
	@piCallingColumnID	integer,
	@pfOverrideFilter	bit
)
AS
BEGIN

	SET NOCOUNT ON;

	/* Return a recordset of the lookup find records, given the table and column IDs.
		@piTableID = the ID of the table on which the find is based.
		@piLookupColumnID = the ID of the column on which the find is based.
	NB. No permissions need to be read, as all users have read permission on lookup tables.
	*/
	DECLARE @sTableName		sysname,
		@iTableID 			integer, 
		@sColumnName 		sysname,
		@sColumnName2 		sysname,
		@iOrderID			integer,
		@sSelectSQL			varchar(MAX),
		@sOrderSQL 			varchar(MAX),
		@sFilterValuesSQL	varchar(MAX),
		@sExecString		nvarchar(MAX),
		@iTemp				integer,
		@sRemainingSQL		varchar(MAX),
		@iLastCharIndex		integer,
		@iCharIndex 		integer,
		@sTempExecString	nvarchar(MAX),
		@sTempParamDefinition	nvarchar(500),
		@sLocateCode		varchar(MAX),
		@sReverseOrderSQL 	varchar(MAX),
		@iCount				integer,
		@iGetCount			integer,
		@sColumnTemp		sysname,
		@iLookupFilterColumnID	integer,
		@iLookupFilterOperator	integer,
		@iLookupFilterColumnDataType	integer;

	/* Initialise variables. */
	SET @sSelectSQL = ''
	SET @sOrderSQL = ''
	SET @sFilterValuesSQL = ''
	SET @sExecString = ''
	SET @sReverseOrderSQL = ''

	/* Clean the input string parameters. */
	IF len(@psFilterValue) > 0 SET @psFilterValue = replace(@psFilterValue, '''', '''''')
	IF len(@psLocateValue) > 0 SET @psLocateValue = replace(@psLocateValue, '''', '''''')
	
	IF @piRecordsRequired <= 0 SET @piRecordsRequired = 1000
	SET @psAction = UPPER(@psAction)
	IF (@psAction <> 'MOVEPREVIOUS') AND 
		(@psAction <> 'MOVENEXT') AND 
		(@psAction <> 'MOVELAST') AND 
		(@psAction <> 'LOCATE')
	BEGIN
		SET @psAction = 'MOVEFIRST'
	END

	/* Get the column name. */
	SELECT @sColumnName = ASRSysColumns.columnName,
		@iTableID = ASRSysColumns.tableID,
		@piColumnType = ASRSysColumns.dataType,
		@piColumnSize = ASRSysColumns.size,
		@piColumnDecimals = ASRSysColumns.decimals
	FROM ASRSysColumns
	WHERE ASRSysColumns.columnId = @piLookupColumnID

	/* Get the table name and default order. */
	SELECT @sTableName = ASRSysTables.tableName,
		@iOrderID = ASRSysTables.defaultOrderID
	FROM ASRSysTables
	WHERE ASRSysTables.tableID = @iTableID

	SET @sSelectSQL = @sTableName + '.' + @sColumnName
	SET @sOrderSQL = @sTableName + '.' + @sColumnName

	/* Filter the values if required */
	SELECT @iLookupFilterColumnID  = ASRSysColumns.LookupFilterColumnID,
		@iLookupFilterOperator = ASRSysColumns.LookupFilterOperator
	FROM ASRSysColumns
	WHERE ASRSysColumns.columnId = @piCallingColumnID

	IF (@iLookupFilterColumnID > 0) and (@pfOverrideFilter = 0)
	BEGIN
		SELECT @sColumnTemp = ASRSysColumns.columnName,
			@iLookupFilterColumnDataType = ASRSysColumns.dataType
		FROM ASRSysColumns
		WHERE ASRSysColumns.columnId = @iLookupFilterColumnID

		IF @iLookupFilterColumnDataType = -7 /* Boolean */
		BEGIN
			SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' = ' 
				+ CASE
					WHEN UPPER(@psFilterValue) = 'TRUE' THEN '1'
					WHEN UPPER(@psFilterValue) = 'FALSE' THEN '0'
					ELSE @psFilterValue
				END
				+ ') '
		END
		ELSE
		BEGIN
			IF (@iLookupFilterColumnDataType = 2) OR (@iLookupFilterColumnDataType = 4) /* Numeric, Integer */
			BEGIN
				IF @iLookupFilterOperator = 1 /* Equals */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' = ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) = 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
					END
				END

				IF @iLookupFilterOperator = 2 /* NOT Equal To */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <> ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) = 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' AND (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null) '
					END
				END

				IF @iLookupFilterOperator = 3 /* Is At Most */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <= ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) >= 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
					END
				END

				IF @iLookupFilterOperator = 4 /* Is At Least */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' >= ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) <= 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
					END
				END

				IF @iLookupFilterOperator = 5 /* Is More Than */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' > ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) < 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
					END
				END

				IF @iLookupFilterOperator = 6 /* Is Less Than */
				BEGIN
					SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' < ' + @psFilterValue + ') '
					IF convert(float, @psFilterValue) > 0
					BEGIN
						SET @sFilterValuesSQL = @sFilterValuesSQL +
							' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
					END
				END
			END
			ELSE
			BEGIN
				IF (@iLookupFilterColumnDataType = 11) /* Date */
				BEGIN
					IF @iLookupFilterOperator = 7 /* On */
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' = ''' + @psFilterValue + ''') '
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 8 /* NOT On */
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <> ''' + @psFilterValue + ''') ' +
								' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null) '
						END
					END

					IF @iLookupFilterOperator = 12 /* On OR Before*/
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <= ''' + @psFilterValue + ''') ' +
								' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
						END
					END

					IF @iLookupFilterOperator = 11 /* On OR After*/
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' >= ''' + @psFilterValue + ''') ' 
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null)' +
								' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null)'
						END
					END

					IF @iLookupFilterOperator = 9 /* After*/
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' > ''' + @psFilterValue + ''') ' 
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null)'
						END
					END

					IF @iLookupFilterOperator = 10 /* Before*/
					BEGIN
						IF len(@psFilterValue) = 10
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' < ''' + @psFilterValue + ''') ' +
								' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
						END
						ELSE
						BEGIN
							SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null)' +
								' AND (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null)'
						END
					END
				END
				ELSE
				BEGIN
					IF (@iLookupFilterColumnDataType = 12) OR (@iLookupFilterColumnDataType = -3) OR (@iLookupFilterColumnDataType = -1) /* varchar, working patter, photo*/
					BEGIN
						IF @iLookupFilterOperator = 14 /* Is */
						BEGIN
							IF len(@psFilterValue) = 0
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' = '''') ' +
									' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS null) '
							END
							ELSE
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' = ''' + @psFilterValue + ''') '
							END
						END

						IF @iLookupFilterOperator = 16 /* Is NOT*/
						BEGIN
							IF len(@psFilterValue) = 0
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <> '''') ' +
									' AND (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null) '
							END
							ELSE
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' <> ''' + @psFilterValue + ''') '
							END
						END

						IF @iLookupFilterOperator = 13 /* Contains*/
						BEGIN
							IF len(@psFilterValue) = 0
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null) ' +
									' OR (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null) '
							END
							ELSE
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' LIKE ''%' + @psFilterValue + '%'') '
							END
						END

						IF @iLookupFilterOperator = 15 /* Does NOT Contain*/
						BEGIN
							IF len(@psFilterValue) = 0
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' IS null) ' +
									' AND (' + @sTableName + '.' + @sColumnTemp  + ' IS NOT null) '
							END
							ELSE
							BEGIN
								SET @sFilterValuesSQL = '(' + @sTableName + '.' + @sColumnTemp  + ' NOT LIKE ''%' + @psFilterValue + '%'') '
							END
						END
					END
				END
			END
		END
	END

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.columnName
	FROM ASRSysOrderItems oi
	INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
	INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
		AND oi.columnID <> @piLookupColumnID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor
	FETCH NEXT FROM orderCursor INTO @sColumnName2
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @sSelectSQL = @sSelectSQL +  ','  + @sTableName + '.' + @sColumnName2

		FETCH NEXT FROM orderCursor INTO @sColumnName2
	END
	CLOSE orderCursor
	DEALLOCATE orderCursor

	/* Create the reverse order string if required. */
	IF (@psAction <> 'MOVEFIRST') 
	BEGIN
		SET @sReverseOrderSQL = @sTableName + '.' + @sColumnName + ' DESC, ' + @sTableName + '.ID DESC'
	END

	/* Get the total number of records. */
	SET @sTempExecString = 'SELECT @recordCount = COUNT(*) ' +
												 'FROM (SELECT DISTINCT ' + @sSelectSQL +
															' FROM ' + @sTableName 
	IF len(@sFilterValuesSQL) > 0 SET @sTempExecString = @sTempExecString + ' WHERE ' + @sFilterValuesSQL
	SET @sTempExecString = @sTempExecString	+ ') ' + 'distinctTable'
	SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
	EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iCount OUTPUT
	SET @piTotalRecCount = @iCount

	SET @sExecString = 'SELECT DISTINCT ' 

	IF @psAction = 'MOVEFIRST' OR @psAction = 'LOCATE' 
	BEGIN
		SET @sExecString = @sExecString + 'TOP ' + convert(varchar(100), @piRecordsRequired) + ' '
	END
	SET @sExecString = @sExecString + @sSelectSQL +
		' FROM ' + @sTableName

	IF (@psAction = 'MOVEFIRST') AND LEN(@sFilterValuesSQL) > 0
	BEGIN
		SET @sExecString = @sExecString + ' WHERE ' + @sFilterValuesSQL
	END

	IF (@psAction = 'MOVELAST') 
	BEGIN
		IF LEN(@sFilterValuesSQL) > 0 SET @sFilterValuesSQL = @sFilterValuesSQL + ' AND '

		SET @sExecString = @sExecString + 
			' WHERE '  + @sFilterValuesSQL + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @piRecordsRequired) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName
	END
	IF @psAction = 'MOVENEXT' 
	BEGIN
		IF LEN(@sFilterValuesSQL) > 0 SET @sFilterValuesSQL = @sFilterValuesSQL + ' AND '

		IF (@piFirstRecPos +  @piCurrentRecCount + @piRecordsRequired - 1) > @piTotalRecCount
		BEGIN
			SET @iGetCount = @piTotalRecCount - (@piCurrentRecCount + @piFirstRecPos - 1)
		END
		ELSE
		BEGIN
			SET @iGetCount = @piRecordsRequired
		END
		SET @sExecString = @sExecString + 
			' WHERE ' + @sFilterValuesSQL + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName

		SET @sExecString = @sExecString + 
			' WHERE ' + @sFilterValuesSQL + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos + @piCurrentRecCount + @piRecordsRequired  - 1) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		IF LEN(@sFilterValuesSQL) > 0 SET @sFilterValuesSQL = @sFilterValuesSQL + ' AND '

		IF @piFirstRecPos <= @piRecordsRequired
		BEGIN
			SET @iGetCount = @piFirstRecPos - 1
		END
		ELSE
		BEGIN
			SET @iGetCount = @piRecordsRequired
		END
		SET @sExecString = @sExecString + 
			' WHERE ' + @sFilterValuesSQL + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @iGetCount) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName

		SET @sExecString = @sExecString + 
			' WHERE ' + @sFilterValuesSQL + @sTableName + '.ID IN (SELECT TOP ' + convert(varchar(100), @piFirstRecPos - 1) + ' ' + @sTableName + '.ID' +
			' FROM ' + @sTableName
	END

	IF @psAction = 'MOVENEXT' OR (@psAction = 'MOVEPREVIOUS')
	BEGIN
		SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL + ')'
	END

	IF (@psAction = 'MOVELAST') OR (@psAction = 'MOVENEXT') OR (@psAction = 'MOVEPREVIOUS')
	BEGIN
		SET @sExecString = @sExecString + ' ORDER BY ' + @sReverseOrderSQL + ')'
	END

	IF (@psAction = 'LOCATE')
	BEGIN
		IF LEN(@sFilterValuesSQL) > 0
			SET @sLocateCode = ' WHERE ((' +@sFilterValuesSQL + ') AND ' +@sTableName + '.' + @sColumnName 
		ELSE 
			SET @sLocateCode = ' WHERE (' + @sTableName + '.' + @sColumnName

		IF (@piColumnType = 12) OR (@piColumnType = -1) /* Character or Working Pattern column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''

			IF len(@psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' OR ' + @sTableName + '.' + @sColumnName + ' IS NULL'
			END
		END

		IF @piColumnType = 11 /* Date column */
		BEGIN
			IF len(@psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' IS NOT NULL  OR ' + @sTableName + '.' + @sColumnName + ' IS NULL'
			END
			ELSE
			BEGIN
				SET @sLocateCode = @sLocateCode + ' >= ''' + @psLocateValue + ''''
			END
		END

		IF @piColumnType = -7 /* Logic column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ' + 
				CASE
					WHEN @psLocateValue = 'True' THEN '1'
					ELSE '0'
				END
		END

		IF (@piColumnType = 2) OR (@piColumnType = 4) /* Numeric or Integer column */
		BEGIN
			SET @sLocateCode = @sLocateCode + ' >= ' + @psLocateValue

			IF convert(float, @psLocateValue) = 0
			BEGIN
				SET @sLocateCode = @sLocateCode + ' OR ' + @sTableName + '.' + @sColumnName + ' IS NULL'
			END
		END

		SET @sLocateCode = @sLocateCode + ')'
		SET @sExecString = @sExecString + @sLocateCode
	END

	/* Add the ORDER BY code to the find record selection string if required. */
	SET @sExecString = @sExecString + ' ORDER BY ' + @sOrderSQL

	/* Set the IsFirstPage, IsLastPage flags, and the page number. */
	IF @psAction = 'MOVEFIRST'
	BEGIN
		SET @piFirstRecPos = 1
		SET @pfFirstPage = 1
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount <= @piRecordsRequired THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVENEXT'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos + @piCurrentRecCount
		SET @pfFirstPage = 0
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVEPREVIOUS'
	BEGIN
		SET @piFirstRecPos = @piFirstRecPos - @iGetCount
		IF @piFirstRecPos <= 0 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @iGetCount THEN 1
				ELSE 0
			END
	END
	IF @psAction = 'MOVELAST'
	BEGIN
		SET @piFirstRecPos = @piTotalRecCount - @piRecordsRequired + 1
		IF @piFirstRecPos < 1 SET @piFirstRecPos = 1
		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 1
	END
	IF @psAction = 'LOCATE'
	BEGIN
		SET @sTempExecString = 'SELECT @recordCount = COUNT(' + @sTableName + '.id) FROM ' + @sTableName + @sLocateCode
		SET @sTempParamDefinition = N'@recordCount integer OUTPUT'
		EXEC sp_executesql @sTempExecString, @sTempParamDefinition, @iTemp OUTPUT

		IF @iTemp <=0 
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount + 1
		END
		ELSE
		BEGIN
			SET @piFirstRecPos = @piTotalRecCount - @iTemp + 1
		END

		SET @pfFirstPage = 
			CASE 
				WHEN @piFirstRecPos = 1 THEN 1
				ELSE 0
			END
		SET @pfLastPage = 
			CASE 
				WHEN @piTotalRecCount < @piFirstRecPos + @piRecordsRequired THEN 1
				ELSE 0
			END
	END

	/* Return a recordset of the required columns in the required order from the given table/view. */
	EXECUTE sp_executeSQL @sExecString;
END
GO


IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[spASRIntGetLookupFindColumnInfo]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[spASRIntGetLookupFindColumnInfo]
GO

CREATE PROCEDURE [dbo].[spASRIntGetLookupFindColumnInfo] (
	@piLookupColumnID 		integer,
	@ps1000SeparatorCols	varchar(MAX)	OUTPUT,
	@psBlanIfZeroCols		varchar(MAX)	OUTPUT
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE 
		@iTableID			integer,
		@bUse1000Separator	bit,
		@bBlankIfZero		bit,
		@iOrderID			integer;
		
	/* Get the column name. */
	SELECT @iTableID = tableID,
		@bUse1000Separator = Use1000Separator,
		@bBlankIfZero = BlankIfZero
	FROM [dbo].[ASRSysColumns]
	WHERE columnID = @piLookupColumnID;

	SET @ps1000SeparatorCols = 
		CASE
			WHEN @bUse1000Separator = 1 THEN '1'
			ELSE '0'
		END;

	SET @psBlanIfZeroCols =
		CASE
			WHEN @bBlankIfZero = 1 THEN '1'
			ELSE '0'
		END;

	/* Get the table name and default order. */
	SELECT @iOrderID = defaultOrderID
	FROM [dbo].[ASRSysTables]
	WHERE tableID = @iTableID;

	/* Create the order select strings. */
	DECLARE orderCursor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT c.Use1000Separator, c.BlankIfZero
	FROM ASRSysOrderItems oi
		INNER JOIN ASRSysColumns c ON oi.columnID = c.columnId
		INNER JOIN ASRSysTables t ON t.tableID = c.tableID
	WHERE oi.orderID = @iOrderID AND oi.type = 'F'
		AND oi.columnID <> @piLookupColumnID
		AND c.dataType <> -4 AND c.datatype <> -3
	ORDER BY oi.sequence;

	OPEN orderCursor;
	FETCH NEXT FROM orderCursor INTO @bUse1000Separator, @bBlankIfZero;
	WHILE (@@fetch_status = 0)
	BEGIN
		SET @ps1000SeparatorCols = @ps1000SeparatorCols + 
			CASE
				WHEN @bUse1000Separator = 1 THEN '1'
				ELSE '0'
			END;

		SET @psBlanIfZeroCols = @psBlanIfZeroCols +
			CASE
				WHEN @bBlankIfZero = 1 THEN '1'
				ELSE '0'
			END;

		FETCH NEXT FROM orderCursor INTO @bUse1000Separator, @bBlankIfZero;
	END
	CLOSE orderCursor;
	DEALLOCATE orderCursor;

END
GO



/*---------------------------------------------*/
/* Ensure the required permissions are granted */
/*---------------------------------------------*/

GO
DECLARE @sSQL nvarchar(MAX),
		@sGroup sysname,
		@sObject sysname,
		@sObjectType char(2);

DECLARE curObjects CURSOR LOCAL FAST_FORWARD FOR
SELECT sysobjects.name, sysobjects.xtype
FROM sysobjects
		 INNER JOIN sysusers ON sysobjects.uid = sysusers.uid
WHERE (((sysobjects.xtype = 'p') AND (sysobjects.name LIKE 'sp_asr%' OR sysobjects.name LIKE 'spasr%'))
		OR ((sysobjects.xtype = 'u') AND (sysobjects.name LIKE 'asrsys%'))
		OR ((sysobjects.xtype = 'fn') AND (sysobjects.name LIKE 'udf_ASRFn%')))
		AND (sysusers.name = 'dbo')

OPEN curObjects
FETCH NEXT FROM curObjects INTO @sObject, @sObjectType
WHILE (@@fetch_status = 0)
BEGIN
		IF rtrim(@sObjectType) = 'P' OR rtrim(@sObjectType) = 'FN'
		BEGIN
				SET @sSQL = 'GRANT EXEC ON [' + @sObject + '] TO [ASRSysGroup]'
				EXEC(@sSQL)
		END
		ELSE
		BEGIN
				SET @sSQL = 'GRANT SELECT,INSERT,UPDATE,DELETE ON [' + @sObject + '] TO [ASRSysGroup]'
				EXEC(@sSQL)
		END

		FETCH NEXT FROM curObjects INTO @sObject, @sObjectType
END
CLOSE curObjects
DEALLOCATE curObjects

GO

		
DECLARE @sVersion varchar(10) = '8.1.35'

EXEC spsys_setsystemsetting 'database', 'version', '8.1';
EXEC spsys_setsystemsetting 'intranet', 'version', @sVersion;
EXEC spsys_setsystemsetting 'ssintranet', 'version', @sVersion;


/*---------------------------------------------*/
/* Insert a record into the Audit Access table */
/*---------------------------------------------*/
INSERT INTO ASRSysAuditAccess
(DateTimeStamp, UserGroup, UserName, ComputerName, HRProModule, Action)
VALUES (getdate(),'<none>',left(system_user,50),lower(left(host_name(),30)),'Intranet', @sVersion)

Print ''
Print '+-----------------------------------------------------------------------+'
Print '|                                                                       |'
Print '|                            SCRIPT SUCCESS                             |'
Print '|                                                                       |'
Print '+-----------------------------------------------------------------------+'

/* ------------------------------------- */
/* Reapply the (1 Row Affected) messages */
/* ------------------------------------- */
SET NOCOUNT OFF

GoTo EndSave

QuitWithRollback:
    Print ''
    Print '+-----------------------------------------------------------------------+'
    Print '|                                                                       |'
    Print '|                            SCRIPT FAILURE                             |'
    Print '|                                                                       |'
    Print '|                    See error messages listed above                    |'
    Print '|                                                                       |'
    Print '+-----------------------------------------------------------------------+'
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION

EndSave:
